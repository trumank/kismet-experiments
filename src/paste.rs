use crate::bytecode::{
    address_index::AddressIndex,
    cfg::ControlFlowGraph,
    dominators::DominatorTree,
    expr::{Expr, ExprKind},
    loops::LoopInfo,
    structured::PhoenixStructurer,
};
use paste_buffer::{
    BPGraph, ExportTextPath, FunctionReference, Guid, Node, NodeData, Pin, PinDirection, PinFlags,
    PinType, UserDefinedPin,
};
use std::collections::HashMap;

pub fn format_as_paste(
    expressions: &[Expr],
    _address_index: &AddressIndex,
    function_name: &str,
    func: &jmap::Function,
) {
    // Build CFG and structure it
    let cfg = ControlFlowGraph::from_expressions(expressions);
    let dom_tree = DominatorTree::compute(&cfg);
    let loop_info = LoopInfo::analyze(&cfg, &dom_tree);

    // Extract just the object name from the full path (e.g., "MyFunction" from "/Script/Module.Class:MyFunction")
    let graph_name = function_name
        .rsplit_once(':')
        .map(|(_, name)| name)
        .unwrap_or(function_name);

    let mut graph = BPGraph {
        graph_name: graph_name.to_string(),
        graph_type: "GT_Function".to_string(),
        original_blueprint: ExportTextPath::blueprint(
            "/Game/Decompiled/GeneratedFunction.GeneratedFunction",
        ),
        nodes: vec![],
    };

    // Create function entry node with parameters
    let entry_node = create_function_entry_node(graph_name, func);
    graph.add_node(entry_node);

    // Convert expressions to Blueprint nodes
    let mut node_counter = 0;
    let mut pin_connections: Vec<(String, Guid, String, Guid)> = Vec::new();

    for expr in expressions {
        if let Some((node, connections)) = expr_to_node(expr, &mut node_counter, None, func) {
            for conn in connections {
                pin_connections.push(conn);
            }
            graph.add_node(node);
        }
    }

    // Connect the nodes
    for (from_node, from_pin, to_node, to_pin) in pin_connections {
        graph.connect_pins(&from_node, &from_pin, &to_node, &to_pin);
    }

    // Serialize and print the graph
    let output = graph.serialize();
    println!("{}", output);
}

fn create_function_entry_node(function_name: &str, func: &jmap::Function) -> Node {
    use paste_buffer::LocalVariable;

    // Create user-defined pins for function parameters
    let mut user_defined_pins = Vec::new();
    let mut pins = vec![Pin {
        pin_id: Guid::random(),
        pin_name: "then".to_string(),
        pin_tooltip: None,
        pin_friendly_name: None,
        direction: Some(PinDirection::Output),
        pin_type: PinType::exec(),
        default_value: None,
        autogenerated_default_value: None,
        default_text_value: None,
        default_object: None,
        linked_to: vec![],
        persistent_guid: Guid::zero(),
        flags: PinFlags::default(),
    }];

    // Collect local variables (non-parameter properties)
    let mut local_variables = Vec::new();

    // Extract parameters from the function - properties with CPF_Parm flag
    for prop in &func.r#struct.properties {
        if prop.flags.contains(jmap::EPropertyFlags::CPF_Parm) {
            let pin_type = property_to_pin_type(prop);

            // Return parameters and out parameters are inputs on the function entry node
            if prop.flags.contains(jmap::EPropertyFlags::CPF_ReturnParm)
                || prop.flags.contains(jmap::EPropertyFlags::CPF_OutParm)
            {
                user_defined_pins.push(UserDefinedPin {
                    pin_name: prop.name.clone(),
                    pin_type: pin_type.clone(),
                    desired_pin_direction: PinDirection::Input,
                    pin_default_value: None,
                });

                pins.push(Pin {
                    pin_id: Guid::random(),
                    pin_name: prop.name.clone(),
                    pin_tooltip: None,
                    pin_friendly_name: None,
                    direction: Some(PinDirection::Input),
                    pin_type,
                    default_value: None,
                    autogenerated_default_value: None,
                    default_text_value: None,
                    default_object: None,
                    linked_to: vec![],
                    persistent_guid: Guid::zero(),
                    flags: PinFlags::default(),
                });
            } else {
                // Regular input parameters are outputs on the function entry node
                user_defined_pins.push(UserDefinedPin {
                    pin_name: prop.name.clone(),
                    pin_type: pin_type.clone(),
                    desired_pin_direction: PinDirection::Output,
                    pin_default_value: None,
                });

                pins.push(Pin {
                    pin_id: Guid::random(),
                    pin_name: prop.name.clone(),
                    pin_tooltip: None,
                    pin_friendly_name: None,
                    direction: Some(PinDirection::Output),
                    pin_type,
                    default_value: None,
                    autogenerated_default_value: None,
                    default_text_value: None,
                    default_object: None,
                    linked_to: vec![],
                    persistent_guid: Guid::zero(),
                    flags: PinFlags::default(),
                });
            }
        } else {
            // This is a local variable
            local_variables.push(LocalVariable {
                var_name: prop.name.clone(),
                var_guid: Guid::random(),
                var_type: property_to_pin_type(prop),
                friendly_name: Some(prop.name.clone()),
                category: None,
                property_flags: Some(5), // Default property flags for local vars
            });
        }
    }

    Node {
        name: "K2Node_FunctionEntry_0".to_string(),
        guid: Guid::random(),
        pos_x: 0,
        pos_y: 0,
        advanced_pin_display: None,
        node_data: NodeData::FunctionEntry {
            function_reference: FunctionReference {
                member_parent: None,
                member_name: function_name.to_string(),
                member_guid: None,
                self_context: false,
            },
            extra_flags: Some(201457664),
            is_editable: Some(true),
            local_variables,
        },
        pins,
        user_defined_pins,
    }
}

fn property_to_pin_type(prop: &jmap::Property) -> PinType {
    // Convert JMAP property type to Blueprint PinType
    match &prop.r#type {
        jmap::PropertyType::Int => PinType::int(),
        jmap::PropertyType::Int8 | jmap::PropertyType::Byte { r#enum: None } => PinType {
            category: "byte".to_string(),
            ..Default::default()
        },
        jmap::PropertyType::Int16 | jmap::PropertyType::UInt16 | jmap::PropertyType::UInt32 => {
            PinType::int()
        }
        jmap::PropertyType::Int64 | jmap::PropertyType::UInt64 => PinType {
            category: "int64".to_string(),
            ..Default::default()
        },
        jmap::PropertyType::Float | jmap::PropertyType::Double => PinType::float(),
        jmap::PropertyType::Bool { .. } => PinType::bool(),
        jmap::PropertyType::Str => PinType::string(),
        jmap::PropertyType::Name => PinType {
            category: "name".to_string(),
            ..Default::default()
        },
        jmap::PropertyType::Text => PinType {
            category: "text".to_string(),
            ..Default::default()
        },
        jmap::PropertyType::Byte { r#enum: Some(_) } => {
            todo!("property_to_pin_type: enum byte properties not yet supported");
        }
        jmap::PropertyType::Enum { r#enum, .. } => {
            todo!(
                "property_to_pin_type: enum properties not yet supported: {:?}",
                r#enum
            );
        }
        jmap::PropertyType::Struct { r#struct } => {
            todo!(
                "property_to_pin_type: struct properties not yet supported: {}",
                r#struct
            );
        }
        jmap::PropertyType::Object { property_class } => PinType::object(property_class),
        jmap::PropertyType::Class {
            property_class,
            meta_class,
        } => PinType {
            category: "class".to_string(),
            sub_category: meta_class.clone(),
            sub_category_object: Some(ExportTextPath::class(property_class)),
            ..Default::default()
        },
        jmap::PropertyType::Interface { interface_class } => PinType {
            category: "interface".to_string(),
            sub_category_object: Some(ExportTextPath::class(interface_class)),
            container_type: Some("None".to_string()),
            ..Default::default()
        },
        jmap::PropertyType::Array { inner } => {
            // Get the inner type and modify it to be an array
            let mut inner_pin_type = property_to_pin_type(inner);
            inner_pin_type.container_type = Some("Array".to_string());
            inner_pin_type
        }
        other => panic!(
            "property_to_pin_type: unsupported property type: {:?}",
            other
        ),
    }
}

/// Convert an expression to a Blueprint node
/// Returns (Node, Vec of connections as (from_node_name, from_pin_id, to_node_name, to_pin_id))
///
/// `context_expr` is an optional expression that provides the target/self object for this operation
/// `func` is the function being decompiled, needed for return node parameter information
fn expr_to_node(
    expr: &Expr,
    node_counter: &mut i32,
    context_expr: Option<&Expr>,
    func: &jmap::Function,
) -> Option<(Node, Vec<(String, Guid, String, Guid)>)> {
    match &expr.kind {
        // Context expression unwraps the inner operation with a target object
        ExprKind::Context {
            object, context, ..
        } => {
            // Recursively process the context expression with the object as the target
            expr_to_node(context, node_counter, Some(object), func)
        }

        ExprKind::VirtualFunction { func, params } => {
            let node_name = format!("K2Node_CallFunction_{}", node_counter);
            *node_counter += 1;

            let mut pins = vec![
                Pin {
                    pin_id: Guid::default(),
                    pin_name: "execute".to_string(),
                    direction: Some(PinDirection::Input),
                    pin_type: PinType::exec(),
                    ..Default::default()
                },
                Pin {
                    pin_id: Guid::default(),
                    pin_name: "then".to_string(),
                    direction: Some(PinDirection::Output),
                    pin_type: PinType::exec(),
                    ..Default::default()
                },
            ];

            // If we have a context expression, add a self/target pin
            if context_expr.is_some() {
                pins.push(Pin {
                    pin_id: Guid::default(),
                    pin_name: "self".to_string(),
                    direction: Some(PinDirection::Input),
                    pin_type: PinType::object("/Script/CoreUObject.Object"), // Generic object type
                    ..Default::default()
                });
            }

            let node = Node {
                name: node_name.clone(),
                guid: Guid::default(),
                pos_x: (*node_counter * 300) as i32,
                pos_y: 0,
                node_data: NodeData::CallFunction {
                    function_reference: FunctionReference {
                        member_parent: None,                // TODO: extract from func
                        member_name: format!("{:?}", func), // TODO: extract actual name
                        member_guid: None,
                        self_context: context_expr.is_none(), // self_context if no explicit target
                    },
                    is_pure: false,
                    is_const: None,
                    is_interface_call: None,
                    error_type: None,
                },
                pins,
                ..Default::default()
            };

            Some((node, vec![]))
        }

        ExprKind::LocalVirtualFunction { func, params } => {
            let node_name = format!("K2Node_CallFunction_{}", node_counter);
            *node_counter += 1;

            let mut pins = vec![
                Pin {
                    pin_name: "execute".to_string(),
                    direction: Some(PinDirection::Input),
                    pin_type: PinType::exec(),
                    ..Default::default()
                },
                Pin {
                    pin_name: "then".to_string(),
                    direction: Some(PinDirection::Output),
                    pin_type: PinType::exec(),
                    ..Default::default()
                },
            ];

            // If we have a context expression, add a self/target pin
            if context_expr.is_some() {
                pins.push(Pin {
                    pin_id: Guid::default(),
                    pin_name: "self".to_string(),
                    direction: Some(PinDirection::Input),
                    pin_type: PinType::object("/Script/CoreUObject.Object"),
                    ..Default::default()
                });
            }

            let node = Node {
                name: node_name.clone(),
                pos_x: (*node_counter * 300) as i32,
                pos_y: 0,
                node_data: NodeData::CallFunction {
                    function_reference: FunctionReference {
                        member_parent: None,
                        member_name: format!("{:?}", func), // TODO: extract actual name
                        member_guid: None,
                        self_context: context_expr.is_none(), // self_context only when no explicit target
                    },
                    is_pure: false,
                    is_const: None,
                    is_interface_call: None,
                    error_type: None,
                },
                pins,
                ..Default::default()
            };

            Some((node, vec![]))
        }

        ExprKind::FinalFunction { func, params } => {
            let node_name = format!("K2Node_CallFunction_{}", node_counter);
            *node_counter += 1;

            let mut pins = vec![
                Pin {
                    pin_name: "execute".to_string(),
                    direction: Some(PinDirection::Input),
                    pin_type: PinType::exec(),
                    ..Default::default()
                },
                Pin {
                    pin_name: "then".to_string(),
                    direction: Some(PinDirection::Output),
                    pin_type: PinType::exec(),
                    ..Default::default()
                },
            ];

            // If we have a context expression, add a self/target pin
            if context_expr.is_some() {
                pins.push(Pin {
                    pin_id: Guid::default(),
                    pin_name: "self".to_string(),
                    direction: Some(PinDirection::Input),
                    pin_type: PinType::object("/Script/CoreUObject.Object"),
                    ..Default::default()
                });
            }

            // TODO: Add parameter pins based on the params array

            let node = Node {
                name: node_name.clone(),
                pos_x: (*node_counter * 300) as i32,
                pos_y: 0,
                node_data: NodeData::CallFunction {
                    function_reference: FunctionReference {
                        member_parent: None,
                        member_name: format!("{:?}", func), // TODO: extract actual function name
                        member_guid: None,
                        self_context: context_expr.is_none(),
                    },
                    is_pure: false, // TODO: determine if function is pure
                    is_const: None,
                    is_interface_call: None,
                    error_type: None,
                },
                pins,
                ..Default::default()
            };

            Some((node, vec![]))
        }

        ExprKind::Let {
            variable, value, ..
        }
        | ExprKind::LetBool { variable, value }
        | ExprKind::LetObj { variable, value }
        | ExprKind::LetWeakObjPtr { variable, value }
        | ExprKind::LetDelegate { variable, value }
        | ExprKind::LetMulticastDelegate { variable, value } => {
            let node_name = format!("K2Node_VariableSet_{}", node_counter);
            *node_counter += 1;

            let node = Node {
                name: node_name.clone(),
                pos_x: (*node_counter * 300) as i32,
                pos_y: 0,
                node_data: NodeData::VariableSet {
                    variable_reference: paste_buffer::VariableReference {
                        member_parent: None,
                        member_scope: None,
                        member_name: "UNKNOWN_VAR".to_string(), // TODO: extract from variable
                        member_guid: None,
                        self_context: true,
                    },
                },
                pins: vec![
                    Pin {
                        pin_name: "execute".to_string(),
                        direction: Some(PinDirection::Input),
                        pin_type: PinType::exec(),
                        ..Default::default()
                    },
                    Pin {
                        pin_name: "then".to_string(),
                        direction: Some(PinDirection::Output),
                        pin_type: PinType::exec(),
                        ..Default::default()
                    },
                    // TODO: Add variable value input pin
                    // TODO: Add Output_Get pin
                ],
                ..Default::default()
            };

            Some((node, vec![]))
        }

        ExprKind::Return(return_expr) => {
            let node_name = format!("K2Node_FunctionResult_{}", node_counter);
            *node_counter += 1;

            let mut pins = vec![Pin {
                pin_name: "execute".to_string(),
                direction: Some(PinDirection::Input),
                pin_type: PinType::exec(),
                ..Default::default()
            }];

            // Add pins for return parameters and out parameters
            for prop in &func.r#struct.properties {
                if prop.flags.contains(jmap::EPropertyFlags::CPF_Parm) {
                    // Include both return parameters and out parameters
                    if prop.flags.contains(jmap::EPropertyFlags::CPF_ReturnParm)
                        || prop.flags.contains(jmap::EPropertyFlags::CPF_OutParm)
                    {
                        let pin_type = property_to_pin_type(prop);
                        pins.push(Pin {
                            pin_id: Guid::random(),
                            pin_name: prop.name.clone(),
                            pin_tooltip: None,
                            pin_friendly_name: None,
                            direction: Some(PinDirection::Input), // Return/out params are inputs on result node
                            pin_type,
                            default_value: None,
                            autogenerated_default_value: None,
                            default_text_value: None,
                            default_object: None,
                            linked_to: vec![],
                            persistent_guid: Guid::zero(),
                            flags: PinFlags::default(),
                        });
                    }
                }
            }

            let node = Node {
                name: node_name.clone(),
                pos_x: (*node_counter * 300) as i32,
                pos_y: 0,
                node_data: NodeData::FunctionResult {
                    function_reference: FunctionReference {
                        member_parent: None,
                        member_name: "UNKNOWN".to_string(), // TODO: get from function context
                        member_guid: None,
                        self_context: false,
                    },
                    is_editable: Some(true),
                },
                pins,
                ..Default::default()
            };

            Some((node, vec![]))
        }

        // Skip control flow expressions for now
        ExprKind::Jump { .. }
        | ExprKind::JumpIfNot { .. }
        | ExprKind::ComputedJump { .. }
        | ExprKind::PushExecutionFlow { .. }
        | ExprKind::PopExecutionFlow
        | ExprKind::PopExecutionFlowIfNot { .. } => {
            None // These are handled by the CFG
        }

        other => {
            panic!("expr_to_node: unsupported expression kind: {:?}", other);
        }
    }
}
