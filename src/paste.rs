use crate::bytecode::{
    address_index::AddressIndex,
    cfg::ControlFlowGraph,
    expr::{Expr, ExprKind},
    refs::FunctionRef,
};
use paste_buffer::{
    BPGraph, ExportTextPath, FunctionReference, Guid, Node, NodeData, Pin, PinConnection,
    PinDirection, PinFlags, PinType, UserDefinedPin,
};

/// Represents a compiled node graph for an expression
/// An expression may compile to multiple nodes (e.g., function call + variable gets for params)
#[derive(Debug, Clone)]
struct NodeGraph {
    /// All nodes generated for this expression
    nodes: Vec<Node>,
    /// The exec input pin (if this graph has execution flow)
    exec_input: Option<(String, Guid)>, // (node_name, pin_id)
    /// The exec output pin (if this graph has execution flow)
    exec_output: Option<(String, Guid)>, // (node_name, pin_id)
    /// Data output pins by parameter name (for value expressions)
    data_outputs: Vec<(String, String, Guid)>, // (param_name, node_name, pin_id)
    /// Internal data connections within this graph (from, to)
    internal_connections: Vec<(PinConnection, PinConnection)>,
}

pub fn format_as_paste(
    expressions: &[Expr],
    address_index: &AddressIndex,
    function_name: &str,
    func: &jmap::Function,
    jmap: &jmap::Jmap,
) {
    // Build CFG and structure it
    let cfg = ControlFlowGraph::from_expressions(expressions);

    // Extract just the object name from the full path (e.g., "MyFunction" from "/Script/Module.Class:MyFunction")
    let graph_name = function_name
        .rsplit_once(':')
        .map(|(_, name)| name)
        .unwrap_or(function_name);

    let mut graph = BPGraph {
        graph_name: graph_name.to_string(),
        graph_type: "GT_Function".to_string(),
        original_blueprint: ExportTextPath::blueprint(
            "/Game/Decompiled/GeneratedFunction.GeneratedFunction",
        ),
        nodes: vec![],
    };

    // Create function entry node with parameters
    let entry_node = create_function_entry_node(graph_name, func);
    graph.add_node(entry_node);

    // Convert expressions to Blueprint node graphs
    let mut node_counter = 0;
    let mut node_graphs: Vec<NodeGraph> = Vec::new();

    for expr in expressions {
        if let Some(node_graph) = expr_to_node(
            expr,
            &mut node_counter,
            None,
            func,
            jmap,
            address_index,
            graph_name,
        ) {
            node_graphs.push(node_graph);
        }
    }

    // Collect all nodes and connect execution flow
    let mut prev_exec_out: Option<(String, Guid)> = None;

    // Start by connecting to the function entry's "then" pin
    // TODO: Extract the entry node's exec output pin

    for node_graph in node_graphs {
        // Add all nodes from this graph
        for node in node_graph.nodes {
            graph.add_node(node);
        }

        // Connect execution flow from previous node
        if let (Some((prev_node, prev_pin)), Some((curr_node, curr_pin))) =
            (prev_exec_out, node_graph.exec_input)
        {
            graph.connect_pins(&prev_node, &prev_pin, &curr_node, &curr_pin);
        }

        // Connect internal data pins (e.g., VariableGet -> CallFunction params)
        for (from, to) in node_graph.internal_connections {
            graph.connect_pins(&from.node_name, &from.pin_id, &to.node_name, &to.pin_id);
        }

        // Update for next iteration
        prev_exec_out = node_graph.exec_output;

        // TODO: Connect data_outputs to next node's inputs
    }

    // Serialize and print the graph
    let output = graph.serialize();
    println!("{}", output);
}

fn create_function_entry_node(function_name: &str, func: &jmap::Function) -> Node {
    use paste_buffer::LocalVariable;

    // Create user-defined pins for function parameters
    let mut user_defined_pins = Vec::new();
    let mut pins = vec![Pin {
        pin_id: Guid::random(),
        pin_name: "then".to_string(),
        pin_tooltip: None,
        pin_friendly_name: None,
        direction: Some(PinDirection::Output),
        pin_type: PinType::exec(),
        default_value: None,
        autogenerated_default_value: None,
        default_text_value: None,
        default_object: None,
        linked_to: vec![],
        persistent_guid: Guid::zero(),
        flags: PinFlags::default(),
    }];

    // Collect local variables (non-parameter properties)
    let mut local_variables = Vec::new();

    // Extract parameters from the function - properties with CPF_Parm flag
    for prop in &func.r#struct.properties {
        if prop.flags.contains(jmap::EPropertyFlags::CPF_Parm) {
            let pin_type = property_to_pin_type(prop);

            // Return parameters and out parameters are inputs on the function entry node
            if prop.flags.contains(jmap::EPropertyFlags::CPF_ReturnParm)
                || prop.flags.contains(jmap::EPropertyFlags::CPF_OutParm)
            {
                user_defined_pins.push(UserDefinedPin {
                    pin_name: prop.name.clone(),
                    pin_type: pin_type.clone(),
                    desired_pin_direction: PinDirection::Input,
                    pin_default_value: None,
                });

                pins.push(Pin {
                    pin_id: Guid::random(),
                    pin_name: prop.name.clone(),
                    pin_tooltip: None,
                    pin_friendly_name: None,
                    direction: Some(PinDirection::Input),
                    pin_type,
                    default_value: None,
                    autogenerated_default_value: None,
                    default_text_value: None,
                    default_object: None,
                    linked_to: vec![],
                    persistent_guid: Guid::zero(),
                    flags: PinFlags::default(),
                });
            } else {
                // Regular input parameters are outputs on the function entry node
                user_defined_pins.push(UserDefinedPin {
                    pin_name: prop.name.clone(),
                    pin_type: pin_type.clone(),
                    desired_pin_direction: PinDirection::Output,
                    pin_default_value: None,
                });

                pins.push(Pin {
                    pin_id: Guid::random(),
                    pin_name: prop.name.clone(),
                    pin_tooltip: None,
                    pin_friendly_name: None,
                    direction: Some(PinDirection::Output),
                    pin_type,
                    default_value: None,
                    autogenerated_default_value: None,
                    default_text_value: None,
                    default_object: None,
                    linked_to: vec![],
                    persistent_guid: Guid::zero(),
                    flags: PinFlags::default(),
                });
            }
        } else {
            // This is a local variable
            local_variables.push(LocalVariable {
                var_name: prop.name.clone(),
                var_guid: Guid::random(),
                var_type: property_to_pin_type(prop),
                friendly_name: Some(prop.name.clone()),
                category: None,
                property_flags: Some(5), // Default property flags for local vars
            });
        }
    }

    Node {
        name: "K2Node_FunctionEntry_0".to_string(),
        guid: Guid::random(),
        pos_x: 0,
        pos_y: 0,
        advanced_pin_display: None,
        node_data: NodeData::FunctionEntry {
            function_reference: FunctionReference {
                member_parent: None,
                member_name: function_name.to_string(),
                member_guid: None,
                self_context: false,
            },
            extra_flags: Some(201457664),
            is_editable: Some(true),
            local_variables,
        },
        pins,
        user_defined_pins,
    }
}

/// Look up a function by its reference (address or name)
///
/// If `context_expr` is None, the function should be resolved on the owning class (self).
/// If `context_expr` is Some, the function should be resolved on the context object's type.
///
/// Returns the function and its full path name from the JMAP
fn resolve_function<'a>(
    func_ref: &FunctionRef,
    context_expr: Option<&Expr>,
    owning_class: &jmap::Function,
    jmap: &'a jmap::Jmap,
    address_index: &AddressIndex<'a>,
) -> Option<(&'a jmap::Function, &'a str)> {
    match func_ref {
        FunctionRef::ByAddress(addr) => {
            // Look up the object by address
            if let Some(obj_name) = address_index.object_index.get(&addr.0) {
                if let Some(jmap::ObjectType::Function(func)) = jmap.objects.get(*obj_name) {
                    return Some((func, *obj_name));
                }
            }
            None
        }
        FunctionRef::ByName(name) => {
            // Virtual function by name - need to resolve on the target class
            let target_class = if let Some(_ctx) = context_expr {
                // TODO: Extract the type from the context expression
                // For now, we can't resolve this without type information
                return None;
            } else {
                // No context means call on self - use the owning class
                // Get the class that owns this function
                if let Some(parent_class) = &owning_class.r#struct.object.outer {
                    parent_class
                } else {
                    return None;
                }
            };

            // Search for a function with this name in the target class
            let name_str = name.as_str();

            // Look for a function object that belongs to this class
            for (obj_path, obj) in &jmap.objects {
                if let jmap::ObjectType::Function(func) = obj {
                    // Check if this function belongs to the target class and has matching name
                    if obj_path.contains(target_class) && obj_path.ends_with(name_str) {
                        return Some((func, obj_path.as_str()));
                    }
                }
            }

            None
        }
    }
}

/// Extract just the function name from a full object path
/// E.g., "/Script/Module.Class:FunctionName" -> "FunctionName"
fn extract_function_name(full_path: &str) -> &str {
    full_path
        .rsplit_once(':')
        .map(|(_, name)| name)
        .unwrap_or(full_path)
}

/// Create a VariableGet node for a parameter expression
/// Returns the node and the pin that outputs the variable value
fn create_variable_get_node(
    expr: &Expr,
    node_counter: &mut i32,
    address_index: &AddressIndex,
    func: &jmap::Function,
    graph_name: &str,
) -> Option<(Node, Guid, PinType)> {
    match &expr.kind {
        ExprKind::LocalVariable(prop_ref) | ExprKind::InstanceVariable(prop_ref) => {
            // Look up the property to get its name and type
            if let Some((owner_path, prop_idx)) =
                address_index.property_index.get(&prop_ref.address.0)
            {
                // Find the property in the owner's struct
                // For now, we'll use a simple approach - extract from the function's properties
                let var_name = func
                    .r#struct
                    .properties
                    .get(*prop_idx)
                    .map(|p| p.name.as_str())
                    .unwrap_or("Unknown");

                let pin_type = func
                    .r#struct
                    .properties
                    .get(*prop_idx)
                    .map(|p| property_to_pin_type(p))
                    .unwrap_or_else(|| PinType::object("/Script/CoreUObject.Object"));

                let node_name = format!("K2Node_VariableGet_{}", node_counter);
                *node_counter += 1;

                let output_pin_id = Guid::random();

                let node = Node {
                    name: node_name,
                    guid: Guid::random(),
                    pos_x: (*node_counter * 200) as i32,
                    pos_y: (*node_counter * 80) as i32,
                    advanced_pin_display: None,
                    node_data: NodeData::VariableGet {
                        variable_reference: paste_buffer::VariableReference {
                            member_parent: None,
                            member_scope: Some(graph_name.to_string()),
                            member_name: var_name.to_string(),
                            member_guid: None,
                            self_context: matches!(expr.kind, ExprKind::InstanceVariable(_)),
                        },
                        self_context_info: None,
                        error_type: None,
                    },
                    pins: vec![Pin {
                        pin_id: output_pin_id,
                        pin_name: var_name.to_string(),
                        pin_tooltip: None,
                        pin_friendly_name: None,
                        direction: Some(PinDirection::Output),
                        pin_type: pin_type.clone(),
                        default_value: None,
                        autogenerated_default_value: None,
                        default_text_value: None,
                        default_object: None,
                        linked_to: vec![],
                        persistent_guid: Guid::zero(),
                        flags: PinFlags::default(),
                    }],
                    user_defined_pins: vec![],
                };

                return Some((node, output_pin_id, pin_type));
            }
            None
        }
        _ => None, // TODO: Handle other parameter expression types
    }
}

/// Create a VariableSet node for an out parameter expression
/// Returns the node and the pin that receives the variable value
fn create_variable_set_node(
    expr: &Expr,
    node_counter: &mut i32,
    address_index: &AddressIndex,
    func: &jmap::Function,
    graph_name: &str,
) -> Option<(Node, Guid, PinType)> {
    match &expr.kind {
        ExprKind::LocalVariable(prop_ref) | ExprKind::InstanceVariable(prop_ref) => {
            // Look up the property to get its name and type
            if let Some((owner_path, prop_idx)) =
                address_index.property_index.get(&prop_ref.address.0)
            {
                let var_name = func
                    .r#struct
                    .properties
                    .get(*prop_idx)
                    .map(|p| p.name.as_str())
                    .unwrap_or("Unknown");

                let pin_type = func
                    .r#struct
                    .properties
                    .get(*prop_idx)
                    .map(|p| property_to_pin_type(p))
                    .unwrap_or_else(|| PinType::object("/Script/CoreUObject.Object"));

                let node_name = format!("K2Node_VariableSet_{}", node_counter);
                *node_counter += 1;

                let exec_in_pin = Guid::random();
                let exec_out_pin = Guid::random();
                let value_input_pin = Guid::random();
                let output_get_pin = Guid::random();

                let node = Node {
                    name: node_name,
                    guid: Guid::random(),
                    pos_x: (*node_counter * 200) as i32,
                    pos_y: (*node_counter * 80) as i32,
                    advanced_pin_display: None,
                    node_data: NodeData::VariableSet {
                        variable_reference: paste_buffer::VariableReference {
                            member_parent: None,
                            member_scope: Some(graph_name.to_string()),
                            member_name: var_name.to_string(),
                            member_guid: None,
                            self_context: matches!(expr.kind, ExprKind::InstanceVariable(_)),
                        },
                    },
                    pins: vec![
                        Pin {
                            pin_id: exec_in_pin,
                            pin_name: "execute".to_string(),
                            direction: Some(PinDirection::Input),
                            pin_type: PinType::exec(),
                            ..Default::default()
                        },
                        Pin {
                            pin_id: exec_out_pin,
                            pin_name: "then".to_string(),
                            direction: Some(PinDirection::Output),
                            pin_type: PinType::exec(),
                            ..Default::default()
                        },
                        Pin {
                            pin_id: value_input_pin,
                            pin_name: var_name.to_string(),
                            direction: Some(PinDirection::Input),
                            pin_type: pin_type.clone(),
                            ..Default::default()
                        },
                        Pin {
                            pin_id: output_get_pin,
                            pin_name: "Output_Get".to_string(),
                            pin_tooltip: Some("Retrieves the value of the variable, can use instead of a separate Get node".to_string()),
                            direction: Some(PinDirection::Output),
                            pin_type: pin_type.clone(),
                            ..Default::default()
                        },
                    ],
                    user_defined_pins: vec![],
                };

                return Some((node, value_input_pin, pin_type));
            }
            None
        }
        _ => None,
    }
}

/// Add parameter pins to a function call node based on the function definition
/// Returns (param_name, pin_id, is_input) for each parameter to help with connections
fn add_function_parameter_pins(
    pins: &mut Vec<Pin>,
    called_func: Option<&jmap::Function>,
) -> Vec<(String, Guid, bool)> {
    let mut param_info = Vec::new();

    if let Some(func) = called_func {
        for prop in &func.r#struct.properties {
            if prop.flags.contains(jmap::EPropertyFlags::CPF_Parm) {
                let pin_id = Guid::random();
                let pin_type = property_to_pin_type(prop);

                // Skip return parameters - they're outputs
                if prop.flags.contains(jmap::EPropertyFlags::CPF_ReturnParm) {
                    pins.push(Pin {
                        pin_id,
                        pin_name: prop.name.clone(),
                        direction: Some(PinDirection::Output),
                        pin_type,
                        ..Default::default()
                    });
                    param_info.push((prop.name.clone(), pin_id, false));
                } else if prop.flags.contains(jmap::EPropertyFlags::CPF_OutParm) {
                    // Out parameters are outputs
                    pins.push(Pin {
                        pin_id,
                        pin_name: prop.name.clone(),
                        direction: Some(PinDirection::Output),
                        pin_type,
                        ..Default::default()
                    });
                    param_info.push((prop.name.clone(), pin_id, false));
                } else {
                    // Regular input parameters
                    pins.push(Pin {
                        pin_id,
                        pin_name: prop.name.clone(),
                        direction: Some(PinDirection::Input),
                        pin_type,
                        ..Default::default()
                    });
                    param_info.push((prop.name.clone(), pin_id, true));
                }
            }
        }
    }

    param_info
}

fn property_to_pin_type(prop: &jmap::Property) -> PinType {
    // Convert JMAP property type to Blueprint PinType
    match &prop.r#type {
        jmap::PropertyType::Int => PinType::int(),
        jmap::PropertyType::Int8 | jmap::PropertyType::Byte { r#enum: None } => PinType {
            category: "byte".to_string(),
            ..Default::default()
        },
        jmap::PropertyType::Int16 | jmap::PropertyType::UInt16 | jmap::PropertyType::UInt32 => {
            PinType::int()
        }
        jmap::PropertyType::Int64 | jmap::PropertyType::UInt64 => PinType {
            category: "int64".to_string(),
            ..Default::default()
        },
        jmap::PropertyType::Float | jmap::PropertyType::Double => PinType::float(),
        jmap::PropertyType::Bool { .. } => PinType::bool(),
        jmap::PropertyType::Str => PinType::string(),
        jmap::PropertyType::Name => PinType {
            category: "name".to_string(),
            ..Default::default()
        },
        jmap::PropertyType::Text => PinType {
            category: "text".to_string(),
            ..Default::default()
        },
        jmap::PropertyType::Byte { r#enum: Some(_) } => {
            todo!("property_to_pin_type: enum byte properties not yet supported");
        }
        jmap::PropertyType::Enum { r#enum, .. } => {
            todo!(
                "property_to_pin_type: enum properties not yet supported: {:?}",
                r#enum
            );
        }
        jmap::PropertyType::Struct { r#struct } => {
            todo!(
                "property_to_pin_type: struct properties not yet supported: {}",
                r#struct
            );
        }
        jmap::PropertyType::Object { property_class } => PinType::object(property_class),
        jmap::PropertyType::Class {
            property_class,
            meta_class,
        } => PinType {
            category: "class".to_string(),
            sub_category: meta_class.clone(),
            sub_category_object: Some(ExportTextPath::class(property_class)),
            ..Default::default()
        },
        jmap::PropertyType::Interface { interface_class } => PinType {
            category: "interface".to_string(),
            sub_category_object: Some(ExportTextPath::class(interface_class)),
            container_type: Some("None".to_string()),
            ..Default::default()
        },
        jmap::PropertyType::Array { inner } => {
            // Get the inner type and modify it to be an array
            let mut inner_pin_type = property_to_pin_type(inner);
            inner_pin_type.container_type = Some("Array".to_string());
            inner_pin_type
        }
        other => panic!(
            "property_to_pin_type: unsupported property type: {:?}",
            other
        ),
    }
}

/// Helper function to create a function call node graph (used by VirtualFunction, LocalVirtualFunction, FinalFunction)
fn create_function_call_node(
    func_ref: &FunctionRef,
    params: &[Expr],
    node_counter: &mut i32,
    context_expr: Option<&Expr>,
    func: &jmap::Function,
    jmap: &jmap::Jmap,
    address_index: &AddressIndex<'_>,
    graph_name: &str,
) -> Option<NodeGraph> {
    let node_name = format!("K2Node_CallFunction_{}", node_counter);
    *node_counter += 1;

    // Try to resolve the function to get parameter information
    let resolved = resolve_function(func_ref, context_expr, func, jmap, address_index);
    let (called_func, func_name) = if let Some((f, path)) = resolved {
        (Some(f), extract_function_name(path).to_string())
    } else {
        (None, format!("{:?}", func_ref))
    };

    let exec_in_pin = Guid::random();
    let exec_out_pin = Guid::random();

    let mut pins = vec![
        Pin {
            pin_id: exec_in_pin,
            pin_name: "execute".to_string(),
            direction: Some(PinDirection::Input),
            pin_type: PinType::exec(),
            ..Default::default()
        },
        Pin {
            pin_id: exec_out_pin,
            pin_name: "then".to_string(),
            direction: Some(PinDirection::Output),
            pin_type: PinType::exec(),
            ..Default::default()
        },
    ];

    // If we have a context expression, add a self/target pin
    if context_expr.is_some() {
        pins.push(Pin {
            pin_id: Guid::random(),
            pin_name: "self".to_string(),
            direction: Some(PinDirection::Input),
            pin_type: PinType::object("/Script/CoreUObject.Object"),
            ..Default::default()
        });
    }

    // Add parameter pins and get their info for connecting
    let param_pins = add_function_parameter_pins(&mut pins, called_func);

    let call_node = Node {
        name: node_name.clone(),
        guid: Guid::random(),
        pos_x: (*node_counter * 300) as i32,
        pos_y: 0,
        node_data: NodeData::CallFunction {
            function_reference: FunctionReference {
                member_parent: None,
                member_name: func_name,
                member_guid: None,
                self_context: context_expr.is_none(),
            },
            is_pure: false,
            is_const: None,
            is_interface_call: None,
            error_type: None,
        },
        pins,
        ..Default::default()
    };

    // Process parameters to create VariableGet/VariableSet nodes and connect them
    let mut all_nodes = vec![call_node];
    let mut param_connections = Vec::new();
    let mut out_param_set_nodes = Vec::new(); // Track VariableSet nodes for execution flow

    for (param_expr, (param_name, param_pin_id, is_input)) in params.iter().zip(param_pins.iter()) {
        if *is_input {
            // Input parameter: Create VariableGet node
            if let Some((var_get_node, var_output_pin, _pin_type)) =
                create_variable_get_node(param_expr, node_counter, address_index, func, graph_name)
            {
                let var_node_name = var_get_node.name.clone();
                all_nodes.push(var_get_node);

                // Track connection: var_get output -> call_node param input
                param_connections.push((
                    PinConnection {
                        node_name: var_node_name,
                        pin_id: var_output_pin,
                    },
                    PinConnection {
                        node_name: node_name.clone(),
                        pin_id: *param_pin_id,
                    },
                ));
            }
        } else {
            // Output parameter: Create VariableSet node
            if let Some((var_set_node, var_input_pin, _pin_type)) =
                create_variable_set_node(param_expr, node_counter, address_index, func, graph_name)
            {
                let var_node_name = var_set_node.name.clone();

                // Get exec pins for chaining
                let var_set_exec_in = var_set_node
                    .pins
                    .iter()
                    .find(|p| p.pin_name == "execute")
                    .map(|p| p.pin_id)
                    .unwrap();
                let var_set_exec_out = var_set_node
                    .pins
                    .iter()
                    .find(|p| p.pin_name == "then")
                    .map(|p| p.pin_id)
                    .unwrap();

                all_nodes.push(var_set_node);
                out_param_set_nodes.push((
                    var_node_name.clone(),
                    var_set_exec_in,
                    var_set_exec_out,
                ));

                // Track connection: call_node param output -> var_set input
                param_connections.push((
                    PinConnection {
                        node_name: node_name.clone(),
                        pin_id: *param_pin_id,
                    },
                    PinConnection {
                        node_name: var_node_name,
                        pin_id: var_input_pin,
                    },
                ));
            }
        }
    }

    // Determine final execution output
    // If there are out parameter VariableSet nodes, chain them and use the last one's output
    let final_exec_output =
        if let Some((first_set_name, first_set_exec_in, _)) = out_param_set_nodes.first() {
            // Connect call_node's exec output to first VariableSet's exec input
            param_connections.push((
                PinConnection {
                    node_name: node_name.clone(),
                    pin_id: exec_out_pin,
                },
                PinConnection {
                    node_name: first_set_name.clone(),
                    pin_id: *first_set_exec_in,
                },
            ));

            // Chain VariableSet nodes together if there are multiple
            for i in 0..out_param_set_nodes.len() - 1 {
                let (curr_name, _, curr_exec_out) = &out_param_set_nodes[i];
                let (next_name, next_exec_in, _) = &out_param_set_nodes[i + 1];
                param_connections.push((
                    PinConnection {
                        node_name: curr_name.clone(),
                        pin_id: *curr_exec_out,
                    },
                    PinConnection {
                        node_name: next_name.clone(),
                        pin_id: *next_exec_in,
                    },
                ));
            }

            // Final output is the last VariableSet's exec output
            let (last_name, _, last_exec_out) = out_param_set_nodes.last().unwrap();
            Some((last_name.clone(), *last_exec_out))
        } else {
            // No out params, use the call_node's exec output directly
            Some((node_name.clone(), exec_out_pin))
        };

    Some(NodeGraph {
        nodes: all_nodes,
        exec_input: Some((node_name, exec_in_pin)),
        exec_output: final_exec_output,
        data_outputs: vec![],
        internal_connections: param_connections,
    })
}

/// Convert an expression to a Blueprint node graph
///
/// Returns a NodeGraph containing all nodes needed for this expression, along with
/// connection points for linking to other expressions.
///
/// `context_expr` is an optional expression that provides the target/self object for this operation
/// `func` is the function being decompiled, needed for return node parameter information
/// `jmap` is the JMAP data for looking up function definitions
/// `address_index` is for resolving addresses to objects
/// `graph_name` is the name of the blueprint graph (used for variable scope)
fn expr_to_node(
    expr: &Expr,
    node_counter: &mut i32,
    context_expr: Option<&Expr>,
    func: &jmap::Function,
    jmap: &jmap::Jmap,
    address_index: &AddressIndex<'_>,
    graph_name: &str,
) -> Option<NodeGraph> {
    let graph = match &expr.kind {
        // Context expression unwraps the inner operation with a target object
        ExprKind::Context {
            object, context, ..
        } => {
            // Recursively process the context expression with the object as the target
            expr_to_node(
                context,
                node_counter,
                Some(object),
                func,
                jmap,
                address_index,
                graph_name,
            )
        }

        ExprKind::VirtualFunction {
            func: func_ref,
            params,
        }
        | ExprKind::LocalVirtualFunction {
            func: func_ref,
            params,
        }
        | ExprKind::FinalFunction {
            func: func_ref,
            params,
        } => create_function_call_node(
            func_ref,
            params,
            node_counter,
            context_expr,
            func,
            jmap,
            address_index,
            graph_name,
        ),

        ExprKind::Let {
            variable, value, ..
        }
        | ExprKind::LetBool { variable, value }
        | ExprKind::LetObj { variable, value }
        | ExprKind::LetWeakObjPtr { variable, value }
        | ExprKind::LetDelegate { variable, value }
        | ExprKind::LetMulticastDelegate { variable, value } => {
            let node_name = format!("K2Node_VariableSet_{}", node_counter);
            *node_counter += 1;

            let exec_in_pin = Guid::random();
            let exec_out_pin = Guid::random();

            let node = Node {
                name: node_name.clone(),
                guid: Guid::random(),
                pos_x: (*node_counter * 300) as i32,
                pos_y: 0,
                node_data: NodeData::VariableSet {
                    variable_reference: paste_buffer::VariableReference {
                        member_parent: None,
                        member_scope: None,
                        member_name: "UNKNOWN_VAR".to_string(), // TODO: extract from variable
                        member_guid: None,
                        self_context: true,
                    },
                },
                pins: vec![
                    Pin {
                        pin_id: exec_in_pin,
                        pin_name: "execute".to_string(),
                        direction: Some(PinDirection::Input),
                        pin_type: PinType::exec(),
                        ..Default::default()
                    },
                    Pin {
                        pin_id: exec_out_pin,
                        pin_name: "then".to_string(),
                        direction: Some(PinDirection::Output),
                        pin_type: PinType::exec(),
                        ..Default::default()
                    },
                    // TODO: Add variable value input pin
                    // TODO: Add Output_Get pin
                ],
                ..Default::default()
            };

            Some(NodeGraph {
                nodes: vec![node],
                exec_input: Some((node_name.clone(), exec_in_pin)),
                exec_output: Some((node_name, exec_out_pin)),
                data_outputs: vec![],
                internal_connections: vec![],
            })
        }

        ExprKind::Return(return_expr) => {
            let node_name = format!("K2Node_FunctionResult_{}", node_counter);
            *node_counter += 1;

            let exec_in_pin = Guid::random();

            let mut pins = vec![Pin {
                pin_id: exec_in_pin,
                pin_name: "execute".to_string(),
                direction: Some(PinDirection::Input),
                pin_type: PinType::exec(),
                ..Default::default()
            }];

            // Add pins for return parameters and out parameters
            for prop in &func.r#struct.properties {
                if prop.flags.contains(jmap::EPropertyFlags::CPF_Parm) {
                    if prop.flags.contains(jmap::EPropertyFlags::CPF_ReturnParm)
                        || prop.flags.contains(jmap::EPropertyFlags::CPF_OutParm)
                    {
                        let pin_type = property_to_pin_type(prop);
                        pins.push(Pin {
                            pin_id: Guid::random(),
                            pin_name: prop.name.clone(),
                            pin_tooltip: None,
                            pin_friendly_name: None,
                            direction: Some(PinDirection::Input),
                            pin_type,
                            default_value: None,
                            autogenerated_default_value: None,
                            default_text_value: None,
                            default_object: None,
                            linked_to: vec![],
                            persistent_guid: Guid::zero(),
                            flags: PinFlags::default(),
                        });
                    }
                }
            }

            let node = Node {
                name: node_name.clone(),
                guid: Guid::random(),
                pos_x: (*node_counter * 300) as i32,
                pos_y: 0,
                node_data: NodeData::FunctionResult {
                    function_reference: FunctionReference {
                        member_parent: None,
                        member_name: "UNKNOWN".to_string(),
                        member_guid: None,
                        self_context: false,
                    },
                    is_editable: Some(true),
                },
                pins,
                ..Default::default()
            };

            Some(NodeGraph {
                nodes: vec![node],
                exec_input: Some((node_name, exec_in_pin)),
                exec_output: None, // Return has no exec output
                data_outputs: vec![],
                internal_connections: vec![],
            })
        }

        // Skip control flow expressions for now
        ExprKind::Jump { .. }
        | ExprKind::JumpIfNot { .. }
        | ExprKind::ComputedJump { .. }
        | ExprKind::PushExecutionFlow { .. }
        | ExprKind::PopExecutionFlow
        | ExprKind::PopExecutionFlowIfNot { .. } => {
            None // These are handled by the CFG
        }

        other => {
            panic!("expr_to_node: unsupported expression kind: {:?}", other);
        }
    };
    dbg!(&graph);
    graph
}
