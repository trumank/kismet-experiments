// Size: 0xb8
class UAIGraph : public UEdGraph {
    /* 0x00b0 */ int32_t GraphVersion;
};

// Size: 0x168
class UAIGraphNode : public UEdGraphNode {
    /* 0x00c8 */ FGraphNodeClassData ClassData;
    /* 0x0130 */ UObject* NodeInstance;
    /* 0x0138 */ UAIGraphNode* ParentNode;
    /* 0x0140 */ TArray<UAIGraphNode*> SubNodes;
    /* 0x0150 */ int32_t CopySubNodeIndex;
    /* 0x0154 */ bool bIsReadOnly;
    /* 0x0154 */ bool bIsSubNode;
    /* 0x0158 */ FString ErrorMessage;
};

// Size: 0x30
class UAIGraphSchema : public UEdGraphSchema {
};

// Size: 0x100
struct FAISchemaAction_AddComment : public FEdGraphSchemaAction {
};

// Size: 0x108
struct FAISchemaAction_NewNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UAIGraphNode* NodeTemplate;
};

// Size: 0x110
struct FAISchemaAction_NewSubNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UAIGraphNode* NodeTemplate;
    /* 0x0108 */ UAIGraphNode* ParentNode;
};

// Size: 0x68
struct FGraphNodeClassData {
    /* 0x0010 */ FString AssetName;
    /* 0x0020 */ FString GeneratedClassPackage;
    /* 0x0030 */ FString ClassName;
    /* 0x0040 */ FText Category;
};

// Size: 0xf8
class UK2Node_AIMoveTo : public UK2Node_BaseAsyncTask {
};

// Size: 0x70
class UAIAsyncTaskBlueprintProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFail;

    void OnMoveCompleted(FAIRequestID RequestID, uint8_t MovementResult);
};

// Size: 0x30
class UAIBlueprintHelperLibrary : public UBlueprintFunctionLibrary {

    static UAIAsyncTaskBlueprintProxy* CreateMoveToProxyObject(UObject* WorldContextObject, APawn* Pawn, FVector Destination, AActor* TargetActor, float AcceptanceRadius, bool bStopOnOverlap);
    static AAIController* GetAIController(AActor* ControlledActor);
    static UBlackboardComponent* GetBlackboard(AActor* Target);
    static UNavigationPath* GetCurrentPath(AController* Controller);
    static int32_t GetCurrentPathIndex(const AController* Controller);
    static TArray<FVector> GetCurrentPathPoints(AController* Controller);
    static int32_t GetNextNavLinkIndex(const AController* Controller);
    static bool IsValidAIDirection(FVector DirectionVector);
    static bool IsValidAILocation(FVector Location);
    static bool IsValidAIRotation(FRotator Rotation);
    static void LockAIResourcesWithAnimation(UAnimInstance* AnimInstance, bool bLockMovement, bool LockAILogic);
    static void SendAIMessage(APawn* Target, FName Message, UObject* MessageSource, bool bSuccess);
    static void SimpleMoveToActor(AController* Controller, const AActor* Goal);
    static void SimpleMoveToLocation(AController* Controller, const FVector& Goal);
    static APawn* SpawnAIFromClass(UObject* WorldContextObject, UClass* PawnClass, UBehaviorTree* BehaviorTree, FVector Location, FRotator Rotation, bool bNoCollisionFail, AActor* Owner);
    static void UnlockAIResourcesWithAnimation(UAnimInstance* AnimInstance, bool bUnlockMovement, bool UnlockAILogic);
};

// Size: 0x408
class AAIController : public AController {
    /* 0x03b0 */ bool bStartAILogicOnPossess;
    /* 0x03b0 */ bool bStopAILogicOnUnposses;
    /* 0x03b0 */ bool bLOSflag;
    /* 0x03b0 */ bool bSkipExtraLOSChecks;
    /* 0x03b0 */ bool bAllowStrafe;
    /* 0x03b0 */ bool bWantsPlayerState;
    /* 0x03b0 */ bool bSetControlRotationFromPawnOrientation;
    /* 0x03b8 */ UPathFollowingComponent* PathFollowingComponent;
    /* 0x03c0 */ UBrainComponent* BrainComponent;
    /* 0x03c8 */ UAIPerceptionComponent* PerceptionComponent;
    /* 0x03d0 */ UPawnActionsComponent* ActionsComp;
    /* 0x03d8 */ UBlackboardComponent* Blackboard;
    /* 0x03e0 */ UGameplayTasksComponent* CachedGameplayTasksComponent;
    /* 0x03e8 */ UClass* DefaultNavigationFilterClass;
    /* 0x03f0 */ FMulticastInlineDelegate ReceiveMoveCompleted;

    void ClaimTaskResource(UClass* ResourceClass);
    UAIPerceptionComponent* GetAIPerceptionComponent();
    FVector GetFocalPoint() const;
    FVector GetFocalPointOnActor(const AActor* Actor) const;
    AActor* GetFocusActor() const;
    FVector GetImmediateMoveDestination() const;
    uint8_t GetMoveStatus() const;
    UPathFollowingComponent* GetPathFollowingComponent() const;
    bool HasPartialPath() const;
    void K2_ClearFocus();
    void K2_SetFocalPoint(FVector FP);
    void K2_SetFocus(AActor* NewFocus);
    uint8_t MoveToActor(AActor* Goal, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bCanStrafe, UClass* FilterClass, bool bAllowPartialPath);
    uint8_t MoveToLocation(const FVector& Dest, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bProjectDestinationToNavigation, bool bCanStrafe, UClass* FilterClass, bool bAllowPartialPath);
    void OnGameplayTaskResourcesClaimed(FGameplayResourceSet NewlyClaimed, FGameplayResourceSet FreshlyReleased);
    void OnUsingBlackBoard(UBlackboardComponent* BlackboardComp, UBlackboardData* BlackboardAsset);
    bool RunBehaviorTree(UBehaviorTree* BTAsset);
    void SetMoveBlockDetection(bool bEnable);
    void SetPathFollowingComponent(UPathFollowingComponent* NewPFComponent);
    void UnclaimTaskResource(UClass* ResourceClass);
    bool UseBlackboard(UBlackboardData* BlackboardAsset, UBlackboardComponent*& BlackboardComponent);
};

// Size: 0x40
struct FAIDamageEvent {
    /* 0x0000 */ float Amount;
    /* 0x0004 */ FVector Location;
    /* 0x0010 */ FVector HitLocation;
    /* 0x0020 */ AActor* DamagedActor;
    /* 0x0028 */ AActor* Instigator;
    /* 0x0030 */ FName Tag;
};

// Size: 0x30
class UAIDataProvider : public UObject {
};

// Size: 0x40
struct FAIDataProviderBoolValue : public FAIDataProviderTypedValue {
    /* 0x0038 */ bool DefaultValue;
};

// Size: 0x40
struct FAIDataProviderFloatValue : public FAIDataProviderTypedValue {
    /* 0x0038 */ float DefaultValue;
};

// Size: 0x40
struct FAIDataProviderIntValue : public FAIDataProviderTypedValue {
    /* 0x0038 */ int32_t DefaultValue;
};

// Size: 0x38
struct FAIDataProviderStructValue : public FAIDataProviderValue {
};

// Size: 0x38
struct FAIDataProviderTypedValue : public FAIDataProviderValue {
    /* 0x0028 */ UClass* PropertyType;
};

// Size: 0x28
struct FAIDataProviderValue {
    /* 0x0010 */ UAIDataProvider* DataBinding;
    /* 0x0018 */ FName DataField;
};

// Size: 0x48
class UAIDataProvider_QueryParams : public UAIDataProvider {
    /* 0x0030 */ FName ParamName;
    /* 0x003c */ float FloatValue;
    /* 0x0040 */ int32_t IntValue;
    /* 0x0044 */ bool BoolValue;
};

// Size: 0x58
class UAIDataProvider_Random : public UAIDataProvider_QueryParams {
    /* 0x0048 */ float Min;
    /* 0x004c */ float Max;
    /* 0x0050 */ bool bInteger;
};

// Size: 0x48
struct FAIDynamicParam {
    /* 0x0000 */ FName ParamName;
    /* 0x000c */ EAIParamType ParamType;
    /* 0x0010 */ float Value;
    /* 0x0018 */ FBlackboardKeySelector BBKey;
};

// Size: 0x30
class UAIHotSpotManager : public UObject {
};

// Size: 0x40
struct FAIMoveRequest {
    /* 0x0000 */ AActor* GoalActor;
};

// Size: 0x30
struct FAINoiseEvent {
    /* 0x0004 */ FVector NoiseLocation;
    /* 0x0010 */ float Loudness;
    /* 0x0014 */ float MaxRange;
    /* 0x0018 */ AActor* Instigator;
    /* 0x0020 */ FName Tag;
};

// Size: 0x1a0
class UAIPerceptionComponent : public UActorComponent {
    /* 0x00c0 */ TArray<UAISenseConfig*> SensesConfig;
    /* 0x00d0 */ UClass* DominantSense;
    /* 0x00e8 */ AAIController* AIOwner;
    /* 0x0170 */ FMulticastInlineDelegate OnPerceptionUpdated;
    /* 0x0180 */ FMulticastInlineDelegate OnTargetPerceptionUpdated;
    /* 0x0190 */ FMulticastInlineDelegate OnTargetPerceptionInfoUpdated;

    void ForgetAll();
    bool GetActorsPerception(AActor* Actor, FActorPerceptionBlueprintInfo& Info);
    void GetCurrentlyPerceivedActors(UClass* SenseToUse, TArray<AActor*>& OutActors) const;
    void GetKnownPerceivedActors(UClass* SenseToUse, TArray<AActor*>& OutActors) const;
    void GetPerceivedActors(UClass* SenseToUse, TArray<AActor*>& OutActors) const;
    void GetPerceivedHostileActors(TArray<AActor*>& OutActors) const;
    void GetPerceivedHostileActorsBySense(const UClass* SenseToUse, TArray<AActor*>& OutActors) const;
    void OnOwnerEndPlay(AActor* Actor, uint8_t EndPlayReason);
    void RequestStimuliListenerUpdate();
    void SetSenseEnabled(UClass* SenseClass, const bool bEnable);
};

// Size: 0x30
class IAIPerceptionListenerInterface : public UInterface {
};

// Size: 0xd8
class UAIPerceptionStimuliSourceComponent : public UActorComponent {
    /* 0x00c0 */ bool bAutoRegisterAsSource;
    /* 0x00c8 */ TArray<UClass*> RegisterAsSourceForSenses;

    void RegisterForSense(UClass* SenseClass);
    void RegisterWithPerceptionSystem();
    void UnregisterFromPerceptionSystem();
    void UnregisterFromSense(UClass* SenseClass);
};

// Size: 0x138
class UAIPerceptionSystem : public UAISubsystem {
    /* 0x0090 */ TArray<UAISense*> Senses;
    /* 0x00a0 */ float PerceptionAgingRate;

    static UClass* GetSenseClassForStimulus(UObject* WorldContextObject, const FAIStimulus& Stimulus);
    void OnPerceptionStimuliSourceEndPlay(AActor* Actor, uint8_t EndPlayReason);
    static bool RegisterPerceptionStimuliSource(UObject* WorldContextObject, UClass* Sense, AActor* Target);
    void ReportEvent(UAISenseEvent* PerceptionEvent);
    static void ReportPerceptionEvent(UObject* WorldContextObject, UAISenseEvent* PerceptionEvent);
};

// Size: 0x18
struct FAIPredictionEvent {
    /* 0x0000 */ AActor* Requestor;
    /* 0x0008 */ AActor* PredictedActor;
};

// Size: 0x4
struct FAIRequestID {
    /* 0x0000 */ uint32_t RequestID;
};

// Size: 0x30
class IAIResourceInterface : public UInterface {
};

// Size: 0x40
class UAIResource_Logic : public UGameplayTaskResource {
};

// Size: 0x40
class UAIResource_Movement : public UGameplayTaskResource {
};

// Size: 0x90
class UAISense : public UObject {
    /* 0x0030 */ float DefaultExpirationAge;
    /* 0x0034 */ EAISenseNotifyType NotifyType;
    /* 0x0038 */ bool bWantsNewPawnNotification;
    /* 0x0038 */ bool bAutoRegisterAllPawnsAsSources;
    /* 0x0040 */ UAIPerceptionSystem* PerceptionSystemInstance;
};

// Size: 0x4
struct FAISenseAffiliationFilter {
    /* 0x0000 */ bool bDetectEnemies;
    /* 0x0000 */ bool bDetectNeutrals;
    /* 0x0000 */ bool bDetectFriendlies;
};

// Size: 0x138
class UAISenseBlueprintListener : public UUserDefinedStruct {
};

// Size: 0x50
class UAISenseConfig : public UObject {
    /* 0x0030 */ FColor DebugColor;
    /* 0x0034 */ float MaxAge;
    /* 0x0038 */ bool bStartsEnabled;
};

// Size: 0x58
class UAISenseConfig_Blueprint : public UAISenseConfig {
    /* 0x0050 */ UClass* Implementation;
};

// Size: 0x58
class UAISenseConfig_Damage : public UAISenseConfig {
    /* 0x0050 */ UClass* Implementation;
};

// Size: 0x68
class UAISenseConfig_Hearing : public UAISenseConfig {
    /* 0x0050 */ UClass* Implementation;
    /* 0x0058 */ float HearingRange;
    /* 0x005c */ float LoSHearingRange;
    /* 0x0060 */ bool bUseLoSHearing;
    /* 0x0064 */ FAISenseAffiliationFilter DetectionByAffiliation;
};

// Size: 0x50
class UAISenseConfig_Prediction : public UAISenseConfig {
};

// Size: 0x78
class UAISenseConfig_Sight : public UAISenseConfig {
    /* 0x0050 */ UClass* Implementation;
    /* 0x0058 */ float SightRadius;
    /* 0x005c */ float LoseSightRadius;
    /* 0x0060 */ float PeripheralVisionAngleDegrees;
    /* 0x0064 */ FAISenseAffiliationFilter DetectionByAffiliation;
    /* 0x0068 */ float AutoSuccessRangeFromLastSeenLocation;
    /* 0x006c */ float PointOfViewBackwardOffset;
    /* 0x0070 */ float NearClippingRadius;
};

// Size: 0x50
class UAISenseConfig_Team : public UAISenseConfig {
};

// Size: 0x50
class UAISenseConfig_Touch : public UAISenseConfig {
};

// Size: 0x30
class UAISenseEvent : public UObject {
};

// Size: 0x70
class UAISenseEvent_Damage : public UAISenseEvent {
    /* 0x0030 */ FAIDamageEvent Event;
};

// Size: 0x60
class UAISenseEvent_Hearing : public UAISenseEvent {
    /* 0x0030 */ FAINoiseEvent Event;
};

// Size: 0xb8
class UAISense_Blueprint : public UAISense {
    /* 0x0090 */ UClass* ListenerDataType;
    /* 0x0098 */ TArray<UAIPerceptionComponent*> ListenerContainer;
    /* 0x00a8 */ TArray<UAISenseEvent*> UnprocessedEvents;

    void GetAllListenerActors(TArray<AActor*>& ListenerActors) const;
    void GetAllListenerComponents(TArray<UAIPerceptionComponent*>& ListenerComponents) const;
    void K2_OnNewPawn(APawn* NewPawn);
    void OnListenerRegistered(AActor* ActorListener, UAIPerceptionComponent* PerceptionComponent);
    void OnListenerUnregistered(AActor* ActorListener, UAIPerceptionComponent* PerceptionComponent);
    void OnListenerUpdated(AActor* ActorListener, UAIPerceptionComponent* PerceptionComponent);
    float OnUpdate(const TArray<UAISenseEvent*>& EventsToProcess);
};

// Size: 0xa0
class UAISense_Damage : public UAISense {
    /* 0x0090 */ TArray<FAIDamageEvent> RegisteredEvents;

    static void ReportDamageEvent(UObject* WorldContextObject, AActor* DamagedActor, AActor* Instigator, float DamageAmount, FVector EventLocation, FVector HitLocation, FName Tag);
};

// Size: 0xf8
class UAISense_Hearing : public UAISense {
    /* 0x0090 */ TArray<FAINoiseEvent> NoiseEvents;
    /* 0x00a0 */ float SpeedOfSoundSq;

    static void ReportNoiseEvent(UObject* WorldContextObject, FVector NoiseLocation, float Loudness, AActor* Instigator, float MaxRange, FName Tag);
};

// Size: 0xa0
class UAISense_Prediction : public UAISense {
    /* 0x0090 */ TArray<FAIPredictionEvent> RegisteredEvents;

    static void RequestControllerPredictionEvent(AAIController* Requestor, AActor* PredictedActor, float PredictionTime);
    static void RequestPawnPredictionEvent(APawn* Requestor, AActor* PredictedActor, float PredictionTime);
};

// Size: 0x180
class UAISense_Sight : public UAISense {
    /* 0x0158 */ int32_t MaxTracesPerTick;
    /* 0x015c */ int32_t MinQueriesPerTimeSliceCheck;
    /* 0x0160 */ double MaxTimeSlicePerTick;
    /* 0x0168 */ float HighImportanceQueryDistanceThreshold;
    /* 0x0170 */ float MaxQueryImportance;
    /* 0x0174 */ float SightLimitQueryImportance;
};

// Size: 0xa0
class UAISense_Team : public UAISense {
    /* 0x0090 */ TArray<FAITeamStimulusEvent> RegisteredEvents;
};

// Size: 0xa0
class UAISense_Touch : public UAISense {
    /* 0x0090 */ TArray<FAITouchEvent> RegisteredEvents;
};

// Size: 0x18
struct FAISightEvent {
    /* 0x0008 */ AActor* SeenActor;
    /* 0x0010 */ AActor* Observer;
};

// Size: 0x30
class IAISightTargetInterface : public UInterface {
};

// Size: 0x44
struct FAIStimulus {
    /* 0x0000 */ float Age;
    /* 0x0004 */ float ExpirationAge;
    /* 0x0008 */ float Strength;
    /* 0x000c */ FVector StimulusLocation;
    /* 0x0018 */ FVector ReceiverLocation;
    /* 0x0024 */ FName Tag;
    /* 0x0040 */ bool bSuccessfullySensed;
};

// Size: 0x40
class UAISubsystem : public UObject {
    /* 0x0038 */ UAISystem* AISystem;
};

// Size: 0x158
class UAISystem : public UAISystemBase {
    /* 0x0070 */ FSoftClassPath PerceptionSystemClassName;
    /* 0x0090 */ FSoftClassPath HotSpotManagerClassName;
    /* 0x00b0 */ float AcceptanceRadius;
    /* 0x00b4 */ float PathfollowingRegularPathPointAcceptanceRadius;
    /* 0x00b8 */ float PathfollowingNavLinkAcceptanceRadius;
    /* 0x00bc */ bool bFinishMoveOnGoalOverlap;
    /* 0x00bd */ bool bAcceptPartialPaths;
    /* 0x00be */ bool bAllowStrafing;
    /* 0x00bf */ bool bEnableBTAITasks;
    /* 0x00c0 */ bool bAllowControllersAsEQSQuerier;
    /* 0x00c1 */ bool bEnableDebuggerPlugin;
    /* 0x00c2 */ bool bForgetStaleActors;
    /* 0x00c3 */ bool bAddBlackboardSelfKey;
    /* 0x00c4 */ uint8_t DefaultSightCollisionChannel;
    /* 0x00c8 */ UBehaviorTreeManager* BehaviorTreeManager;
    /* 0x00d0 */ UEnvQueryManager* EnvironmentQueryManager;
    /* 0x00d8 */ UAIPerceptionSystem* PerceptionSystem;
    /* 0x00e0 */ TArray<UAIAsyncTaskBlueprintProxy*> AllProxyObjects;
    /* 0x00f0 */ UAIHotSpotManager* HotSpotManager;
    /* 0x00f8 */ UNavLocalGridManager* NavLocalGrids;

    void AIIgnorePlayers();
    void AILoggingVerbose();
};

// Size: 0x88
class UAITask : public UGameplayTask {
    /* 0x0080 */ AAIController* OwnerController;
};

// Size: 0x88
class UAITask_LockLogic : public UAITask {
};

// Size: 0x128
class UAITask_MoveTo : public UAITask {
    /* 0x0088 */ FMulticastInlineDelegate OnRequestFailed;
    /* 0x0098 */ FMulticastInlineDelegate OnMoveFinished;
    /* 0x00a8 */ FAIMoveRequest MoveRequest;

    static UAITask_MoveTo* AIMoveTo(AAIController* Controller, FVector GoalLocation, AActor* GoalActor, float AcceptanceRadius, uint8_t StopOnOverlap, uint8_t AcceptPartialPath, bool bUsePathfinding, bool bLockAILogic, bool bUseContinuosGoalTracking, uint8_t ProjectGoalOnNavigation);
};

// Size: 0x108
class UAITask_RunEQS : public UAITask {

    static UAITask_RunEQS* RunEQS(AAIController* Controller, UEnvQuery* QueryTemplate);
};

// Size: 0x38
struct FAITeamStimulusEvent {
    /* 0x0028 */ AActor* Broadcaster;
    /* 0x0030 */ AActor* Enemy;
};

// Size: 0x20
struct FAITouchEvent {
    /* 0x0010 */ AActor* TouchReceiver;
    /* 0x0018 */ AActor* OtherActor;
};

// Size: 0x20
struct FActorPerceptionBlueprintInfo {
    /* 0x0000 */ AActor* Target;
    /* 0x0008 */ TArray<FAIStimulus> LastSensedStimuli;
    /* 0x0018 */ bool bIsHostile;
};

// Size: 0x50
struct FActorPerceptionUpdateInfo {
    /* 0x0000 */ int32_t TargetId;
    /* 0x0004 */ TWeakObjectPtr<AActor> Target;
    /* 0x000c */ FAIStimulus Stimulus;
};

// Size: 0x70
class UBTAuxiliaryNode : public UBTNode {
};

// Size: 0x30
struct FBTCompositeChild {
    /* 0x0000 */ UBTCompositeNode* ChildComposite;
    /* 0x0008 */ UBTTaskNode* ChildTask;
    /* 0x0010 */ TArray<UBTDecorator*> Decorators;
    /* 0x0020 */ TArray<FBTDecoratorLogic> DecoratorOps;
};

// Size: 0xa0
class UBTCompositeNode : public UBTNode {
    /* 0x0068 */ TArray<FBTCompositeChild> Children;
    /* 0x0078 */ TArray<UBTService*> Services;
    /* 0x0098 */ bool bApplyDecoratorScope;
};

// Size: 0xa0
class UBTComposite_Selector : public UBTCompositeNode {
};

// Size: 0xa0
class UBTComposite_Sequence : public UBTCompositeNode {
};

// Size: 0xa8
class UBTComposite_SimpleParallel : public UBTCompositeNode {
    /* 0x00a0 */ uint8_t FinishMode;
};

// Size: 0x78
class UBTDecorator : public UBTAuxiliaryNode {
    /* 0x0070 */ bool bInverseCondition;
    /* 0x0074 */ uint8_t FlowAbortMode;
};

// Size: 0x4
struct FBTDecoratorLogic {
    /* 0x0000 */ uint8_t Operation;
    /* 0x0002 */ uint16_t Number;
};

// Size: 0xd8
class UBTDecorator_Blackboard : public UBTDecorator_BlackboardBase {
    /* 0x00a8 */ int32_t IntValue;
    /* 0x00ac */ float FloatValue;
    /* 0x00b0 */ FString StringValue;
    /* 0x00c0 */ FString CachedDescription;
    /* 0x00d0 */ uint8_t OperationType;
    /* 0x00d1 */ uint8_t NotifyObserver;
    /* 0x00d2 */ uint8_t BasicOperation;
    /* 0x00d3 */ uint8_t ArithmeticOperation;
    /* 0x00d4 */ uint8_t TextOperation;
};

// Size: 0xa8
class UBTDecorator_BlackboardBase : public UBTDecorator {
    /* 0x0078 */ FBlackboardKeySelector BlackboardKey;
};

// Size: 0xc0
class UBTDecorator_BlueprintBase : public UBTDecorator {
    /* 0x0078 */ AAIController* AIOwner;
    /* 0x0080 */ AActor* ActorOwner;
    /* 0x0088 */ TArray<FName> ObservedKeyNames;
    /* 0x00a8 */ FString CustomDescription;
    /* 0x00b8 */ bool bShowPropertyDetails;
    /* 0x00b8 */ bool bCheckConditionOnlyBlackBoardChanges;
    /* 0x00b8 */ bool bIsObservingBB;

    bool IsDecoratorExecutionActive() const;
    bool IsDecoratorObserverActive() const;
    bool PerformConditionCheck(AActor* OwnerActor);
    bool PerformConditionCheckAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveExecutionFinish(AActor* OwnerActor, uint8_t NodeResult);
    void ReceiveExecutionFinishAI(AAIController* OwnerController, APawn* ControlledPawn, uint8_t NodeResult);
    void ReceiveExecutionStart(AActor* OwnerActor);
    void ReceiveExecutionStartAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveObserverActivated(AActor* OwnerActor);
    void ReceiveObserverActivatedAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveObserverDeactivated(AActor* OwnerActor);
    void ReceiveObserverDeactivatedAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveTick(AActor* OwnerActor, float DeltaSeconds);
    void ReceiveTickAI(AAIController* OwnerController, APawn* ControlledPawn, float DeltaSeconds);
};

// Size: 0xe0
class UBTDecorator_CheckGameplayTagsOnActor : public UBTDecorator {
    /* 0x0078 */ FBlackboardKeySelector ActorToCheck;
    /* 0x00a8 */ EGameplayContainerMatchType TagsToMatch;
    /* 0x00b0 */ FGameplayTagContainer GameplayTags;
    /* 0x00d0 */ FString CachedDescription;
};

// Size: 0xe0
class UBTDecorator_CompareBBEntries : public UBTDecorator {
    /* 0x0078 */ uint8_t Operator;
    /* 0x0080 */ FBlackboardKeySelector BlackboardKeyA;
    /* 0x00b0 */ FBlackboardKeySelector BlackboardKeyB;
};

// Size: 0xd8
class UBTDecorator_ConditionalLoop : public UBTDecorator_Blackboard {
};

// Size: 0x118
class UBTDecorator_ConeCheck : public UBTDecorator {
    /* 0x0078 */ float ConeHalfAngle;
    /* 0x0080 */ FBlackboardKeySelector ConeOrigin;
    /* 0x00b0 */ FBlackboardKeySelector ConeDirection;
    /* 0x00e0 */ FBlackboardKeySelector Observed;
};

// Size: 0x80
class UBTDecorator_Cooldown : public UBTDecorator {
    /* 0x0078 */ float CoolDownTime;
};

// Size: 0xe8
class UBTDecorator_DoesPathExist : public UBTDecorator {
    /* 0x0078 */ FBlackboardKeySelector BlackboardKeyA;
    /* 0x00a8 */ FBlackboardKeySelector BlackboardKeyB;
    /* 0x00d8 */ bool bUseSelf;
    /* 0x00dc */ uint8_t PathQueryType;
    /* 0x00e0 */ UClass* FilterClass;
};

// Size: 0x78
class UBTDecorator_ForceSuccess : public UBTDecorator {
};

// Size: 0xf8
class UBTDecorator_IsAtLocation : public UBTDecorator_BlackboardBase {
    /* 0x00a8 */ float AcceptableRadius;
    /* 0x00b0 */ FAIDataProviderFloatValue ParametrizedAcceptableRadius;
    /* 0x00f0 */ FAIDistanceType GeometricDistanceType;
    /* 0x00f4 */ bool bUseParametrizedRadius;
    /* 0x00f4 */ bool bUseNavAgentGoalLocation;
    /* 0x00f4 */ bool bPathFindingBasedTest;
};

// Size: 0xb0
class UBTDecorator_IsBBEntryOfClass : public UBTDecorator_BlackboardBase {
    /* 0x00a8 */ UClass* TestClass;
};

// Size: 0xe8
class UBTDecorator_KeepInCone : public UBTDecorator {
    /* 0x0078 */ float ConeHalfAngle;
    /* 0x0080 */ FBlackboardKeySelector ConeOrigin;
    /* 0x00b0 */ FBlackboardKeySelector Observed;
    /* 0x00e0 */ bool bUseSelfAsOrigin;
    /* 0x00e0 */ bool bUseSelfAsObserved;
};

// Size: 0x88
class UBTDecorator_Loop : public UBTDecorator {
    /* 0x0078 */ int32_t NumLoops;
    /* 0x007c */ bool bInfiniteLoop;
    /* 0x0080 */ float InfiniteLoopTimeoutTime;
};

// Size: 0x78
class UBTDecorator_ReachedMoveGoal : public UBTDecorator {
};

// Size: 0x90
class UBTDecorator_SetTagCooldown : public UBTDecorator {
    /* 0x0078 */ FGameplayTag CooldownTag;
    /* 0x0084 */ float CooldownDuration;
    /* 0x0088 */ bool bAddToExistingDuration;
};

// Size: 0x90
class UBTDecorator_TagCooldown : public UBTDecorator {
    /* 0x0078 */ FGameplayTag CooldownTag;
    /* 0x0084 */ float CooldownDuration;
    /* 0x0088 */ bool bAddToExistingDuration;
    /* 0x0089 */ bool bActivatesCooldown;
};

// Size: 0x80
class UBTDecorator_TimeLimit : public UBTDecorator {
    /* 0x0078 */ float TimeLimit;
};

// Size: 0x30
class UBTFunctionLibrary : public UBlueprintFunctionLibrary {

    static void ClearBlackboardValue(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static void ClearBlackboardValueAsVector(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static AActor* GetBlackboardValueAsActor(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static bool GetBlackboardValueAsBool(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static UClass* GetBlackboardValueAsClass(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static uint8_t GetBlackboardValueAsEnum(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static float GetBlackboardValueAsFloat(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static int32_t GetBlackboardValueAsInt(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static FName GetBlackboardValueAsName(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static UObject* GetBlackboardValueAsObject(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static FRotator GetBlackboardValueAsRotator(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static FString GetBlackboardValueAsString(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static FVector GetBlackboardValueAsVector(UBTNode* NodeOwner, const FBlackboardKeySelector& Key);
    static UBehaviorTreeComponent* GetOwnerComponent(UBTNode* NodeOwner);
    static UBlackboardComponent* GetOwnersBlackboard(UBTNode* NodeOwner);
    static void SetBlackboardValueAsBool(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, bool Value);
    static void SetBlackboardValueAsClass(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, UClass* Value);
    static void SetBlackboardValueAsEnum(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, uint8_t Value);
    static void SetBlackboardValueAsFloat(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, float Value);
    static void SetBlackboardValueAsInt(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, int32_t Value);
    static void SetBlackboardValueAsName(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, FName Value);
    static void SetBlackboardValueAsObject(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, UObject* Value);
    static void SetBlackboardValueAsRotator(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, FRotator Value);
    static void SetBlackboardValueAsString(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, FString Value);
    static void SetBlackboardValueAsVector(UBTNode* NodeOwner, const FBlackboardKeySelector& Key, FVector Value);
    static void StartUsingExternalEvent(UBTNode* NodeOwner, AActor* OwningActor);
    static void StopUsingExternalEvent(UBTNode* NodeOwner);
};

// Size: 0x68
class UBTNode : public UObject {
    /* 0x0038 */ FString NodeName;
    /* 0x0048 */ UBehaviorTree* TreeAsset;
    /* 0x0050 */ UBTCompositeNode* ParentNode;
};

// Size: 0x80
class UBTService : public UBTAuxiliaryNode {
    /* 0x0070 */ float Interval;
    /* 0x0074 */ float RandomDeviation;
    /* 0x0078 */ bool bCallTickOnSearchStart;
    /* 0x0078 */ bool bRestartTimerOnEachActivation;
};

// Size: 0xb0
class UBTService_BlackboardBase : public UBTService {
    /* 0x0080 */ FBlackboardKeySelector BlackboardKey;
};

// Size: 0xb8
class UBTService_BlueprintBase : public UBTService {
    /* 0x0080 */ AAIController* AIOwner;
    /* 0x0088 */ AActor* ActorOwner;
    /* 0x00a0 */ FString CustomDescription;
    /* 0x00b0 */ bool bShowPropertyDetails;
    /* 0x00b0 */ bool bShowEventDetails;

    bool IsServiceActive() const;
    void ReceiveActivation(AActor* OwnerActor);
    void ReceiveActivationAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveDeactivation(AActor* OwnerActor);
    void ReceiveDeactivationAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveSearchStart(AActor* OwnerActor);
    void ReceiveSearchStartAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveTick(AActor* OwnerActor, float DeltaSeconds);
    void ReceiveTickAI(AAIController* OwnerController, APawn* ControlledPawn, float DeltaSeconds);
};

// Size: 0xb8
class UBTService_DefaultFocus : public UBTService_BlackboardBase {
    /* 0x00b0 */ uint8_t FocusPriority;
};

// Size: 0x110
class UBTService_RunEQS : public UBTService_BlackboardBase {
    /* 0x00b0 */ FEQSParametrizedQueryExecutionRequest EQSRequest;
};

// Size: 0x80
class UBTTaskNode : public UBTNode {
    /* 0x0068 */ TArray<UBTService*> Services;
    /* 0x0078 */ bool bIgnoreRestartSelf;
};

// Size: 0xb0
class UBTTask_BlackboardBase : public UBTTaskNode {
    /* 0x0080 */ FBlackboardKeySelector BlackboardKey;
};

// Size: 0xc8
class UBTTask_BlueprintBase : public UBTTaskNode {
    /* 0x0080 */ AAIController* AIOwner;
    /* 0x0088 */ AActor* ActorOwner;
    /* 0x0090 */ FIntervalCountdown TickInterval;
    /* 0x00b0 */ FString CustomDescription;
    /* 0x00c0 */ bool bShowPropertyDetails;

    void FinishAbort();
    void FinishExecute(bool bSuccess);
    bool IsTaskAborting() const;
    bool IsTaskExecuting() const;
    void ReceiveAbort(AActor* OwnerActor);
    void ReceiveAbortAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveExecute(AActor* OwnerActor);
    void ReceiveExecuteAI(AAIController* OwnerController, APawn* ControlledPawn);
    void ReceiveTick(AActor* OwnerActor, float DeltaSeconds);
    void ReceiveTickAI(AAIController* OwnerController, APawn* ControlledPawn, float DeltaSeconds);
    void SetFinishOnMessage(FName MessageName);
    void SetFinishOnMessageWithId(FName MessageName, int32_t RequestID);
};

// Size: 0x88
class UBTTask_FinishWithResult : public UBTTaskNode {
    /* 0x0080 */ uint8_t Result;
};

// Size: 0x88
class UBTTask_GameplayTaskBase : public UBTTaskNode {
    /* 0x0080 */ bool bWaitForGameplayTask;
};

// Size: 0x88
class UBTTask_MakeNoise : public UBTTaskNode {
    /* 0x0080 */ float Loudnes;
};

// Size: 0xd0
class UBTTask_MoveDirectlyToward : public UBTTask_MoveTo {
    /* 0x00c8 */ bool bDisablePathUpdateOnGoalLocationChange;
    /* 0x00c8 */ bool bProjectVectorGoalToNavigation;
    /* 0x00c8 */ bool bUpdatedDeprecatedProperties;
};

// Size: 0xc8
class UBTTask_MoveTo : public UBTTask_BlackboardBase {
    /* 0x00b0 */ float AcceptableRadius;
    /* 0x00b8 */ UClass* FilterClass;
    /* 0x00c0 */ float ObservedBlackboardValueTolerance;
    /* 0x00c4 */ bool bObserveBlackboardValue;
    /* 0x00c4 */ bool bAllowStrafe;
    /* 0x00c4 */ bool bAllowPartialPath;
    /* 0x00c4 */ bool bTrackMovingGoal;
    /* 0x00c4 */ bool bProjectGoalLocation;
    /* 0x00c4 */ bool bReachTestIncludesAgentRadius;
    /* 0x00c4 */ bool bReachTestIncludesGoalRadius;
    /* 0x00c4 */ bool bStopOnOverlap;
    /* 0x00c5 */ bool bStopOnOverlapNeedsUpdate;
};

// Size: 0x80
class UBTTask_PawnActionBase : public UBTTaskNode {
};

// Size: 0xc0
class UBTTask_PlayAnimation : public UBTTaskNode {
    /* 0x0080 */ UAnimationAsset* AnimationToPlay;
    /* 0x0088 */ bool bLooping;
    /* 0x0088 */ bool bNonBlocking;
    /* 0x0090 */ UBehaviorTreeComponent* MyOwnerComp;
    /* 0x0098 */ USkeletalMeshComponent* CachedSkelMesh;
};

// Size: 0x88
class UBTTask_PlaySound : public UBTTaskNode {
    /* 0x0080 */ USoundCue* SoundToPlay;
};

// Size: 0x88
class UBTTask_PushPawnAction : public UBTTask_PawnActionBase {
    /* 0x0080 */ UPawnAction* Action;
};

// Size: 0xb8
class UBTTask_RotateToFaceBBEntry : public UBTTask_BlackboardBase {
    /* 0x00b0 */ float Precision;
};

// Size: 0x88
class UBTTask_RunBehavior : public UBTTaskNode {
    /* 0x0080 */ UBehaviorTree* BehaviorAsset;
};

// Size: 0xa0
class UBTTask_RunBehaviorDynamic : public UBTTaskNode {
    /* 0x0080 */ FGameplayTag InjectionTag;
    /* 0x0090 */ UBehaviorTree* DefaultBehaviorAsset;
    /* 0x0098 */ UBehaviorTree* BehaviorAsset;
};

// Size: 0x178
class UBTTask_RunEQSQuery : public UBTTask_BlackboardBase {
    /* 0x00b0 */ UEnvQuery* QueryTemplate;
    /* 0x00b8 */ TArray<FEnvNamedValue> QueryParams;
    /* 0x00c8 */ TArray<FAIDynamicParam> QueryConfig;
    /* 0x00d8 */ uint8_t RunMode;
    /* 0x00e0 */ FBlackboardKeySelector EQSQueryBlackboardKey;
    /* 0x0110 */ bool bUseBBKey;
    /* 0x0118 */ FEQSParametrizedQueryExecutionRequest EQSRequest;
};

// Size: 0x98
class UBTTask_SetTagCooldown : public UBTTaskNode {
    /* 0x0080 */ FGameplayTag CooldownTag;
    /* 0x008c */ bool bAddToExistingDuration;
    /* 0x0090 */ float CooldownDuration;
};

// Size: 0x88
class UBTTask_Wait : public UBTTaskNode {
    /* 0x0080 */ float WaitTime;
    /* 0x0084 */ float RandomDeviation;
};

// Size: 0xb8
class UBTTask_WaitBlackboardTime : public UBTTask_Wait {
    /* 0x0088 */ FBlackboardKeySelector BlackboardKey;
};

// Size: 0x88
class UBehaviorTree : public UObject {
    /* 0x0038 */ UBTCompositeNode* RootNode;
    /* 0x0040 */ UEdGraph* BTGraph;
    /* 0x0048 */ TArray<FEditedDocumentInfo> LastEditedDocuments;
    /* 0x0058 */ UBlackboardData* BlackboardAsset;
    /* 0x0060 */ TArray<UBTDecorator*> RootDecorators;
    /* 0x0070 */ TArray<FBTDecoratorLogic> RootDecoratorOps;
};

// Size: 0x338
class UBehaviorTreeComponent : public UBrainComponent {
    /* 0x0138 */ TArray<UBTNode*> NodeInstances;
    /* 0x0318 */ UBehaviorTree* DefaultBehaviorTreeAsset;

    void AddCooldownTagDuration(FGameplayTag CooldownTag, float CooldownDuration, bool bAddToExistingDuration);
    float GetTagCooldownEndTime(FGameplayTag CooldownTag) const;
    void SetDynamicSubtree(FGameplayTag InjectTag, UBehaviorTree* BehaviorAsset);
};

// Size: 0x58
class UBehaviorTreeManager : public UObject {
    /* 0x0030 */ int32_t MaxDebuggerSteps;
    /* 0x0038 */ TArray<FBehaviorTreeTemplateInfo> LoadedTemplates;
    /* 0x0048 */ TArray<UBehaviorTreeComponent*> ActiveComponents;
};

// Size: 0x18
struct FBehaviorTreeTemplateInfo {
    /* 0x0000 */ UBehaviorTree* Asset;
    /* 0x0008 */ UBTCompositeNode* Template;
};

// Size: 0x30
class UBehaviorTreeTypes : public UObject {
};

// Size: 0x30
class IBlackboardAssetProvider : public UInterface {

    UBlackboardData* GetBlackboardAsset() const;
};

// Size: 0x1c8
class UBlackboardComponent : public UActorComponent {
    /* 0x00c0 */ UBrainComponent* BrainComp;
    /* 0x00c8 */ UBlackboardData* DefaultBlackboardAsset;
    /* 0x00d0 */ UBlackboardData* BlackboardAsset;
    /* 0x00f8 */ TArray<UBlackboardKeyType*> KeyInstances;

    void ClearValue(const FName& KeyName);
    bool GetLocationFromEntry(const FName& KeyName, FVector& ResultLocation) const;
    bool GetRotationFromEntry(const FName& KeyName, FRotator& ResultRotation) const;
    bool GetValueAsBool(const FName& KeyName) const;
    UClass* GetValueAsClass(const FName& KeyName) const;
    uint8_t GetValueAsEnum(const FName& KeyName) const;
    float GetValueAsFloat(const FName& KeyName) const;
    int32_t GetValueAsInt(const FName& KeyName) const;
    FName GetValueAsName(const FName& KeyName) const;
    UObject* GetValueAsObject(const FName& KeyName) const;
    FRotator GetValueAsRotator(const FName& KeyName) const;
    FString GetValueAsString(const FName& KeyName) const;
    FVector GetValueAsVector(const FName& KeyName) const;
    bool IsVectorValueSet(const FName& KeyName) const;
    void SetValueAsBool(const FName& KeyName, bool BoolValue);
    void SetValueAsClass(const FName& KeyName, UClass* ClassValue);
    void SetValueAsEnum(const FName& KeyName, uint8_t EnumValue);
    void SetValueAsFloat(const FName& KeyName, float FloatValue);
    void SetValueAsInt(const FName& KeyName, int32_t IntValue);
    void SetValueAsName(const FName& KeyName, FName NameValue);
    void SetValueAsObject(const FName& KeyName, UObject* ObjectValue);
    void SetValueAsRotator(const FName& KeyName, FRotator VectorValue);
    void SetValueAsString(const FName& KeyName, FString StringValue);
    void SetValueAsVector(const FName& KeyName, FVector VectorValue);
};

// Size: 0x68
class UBlackboardData : public UDataAsset {
    /* 0x0038 */ UBlackboardData* Parent;
    /* 0x0040 */ TArray<FBlackboardEntry> ParentKeys;
    /* 0x0050 */ TArray<FBlackboardEntry> Keys;
    /* 0x0060 */ bool bHasSynchronizedKeys;
};

// Size: 0x40
struct FBlackboardEntry {
    /* 0x0000 */ FName EntryName;
    /* 0x0010 */ FString EntryDescription;
    /* 0x0020 */ FName EntryCategory;
    /* 0x0030 */ UBlackboardKeyType* KeyType;
    /* 0x0038 */ bool bInstanceSynced;
};

// Size: 0x30
struct FBlackboardKeySelector {
    /* 0x0000 */ TArray<UBlackboardKeyType*> AllowedTypes;
    /* 0x0010 */ FName SelectedKeyName;
    /* 0x0020 */ UClass* SelectedKeyType;
    /* 0x0028 */ uint8_t SelectedKeyID;
    /* 0x002c */ bool bNoneIsAllowedValue;
};

// Size: 0x38
class UBlackboardKeyType : public UObject {
};

// Size: 0x38
class UBlackboardKeyType_Bool : public UBlackboardKeyType {
};

// Size: 0x40
class UBlackboardKeyType_Class : public UBlackboardKeyType {
    /* 0x0038 */ UClass* BaseClass;
};

// Size: 0x58
class UBlackboardKeyType_Enum : public UBlackboardKeyType {
    /* 0x0038 */ UEnum* EnumType;
    /* 0x0040 */ FString EnumName;
    /* 0x0050 */ bool bIsEnumNameValid;
};

// Size: 0x38
class UBlackboardKeyType_Float : public UBlackboardKeyType {
};

// Size: 0x38
class UBlackboardKeyType_Int : public UBlackboardKeyType {
};

// Size: 0x38
class UBlackboardKeyType_Name : public UBlackboardKeyType {
};

// Size: 0x50
class UBlackboardKeyType_NativeEnum : public UBlackboardKeyType {
    /* 0x0038 */ FString EnumName;
    /* 0x0048 */ UEnum* EnumType;
};

// Size: 0x40
class UBlackboardKeyType_Object : public UBlackboardKeyType {
    /* 0x0038 */ UClass* BaseClass;
};

// Size: 0x38
class UBlackboardKeyType_Rotator : public UBlackboardKeyType {
};

// Size: 0x48
class UBlackboardKeyType_String : public UBlackboardKeyType {
    /* 0x0038 */ FString StringValue;
};

// Size: 0x38
class UBlackboardKeyType_Vector : public UBlackboardKeyType {
};

// Size: 0x118
class UBrainComponent : public UActorComponent {
    /* 0x00c8 */ UBlackboardComponent* BlackboardComp;
    /* 0x00d0 */ AAIController* AIOwner;

    bool IsPaused() const;
    bool IsRunning() const;
    void RestartLogic();
    void StartLogic();
    void StopLogic(FString reason);
};

// Size: 0x30
class ICrowdAgentInterface : public UInterface {
};

// Size: 0x1c
struct FCrowdAvoidanceConfig {
    /* 0x0000 */ float VelocityBias;
    /* 0x0004 */ float DesiredVelocityWeight;
    /* 0x0008 */ float CurrentVelocityWeight;
    /* 0x000c */ float SideBiasWeight;
    /* 0x0010 */ float ImpactTimeWeight;
    /* 0x0014 */ float ImpactTimeRange;
    /* 0x0018 */ uint8_t CustomPatternIdx;
    /* 0x0019 */ uint8_t AdaptiveDivisions;
    /* 0x001a */ uint8_t AdaptiveRings;
    /* 0x001b */ uint8_t AdaptiveDepth;
};

// Size: 0x20
struct FCrowdAvoidanceSamplingPattern {
    /* 0x0000 */ TArray<float> Angles;
    /* 0x0010 */ TArray<float> Radii;
};

// Size: 0x2e0
class UCrowdFollowingComponent : public UPathFollowingComponent {
    /* 0x0298 */ FVector CrowdAgentMoveDirection;
    /* 0x02a8 */ UCharacterMovementComponent* CharacterMovement;
    /* 0x02b0 */ FNavAvoidanceMask AvoidanceGroup;
    /* 0x02b4 */ FNavAvoidanceMask GroupsToAvoid;
    /* 0x02b8 */ FNavAvoidanceMask GroupsToIgnore;

    void SuspendCrowdSteering(bool bSuspend);
};

// Size: 0x108
class UCrowdManager : public UCrowdManagerBase {
    /* 0x0030 */ ANavigationData* MyNavData;
    /* 0x0038 */ TArray<FCrowdAvoidanceConfig> AvoidanceConfig;
    /* 0x0048 */ TArray<FCrowdAvoidanceSamplingPattern> SamplingPatterns;
    /* 0x0058 */ int32_t MaxAgents;
    /* 0x005c */ float MaxAgentRadius;
    /* 0x0060 */ int32_t MaxAvoidedAgents;
    /* 0x0064 */ int32_t MaxAvoidedWalls;
    /* 0x0068 */ float NavmeshCheckInterval;
    /* 0x006c */ float PathOptimizationInterval;
    /* 0x0070 */ float SeparationDirClamp;
    /* 0x0074 */ float PathOffsetRadiusMultiplier;
    /* 0x0078 */ bool bResolveCollisions;
    /* 0x0100 */ UWorld* DebugDrawingWorld;
};

// Size: 0x408
class ADetourCrowdAIController : public AAIController {
};

enum class EAILockSource {
    Animation = 0,
    Logic = 1,
    Script = 2,
    Gameplay = 3,
    MAX = 4,
};

enum class EAIOptionFlag {
    Default = 0,
    Enable = 1,
    Disable = 2,
    MAX = 3,
};

enum class EAIParamType {
    Float = 0,
    Int = 1,
    Bool = 2,
    MAX = 3,
};

enum class EAIRequestPriority {
    SoftScript = 0,
    Logic = 1,
    HardScript = 2,
    Reaction = 3,
    Ultimate = 4,
    MAX = 5,
};

enum class EAISenseNotifyType {
    OnEveryPerception = 0,
    OnPerceptionChange = 1,
    EAISenseNotifyType_MAX = 2,
};

enum class EAITaskPriority {
    Lowest = 0,
    Low = 64,
    AutonomousAI = 127,
    High = 192,
    Ultimate = 254,
    EAITaskPriority_MAX = 255,
};

enum class EArithmeticKeyOperation {
    Equal = 0,
    NotEqual = 1,
    Less = 2,
    LessOrEqual = 3,
    Greater = 4,
    GreaterOrEqual = 5,
    EArithmeticKeyOperation_MAX = 6,
};

enum class EBTBlackboardRestart {
    ValueChange = 0,
    ResultChange = 1,
    EBTBlackboardRestart_MAX = 2,
};

enum class EBTChildIndex {
    FirstNode = 0,
    TaskNode = 1,
    EBTChildIndex_MAX = 2,
};

enum class EBTDecoratorLogic {
    Invalid = 0,
    Test = 1,
    And = 2,
    Or = 3,
    Not = 4,
    EBTDecoratorLogic_MAX = 5,
};

enum class EBTFlowAbortMode {
    None = 0,
    LowerPriority = 1,
    Self = 2,
    Both = 3,
    EBTFlowAbortMode_MAX = 4,
};

enum class EBTNodeResult {
    Succeeded = 0,
    Failed = 1,
    Aborted = 2,
    InProgress = 3,
    EBTNodeResult_MAX = 4,
};

enum class EBTParallelMode {
    AbortBackground = 0,
    WaitForBackground = 1,
    EBTParallelMode_MAX = 2,
};

enum class EBasicKeyOperation {
    Set = 0,
    NotSet = 1,
    EBasicKeyOperation_MAX = 2,
};

enum class EBlackBoardEntryComparison {
    Equal = 0,
    NotEqual = 1,
    EBlackBoardEntryComparison_MAX = 2,
};

enum class EEQSNormalizationType {
    Absolute = 0,
    RelativeToScores = 1,
    EEQSNormalizationType_MAX = 2,
};

enum class EEnvDirection {
    TwoPoints = 0,
    Rotation = 1,
    EEnvDirection_MAX = 2,
};

enum class EEnvOverlapShape {
    Box = 0,
    Sphere = 1,
    Capsule = 2,
    EEnvOverlapShape_MAX = 3,
};

enum class EEnvQueryHightlightMode {
    All = 0,
    Best5Pct = 1,
    Best25Pct = 2,
    EEnvQueryHightlightMode_MAX = 3,
};

enum class EEnvQueryParam {
    Float = 0,
    Int = 1,
    Bool = 2,
    EEnvQueryParam_MAX = 3,
};

enum class EEnvQueryRunMode {
    SingleResult = 0,
    RandomBest5Pct = 1,
    RandomBest25Pct = 2,
    AllMatching = 3,
    EEnvQueryRunMode_MAX = 4,
};

enum class EEnvQueryStatus {
    Processing = 0,
    Success = 1,
    Failed = 2,
    Aborted = 3,
    OwnerLost = 4,
    MissingParam = 5,
    EEnvQueryStatus_MAX = 6,
};

enum class EEnvQueryTestClamping {
    None = 0,
    SpecifiedValue = 1,
    FilterThreshold = 2,
    EEnvQueryTestClamping_MAX = 3,
};

enum class EEnvQueryTrace {
    None = 0,
    Navigation = 1,
    Geometry = 2,
    NavigationOverLedges = 3,
    EEnvQueryTrace_MAX = 4,
};

enum class EEnvTestCost {
    Low = 0,
    Medium = 1,
    High = 2,
    EEnvTestCost_MAX = 3,
};

enum class EEnvTestDistance {
    Distance3D = 0,
    Distance2D = 1,
    DistanceZ = 2,
    DistanceAbsoluteZ = 3,
    EEnvTestDistance_MAX = 4,
};

enum class EEnvTestDot {
    Dot3D = 0,
    Dot2D = 1,
    EEnvTestDot_MAX = 2,
};

enum class EEnvTestFilterOperator {
    AllPass = 0,
    AnyPass = 1,
    EEnvTestFilterOperator_MAX = 2,
};

enum class EEnvTestFilterType {
    Minimum = 0,
    Maximum = 1,
    Range = 2,
    Match = 3,
    EEnvTestFilterType_MAX = 4,
};

enum class EEnvTestPathfinding {
    PathExist = 0,
    PathCost = 1,
    PathLength = 2,
    EEnvTestPathfinding_MAX = 3,
};

enum class EEnvTestPurpose {
    Filter = 0,
    Score = 1,
    FilterAndScore = 2,
    EEnvTestPurpose_MAX = 3,
};

enum class EEnvTestScoreEquation {
    Linear = 0,
    Square = 1,
    InverseLinear = 2,
    SquareRoot = 3,
    Constant = 4,
    EEnvTestScoreEquation_MAX = 5,
};

enum class EEnvTestScoreOperator {
    AverageScore = 0,
    MinScore = 1,
    MaxScore = 2,
    Multiply = 3,
    EEnvTestScoreOperator_MAX = 4,
};

enum class EEnvTestWeight {
    None = 0,
    Square = 1,
    Inverse = 2,
    Unused = 3,
    Constant = 4,
    Skip = 5,
    EEnvTestWeight_MAX = 6,
};

enum class EEnvTraceShape {
    Line = 0,
    Box = 1,
    Sphere = 2,
    Capsule = 3,
    EEnvTraceShape_MAX = 4,
};

enum class EGenericAICheck {
    Less = 0,
    LessOrEqual = 1,
    Equal = 2,
    NotEqual = 3,
    GreaterOrEqual = 4,
    Greater = 5,
    IsTrue = 6,
    MAX = 7,
};

enum class EPathExistanceQueryType {
    NavmeshRaycast2D = 0,
    HierarchicalQuery = 1,
    RegularPathFinding = 2,
    EPathExistanceQueryType_MAX = 3,
};

enum class EPathFollowingAction {
    Error = 0,
    NoMove = 1,
    DirectMove = 2,
    PartialPath = 3,
    PathToGoal = 4,
    EPathFollowingAction_MAX = 5,
};

enum class EPathFollowingRequestResult {
    Failed = 0,
    AlreadyAtGoal = 1,
    RequestSuccessful = 2,
    EPathFollowingRequestResult_MAX = 3,
};

enum class EPathFollowingResult {
    Success = 0,
    Blocked = 1,
    OffPath = 2,
    Aborted = 3,
    Skipped_DEPRECATED = 4,
    Invalid = 5,
    EPathFollowingResult_MAX = 6,
};

enum class EPathFollowingStatus {
    Idle = 0,
    Waiting = 1,
    Paused = 2,
    Moving = 3,
    EPathFollowingStatus_MAX = 4,
};

enum class EPawnActionAbortState {
    NeverStarted = 0,
    NotBeingAborted = 1,
    MarkPendingAbort = 2,
    LatentAbortInProgress = 3,
    AbortDone = 4,
    MAX = 5,
};

enum class EPawnActionEventType {
    Invalid = 0,
    FailedToStart = 1,
    InstantAbort = 2,
    FinishedAborting = 3,
    FinishedExecution = 4,
    Push = 5,
    EPawnActionEventType_MAX = 6,
};

enum class EPawnActionFailHandling {
    RequireSuccess = 0,
    IgnoreFailure = 1,
    EPawnActionFailHandling_MAX = 2,
};

enum class EPawnActionMoveMode {
    UsePathfinding = 0,
    StraightLine = 1,
    EPawnActionMoveMode_MAX = 2,
};

enum class EPawnActionResult {
    NotStarted = 0,
    InProgress = 1,
    Success = 2,
    Failed = 3,
    Aborted = 4,
    EPawnActionResult_MAX = 5,
};

enum class EPawnSubActionTriggeringPolicy {
    CopyBeforeTriggering = 0,
    ReuseInstances = 1,
    EPawnSubActionTriggeringPolicy_MAX = 2,
};

enum class EPointOnCircleSpacingMethod {
    BySpaceBetween = 0,
    ByNumberOfPoints = 1,
    EPointOnCircleSpacingMethod_MAX = 2,
};

// Size: 0x50
struct FEQSParametrizedQueryExecutionRequest {
    /* 0x0000 */ UEnvQuery* QueryTemplate;
    /* 0x0008 */ TArray<FAIDynamicParam> QueryConfig;
    /* 0x0018 */ FBlackboardKeySelector EQSQueryBlackboardKey;
    /* 0x0048 */ uint8_t RunMode;
    /* 0x004c */ bool bUseBBKeyForQueryTemplate;
};

// Size: 0x30
class IEQSQueryResultSourceInterface : public UInterface {
};

// Size: 0x580
class UEQSRenderingComponent : public UPrimitiveComponent {
};

// Size: 0x640
class AEQSTestingPawn : public ACharacter {
    /* 0x05a0 */ UEnvQuery* QueryTemplate;
    /* 0x05a8 */ TArray<FEnvNamedValue> QueryParams;
    /* 0x05b8 */ TArray<FAIDynamicParam> QueryConfig;
    /* 0x05c8 */ float TimeLimitPerStep;
    /* 0x05cc */ int32_t StepToDebugDraw;
    /* 0x05d0 */ EEnvQueryHightlightMode HighlightMode;
    /* 0x05d4 */ bool bDrawLabels;
    /* 0x05d4 */ bool bDrawFailedItems;
    /* 0x05d4 */ bool bReRunQueryOnlyOnFinishedMove;
    /* 0x05d4 */ bool bShouldBeVisibleInGame;
    /* 0x05d4 */ bool bTickDuringGame;
    /* 0x05d8 */ uint8_t QueryingMode;
    /* 0x05e0 */ FNavAgentProperties NavAgentProperties;
    /* 0x0618 */ UEQSRenderingComponent* EdRenderComp;
};

enum class ETeamAttitude {
    Friendly = 0,
    Neutral = 1,
    Hostile = 2,
    ETeamAttitude_MAX = 3,
};

enum class ETextKeyOperation {
    Equal = 0,
    NotEqual = 1,
    Contain = 2,
    NotContain = 3,
    ETextKeyOperation_MAX = 4,
};

// Size: 0x20
struct FEnvDirection {
    /* 0x0000 */ UClass* LineFrom;
    /* 0x0008 */ UClass* LineTo;
    /* 0x0010 */ UClass* Rotation;
    /* 0x0018 */ uint8_t DirMode;
};

// Size: 0x14
struct FEnvNamedValue {
    /* 0x0000 */ FName ParamName;
    /* 0x000c */ EAIParamType ParamType;
    /* 0x0010 */ float Value;
};

// Size: 0x20
struct FEnvOverlapData {
    /* 0x0000 */ float ExtentX;
    /* 0x0004 */ float ExtentY;
    /* 0x0008 */ float ExtentZ;
    /* 0x000c */ FVector ShapeOffset;
    /* 0x0018 */ uint8_t OverlapChannel;
    /* 0x0019 */ uint8_t OverlapShape;
    /* 0x001c */ bool bOnlyBlockingHits;
    /* 0x001c */ bool bOverlapComplex;
    /* 0x001c */ bool bSkipOverlapQuerier;
};

// Size: 0x60
class UEnvQuery : public UDataAsset {
    /* 0x0038 */ UEdGraph* EdGraph;
    /* 0x0040 */ FName QueryName;
    /* 0x0050 */ TArray<UEnvQueryOption*> Options;
};

// Size: 0x30
class UEnvQueryContext : public UObject {
};

// Size: 0x38
class UEnvQueryContext_BlueprintBase : public UEnvQueryContext {

    void ProvideActorsSet(UObject* QuerierObject, AActor* QuerierActor, TArray<AActor*>& ResultingActorsSet) const;
    void ProvideLocationsSet(UObject* QuerierObject, AActor* QuerierActor, TArray<FVector>& ResultingLocationSet) const;
    void ProvideSingleActor(UObject* QuerierObject, AActor* QuerierActor, AActor*& ResultingActor) const;
    void ProvideSingleLocation(UObject* QuerierObject, AActor* QuerierActor, FVector& ResultingLocation) const;
};

// Size: 0x30
class UEnvQueryContext_Item : public UEnvQueryContext {
};

// Size: 0x30
class UEnvQueryContext_Querier : public UEnvQueryContext {
};

// Size: 0x30
class UEnvQueryDebugHelpers : public UObject {
};

// Size: 0x58
class UEnvQueryGenerator : public UEnvQueryNode {
    /* 0x0038 */ FString OptionName;
    /* 0x0048 */ UClass* ItemType;
    /* 0x0050 */ bool bAutoSortTests;
};

// Size: 0xe8
class UEnvQueryGenerator_ActorsOfClass : public UEnvQueryGenerator {
    /* 0x0058 */ UClass* SearchedActorClass;
    /* 0x0060 */ FAIDataProviderBoolValue GenerateOnlyActorsInRadius;
    /* 0x00a0 */ FAIDataProviderFloatValue SearchRadius;
    /* 0x00e0 */ UClass* SearchCenter;
};

// Size: 0x88
class UEnvQueryGenerator_BlueprintBase : public UEnvQueryGenerator {
    /* 0x0058 */ FText GeneratorsActionDescription;
    /* 0x0070 */ UClass* Context;
    /* 0x0078 */ UClass* GeneratedItemType;

    void AddGeneratedActor(AActor* GeneratedActor) const;
    void AddGeneratedVector(FVector GeneratedVector) const;
    void DoItemGeneration(const TArray<FVector>& ContextLocations) const;
    UObject* GetQuerier() const;
};

// Size: 0x78
class UEnvQueryGenerator_Composite : public UEnvQueryGenerator {
    /* 0x0058 */ TArray<UEnvQueryGenerator*> Generators;
    /* 0x0068 */ bool bAllowDifferentItemTypes;
    /* 0x0068 */ bool bHasMatchingItemType;
    /* 0x0070 */ UClass* ForcedItemType;
};

// Size: 0x198
class UEnvQueryGenerator_Cone : public UEnvQueryGenerator_ProjectedPoints {
    /* 0x0088 */ FAIDataProviderFloatValue AlignedPointsDistance;
    /* 0x00c8 */ FAIDataProviderFloatValue ConeDegrees;
    /* 0x0108 */ FAIDataProviderFloatValue AngleStep;
    /* 0x0148 */ FAIDataProviderFloatValue Range;
    /* 0x0188 */ UClass* CenterActor;
    /* 0x0190 */ bool bIncludeContextLocation;
};

// Size: 0x60
class UEnvQueryGenerator_CurrentLocation : public UEnvQueryGenerator {
    /* 0x0058 */ UClass* QueryContext;
};

// Size: 0x200
class UEnvQueryGenerator_Donut : public UEnvQueryGenerator_ProjectedPoints {
    /* 0x0088 */ FAIDataProviderFloatValue InnerRadius;
    /* 0x00c8 */ FAIDataProviderFloatValue OuterRadius;
    /* 0x0108 */ FAIDataProviderIntValue NumberOfRings;
    /* 0x0148 */ FAIDataProviderIntValue PointsPerRing;
    /* 0x0188 */ FEnvDirection ArcDirection;
    /* 0x01a8 */ FAIDataProviderFloatValue ArcAngle;
    /* 0x01e8 */ bool bUseSpiralPattern;
    /* 0x01f0 */ UClass* Center;
    /* 0x01f8 */ bool bDefineArc;
};

// Size: 0x240
class UEnvQueryGenerator_OnCircle : public UEnvQueryGenerator_ProjectedPoints {
    /* 0x0088 */ FAIDataProviderFloatValue CircleRadius;
    /* 0x00c8 */ FAIDataProviderFloatValue SpaceBetween;
    /* 0x0108 */ FAIDataProviderIntValue NumberOfPoints;
    /* 0x0148 */ EPointOnCircleSpacingMethod PointOnCircleSpacingMethod;
    /* 0x0150 */ FEnvDirection ArcDirection;
    /* 0x0170 */ FAIDataProviderFloatValue ArcAngle;
    /* 0x01b0 */ float AngleRadians;
    /* 0x01b8 */ UClass* CircleCenter;
    /* 0x01c0 */ bool bIgnoreAnyContextActorsWhenGeneratingCircle;
    /* 0x01c8 */ FAIDataProviderFloatValue CircleCenterZOffset;
    /* 0x0208 */ FEnvTraceData TraceData;
    /* 0x0238 */ bool bDefineArc;
};

// Size: 0x198
class UEnvQueryGenerator_PathingGrid : public UEnvQueryGenerator_SimpleGrid {
    /* 0x0110 */ FAIDataProviderBoolValue PathToItem;
    /* 0x0150 */ UClass* NavigationFilter;
    /* 0x0158 */ FAIDataProviderFloatValue ScanRangeMultiplier;
};

// Size: 0x88
class UEnvQueryGenerator_ProjectedPoints : public UEnvQueryGenerator {
    /* 0x0058 */ FEnvTraceData ProjectionData;
};

// Size: 0x110
class UEnvQueryGenerator_SimpleGrid : public UEnvQueryGenerator_ProjectedPoints {
    /* 0x0088 */ FAIDataProviderFloatValue GridSize;
    /* 0x00c8 */ FAIDataProviderFloatValue SpaceBetween;
    /* 0x0108 */ UClass* GenerateAround;
};

// Size: 0x88
class UEnvQueryInstanceBlueprintWrapper : public UObject {
    /* 0x0038 */ int32_t QueryID;
    /* 0x0060 */ UClass* ItemType;
    /* 0x0068 */ int32_t OptionIndex;
    /* 0x0070 */ FMulticastInlineDelegate OnQueryFinishedEvent;

    void EQSQueryDoneSignature__DelegateSignature(UEnvQueryInstanceBlueprintWrapper* QueryInstance, uint8_t QueryStatus);
    float GetItemScore(int32_t ItemIndex) const;
    bool GetQueryResultsAsActors(TArray<AActor*>& ResultActors) const;
    bool GetQueryResultsAsLocations(TArray<FVector>& ResultLocations) const;
    TArray<AActor*> GetResultsAsActors() const;
    TArray<FVector> GetResultsAsLocations() const;
    void SetNamedParam(FName ParamName, float Value);
};

// Size: 0x1f8
struct FEnvQueryInstanceCache {
    /* 0x0000 */ UEnvQuery* Template;
};

// Size: 0x38
class UEnvQueryItemType : public UObject {
};

// Size: 0x38
class UEnvQueryItemType_Actor : public UEnvQueryItemType_ActorBase {
};

// Size: 0x38
class UEnvQueryItemType_ActorBase : public UEnvQueryItemType_VectorBase {
};

// Size: 0x38
class UEnvQueryItemType_Direction : public UEnvQueryItemType_VectorBase {
};

// Size: 0x38
class UEnvQueryItemType_Point : public UEnvQueryItemType_VectorBase {
};

// Size: 0x38
class UEnvQueryItemType_VectorBase : public UEnvQueryItemType {
};

// Size: 0x1f8
class UEnvQueryManager : public UAISubsystem {
    /* 0x0150 */ TArray<FEnvQueryInstanceCache> InstanceCache;
    /* 0x0160 */ TArray<UEnvQueryContext*> LocalContexts;
    /* 0x0170 */ TArray<UEnvQueryInstanceBlueprintWrapper*> GCShieldedWrappers;
    /* 0x01d4 */ float MaxAllowedTestingTime;
    /* 0x01d8 */ bool bTestQueriesUsingBreadth;
    /* 0x01dc */ int32_t QueryCountWarningThreshold;
    /* 0x01e0 */ double QueryCountWarningInterval;

    static UEnvQueryInstanceBlueprintWrapper* RunEQSQuery(UObject* WorldContextObject, UEnvQuery* QueryTemplate, UObject* Querier, uint8_t RunMode, UClass* WrapperClass);
};

// Size: 0x38
class UEnvQueryNode : public UObject {
    /* 0x0030 */ int32_t VerNum;
};

// Size: 0x48
class UEnvQueryOption : public UObject {
    /* 0x0030 */ UEnvQueryGenerator* Generator;
    /* 0x0038 */ TArray<UEnvQueryTest*> Tests;
};

// Size: 0x68
struct FEnvQueryRequest {
    /* 0x0000 */ UEnvQuery* QueryTemplate;
    /* 0x0008 */ UObject* Owner;
    /* 0x0010 */ UWorld* World;
};

// Size: 0x40
struct FEnvQueryResult {
    /* 0x0010 */ UClass* ItemType;
    /* 0x002c */ int32_t OptionIndex;
    /* 0x0030 */ int32_t QueryID;
};

// Size: 0x260
class UEnvQueryTest : public UEnvQueryNode {
    /* 0x0038 */ int32_t TestOrder;
    /* 0x003c */ uint8_t TestPurpose;
    /* 0x0040 */ FString TestComment;
    /* 0x0050 */ uint8_t MultipleContextFilterOp;
    /* 0x0051 */ uint8_t MultipleContextScoreOp;
    /* 0x0052 */ uint8_t FilterType;
    /* 0x0058 */ FAIDataProviderBoolValue BoolValue;
    /* 0x0098 */ FAIDataProviderFloatValue FloatValueMin;
    /* 0x00d8 */ FAIDataProviderFloatValue FloatValueMax;
    /* 0x0119 */ uint8_t ScoringEquation;
    /* 0x011a */ uint8_t ClampMinType;
    /* 0x011b */ uint8_t ClampMaxType;
    /* 0x011c */ EEQSNormalizationType NormalizationType;
    /* 0x0120 */ FAIDataProviderFloatValue ScoreClampMin;
    /* 0x0160 */ FAIDataProviderFloatValue ScoreClampMax;
    /* 0x01a0 */ FAIDataProviderFloatValue ScoringFactor;
    /* 0x01e0 */ FAIDataProviderFloatValue ReferenceValue;
    /* 0x0220 */ bool bDefineReferenceValue;
    /* 0x0258 */ bool bWorkOnFloatValues;
};

// Size: 0x270
class UEnvQueryTest_Distance : public UEnvQueryTest {
    /* 0x0260 */ uint8_t TestMode;
    /* 0x0268 */ UClass* DistanceTo;
};

// Size: 0x2a8
class UEnvQueryTest_Dot : public UEnvQueryTest {
    /* 0x0260 */ FEnvDirection LineA;
    /* 0x0280 */ FEnvDirection LineB;
    /* 0x02a0 */ EEnvTestDot TestMode;
    /* 0x02a1 */ bool bAbsoluteValue;
};

// Size: 0x2d0
class UEnvQueryTest_GameplayTags : public UEnvQueryTest {
    /* 0x0260 */ FGameplayTagQuery TagQueryToMatch;
    /* 0x02a8 */ bool bUpdatedToUseQuery;
    /* 0x02a9 */ EGameplayContainerMatchType TagsToMatch;
    /* 0x02b0 */ FGameplayTagContainer GameplayTags;
};

// Size: 0x280
class UEnvQueryTest_Overlap : public UEnvQueryTest {
    /* 0x0260 */ FEnvOverlapData OverlapData;
};

// Size: 0x2f8
class UEnvQueryTest_Pathfinding : public UEnvQueryTest {
    /* 0x0260 */ uint8_t TestMode;
    /* 0x0268 */ UClass* Context;
    /* 0x0270 */ FAIDataProviderBoolValue PathFromContext;
    /* 0x02b0 */ FAIDataProviderBoolValue SkipUnreachable;
    /* 0x02f0 */ UClass* FilterClass;
};

// Size: 0x338
class UEnvQueryTest_PathfindingBatch : public UEnvQueryTest_Pathfinding {
    /* 0x02f8 */ FAIDataProviderFloatValue ScanRangeMultiplier;
};

// Size: 0x290
class UEnvQueryTest_Project : public UEnvQueryTest {
    /* 0x0260 */ FEnvTraceData ProjectionData;
};

// Size: 0x260
class UEnvQueryTest_Random : public UEnvQueryTest {
};

// Size: 0x358
class UEnvQueryTest_Trace : public UEnvQueryTest {
    /* 0x0260 */ FEnvTraceData TraceData;
    /* 0x0290 */ FAIDataProviderBoolValue TraceFromContext;
    /* 0x02d0 */ FAIDataProviderFloatValue ItemHeightOffset;
    /* 0x0310 */ FAIDataProviderFloatValue ContextHeightOffset;
    /* 0x0350 */ UClass* Context;
};

// Size: 0x278
class UEnvQueryTest_Volume : public UEnvQueryTest {
    /* 0x0260 */ UClass* VolumeContext;
    /* 0x0268 */ UClass* VolumeClass;
    /* 0x0270 */ bool bDoComplexVolumeTest;
};

// Size: 0x30
class UEnvQueryTypes : public UObject {
};

// Size: 0x30
struct FEnvTraceData {
    /* 0x0000 */ int32_t VersionNum;
    /* 0x0008 */ UClass* NavigationFilter;
    /* 0x0010 */ float ProjectDown;
    /* 0x0014 */ float ProjectUp;
    /* 0x0018 */ float ExtentX;
    /* 0x001c */ float ExtentY;
    /* 0x0020 */ float ExtentZ;
    /* 0x0024 */ float PostProjectionVerticalOffset;
    /* 0x0028 */ uint8_t TraceChannel;
    /* 0x0029 */ uint8_t SerializedChannel;
    /* 0x002a */ uint8_t TraceShape;
    /* 0x002b */ uint8_t TraceMode;
    /* 0x002c */ bool bTraceComplex;
    /* 0x002c */ bool bOnlyBlockingHits;
    /* 0x002c */ bool bCanTraceOnNavMesh;
    /* 0x002c */ bool bCanTraceOnGeometry;
    /* 0x002c */ bool bCanDisableTrace;
    /* 0x002c */ bool bCanProjectDown;
};

enum class FAIDistanceType {
    Distance3D = 0,
    Distance2D = 1,
    DistanceZ = 2,
    MAX = 3,
};

// Size: 0x30
class IGenericTeamAgentInterface : public UInterface {
};

// Size: 0x1
struct FGenericTeamId {
    /* 0x0000 */ uint8_t TeamID;
};

// Size: 0x408
class AGridPathAIController : public AAIController {
};

// Size: 0x2b0
class UGridPathFollowingComponent : public UPathFollowingComponent {
    /* 0x0280 */ UNavLocalGridManager* GridManager;
};

// Size: 0x8
struct FIntervalCountdown {
    /* 0x0000 */ float Interval;
};

// Size: 0x50
class UNavFilter_AIControllerDefault : public UNavigationQueryFilter {
};

// Size: 0x358
class ANavLinkProxy : public AActor {
    /* 0x0308 */ TArray<FNavigationLink> PointLinks;
    /* 0x0318 */ TArray<FNavigationSegmentLink> SegmentLinks;
    /* 0x0328 */ UNavLinkCustomComponent* SmartLinkComp;
    /* 0x0330 */ bool bSmartLinkIsRelevant;
    /* 0x0338 */ UNavLinkRenderingComponent* EdRenderComp;
    /* 0x0340 */ UBillboardComponent* SpriteComponent;
    /* 0x0348 */ FMulticastInlineDelegate OnSmartLinkReached;

    void CopyEndPointsFromSimpleLinkToSmartLink();
    bool HasMovingAgents() const;
    bool IsSmartLinkEnabled() const;
    void ReceiveSmartLinkReached(AActor* Agent, const FVector& Destination);
    void ResumePathFollowing(AActor* Agent);
    void SetSmartLinkEnabled(bool bEnabled);
};

// Size: 0x60
class UNavLocalGridManager : public UObject {

    static int32_t AddLocalNavigationGridForBox(UObject* WorldContextObject, const FVector& Location, FVector Extent, FRotator Rotation, const int32_t Radius2D, const float Height, bool bRebuildGrids);
    static int32_t AddLocalNavigationGridForCapsule(UObject* WorldContextObject, const FVector& Location, float CapsuleRadius, float CapsuleHalfHeight, const int32_t Radius2D, const float Height, bool bRebuildGrids);
    static int32_t AddLocalNavigationGridForPoint(UObject* WorldContextObject, const FVector& Location, const int32_t Radius2D, const float Height, bool bRebuildGrids);
    static int32_t AddLocalNavigationGridForPoints(UObject* WorldContextObject, const TArray<FVector>& Locations, const int32_t Radius2D, const float Height, bool bRebuildGrids);
    static bool FindLocalNavigationGridPath(UObject* WorldContextObject, const FVector& Start, const FVector& End, TArray<FVector>& PathPoints);
    static void RemoveLocalNavigationGrid(UObject* WorldContextObject, int32_t GridId, bool bRebuildGrids);
    static bool SetLocalNavigationGridDensity(UObject* WorldContextObject, float CellSize);
};

// Size: 0x280
class UPathFollowingComponent : public UActorComponent {
    /* 0x0110 */ UNavMovementComponent* MovementComp;
    /* 0x0120 */ ANavigationData* MyNavData;

    uint8_t GetPathActionType() const;
    FVector GetPathDestination() const;
    void OnActorBump(AActor* SelfActor, AActor* OtherActor, FVector NormalImpulse, const FHitResult& Hit);
    void OnNavDataRegistered(ANavigationData* NavData);
};

// Size: 0x30
class UPathFollowingManager : public UObject {
};

// Size: 0x98
class UPawnAction : public UObject {
    /* 0x0030 */ UPawnAction* ChildAction;
    /* 0x0038 */ UPawnAction* ParentAction;
    /* 0x0040 */ UPawnActionsComponent* OwnerComponent;
    /* 0x0048 */ UObject* Instigator;
    /* 0x0050 */ UBrainComponent* BrainComp;
    /* 0x0088 */ bool bAllowNewSameClassInstance;
    /* 0x0088 */ bool bReplaceActiveSameClassInstance;
    /* 0x0088 */ bool bShouldPauseMovement;
    /* 0x0088 */ bool bAlwaysNotifyOnFinished;

    static UPawnAction* CreateActionInstance(UObject* WorldContextObject, UClass* ActionClass);
    void Finish(uint8_t WithResult);
    uint8_t GetActionPriority();
};

// Size: 0x18
struct FPawnActionEvent {
    /* 0x0000 */ UPawnAction* Action;
};

// Size: 0x8
struct FPawnActionStack {
    /* 0x0000 */ UPawnAction* TopAction;
};

// Size: 0x98
class UPawnAction_BlueprintBase : public UPawnAction {

    void ActionFinished(APawn* ControlledPawn, uint8_t WithResult);
    void ActionPause(APawn* ControlledPawn);
    void ActionResume(APawn* ControlledPawn);
    void ActionStart(APawn* ControlledPawn);
    void ActionTick(APawn* ControlledPawn, float DeltaSeconds);
};

// Size: 0xe8
class UPawnAction_Move : public UPawnAction {
    /* 0x0098 */ AActor* GoalActor;
    /* 0x00a0 */ FVector GoalLocation;
    /* 0x00ac */ float AcceptableRadius;
    /* 0x00b0 */ UClass* FilterClass;
    /* 0x00b8 */ bool bAllowStrafe;
    /* 0x00b8 */ bool bFinishOnOverlap;
    /* 0x00b8 */ bool bUsePathfinding;
    /* 0x00b8 */ bool bAllowPartialPath;
    /* 0x00b8 */ bool bProjectGoalToNavigation;
    /* 0x00b8 */ bool bUpdatePathToGoal;
    /* 0x00b8 */ bool bAbortChildActionOnPathChange;
};

// Size: 0xb8
class UPawnAction_Repeat : public UPawnAction {
    /* 0x0098 */ UPawnAction* ActionToRepeat;
    /* 0x00a0 */ UPawnAction* RecentActionCopy;
    /* 0x00a8 */ uint8_t ChildFailureHandlingMode;
};

// Size: 0xc0
class UPawnAction_Sequence : public UPawnAction {
    /* 0x0098 */ TArray<UPawnAction*> ActionSequence;
    /* 0x00a8 */ uint8_t ChildFailureHandlingMode;
    /* 0x00b0 */ UPawnAction* RecentActionCopy;
};

// Size: 0xa8
class UPawnAction_Wait : public UPawnAction {
    /* 0x0098 */ float TimeToWait;
};

// Size: 0xf8
class UPawnActionsComponent : public UActorComponent {
    /* 0x00c0 */ APawn* ControlledPawn;
    /* 0x00c8 */ TArray<FPawnActionStack> ActionStacks;
    /* 0x00d8 */ TArray<FPawnActionEvent> ActionEvents;
    /* 0x00e8 */ UPawnAction* CurrentAction;

    uint8_t K2_AbortAction(UPawnAction* ActionToAbort);
    uint8_t K2_ForceAbortAction(UPawnAction* ActionToAbort);
    static bool K2_PerformAction(APawn* Pawn, UPawnAction* Action, uint8_t Priority);
    bool K2_PushAction(UPawnAction* NewAction, uint8_t Priority, UObject* Instigator);
};

// Size: 0x108
class UPawnSensingComponent : public UActorComponent {
    /* 0x00c0 */ float HearingThreshold;
    /* 0x00c4 */ float LOSHearingThreshold;
    /* 0x00c8 */ float SightRadius;
    /* 0x00cc */ float SensingInterval;
    /* 0x00d0 */ float HearingMaxSoundAge;
    /* 0x00d4 */ bool bEnableSensingUpdates;
    /* 0x00d4 */ bool bOnlySensePlayers;
    /* 0x00d4 */ bool bSeePawns;
    /* 0x00d4 */ bool bHearNoises;
    /* 0x00e0 */ FMulticastInlineDelegate OnSeePawn;
    /* 0x00f0 */ FMulticastInlineDelegate OnHearNoise;
    /* 0x0100 */ float PeripheralVisionAngle;
    /* 0x0104 */ float PeripheralVisionCosine;

    float GetPeripheralVisionAngle() const;
    float GetPeripheralVisionCosine() const;
    void HearNoiseDelegate__DelegateSignature(APawn* Instigator, const FVector& Location, float Volume);
    void SeePawnDelegate__DelegateSignature(APawn* Pawn);
    void SetPeripheralVisionAngle(const float NewPeripheralVisionAngle);
    void SetSensingInterval(const float NewSensingInterval);
    void SetSensingUpdatesEnabled(const bool bEnabled);
};

// Size: 0x98
struct FRecastGraphWrapper {
    /* 0x0000 */ ARecastNavMesh* RecastNavMeshActor;
};

// Size: 0x30
class UVisualLoggerExtension : public UObject {
};

// Size: 0x60
class UMockAI : public UObject {
    /* 0x0040 */ UBlackboardComponent* BBComp;
    /* 0x0048 */ UBrainComponent* BrainComp;
    /* 0x0050 */ UAIPerceptionComponent* PerceptionComp;
    /* 0x0058 */ UPawnActionsComponent* PawnActionComp;
};

// Size: 0x78
class UMockAI_BT : public UMockAI {
    /* 0x0060 */ UBehaviorTreeComponent* BTComp;
};

// Size: 0x40
class UMockGameplayTaskOwner : public UObject {
    /* 0x0038 */ UGameplayTasksComponent* GTComponent;
};

// Size: 0x130
class UMockGameplayTasksComponent : public UGameplayTasksComponent {
};

// Size: 0x90
class UMockTask_Log : public UGameplayTask {
};

// Size: 0xe8
class UTestBTDecorator_Blackboard : public UBTDecorator_Blackboard {
    /* 0x00d8 */ int32_t LogIndexBecomeRelevant;
    /* 0x00dc */ int32_t LogIndexCeaseRelevant;
    /* 0x00e0 */ int32_t LogIndexCalculate;
};

// Size: 0x78
class UTestBTDecorator_CantExecute : public UBTDecorator {
};

// Size: 0x80
class UTestBTDecorator_DelayedAbort : public UBTDecorator {
    /* 0x0078 */ int32_t DelayTicks;
    /* 0x007c */ bool bOnlyOnce;
};

// Size: 0x98
class UTestBTService_Log : public UBTService {
    /* 0x0080 */ int32_t LogActivation;
    /* 0x0084 */ int32_t LogDeactivation;
    /* 0x0088 */ FName KeyNameTick;
    /* 0x0094 */ int32_t LogTick;
};

// Size: 0xb8
class UTestBTTask_LatentWithFlags : public UBTTaskNode {
    /* 0x0080 */ int32_t LogIndexExecuteStart;
    /* 0x0084 */ int32_t LogIndexExecuteFinish;
    /* 0x0088 */ int32_t LogIndexAbortStart;
    /* 0x008c */ int32_t LogIndexAbortFinish;
    /* 0x0090 */ int32_t ExecuteTicks;
    /* 0x0094 */ int32_t AbortTicks;
    /* 0x0098 */ FName KeyNameExecute;
    /* 0x00a4 */ FName KeyNameAbort;
    /* 0x00b0 */ uint8_t LogResult;
};

// Size: 0x90
class UTestBTTask_Log : public UBTTaskNode {
    /* 0x0080 */ int32_t LogIndex;
    /* 0x0084 */ int32_t LogFinished;
    /* 0x0088 */ int32_t ExecutionTicks;
    /* 0x008c */ uint8_t LogResult;
};

// Size: 0xa0
class UTestBTTask_SetFlag : public UBTTaskNode {
    /* 0x0080 */ FName KeyName;
    /* 0x008c */ bool bValue;
    /* 0x0090 */ FName OnAbortKeyName;
    /* 0x009c */ bool bOnAbortValue;
    /* 0x009d */ uint8_t TaskResult;
};

// Size: 0xa8
class UTestBTTask_SetValue : public UBTTaskNode {
    /* 0x0080 */ FName KeyName;
    /* 0x008c */ int32_t Value;
    /* 0x0090 */ FName OnAbortKeyName;
    /* 0x009c */ int32_t OnAbortValue;
    /* 0x00a0 */ uint8_t TaskResult;
};

// Size: 0xa8
class UTestPawnAction_CallFunction : public UTestPawnAction_Log {
};

// Size: 0xa0
class UTestPawnAction_Log : public UPawnAction {
};

// Size: 0xc
struct FActorLayer {
    /* 0x0000 */ FName Name;
};

// Size: 0x30
class ULayersBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void AddActorToLayer(AActor* InActor, const FActorLayer& Layer);
    static TArray<AActor*> GetActors(UObject* WorldContextObject, const FActorLayer& ActorLayer);
    static void RemoveActorFromLayer(AActor* InActor, const FActorLayer& Layer);
};

// Size: 0x98
class UActorSequence : public UMovieSceneSequence {
    /* 0x0068 */ UMovieScene* MovieScene;
    /* 0x0070 */ FActorSequenceObjectReferenceMap ObjectReferences;
    /* 0x0090 */ bool bHasBeenInitialized;
};

// Size: 0xe8
class UActorSequenceComponent : public UActorComponent {
    /* 0x00c0 */ FMovieSceneSequencePlaybackSettings PlaybackSettings;
    /* 0x00d8 */ UActorSequence* Sequence;
    /* 0x00e0 */ UActorSequencePlayer* SequencePlayer;
};

// Size: 0x28
struct FActorSequenceObjectReference {
    /* 0x0000 */ EActorSequenceObjectReferenceType Type;
    /* 0x0004 */ FGuid ActorId;
    /* 0x0018 */ FString PathToComponent;
};

// Size: 0x20
struct FActorSequenceObjectReferenceMap {
    /* 0x0000 */ TArray<FGuid> BindingIds;
    /* 0x0010 */ TArray<FActorSequenceObjectReferences> References;
};

// Size: 0x10
struct FActorSequenceObjectReferences {
    /* 0x0000 */ TArray<FActorSequenceObjectReference> Array;
};

// Size: 0x500
class UActorSequencePlayer : public UMovieSceneSequencePlayer {
};

enum class EActorSequenceObjectReferenceType {
    ContextActor = 0,
    ExternalActor = 1,
    Component = 2,
    EActorSequenceObjectReferenceType_MAX = 3,
};

enum class EContentSourceCategory {
    BlueprintFeature = 0,
    CodeFeature = 1,
    EnterpriseFeature = 2,
    Content = 3,
    EnterpriseContent = 4,
    SharedPack = 5,
    Unknown = 6,
    EContentSourceCategory_MAX = 7,
};

enum class EFeaturePackDetailLevel {
    Standard = 0,
    High = 1,
    EFeaturePackDetailLevel_MAX = 2,
};

// Size: 0x20
struct FFeatureAdditionalFiles {
    /* 0x0000 */ FString DestinationFilesFolder;
    /* 0x0010 */ TArray<FString> AdditionalFilesList;
};

// Size: 0x20
struct FFeaturePackLevelSet {
    /* 0x0000 */ TArray<EFeaturePackDetailLevel> DetailLevels;
    /* 0x0010 */ FString MountName;
};

// Size: 0x98
class UAssetViewerSettings : public UObject {
    /* 0x0038 */ TArray<FPreviewSceneProfile> Profiles;
};

// Size: 0x40
class ULocalProfiles : public UObject {
    /* 0x0030 */ TArray<FPreviewSceneProfile> Profiles;
};

// Size: 0x640
struct FPreviewSceneProfile {
    /* 0x0000 */ FString ProfileName;
    /* 0x0010 */ bool bSharedProfile;
    /* 0x0011 */ bool bUseSkyLighting;
    /* 0x0014 */ float DirectionalLightIntensity;
    /* 0x0018 */ FLinearColor DirectionalLightColor;
    /* 0x0028 */ float SkyLightIntensity;
    /* 0x002c */ bool bRotateLightingRig;
    /* 0x002d */ bool bShowEnvironment;
    /* 0x002e */ bool bShowFloor;
    /* 0x0030 */ FLinearColor EnvironmentColor;
    /* 0x0040 */ float EnvironmentIntensity;
    /* 0x0048 */ TSoftObjectPtr<UTextureCube> EnvironmentCubeMap;
    /* 0x0078 */ FString EnvironmentCubeMapPath;
    /* 0x0088 */ bool bPostProcessingEnabled;
    /* 0x0090 */ FPostProcessSettings PostProcessingSettings;
    /* 0x0620 */ float LightingRigRotation;
    /* 0x0624 */ float RotationSpeed;
    /* 0x0628 */ FRotator DirectionalLightRotation;
};

// Size: 0x40
class USharedProfiles : public UObject {
    /* 0x0030 */ TArray<FPreviewSceneProfile> Profiles;
};

// Size: 0xb8
class UAlembicImportFactory : public UFactory {
    /* 0x00a8 */ UAbcImportSettings* ImportSettings;
    /* 0x00b0 */ bool bShowOption;
};

// Size: 0x88
class UAbcAssetImportData : public UAssetImportData {
    /* 0x0060 */ TArray<FString> TrackNames;
    /* 0x0070 */ FAbcSamplingSettings SamplingSettings;
};

// Size: 0x10
struct FAbcCompressionSettings {
    /* 0x0000 */ bool bMergeMeshes;
    /* 0x0001 */ bool bBakeMatrixAnimation;
    /* 0x0002 */ EBaseCalculationType BaseCalculationType;
    /* 0x0004 */ float PercentageOfTotalBases;
    /* 0x0008 */ int32_t MaxNumberOfBases;
    /* 0x000c */ float MinimumNumberOfVertexInfluencePercentage;
};

// Size: 0x1c
struct FAbcConversionSettings {
    /* 0x0000 */ EAbcConversionPreset Preset;
    /* 0x0001 */ bool bFlipU;
    /* 0x0002 */ bool bFlipV;
    /* 0x0004 */ FVector Scale;
    /* 0x0010 */ FVector Rotation;
};

// Size: 0x10
struct FAbcGeometryCacheSettings {
    /* 0x0000 */ bool bFlattenTracks;
    /* 0x0001 */ bool bApplyConstantTopologyOptimizations;
    /* 0x0002 */ bool bCalculateMotionVectorsDuringImport;
    /* 0x0003 */ EAbcGeometryCacheMotionVectorsImport MotionVectors;
    /* 0x0004 */ bool bOptimizeIndexBuffers;
    /* 0x0008 */ float CompressedPositionPrecision;
    /* 0x000c */ int32_t CompressedTextureCoordinatesNumberOfBits;
};

// Size: 0xa8
class UAbcImportSettings : public UObject {
    /* 0x0030 */ EAlembicImportType ImportType;
    /* 0x0034 */ FAbcSamplingSettings SamplingSettings;
    /* 0x004c */ FAbcNormalGenerationSettings NormalGenerationSettings;
    /* 0x0058 */ FAbcMaterialSettings MaterialSettings;
    /* 0x005c */ FAbcCompressionSettings CompressionSettings;
    /* 0x006c */ FAbcStaticMeshSettings StaticMeshSettings;
    /* 0x0070 */ FAbcGeometryCacheSettings GeometryCacheSettings;
    /* 0x0080 */ FAbcConversionSettings ConversionSettings;
};

// Size: 0x2
struct FAbcMaterialSettings {
    /* 0x0000 */ bool bCreateMaterials;
    /* 0x0001 */ bool bFindMaterials;
};

// Size: 0xc
struct FAbcNormalGenerationSettings {
    /* 0x0000 */ bool bForceOneSmoothingGroupPerObject;
    /* 0x0004 */ float HardEdgeAngleThreshold;
    /* 0x0008 */ bool bRecomputeNormals;
    /* 0x0009 */ bool bIgnoreDegenerateTriangles;
    /* 0x000a */ bool bSkipComputingTangents;
};

// Size: 0x18
struct FAbcSamplingSettings {
    /* 0x0000 */ EAlembicSamplingType SamplingType;
    /* 0x0004 */ int32_t FrameSteps;
    /* 0x0008 */ float TimeSteps;
    /* 0x000c */ int32_t FrameStart;
    /* 0x0010 */ int32_t FrameEnd;
    /* 0x0014 */ bool bSkipEmpty;
};

// Size: 0x3
struct FAbcStaticMeshSettings {
    /* 0x0000 */ bool bMergeMeshes;
    /* 0x0001 */ bool bPropagateMatrixTransformations;
    /* 0x0002 */ bool bGenerateLightmapUVs;
};

// Size: 0xa8
class UAlembicTestCommandlet : public UCommandlet {
};

enum class EAbcConversionPreset {
    Maya = 0,
    Max = 1,
    Custom = 2,
    EAbcConversionPreset_MAX = 3,
};

enum class EAbcGeometryCacheMotionVectorsImport {
    NoMotionVectors = 0,
    ImportAbcVelocitiesAsMotionVectors = 1,
    CalculateMotionVectorsDuringImport = 2,
    EAbcGeometryCacheMotionVectorsImport_MAX = 3,
};

enum class EAlembicImportType {
    StaticMesh = 0,
    GeometryCache = 1,
    Skeletal = 2,
    EAlembicImportType_MAX = 3,
};

enum class EAlembicSamplingType {
    PerFrame = 0,
    PerXFrames = 1,
    PerTimeStep = 2,
    EAlembicSamplingType_MAX = 3,
};

enum class EBaseCalculationType {
    None = 0,
    PercentageBased = 1,
    FixedNumber = 2,
    NoCompression = 3,
    EBaseCalculationType_MAX = 4,
};

// Size: 0x88
class UAndroidFileMediaSourceFactory : public UFactory {
};

// Size: 0x38
class UAndroidMediaSettings : public UObject {
    /* 0x0030 */ bool CacheableVideoSampleBuffers;
};

// Size: 0x50
class UAndroidPermissionCallbackProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnPermissionsGrantedDynamicDelegate;
};

// Size: 0x30
class UAndroidPermissionFunctionLibrary : public UBlueprintFunctionLibrary {

    static UAndroidPermissionCallbackProxy* AcquirePermissions(const TArray<FString>& Permissions);
    static bool CheckPermission(FString permission);
};

// Size: 0x90
class UAndroidSDKSettings : public UObject {
    /* 0x0030 */ FDirectoryPath SDKPath;
    /* 0x0040 */ FDirectoryPath NDKPath;
    /* 0x0050 */ FDirectoryPath JavaPath;
    /* 0x0060 */ FString SDKAPILevel;
    /* 0x0070 */ FString NDKAPILevel;
};

// Size: 0x2f0
class UAndroidRuntimeSettings : public UObject {
    /* 0x0030 */ FString PackageName;
    /* 0x0040 */ int32_t StoreVersion;
    /* 0x0044 */ int32_t StoreVersionOffsetArmV7;
    /* 0x0048 */ int32_t StoreVersionOffsetArm64;
    /* 0x004c */ int32_t StoreVersionOffsetX8664;
    /* 0x0050 */ FString ApplicationDisplayName;
    /* 0x0060 */ FString VersionDisplayName;
    /* 0x0070 */ int32_t MinSDKVersion;
    /* 0x0074 */ int32_t TargetSDKVersion;
    /* 0x0078 */ uint8_t InstallLocation;
    /* 0x0079 */ bool bEnableGradle;
    /* 0x007a */ bool bEnableLint;
    /* 0x007b */ bool bPackageDataInsideApk;
    /* 0x007c */ bool bCreateAllPlatformsInstall;
    /* 0x007d */ bool bDisableVerifyOBBOnStartUp;
    /* 0x007e */ bool bForceSmallOBBFiles;
    /* 0x007f */ bool bAllowLargeOBBFiles;
    /* 0x0080 */ bool bAllowPatchOBBFile;
    /* 0x0081 */ bool bAllowOverflowOBBFiles;
    /* 0x0082 */ bool bUseExternalFilesDir;
    /* 0x0083 */ bool bPublicLogFiles;
    /* 0x0084 */ uint8_t Orientation;
    /* 0x0088 */ float MaxAspectRatio;
    /* 0x008c */ bool bUseDisplayCutout;
    /* 0x008d */ bool bRestoreNotificationsOnReboot;
    /* 0x008e */ bool bFullScreen;
    /* 0x008f */ bool bEnableNewKeyboard;
    /* 0x0090 */ uint8_t DepthBufferPreference;
    /* 0x0091 */ bool bValidateTextureFormats;
    /* 0x0092 */ bool bEnableBundle;
    /* 0x0093 */ bool bEnableUniversalAPK;
    /* 0x0094 */ bool bBundleABISplit;
    /* 0x0095 */ bool bBundleLanguageSplit;
    /* 0x0096 */ bool bBundleDensitySplit;
    /* 0x0098 */ TArray<FString> ExtraManifestNodeTags;
    /* 0x00a8 */ TArray<FString> ExtraApplicationNodeTags;
    /* 0x00b8 */ FString ExtraApplicationSettings;
    /* 0x00c8 */ TArray<FString> ExtraActivityNodeTags;
    /* 0x00d8 */ FString ExtraActivitySettings;
    /* 0x00e8 */ TArray<FString> ExtraPermissions;
    /* 0x00f8 */ bool bAndroidVoiceEnabled;
    /* 0x0100 */ TArray<uint8_t> PackageForOculusMobile;
    /* 0x0110 */ bool bRemoveOSIG;
    /* 0x0118 */ TArray<uint8_t> GoogleVRCaps;
    /* 0x0128 */ bool bGoogleVRSustainedPerformance;
    /* 0x0130 */ FString KeyStore;
    /* 0x0140 */ FString KeyAlias;
    /* 0x0150 */ FString KeyStorePassword;
    /* 0x0160 */ FString KeyPassword;
    /* 0x0170 */ bool bBuildForArmV7;
    /* 0x0171 */ bool bBuildForArm64;
    /* 0x0172 */ bool bBuildForX8664;
    /* 0x0173 */ bool bBuildForES31;
    /* 0x0174 */ bool bSupportsVulkan;
    /* 0x0175 */ bool bSupportsVulkanSM5;
    /* 0x0176 */ uint8_t ClangSanitizer;
    /* 0x0177 */ bool bAndroidOpenGLSupportsBackbufferSampling;
    /* 0x0178 */ bool bDetectVulkanByDefault;
    /* 0x0179 */ bool bBuildWithHiddenSymbolVisibility;
    /* 0x017a */ bool bSaveSymbols;
    /* 0x017b */ bool bForceLDLinker;
    /* 0x017c */ bool bEnableGooglePlaySupport;
    /* 0x017d */ bool bUseGetAccounts;
    /* 0x0180 */ FString GamesAppID;
    /* 0x0190 */ TArray<FGooglePlayAchievementMapping> AchievementMap;
    /* 0x01a0 */ TArray<FGooglePlayLeaderboardMapping> LeaderboardMap;
    /* 0x01b0 */ bool bEnableSnapshots;
    /* 0x01b1 */ bool bSupportAdMob;
    /* 0x01b8 */ FString AdMobAdUnitID;
    /* 0x01c8 */ TArray<FString> AdMobAdUnitIDs;
    /* 0x01d8 */ FString GooglePlayLicenseKey;
    /* 0x01e8 */ FString GCMClientSenderID;
    /* 0x01f8 */ bool bShowLaunchImage;
    /* 0x01f9 */ bool bAllowIMU;
    /* 0x01fa */ bool bAllowControllers;
    /* 0x01fb */ bool bBlockAndroidKeysOnControllers;
    /* 0x01fc */ bool bControllersBlockDeviceFeedback;
    /* 0x01fd */ uint8_t AndroidAudio;
    /* 0x0200 */ int32_t AudioSampleRate;
    /* 0x0204 */ int32_t AudioCallbackBufferFrameSize;
    /* 0x0208 */ int32_t AudioNumBuffersToEnqueue;
    /* 0x020c */ int32_t AudioMaxChannels;
    /* 0x0210 */ int32_t AudioNumSourceWorkers;
    /* 0x0218 */ FString SpatializationPlugin;
    /* 0x0228 */ FString ReverbPlugin;
    /* 0x0238 */ FString OcclusionPlugin;
    /* 0x0248 */ FPlatformRuntimeAudioCompressionOverrides CompressionOverrides;
    /* 0x0258 */ bool bUseAudioStreamCaching;
    /* 0x025c */ int32_t CacheSizeKB;
    /* 0x0260 */ int32_t MaxChunkSizeOverrideKB;
    /* 0x0264 */ bool bResampleForDevice;
    /* 0x0268 */ int32_t SoundCueCookQualityIndex;
    /* 0x026c */ float MaxSampleRate;
    /* 0x0270 */ float HighSampleRate;
    /* 0x0274 */ float MedSampleRate;
    /* 0x0278 */ float LowSampleRate;
    /* 0x027c */ float MinSampleRate;
    /* 0x0280 */ float CompressionQualityModifier;
    /* 0x0284 */ float AutoStreamingThreshold;
    /* 0x0288 */ uint8_t AndroidGraphicsDebugger;
    /* 0x0290 */ FDirectoryPath MaliGraphicsDebuggerPath;
    /* 0x02a0 */ bool bEnableMaliPerfCounters;
    /* 0x02a1 */ bool bMultiTargetFormat_ETC2;
    /* 0x02a2 */ bool bMultiTargetFormat_DXT;
    /* 0x02a3 */ bool bMultiTargetFormat_ASTC;
    /* 0x02a4 */ float TextureFormatPriority_ETC2;
    /* 0x02a8 */ float TextureFormatPriority_DXT;
    /* 0x02ac */ float TextureFormatPriority_ASTC;
    /* 0x02b0 */ FString SDKAPILevelOverride;
    /* 0x02c0 */ FString NDKAPILevelOverride;
    /* 0x02d0 */ bool bStreamLandscapeMeshLODs;
    /* 0x02d1 */ bool bEnableDomStorage;
};

enum class EAndroidAudio {
    Default = 0,
    OGG = 1,
    ADPCM = 2,
    EAndroidAudio_MAX = 3,
};

enum class EAndroidDepthBufferPreference {
    Default = 0,
    Bits16 = 16,
    Bits24 = 24,
    Bits32 = 32,
    EAndroidDepthBufferPreference_MAX = 33,
};

enum class EAndroidGraphicsDebugger {
    None = 0,
    Mali = 1,
    Adreno = 2,
    EAndroidGraphicsDebugger_MAX = 3,
};

enum class EAndroidInstallLocation {
    InternalOnly = 0,
    PreferExternal = 1,
    Auto = 2,
    EAndroidInstallLocation_MAX = 3,
};

enum class EAndroidScreenOrientation {
    Portrait = 0,
    ReversePortrait = 1,
    SensorPortrait = 2,
    Landscape = 3,
    ReverseLandscape = 4,
    SensorLandscape = 5,
    Sensor = 6,
    FullSensor = 7,
    EAndroidScreenOrientation_MAX = 8,
};

enum class EClangSanitizer {
    None = 0,
    Address = 1,
    HwAddress = 2,
    UndefinedBehavior = 3,
    UndefinedBehaviorMinimal = 4,
    EClangSanitizer_MAX = 5,
};

enum class EGoogleVRCaps {
    Cardboard = 0,
    Daydream33 = 1,
    Daydream63 = 2,
    Daydream66 = 3,
    EGoogleVRCaps_MAX = 4,
};

enum class EGoogleVRMode {
    Cardboard = 0,
    Daydream = 1,
    DaydreamAndCardboard = 2,
    EGoogleVRMode_MAX = 3,
};

enum class EOculusMobileDevice {
    Quest = 1,
    Quest2 = 2,
    EOculusMobileDevice_MAX = 3,
};

// Size: 0x20
struct FGooglePlayAchievementMapping {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FString AchievementID;
};

// Size: 0x20
struct FGooglePlayLeaderboardMapping {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FString LeaderboardID;
};

// Size: 0x80
struct FAnimBlueprintFunctionPinInfo {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ FEdGraphPinType Type;
};

// Size: 0x30
class UAnimBlueprintPostCompileValidation : public UObject {
};

// Size: 0x120
struct FAnimGraphNodePropertyBinding {
    /* 0x0000 */ FEdGraphPinType PinType;
    /* 0x0070 */ FEdGraphPinType PromotedPinType;
    /* 0x00e0 */ FName PropertyName;
    /* 0x00f0 */ FText PathAsText;
    /* 0x0108 */ TArray<FString> PropertyPath;
    /* 0x0118 */ EAnimGraphNodePropertyBindingType Type;
    /* 0x011c */ bool bIsBound;
    /* 0x011d */ bool bIsPromotion;
};

// Size: 0x3d0
class UAnimGraphNode_AimOffsetLookAt : public UAnimGraphNode_BlendSpaceBase {
    /* 0x0180 */ FAnimNode_AimOffsetLookAt Node;
};

// Size: 0x6f0
class UAnimGraphNode_AnimDynamics : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_AnimDynamics Node;
    /* 0x0630 */ bool bPreviewLive;
    /* 0x0631 */ bool bShowLinearLimits;
    /* 0x0632 */ bool bShowAngularLimits;
    /* 0x0633 */ bool bShowPlanarLimit;
    /* 0x0634 */ bool bShowSphericalLimit;
    /* 0x0635 */ bool bShowCollisionSpheres;
    /* 0x0638 */ USkeletalMeshComponent* LastPreviewComponent;
};

// Size: 0x250
class UAnimGraphNode_ApplyAdditive : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_ApplyAdditive Node;
};

// Size: 0x2b0
class UAnimGraphNode_ApplyLimits : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_ApplyLimits Node;
};

// Size: 0x258
class UAnimGraphNode_ApplyMeshSpaceAdditive : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_ApplyMeshSpaceAdditive Node;
};

// Size: 0x180
class UAnimGraphNode_AssetPlayerBase : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimationGroupReference SyncGroup;
};

// Size: 0x170
class UAnimGraphNode_Base : public UK2Node {
    /* 0x00c8 */ TArray<FOptionalPinFromProperty> ShowPinForProperties;
    /* 0x00d8 */ TMap<FName, FAnimGraphNodePropertyBinding> PropertyBindings;
    /* 0x0128 */ EBlueprintUsage BlueprintUsage;
};

// Size: 0x1e8
class UAnimGraphNode_BlendBoneByChannel : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_BlendBoneByChannel BlendNode;
};

// Size: 0x178
class UAnimGraphNode_BlendListBase : public UAnimGraphNode_Base {
};

// Size: 0x218
class UAnimGraphNode_BlendListByBool : public UAnimGraphNode_BlendListBase {
    /* 0x0178 */ FAnimNode_BlendListByBool Node;
};

// Size: 0x268
class UAnimGraphNode_BlendListByEnum : public UAnimGraphNode_BlendListBase {
    /* 0x0180 */ FAnimNode_BlendListByEnum Node;
    /* 0x0230 */ UEnum* BoundEnum;
    /* 0x0238 */ TArray<FName> VisibleEnumEntries;
};

// Size: 0x218
class UAnimGraphNode_BlendListByInt : public UAnimGraphNode_BlendListBase {
    /* 0x0178 */ FAnimNode_BlendListByInt Node;
};

// Size: 0x180
class UAnimGraphNode_BlendSpaceBase : public UAnimGraphNode_AssetPlayerBase {
};

// Size: 0x2f8
class UAnimGraphNode_BlendSpaceEvaluator : public UAnimGraphNode_BlendSpaceBase {
    /* 0x0180 */ FAnimNode_BlendSpaceEvaluator Node;
};

// Size: 0x2f0
class UAnimGraphNode_BlendSpacePlayer : public UAnimGraphNode_BlendSpaceBase {
    /* 0x0180 */ FAnimNode_BlendSpacePlayer Node;
};

// Size: 0x2f0
class UAnimGraphNode_BoneDrivenController : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_BoneDrivenController Node;
};

// Size: 0x3f0
class UAnimGraphNode_CCDIK : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_CCDIK Node;
};

// Size: 0x198
class UAnimGraphNode_ComponentToLocalSpace : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_ConvertComponentToLocalSpace Node;
};

// Size: 0x3d0
class UAnimGraphNode_Constraint : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_Constraint Node;
};

// Size: 0x340
class UAnimGraphNode_CopyBone : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_CopyBone Node;
};

// Size: 0x2c8
class UAnimGraphNode_CopyBoneDelta : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_CopyBoneDelta Node;
};

// Size: 0x348
class UAnimGraphNode_CopyPoseFromMesh : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_CopyPoseFromMesh Node;
};

// Size: 0x1b8
class UAnimGraphNode_CurveSource : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_CurveSource Node;
};

// Size: 0x198
class UAnimGraphNode_CustomProperty : public UAnimGraphNode_Base {
    /* 0x0178 */ TArray<FName> KnownExposableProperties;
    /* 0x0188 */ TArray<FName> ExposedPropertyNames;
};

// Size: 0x1b0
class UAnimGraphNode_CustomTransitionResult : public UAnimGraphNode_StateResult {
};

// Size: 0x3b0
class UAnimGraphNode_Fabrik : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_Fabrik Node;
};

// Size: 0x2f8
class UAnimGraphNode_HandIKRetargeting : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_HandIKRetargeting Node;
};

// Size: 0x188
class UAnimGraphNode_IdentityPose : public UAnimGraphNode_RefPoseBase {
};

// Size: 0x1e8
class UAnimGraphNode_Inertialization : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_Inertialization Node;
};

// Size: 0x240
class UAnimGraphNode_LayeredBoneBlend : public UAnimGraphNode_BlendListBase {
    /* 0x0178 */ FAnimNode_LayeredBoneBlend Node;
};

// Size: 0x2c0
class UAnimGraphNode_LegIK : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_LegIK Node;
};

// Size: 0x248
class UAnimGraphNode_LinkedAnimGraph : public UAnimGraphNode_LinkedAnimGraphBase {
    /* 0x0198 */ FAnimNode_LinkedAnimGraph Node;
};

// Size: 0x198
class UAnimGraphNode_LinkedAnimGraphBase : public UAnimGraphNode_CustomProperty {
};

// Size: 0x290
class UAnimGraphNode_LinkedAnimLayer : public UAnimGraphNode_LinkedAnimGraphBase {
    /* 0x0198 */ FAnimNode_LinkedAnimLayer Node;
    /* 0x0278 */ FGuid InterfaceGuid;
};

// Size: 0x2f0
class UAnimGraphNode_LinkedInputPose : public UAnimGraphNode_Base {
    /* 0x0178 */ FAnimNode_LinkedInputPose Node;
    /* 0x02a0 */ TArray<FAnimBlueprintFunctionPinInfo> Inputs;
    /* 0x02b0 */ FMemberReference FunctionReference;
    /* 0x02e8 */ int32_t InputPoseIndex;
};

// Size: 0x188
class UAnimGraphNode_LocalRefPose : public UAnimGraphNode_RefPoseBase {
};

// Size: 0x198
class UAnimGraphNode_LocalToComponentSpace : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_ConvertLocalToComponentSpace Node;
};

// Size: 0x510
class UAnimGraphNode_LookAt : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_LookAt Node;
};

// Size: 0x1b8
class UAnimGraphNode_MakeDynamicAdditive : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_MakeDynamicAdditive Node;
};

// Size: 0x180
class UAnimGraphNode_MeshRefPose : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_MeshSpaceRefPose Node;
};

// Size: 0x358
class UAnimGraphNode_ModifyBone : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_ModifyBone Node;
};

// Size: 0x1d0
class UAnimGraphNode_ModifyCurve : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_ModifyCurve Node;
};

// Size: 0x1c8
class UAnimGraphNode_MultiWayBlend : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_MultiWayBlend Node;
};

// Size: 0x2d0
class UAnimGraphNode_ObserveBone : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_ObserveBone Node;
};

// Size: 0x240
class UAnimGraphNode_PoseBlendNode : public UAnimGraphNode_PoseHandler {
    /* 0x0180 */ FAnimNode_PoseBlendNode Node;
};

// Size: 0x248
class UAnimGraphNode_PoseByName : public UAnimGraphNode_AssetPlayerBase {
    /* 0x0180 */ FAnimNode_PoseByName Node;
};

// Size: 0x3d0
class UAnimGraphNode_PoseDriver : public UAnimGraphNode_PoseHandler {
    /* 0x0180 */ FAnimNode_PoseDriver Node;
    /* 0x0320 */ float AxisLength;
    /* 0x0324 */ int32_t ConeSubdivision;
    /* 0x0328 */ bool bDrawDebugCones;
    /* 0x0348 */ USkeletalMeshComponent* LastPreviewComponent;
};

// Size: 0x180
class UAnimGraphNode_PoseHandler : public UAnimGraphNode_AssetPlayerBase {
};

// Size: 0x220
class UAnimGraphNode_PoseSnapshot : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_PoseSnapshot Node;
};

// Size: 0x1e8
class UAnimGraphNode_RandomPlayer : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_RandomPlayer Node;
};

// Size: 0x188
class UAnimGraphNode_RefPoseBase : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_RefPose Node;
};

// Size: 0x2a0
class UAnimGraphNode_ResetRoot : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_ResetRoot Node;
};

// Size: 0xa20
class UAnimGraphNode_RigidBody : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_RigidBody Node;
};

// Size: 0x1b0
class UAnimGraphNode_Root : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_Root Node;
};

// Size: 0x218
class UAnimGraphNode_RotateRootBone : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_RotateRootBone Node;
};

// Size: 0x340
class UAnimGraphNode_RotationMultiplier : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_RotationMultiplier Node;
};

// Size: 0x3a8
class UAnimGraphNode_RotationOffsetBlendSpace : public UAnimGraphNode_BlendSpaceBase {
    /* 0x0180 */ FAnimNode_RotationOffsetBlendSpace Node;
};

// Size: 0x300
class UAnimGraphNode_SaveCachedPose : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_SaveCachedPose Node;
    /* 0x02d0 */ FString CacheName;
};

// Size: 0x1f8
class UAnimGraphNode_ScaleChainLength : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_ScaleChainLength Node;
};

// Size: 0x1f8
class UAnimGraphNode_SequenceEvaluator : public UAnimGraphNode_AssetPlayerBase {
    /* 0x0180 */ FAnimNode_SequenceEvaluator Node;
};

// Size: 0x298
class UAnimGraphNode_SequencePlayer : public UAnimGraphNode_AssetPlayerBase {
    /* 0x0180 */ FAnimNode_SequencePlayer Node;
};

// Size: 0x170
class UAnimGraphNode_SkeletalControlBase : public UAnimGraphNode_Base {
};

// Size: 0x248
class UAnimGraphNode_Slot : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_Slot Node;
};

// Size: 0x4c0
class UAnimGraphNode_SplineIK : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_SplineIK Node;
};

// Size: 0x378
class UAnimGraphNode_SpringBone : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_SpringBone Node;
};

// Size: 0x248
class UAnimGraphNode_StateMachine : public UAnimGraphNode_StateMachineBase {
    /* 0x0198 */ FAnimNode_StateMachine Node;
};

// Size: 0x198
class UAnimGraphNode_StateMachineBase : public UAnimGraphNode_Base {
    /* 0x0170 */ UAnimationStateMachineGraph* EditorStateMachineGraph;
};

// Size: 0x1b0
class UAnimGraphNode_StateResult : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_StateResult Node;
};

// Size: 0x4e0
class UAnimGraphNode_Trail : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_Trail Node;
};

// Size: 0x268
class UAnimGraphNode_TransitionPoseEvaluator : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_TransitionPoseEvaluator Node;
};

// Size: 0x198
class UAnimGraphNode_TransitionResult : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_TransitionResult Node;
};

// Size: 0x310
class UAnimGraphNode_TwistCorrectiveNode : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_TwistCorrectiveNode Node;
};

// Size: 0x4b0
class UAnimGraphNode_TwoBoneIK : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_TwoBoneIK Node;
    /* 0x0420 */ bool bEnableDebugDraw;
};

// Size: 0x248
class UAnimGraphNode_TwoWayBlend : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_TwoWayBlend BlendNode;
};

// Size: 0x1c0
class UAnimGraphNode_UseCachedPose : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_UseCachedPose Node;
    /* 0x01a8 */ TWeakObjectPtr<UAnimGraphNode_SaveCachedPose> SaveCachedPoseNode;
    /* 0x01b0 */ FString NameOfCache;
};

// Size: 0x300
class UAnimPreviewAttacheInstance : public UAnimInstance {
};

// Size: 0x9f0
struct FAnimPreviewAttacheInstanceProxy : public FAnimInstanceProxy {
};

// Size: 0x320
class UAnimPreviewInstance : public UAnimSingleNodeInstance {
    /* 0x0318 */ uint8_t MontagePreviewType;
    /* 0x031c */ int32_t MontagePreviewStartSectionIdx;
};

// Size: 0xc90
struct FAnimPreviewInstanceProxy : public FAnimSingleNodeInstanceProxy {
};

// Size: 0xd0
class UAnimStateConduitNode : public UAnimStateNodeBase {
    /* 0x00c8 */ UEdGraph* BoundGraph;
};

// Size: 0xc8
class UAnimStateEntryNode : public UEdGraphNode {
};

// Size: 0x380
class UAnimStateNode : public UAnimStateNodeBase {
    /* 0x00c8 */ UEdGraph* BoundGraph;
    /* 0x00d0 */ uint8_t StateType;
    /* 0x00d8 */ FAnimNotifyEvent StateEntered;
    /* 0x01b8 */ FAnimNotifyEvent StateLeft;
    /* 0x0298 */ FAnimNotifyEvent StateFullyBlended;
    /* 0x0378 */ bool bAlwaysResetOnEntry;
};

// Size: 0xc8
class UAnimStateNodeBase : public UEdGraphNode {
};

// Size: 0x400
class UAnimStateTransitionNode : public UAnimStateNodeBase {
    /* 0x00c8 */ UEdGraph* BoundGraph;
    /* 0x00d0 */ UEdGraph* CustomTransitionGraph;
    /* 0x00d8 */ int32_t PriorityOrder;
    /* 0x00dc */ float CrossfadeDuration;
    /* 0x00e0 */ uint8_t CrossfadeMode;
    /* 0x00e1 */ EAlphaBlendOption BlendMode;
    /* 0x00e8 */ UCurveFloat* CustomBlendCurve;
    /* 0x00f0 */ UBlendProfile* BlendProfile;
    /* 0x00f8 */ bool bAutomaticRuleBasedOnSequencePlayerInState;
    /* 0x00f9 */ uint8_t LogicType;
    /* 0x0100 */ FAnimNotifyEvent TransitionStart;
    /* 0x01e0 */ FAnimNotifyEvent TransitionEnd;
    /* 0x02c0 */ FAnimNotifyEvent TransitionInterrupt;
    /* 0x03a0 */ bool Bidirectional;
    /* 0x03a1 */ bool bSharedRules;
    /* 0x03a2 */ bool bSharedCrossfade;
    /* 0x03a8 */ FString SharedRulesName;
    /* 0x03b8 */ FGuid SharedRulesGuid;
    /* 0x03c8 */ FLinearColor SharedColor;
    /* 0x03d8 */ FString SharedCrossfadeName;
    /* 0x03e8 */ FGuid SharedCrossfadeGuid;
    /* 0x03f8 */ int32_t SharedCrossfadeIdx;
};

// Size: 0x40
class UAnimationConduitGraphSchema : public UEdGraphSchema_K2 {
};

// Size: 0xd8
class UAnimationCustomTransitionGraph : public UAnimationGraph {
    /* 0x00d0 */ UAnimGraphNode_CustomTransitionResult* MyResultNode;
};

// Size: 0xa8
class UAnimationCustomTransitionSchema : public UAnimationGraphSchema {
};

// Size: 0xd0
class UAnimationGraph : public UEdGraph {
    /* 0x00c8 */ FAnimGraphBlendOptions BlendOptions;
};

// Size: 0xa8
class UAnimationGraphSchema : public UEdGraphSchema_K2 {
    /* 0x0040 */ FString PN_SequenceName;
    /* 0x0050 */ FName NAME_NeverAsPin;
    /* 0x005c */ FName NAME_PinHiddenByDefault;
    /* 0x0068 */ FName NAME_PinShownByDefault;
    /* 0x0074 */ FName NAME_AlwaysAsPin;
    /* 0x0080 */ FName NAME_CustomizeProperty;
    /* 0x008c */ FName NAME_OnEvaluate;
    /* 0x0098 */ FName DefaultEvaluationHandlerName;
};

// Size: 0xd8
class UAnimationStateGraph : public UAnimationGraph {
    /* 0x00d0 */ UAnimGraphNode_StateResult* MyResultNode;
};

// Size: 0xa8
class UAnimationStateGraphSchema : public UAnimationGraphSchema {
};

// Size: 0xc0
class UAnimationStateMachineGraph : public UEdGraph {
    /* 0x00b0 */ UAnimStateEntryNode* EntryNode;
    /* 0x00b8 */ UAnimGraphNode_StateMachineBase* OwnerAnimGraphNode;
};

// Size: 0x30
class UAnimationStateMachineSchema : public UEdGraphSchema {
};

// Size: 0xd8
class UAnimationTransitionGraph : public UAnimationGraph {
    /* 0x00d0 */ UAnimGraphNode_TransitionResult* MyResultNode;
};

// Size: 0x40
class UAnimationTransitionSchema : public UEdGraphSchema_K2 {
};

// Size: 0x30
class IClassVariableCreator : public UInterface {
};

enum class EAnimGraphNodePropertyBindingType {
    None = 0,
    Property = 1,
    Function = 2,
    EAnimGraphNodePropertyBindingType_MAX = 3,
};

enum class EAnimStateType {
    AST_SingleAnimation = 0,
    AST_BlendGraph = 1,
    AST_MAX = 2,
};

enum class EBlueprintUsage {
    NoProperties = 0,
    DoesNotUseBlueprint = 1,
    UsesBlueprint = 2,
    EBlueprintUsage_MAX = 3,
};

enum class EMontagePreviewType {
    EMPT_Normal = 0,
    EMPT_AllSections = 1,
    EMPT_MAX = 2,
};

enum class ETransitionGetter {
    AnimationAsset_GetCurrentTime = 0,
    AnimationAsset_GetLength = 1,
    AnimationAsset_GetCurrentTimeFraction = 2,
    AnimationAsset_GetTimeFromEnd = 3,
    AnimationAsset_GetTimeFromEndFraction = 4,
    CurrentState_ElapsedTime = 5,
    CurrentState_GetBlendWeight = 6,
    CurrentTransitionDuration = 7,
    ArbitraryState_GetBlendWeight = 8,
    ETransitionGetter_MAX = 9,
};

// Size: 0x100
struct FEdGraphSchemaAction_NewStateComment : public FEdGraphSchemaAction {
};

// Size: 0x108
struct FEdGraphSchemaAction_NewStateNode : public FEdGraphSchemaAction {
};

// Size: 0x1a0
class UK2Node_AnimGetter : public UK2Node_CallFunction {
    /* 0x0158 */ UAnimGraphNode_Base* SourceNode;
    /* 0x0160 */ UAnimStateNodeBase* SourceStateNode;
    /* 0x0168 */ UClass* GetterClass;
    /* 0x0170 */ UAnimBlueprint* SourceAnimBlueprint;
    /* 0x0178 */ FText CachedTitle;
    /* 0x0190 */ TArray<FString> Contexts;
};

// Size: 0xf8
class UK2Node_PlayMontage : public UK2Node_BaseAsyncTask {
};

// Size: 0xe0
class UK2Node_TransitionRuleGetter : public UK2Node {
    /* 0x00c8 */ uint8_t GetterType;
    /* 0x00d0 */ UAnimGraphNode_Base* AssociatedAnimAssetPlayerNode;
    /* 0x00d8 */ UAnimStateNode* AssociatedStateNode;
};

// Size: 0x50
struct FNodeSpawnData {
    /* 0x0000 */ FText CachedTitle;
    /* 0x0018 */ UAnimGraphNode_Base* SourceNode;
    /* 0x0020 */ UAnimStateNodeBase* SourceStateNode;
    /* 0x0028 */ UClass* AnimInstanceClass;
    /* 0x0030 */ UAnimBlueprint* SourceBlueprint;
    /* 0x0038 */ UField* Getter;
    /* 0x0040 */ FString GetterContextString;
};

// Size: 0x2c
struct FAngularRangeLimit {
    /* 0x0000 */ FVector LimitMin;
    /* 0x000c */ FVector LimitMax;
    /* 0x0018 */ FBoneReference Bone;
};

// Size: 0xa0
struct FAnimLegIKData {
};

// Size: 0x34
struct FAnimLegIKDefinition {
    /* 0x0000 */ FBoneReference IKFootBone;
    /* 0x0014 */ FBoneReference FKFootBone;
    /* 0x0028 */ int32_t NumBonesInLimb;
    /* 0x002c */ float MinRotationAngle;
    /* 0x0030 */ uint8_t FootBoneForwardAxis;
    /* 0x0031 */ uint8_t HingeRotationAxis;
    /* 0x0032 */ bool bEnableRotationLimit;
    /* 0x0033 */ bool bEnableKneeTwistCorrection;
};

// Size: 0x1d0
struct FAnimNode_AimOffsetLookAt : public FAnimNode_BlendSpacePlayer {
    /* 0x0150 */ FPoseLink BasePose;
    /* 0x0168 */ int32_t LODThreshold;
    /* 0x016c */ FName SourceSocketName;
    /* 0x0178 */ FName PivotSocketName;
    /* 0x0184 */ FVector LookAtLocation;
    /* 0x0190 */ FVector SocketAxis;
    /* 0x019c */ float Alpha;
};

// Size: 0x4c0
struct FAnimNode_AnimDynamics : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ float LinearDampingOverride;
    /* 0x0124 */ float AngularDampingOverride;
    /* 0x0190 */ FBoneReference RelativeSpaceBone;
    /* 0x01a4 */ FBoneReference BoundBone;
    /* 0x01b8 */ FBoneReference ChainEnd;
    /* 0x01cc */ FVector BoxExtents;
    /* 0x01d8 */ FVector LocalJointOffset;
    /* 0x01e4 */ float GravityScale;
    /* 0x01e8 */ FVector GravityOverride;
    /* 0x01f4 */ float LinearSpringConstant;
    /* 0x01f8 */ float AngularSpringConstant;
    /* 0x01fc */ float WindScale;
    /* 0x0200 */ FVector ComponentLinearAccScale;
    /* 0x020c */ FVector ComponentLinearVelScale;
    /* 0x0218 */ FVector ComponentAppliedLinearAccClamp;
    /* 0x0224 */ float AngularBiasOverride;
    /* 0x0228 */ int32_t NumSolverIterationsPreUpdate;
    /* 0x022c */ int32_t NumSolverIterationsPostUpdate;
    /* 0x0230 */ FAnimPhysConstraintSetup ConstraintSetup;
    /* 0x0288 */ TArray<FAnimPhysSphericalLimit> SphericalLimits;
    /* 0x0298 */ float SphereCollisionRadius;
    /* 0x029c */ FVector ExternalForce;
    /* 0x02a8 */ TArray<FAnimPhysPlanarLimit> PlanarLimits;
    /* 0x02b8 */ AnimPhysCollisionType CollisionType;
    /* 0x02b9 */ AnimPhysSimSpaceType SimulationSpace;
    /* 0x02bc */ bool bUseSphericalLimits;
    /* 0x02bc */ bool bUsePlanarLimit;
    /* 0x02bc */ bool bDoUpdate;
    /* 0x02bc */ bool bDoEval;
    /* 0x02bc */ bool bOverrideLinearDamping;
    /* 0x02bc */ bool bOverrideAngularBias;
    /* 0x02bc */ bool bOverrideAngularDamping;
    /* 0x02bc */ bool bEnableWind;
    /* 0x02bd */ bool bUseGravityOverride;
    /* 0x02bd */ bool bLinearSpring;
    /* 0x02bd */ bool bAngularSpring;
    /* 0x02bd */ bool bChain;
    /* 0x02c0 */ FRotationRetargetingInfo RetargetingSettings;
};

// Size: 0xe0
struct FAnimNode_ApplyAdditive : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink Base;
    /* 0x0028 */ FPoseLink Additive;
    /* 0x0040 */ float Alpha;
    /* 0x0044 */ FInputScaleBias AlphaScaleBias;
    /* 0x004c */ int32_t LODThreshold;
    /* 0x0050 */ FInputAlphaBoolBlend AlphaBoolBlend;
    /* 0x0098 */ FName AlphaCurveName;
    /* 0x00a4 */ FInputScaleBiasClamp AlphaScaleBiasClamp;
    /* 0x00d8 */ EAnimAlphaInputType AlphaInputType;
    /* 0x00d9 */ bool bAlphaBoolEnabled;
};

// Size: 0x140
struct FAnimNode_ApplyLimits : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ TArray<FAngularRangeLimit> AngularRangeLimits;
    /* 0x0130 */ TArray<FVector> AngularOffsets;
};

// Size: 0x78
struct FAnimNode_BlendBoneByChannel : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink A;
    /* 0x0028 */ FPoseLink B;
    /* 0x0040 */ TArray<FBlendBoneByChannelEntry> BoneDefinitions;
    /* 0x0060 */ float Alpha;
    /* 0x0068 */ FInputScaleBias AlphaScaleBias;
    /* 0x0070 */ uint8_t TransformsSpace;
};

// Size: 0x98
struct FAnimNode_BlendListBase : public FAnimNode_Base {
    /* 0x0010 */ TArray<FPoseLink> BlendPose;
    /* 0x0020 */ TArray<float> BlendTime;
    /* 0x0030 */ EBlendListTransitionType TransitionType;
    /* 0x0031 */ EAlphaBlendOption BlendType;
    /* 0x0032 */ bool bResetChildOnActivation;
    /* 0x0038 */ UCurveFloat* CustomBlendCurve;
    /* 0x0040 */ UBlendProfile* BlendProfile;
};

// Size: 0xa0
struct FAnimNode_BlendListByBool : public FAnimNode_BlendListBase {
    /* 0x0098 */ bool bActiveValue;
};

// Size: 0xb0
struct FAnimNode_BlendListByEnum : public FAnimNode_BlendListBase {
    /* 0x0098 */ TArray<int32_t> EnumToPoseIndex;
    /* 0x00a8 */ uint8_t ActiveEnumValue;
};

// Size: 0xa0
struct FAnimNode_BlendListByInt : public FAnimNode_BlendListBase {
    /* 0x0098 */ int32_t ActiveChildIndex;
};

// Size: 0xf8
struct FAnimNode_BlendSpaceEvaluator : public FAnimNode_BlendSpacePlayer {
    /* 0x00f0 */ float NormalizedTime;
};

// Size: 0xf0
struct FAnimNode_BlendSpacePlayer : public FAnimNode_AssetPlayerBase {
    /* 0x0040 */ float X;
    /* 0x0044 */ float Y;
    /* 0x0048 */ float Z;
    /* 0x004c */ float PlayRate;
    /* 0x0050 */ bool bLoop;
    /* 0x0051 */ bool bResetPlayTimeWhenBlendSpaceChanges;
    /* 0x0054 */ float StartPosition;
    /* 0x0058 */ UBlendSpaceBase* BlendSpace;
    /* 0x00e8 */ UBlendSpaceBase* PreviousBlendSpace;
};

// Size: 0x180
struct FAnimNode_BoneDrivenController : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference SourceBone;
    /* 0x0138 */ UCurveFloat* DrivingCurve;
    /* 0x0140 */ float Multiplier;
    /* 0x0144 */ float RangeMin;
    /* 0x0148 */ float RangeMax;
    /* 0x014c */ float RemappedMin;
    /* 0x0150 */ float RemappedMax;
    /* 0x0154 */ FName ParameterName;
    /* 0x0160 */ FBoneReference TargetBone;
    /* 0x0174 */ uint8_t TargetComponent;
    /* 0x0175 */ EDrivenDestinationMode DestinationMode;
    /* 0x0176 */ EDrivenBoneModificationMode ModificationMode;
    /* 0x0177 */ uint8_t SourceComponent;
    /* 0x0178 */ bool bUseRange;
    /* 0x0178 */ bool bAffectTargetTranslationX;
    /* 0x0178 */ bool bAffectTargetTranslationY;
    /* 0x0178 */ bool bAffectTargetTranslationZ;
    /* 0x0178 */ bool bAffectTargetRotationX;
    /* 0x0178 */ bool bAffectTargetRotationY;
    /* 0x0178 */ bool bAffectTargetRotationZ;
    /* 0x0178 */ bool bAffectTargetScaleX;
    /* 0x0179 */ bool bAffectTargetScaleY;
    /* 0x0179 */ bool bAffectTargetScaleZ;
};

// Size: 0x200
struct FAnimNode_CCDIK : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FVector EffectorLocation;
    /* 0x012c */ uint8_t EffectorLocationSpace;
    /* 0x0130 */ FBoneSocketTarget EffectorTarget;
    /* 0x01a0 */ FBoneReference TipBone;
    /* 0x01b4 */ FBoneReference RootBone;
    /* 0x01c8 */ float Precision;
    /* 0x01cc */ int32_t MaxIterations;
    /* 0x01d0 */ bool bStartFromTail;
    /* 0x01d1 */ bool bEnableRotationLimit;
    /* 0x01d8 */ TArray<float> RotationLimitPerJoints;
};

// Size: 0x1e0
struct FAnimNode_Constraint : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference BoneToModify;
    /* 0x0138 */ TArray<FConstraint> ConstraintSetup;
    /* 0x0148 */ TArray<float> ConstraintWeights;
};

// Size: 0x150
struct FAnimNode_CopyBone : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference SourceBone;
    /* 0x0134 */ FBoneReference TargetBone;
    /* 0x0148 */ bool bCopyTranslation;
    /* 0x0149 */ bool bCopyRotation;
    /* 0x014a */ bool bCopyScale;
    /* 0x014b */ uint8_t ControlSpace;
};

// Size: 0x158
struct FAnimNode_CopyBoneDelta : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference SourceBone;
    /* 0x0134 */ FBoneReference TargetBone;
    /* 0x0148 */ bool bCopyTranslation;
    /* 0x0149 */ bool bCopyRotation;
    /* 0x014a */ bool bCopyScale;
    /* 0x014b */ CopyBoneDeltaMode CopyMode;
    /* 0x014c */ float TranslationMultiplier;
    /* 0x0150 */ float RotationMultiplier;
    /* 0x0154 */ float ScaleMultiplier;
};

// Size: 0x1d8
struct FAnimNode_CopyPoseFromMesh : public FAnimNode_Base {
    /* 0x0010 */ TWeakObjectPtr<USkeletalMeshComponent> SourceMeshComponent;
    /* 0x0018 */ bool bUseAttachedParent;
    /* 0x0018 */ bool bCopyCurves;
    /* 0x0019 */ bool bCopyCustomAttributes;
    /* 0x001a */ bool bUseMeshPose;
    /* 0x001c */ FName RootBoneToCopy;
};

// Size: 0x48
struct FAnimNode_CurveSource : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink SourcePose;
    /* 0x0028 */ FName SourceBinding;
    /* 0x0034 */ float Alpha;
    /* 0x0038 */ TScriptInterface<ICurveSourceInterface> CurveSource;
};

// Size: 0x240
struct FAnimNode_Fabrik : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FTransform EffectorTransform;
    /* 0x0150 */ FBoneSocketTarget EffectorTarget;
    /* 0x01c0 */ FBoneReference TipBone;
    /* 0x01d4 */ FBoneReference RootBone;
    /* 0x01e8 */ float Precision;
    /* 0x01ec */ int32_t MaxIterations;
    /* 0x01f0 */ uint8_t EffectorTransformSpace;
    /* 0x01f1 */ uint8_t EffectorRotationSource;
    /* 0x01f2 */ bool bEnableDebugDraw;
    /* 0x01f4 */ FBoneReference EffectorTransformBone;
};

// Size: 0x188
struct FAnimNode_HandIKRetargeting : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference RightHandFK;
    /* 0x0134 */ FBoneReference LeftHandFK;
    /* 0x0148 */ FBoneReference RightHandIK;
    /* 0x015c */ FBoneReference LeftHandIK;
    /* 0x0170 */ TArray<FBoneReference> IKBonesToMove;
    /* 0x0180 */ float HandFKWeight;
};

// Size: 0xc8
struct FAnimNode_LayeredBoneBlend : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink BasePose;
    /* 0x0028 */ TArray<FPoseLink> BlendPoses;
    /* 0x0038 */ TArray<FInputBlendPose> LayerSetup;
    /* 0x0048 */ TArray<float> BlendWeights;
    /* 0x0058 */ bool bMeshSpaceRotationBlend;
    /* 0x0059 */ bool bMeshSpaceScaleBlend;
    /* 0x005a */ uint8_t CurveBlendOption;
    /* 0x005b */ bool bBlendRootMotionBasedOnRootBone;
    /* 0x0060 */ int32_t LODThreshold;
    /* 0x0068 */ TArray<FPerBoneBlendWeight> PerBoneBlendWeights;
    /* 0x0078 */ FGuid SkeletonGuid;
    /* 0x0088 */ FGuid VirtualBoneGuid;
};

// Size: 0x150
struct FAnimNode_LegIK : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ float ReachPrecision;
    /* 0x0124 */ int32_t MaxIterations;
    /* 0x0128 */ TArray<FAnimLegIKDefinition> LegsDefinition;
};

// Size: 0x320
struct FAnimNode_LookAt : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference BoneToModify;
    /* 0x0140 */ FBoneSocketTarget LookAtTarget;
    /* 0x01b0 */ FVector LookAtLocation;
    /* 0x01bc */ FAxis LookAt_Axis;
    /* 0x01cc */ bool bUseLookUpAxis;
    /* 0x01cd */ uint8_t InterpolationType;
    /* 0x01d0 */ FAxis LookUp_Axis;
    /* 0x01e0 */ float LookAtClamp;
    /* 0x01e4 */ float InterpolationTime;
    /* 0x01e8 */ float InterpolationTriggerThreashold;
    /* 0x01ec */ FBoneReference LookAtBone;
    /* 0x0200 */ FName LookAtSocket;
    /* 0x020c */ uint8_t LookAtAxis;
    /* 0x0210 */ FVector CustomLookAtAxis;
    /* 0x021c */ uint8_t LookUpAxis;
    /* 0x0220 */ FVector CustomLookUpAxis;
};

// Size: 0x48
struct FAnimNode_MakeDynamicAdditive : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink Base;
    /* 0x0028 */ FPoseLink Additive;
    /* 0x0040 */ bool bMeshSpaceAdditive;
};

// Size: 0x10
struct FAnimNode_MeshSpaceRefPose : public FAnimNode_Base {
};

// Size: 0x160
struct FAnimNode_ModifyBone : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference BoneToModify;
    /* 0x0134 */ FVector Translation;
    /* 0x0140 */ FRotator Rotation;
    /* 0x014c */ FVector Scale;
    /* 0x0158 */ uint8_t TranslationMode;
    /* 0x0159 */ uint8_t RotationMode;
    /* 0x015a */ uint8_t ScaleMode;
    /* 0x015b */ uint8_t TranslationSpace;
    /* 0x015c */ uint8_t RotationSpace;
    /* 0x015d */ uint8_t ScaleSpace;
};

// Size: 0x60
struct FAnimNode_ModifyCurve : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink SourcePose;
    /* 0x0028 */ TArray<float> CurveValues;
    /* 0x0038 */ TArray<FName> CurveNames;
    /* 0x0058 */ float Alpha;
    /* 0x005c */ EModifyCurveApplyMode ApplyMode;
};

// Size: 0x50
struct FAnimNode_MultiWayBlend : public FAnimNode_Base {
    /* 0x0010 */ TArray<FPoseLink> Poses;
    /* 0x0020 */ TArray<float> DesiredAlphas;
    /* 0x0040 */ FInputScaleBias AlphaScaleBias;
    /* 0x0048 */ bool bAdditiveNode;
    /* 0x0049 */ bool bNormalizeAlpha;
};

// Size: 0x160
struct FAnimNode_ObserveBone : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference BoneToObserve;
    /* 0x0134 */ uint8_t DisplaySpace;
    /* 0x0135 */ bool bRelativeToRefPose;
    /* 0x0138 */ FVector Translation;
    /* 0x0144 */ FRotator Rotation;
    /* 0x0150 */ FVector Scale;
};

// Size: 0xb0
struct FAnimNode_PoseBlendNode : public FAnimNode_PoseHandler {
    /* 0x0088 */ FPoseLink SourcePose;
    /* 0x00a0 */ EAlphaBlendOption BlendOption;
    /* 0x00a8 */ UCurveFloat* CustomCurve;
};

// Size: 0xa8
struct FAnimNode_PoseByName : public FAnimNode_PoseHandler {
    /* 0x0088 */ FName PoseName;
    /* 0x0094 */ float PoseWeight;
};

// Size: 0x1a0
struct FAnimNode_PoseDriver : public FAnimNode_PoseHandler {
    /* 0x0088 */ FPoseLink SourcePose;
    /* 0x00a0 */ TArray<FBoneReference> SourceBones;
    /* 0x00b0 */ TArray<FBoneReference> OnlyDriveBones;
    /* 0x00c0 */ TArray<FPoseDriverTarget> PoseTargets;
    /* 0x0100 */ FBoneReference EvalSpaceBone;
    /* 0x0114 */ FRBFParams RBFParams;
    /* 0x0140 */ FBoneReference SourceBone;
    /* 0x0154 */ uint8_t TwistAxis;
    /* 0x0155 */ EPoseDriverType Type;
    /* 0x0158 */ float RadialScaling;
    /* 0x015c */ EPoseDriverSource DriveSource;
    /* 0x015d */ EPoseDriverOutput DriveOutput;
    /* 0x015e */ bool bOnlyDriveSelectedBones;
    /* 0x0164 */ bool bSoloDrivenOnly;
    /* 0x0168 */ int32_t LODThreshold;
};

// Size: 0x88
struct FAnimNode_PoseHandler : public FAnimNode_AssetPlayerBase {
    /* 0x0040 */ UPoseAsset* PoseAsset;
};

// Size: 0xb0
struct FAnimNode_PoseSnapshot : public FAnimNode_Base {
    /* 0x0010 */ FName SnapshotName;
    /* 0x0020 */ FPoseSnapshot Snapshot;
    /* 0x0060 */ ESnapshotSourceMode Mode;
};

// Size: 0x78
struct FAnimNode_RandomPlayer : public FAnimNode_Base {
    /* 0x0010 */ TArray<FRandomPlayerSequenceEntry> Entries;
    /* 0x0070 */ bool bShuffleMode;
};

// Size: 0x18
struct FAnimNode_RefPose : public FAnimNode_Base {
    /* 0x0010 */ uint8_t RefPoseType;
};

// Size: 0x130
struct FAnimNode_ResetRoot : public FAnimNode_SkeletalControlBase {
};

// Size: 0x8b0
struct FAnimNode_RigidBody : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ UPhysicsAsset* OverridePhysicsAsset;
    /* 0x01c8 */ FVector OverrideWorldGravity;
    /* 0x01d4 */ FVector ExternalForce;
    /* 0x01e0 */ FVector ComponentLinearAccScale;
    /* 0x01ec */ FVector ComponentLinearVelScale;
    /* 0x01f8 */ FVector ComponentAppliedLinearAccClamp;
    /* 0x0204 */ FSimSpaceSettings SimSpaceSettings;
    /* 0x0244 */ float CachedBoundsScale;
    /* 0x0248 */ FBoneReference BaseBoneRef;
    /* 0x025c */ uint8_t OverlapChannel;
    /* 0x025d */ ESimulationSpace SimulationSpace;
    /* 0x025e */ bool bForceDisableCollisionBetweenConstraintBodies;
    /* 0x0260 */ bool bEnableWorldGeometry;
    /* 0x0260 */ bool bOverrideWorldGravity;
    /* 0x0260 */ bool bTransferBoneVelocities;
    /* 0x0260 */ bool bFreezeIncomingPoseOnStart;
    /* 0x0260 */ bool bClampLinearTranslationLimitToRefPose;
    /* 0x0264 */ float WorldSpaceMinimumScale;
    /* 0x0268 */ float EvaluationResetTime;
    /* 0x026d */ bool bComponentSpaceSimulation;
};

// Size: 0xa8
struct FAnimNode_RotateRootBone : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink BasePose;
    /* 0x0028 */ float Pitch;
    /* 0x002c */ float Yaw;
    /* 0x0030 */ FInputScaleBiasClamp PitchScaleBiasClamp;
    /* 0x0060 */ FInputScaleBiasClamp YawScaleBiasClamp;
    /* 0x0090 */ FRotator MeshToComponent;
};

// Size: 0x150
struct FAnimNode_RotationMultiplier : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference TargetBone;
    /* 0x0134 */ FBoneReference SourceBone;
    /* 0x0148 */ float Multiplier;
    /* 0x014c */ uint8_t RotationAxisToRefer;
    /* 0x014d */ bool bIsAdditive;
};

// Size: 0x1a8
struct FAnimNode_RotationOffsetBlendSpace : public FAnimNode_BlendSpacePlayer {
    /* 0x00f0 */ FPoseLink BasePose;
    /* 0x0108 */ int32_t LODThreshold;
    /* 0x010c */ float Alpha;
    /* 0x0110 */ FInputScaleBias AlphaScaleBias;
    /* 0x0118 */ FInputAlphaBoolBlend AlphaBoolBlend;
    /* 0x0160 */ FName AlphaCurveName;
    /* 0x016c */ FInputScaleBiasClamp AlphaScaleBiasClamp;
    /* 0x01a0 */ EAnimAlphaInputType AlphaInputType;
    /* 0x01a1 */ bool bAlphaBoolEnabled;
};

// Size: 0x88
struct FAnimNode_ScaleChainLength : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink InputPose;
    /* 0x0028 */ float DefaultChainLength;
    /* 0x002c */ FBoneReference ChainStartBone;
    /* 0x0040 */ FBoneReference ChainEndBone;
    /* 0x0054 */ FVector TargetLocation;
    /* 0x0060 */ float Alpha;
    /* 0x0068 */ FInputScaleBias AlphaScaleBias;
    /* 0x0070 */ EScaleChainInitialLength ChainInitialLength;
};

// Size: 0x58
struct FAnimNode_SequenceEvaluator : public FAnimNode_AssetPlayerBase {
    /* 0x0040 */ UAnimSequenceBase* Sequence;
    /* 0x0048 */ float ExplicitTime;
    /* 0x004c */ bool bShouldLoop;
    /* 0x004d */ bool bTeleportToExplicitTime;
    /* 0x004e */ uint8_t ReinitializationBehavior;
    /* 0x0050 */ float StartPosition;
};

// Size: 0x120
struct FAnimNode_SkeletalControlBase : public FAnimNode_Base {
    /* 0x0010 */ FComponentSpacePoseLink ComponentPose;
    /* 0x0028 */ int32_t LODThreshold;
    /* 0x002c */ float ActualAlpha;
    /* 0x0030 */ EAnimAlphaInputType AlphaInputType;
    /* 0x0031 */ bool bAlphaBoolEnabled;
    /* 0x0034 */ float Alpha;
    /* 0x0038 */ FInputScaleBias AlphaScaleBias;
    /* 0x0040 */ FInputAlphaBoolBlend AlphaBoolBlend;
    /* 0x0088 */ FName AlphaCurveName;
    /* 0x0094 */ FInputScaleBiasClamp AlphaScaleBiasClamp;
};

// Size: 0x58
struct FAnimNode_Slot : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink Source;
    /* 0x0028 */ FName SlotName;
    /* 0x0034 */ bool bAlwaysUpdateSourcePose;
};

// Size: 0x2d0
struct FAnimNode_SplineIK : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference StartBone;
    /* 0x0134 */ FBoneReference EndBone;
    /* 0x0148 */ ESplineBoneAxis BoneAxis;
    /* 0x0149 */ bool bAutoCalculateSpline;
    /* 0x014c */ int32_t PointCount;
    /* 0x0150 */ TArray<FTransform> ControlPoints;
    /* 0x0160 */ float Roll;
    /* 0x0164 */ float TwistStart;
    /* 0x0168 */ float TwistEnd;
    /* 0x0170 */ FAlphaBlend TwistBlend;
    /* 0x01a0 */ float Stretch;
    /* 0x01a4 */ float Offset;
};

// Size: 0x188
struct FAnimNode_SpringBone : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference SpringBone;
    /* 0x0134 */ float MaxDisplacement;
    /* 0x0138 */ float SpringStiffness;
    /* 0x013c */ float SpringDamping;
    /* 0x0140 */ float ErrorResetThresh;
    /* 0x0180 */ bool bNoZSpring;
    /* 0x0181 */ bool bLimitDisplacement;
    /* 0x0181 */ bool bTranslateX;
    /* 0x0181 */ bool bTranslateY;
    /* 0x0181 */ bool bTranslateZ;
    /* 0x0181 */ bool bRotateX;
    /* 0x0181 */ bool bRotateY;
    /* 0x0181 */ bool bRotateZ;
};

// Size: 0x40
struct FAnimNode_StateResult : public FAnimNode_Root {
};

// Size: 0x2f0
struct FAnimNode_Trail : public FAnimNode_SkeletalControlBase {
    /* 0x0150 */ FBoneReference TrailBone;
    /* 0x0164 */ int32_t ChainLength;
    /* 0x0168 */ uint8_t ChainBoneAxis;
    /* 0x0169 */ bool bInvertChainBoneAxis;
    /* 0x0169 */ bool bLimitStretch;
    /* 0x0169 */ bool bLimitRotation;
    /* 0x0169 */ bool bUsePlanarLimit;
    /* 0x0169 */ bool bActorSpaceFakeVel;
    /* 0x0169 */ bool bReorientParentToChild;
    /* 0x0169 */ bool bEnableDebug;
    /* 0x016a */ bool bShowBaseMotion;
    /* 0x016a */ bool bShowTrailLocation;
    /* 0x016a */ bool bShowLimit;
    /* 0x016c */ float DebugLifeTime;
    /* 0x0170 */ float TrailRelaxation;
    /* 0x0174 */ float MaxDeltaTime;
    /* 0x0178 */ float RelaxationSpeedScale;
    /* 0x0180 */ FRuntimeFloatCurve TrailRelaxationSpeed;
    /* 0x0208 */ FInputScaleBiasClamp RelaxationSpeedScaleInputProcessor;
    /* 0x0238 */ TArray<FRotationLimit> RotationLimits;
    /* 0x0248 */ TArray<FVector> RotationOffsets;
    /* 0x0258 */ TArray<FAnimPhysPlanarLimit> PlanarLimits;
    /* 0x0268 */ float StretchLimit;
    /* 0x026c */ FVector FakeVelocity;
    /* 0x0278 */ FBoneReference BaseJoint;
    /* 0x028c */ float TrailBoneRotationBlendAlpha;
    /* 0x0290 */ float LastBoneRotationAnimAlphaBlend;
};

// Size: 0x1a0
struct FAnimNode_TwistCorrectiveNode : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FReferenceBoneFrame BaseFrame;
    /* 0x0144 */ FReferenceBoneFrame TwistFrame;
    /* 0x0168 */ FAxis TwistPlaneNormalAxis;
    /* 0x0178 */ float RangeMax;
    /* 0x017c */ float RemappedMin;
    /* 0x0180 */ float RemappedMax;
    /* 0x0184 */ FAnimCurveParam Curve;
};

// Size: 0x2b0
struct FAnimNode_TwoBoneIK : public FAnimNode_SkeletalControlBase {
    /* 0x0120 */ FBoneReference IKBone;
    /* 0x0134 */ float StartStretchRatio;
    /* 0x0138 */ float MaxStretchScale;
    /* 0x013c */ FVector2D StretchLimits;
    /* 0x0144 */ bool bNoTwist;
    /* 0x0148 */ FName JointTargetSpaceBoneName;
    /* 0x0154 */ FName EffectorSpaceBoneName;
    /* 0x0160 */ FVector EffectorLocation;
    /* 0x0170 */ FBoneSocketTarget EffectorTarget;
    /* 0x01e0 */ FVector JointTargetLocation;
    /* 0x01f0 */ FBoneSocketTarget JointTarget;
    /* 0x0260 */ FAxis TwistAxis;
    /* 0x0270 */ uint8_t EffectorLocationSpace;
    /* 0x0271 */ uint8_t JointTargetLocationSpace;
    /* 0x0272 */ bool bAllowStretching;
    /* 0x0272 */ bool bTakeRotationFromEffectorSpace;
    /* 0x0272 */ bool bMaintainEffectorRelRot;
    /* 0x0272 */ bool bAllowTwist;
};

// Size: 0xd8
struct FAnimNode_TwoWayBlend : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink A;
    /* 0x0028 */ FPoseLink B;
    /* 0x0040 */ EAnimAlphaInputType AlphaInputType;
    /* 0x0041 */ bool bAlphaBoolEnabled;
    /* 0x0041 */ bool bResetChildOnActivation;
    /* 0x0044 */ float Alpha;
    /* 0x0048 */ FInputScaleBias AlphaScaleBias;
    /* 0x0050 */ FInputAlphaBoolBlend AlphaBoolBlend;
    /* 0x0098 */ FName AlphaCurveName;
    /* 0x00a4 */ FInputScaleBiasClamp AlphaScaleBiasClamp;
};

// Size: 0x50
class UAnimNotify_PlayMontageNotify : public UAnimNotify {
    /* 0x0040 */ FName NotifyName;
};

// Size: 0x48
class UAnimNotify_PlayMontageNotifyWindow : public UAnimNotifyState {
    /* 0x0038 */ FName NotifyName;
};

enum class AnimPhysAngularConstraintType {
    Angular = 0,
    Cone = 1,
    AnimPhysAngularConstraintType_MAX = 2,
};

// Size: 0x54
struct FAnimPhysConstraintSetup {
    /* 0x0000 */ AnimPhysLinearConstraintType LinearXLimitType;
    /* 0x0001 */ AnimPhysLinearConstraintType LinearYLimitType;
    /* 0x0002 */ AnimPhysLinearConstraintType LinearZLimitType;
    /* 0x0004 */ FVector LinearAxesMin;
    /* 0x0010 */ FVector LinearAxesMax;
    /* 0x001c */ AnimPhysAngularConstraintType AngularConstraintType;
    /* 0x001d */ AnimPhysTwistAxis TwistAxis;
    /* 0x001e */ AnimPhysTwistAxis AngularTargetAxis;
    /* 0x0020 */ float ConeAngle;
    /* 0x0024 */ float AngularXAngle;
    /* 0x0028 */ float AngularYAngle;
    /* 0x002c */ float AngularZAngle;
    /* 0x0030 */ FVector AngularLimitsMin;
    /* 0x003c */ FVector AngularLimitsMax;
    /* 0x0048 */ FVector AngularTarget;
};

enum class AnimPhysLinearConstraintType {
    Free = 0,
    Limited = 1,
    AnimPhysLinearConstraintType_MAX = 2,
};

// Size: 0x50
struct FAnimPhysPlanarLimit {
    /* 0x0000 */ FBoneReference DrivingBone;
    /* 0x0020 */ FTransform PlaneTransform;
};

enum class AnimPhysSimSpaceType {
    Component = 0,
    Actor = 1,
    World = 2,
    RootRelative = 3,
    BoneRelative = 4,
    AnimPhysSimSpaceType_MAX = 5,
};

// Size: 0x28
struct FAnimPhysSphericalLimit {
    /* 0x0000 */ FBoneReference DrivingBone;
    /* 0x0014 */ FVector SphereLocalOffset;
    /* 0x0020 */ float LimitRadius;
    /* 0x0024 */ ESphericalLimitType LimitType;
};

// Size: 0x300
class UAnimSequencerInstance : public UAnimInstance {
};

// Size: 0xae0
struct FAnimSequencerInstanceProxy : public FAnimInstanceProxy {
};

// Size: 0x2c
struct FBlendBoneByChannelEntry {
    /* 0x0000 */ FBoneReference SourceBone;
    /* 0x0014 */ FBoneReference TargetBone;
    /* 0x0028 */ bool bBlendTranslation;
    /* 0x0029 */ bool bBlendRotation;
    /* 0x002a */ bool bBlendScale;
};

// Size: 0x70
struct FBoneSocketTarget {
    /* 0x0000 */ bool bUseSocket;
    /* 0x0004 */ FBoneReference BoneReference;
    /* 0x0020 */ FSocketReference SocketReference;
};

// Size: 0x20
struct FConstraint {
    /* 0x0000 */ FBoneReference TargetBone;
    /* 0x0014 */ EConstraintOffsetOption OffsetOption;
    /* 0x0015 */ ETransformConstraintType TransformType;
    /* 0x0016 */ FFilterOptionPerAxis PerAxis;
};

enum class CopyBoneDeltaMode {
    Accumulate = 0,
    Copy = 1,
    CopyBoneDeltaMode_MAX = 2,
};

enum class EBlendListTransitionType {
    StandardBlend = 0,
    Inertialization = 1,
    EBlendListTransitionType_MAX = 2,
};

enum class EBoneModificationMode {
    BMM_Ignore = 0,
    BMM_Replace = 1,
    BMM_Additive = 2,
    BMM_MAX = 3,
};

enum class EConstraintOffsetOption {
    None = 0,
    Offset_RefPose = 1,
    EConstraintOffsetOption_MAX = 2,
};

enum class EDrivenBoneModificationMode {
    AddToInput = 0,
    ReplaceComponent = 1,
    AddToRefPose = 2,
    EDrivenBoneModificationMode_MAX = 3,
};

enum class EDrivenDestinationMode {
    Bone = 0,
    MorphTarget = 1,
    MaterialParameter = 2,
    EDrivenDestinationMode_MAX = 3,
};

enum class EEasingFuncType {
    Linear = 0,
    Sinusoidal = 1,
    Cubic = 2,
    QuadraticInOut = 3,
    CubicInOut = 4,
    HermiteCubic = 5,
    QuarticInOut = 6,
    QuinticInOut = 7,
    CircularIn = 8,
    CircularOut = 9,
    CircularInOut = 10,
    ExpIn = 11,
    ExpOut = 12,
    ExpInOut = 13,
    CustomCurve = 14,
    EEasingFuncType_MAX = 15,
};

enum class EInterpolationBlend {
    Linear = 0,
    Cubic = 1,
    Sinusoidal = 2,
    EaseInOutExponent2 = 3,
    EaseInOutExponent3 = 4,
    EaseInOutExponent4 = 5,
    EaseInOutExponent5 = 6,
    MAX = 7,
};

enum class EModifyCurveApplyMode {
    Add = 0,
    Scale = 1,
    Blend = 2,
    WeightedMovingAverage = 3,
    RemapCurve = 4,
    EModifyCurveApplyMode_MAX = 5,
};

enum class EPoseDriverOutput {
    DrivePoses = 0,
    DriveCurves = 1,
    EPoseDriverOutput_MAX = 2,
};

enum class EPoseDriverSource {
    Rotation = 0,
    Translation = 1,
    EPoseDriverSource_MAX = 2,
};

enum class EPoseDriverType {
    SwingAndTwist = 0,
    SwingOnly = 1,
    Translation = 2,
    EPoseDriverType_MAX = 3,
};

enum class ERBFDistanceMethod {
    Euclidean = 0,
    Quaternion = 1,
    SwingAngle = 2,
    TwistAngle = 3,
    DefaultMethod = 4,
    ERBFDistanceMethod_MAX = 5,
};

enum class ERBFFunctionType {
    Gaussian = 0,
    Exponential = 1,
    Linear = 2,
    Cubic = 3,
    Quintic = 4,
    DefaultFunction = 5,
    ERBFFunctionType_MAX = 6,
};

enum class ERBFNormalizeMethod {
    OnlyNormalizeAboveOne = 0,
    AlwaysNormalize = 1,
    NormalizeWithinMedian = 2,
    NoNormalization = 3,
    ERBFNormalizeMethod_MAX = 4,
};

enum class ERBFSolverType {
    Additive = 0,
    Interpolative = 1,
    ERBFSolverType_MAX = 2,
};

enum class ERefPoseType {
    EIT_LocalSpace = 0,
    EIT_Additive = 1,
    EIT_MAX = 2,
};

enum class ERotationComponent {
    EulerX = 0,
    EulerY = 1,
    EulerZ = 2,
    QuaternionAngle = 3,
    SwingAngle = 4,
    TwistAngle = 5,
    ERotationComponent_MAX = 6,
};

enum class EScaleChainInitialLength {
    FixedDefaultLengthValue = 0,
    Distance = 1,
    ChainLength = 2,
    EScaleChainInitialLength_MAX = 3,
};

enum class ESequenceEvalReinit {
    NoReset = 0,
    StartPosition = 1,
    ExplicitTime = 2,
    ESequenceEvalReinit_MAX = 3,
};

enum class ESimulationSpace {
    ComponentSpace = 0,
    WorldSpace = 1,
    BaseBoneSpace = 2,
    ESimulationSpace_MAX = 3,
};

enum class ESnapshotSourceMode {
    NamedSnapshot = 0,
    SnapshotPin = 1,
    ESnapshotSourceMode_MAX = 2,
};

enum class ESphericalLimitType {
    Inner = 0,
    Outer = 1,
    ESphericalLimitType_MAX = 2,
};

enum class ESplineBoneAxis {
    None = 0,
    X = 1,
    Y = 2,
    Z = 3,
    ESplineBoneAxis_MAX = 4,
};

// Size: 0x38
struct FIKChain {
};

// Size: 0x40
struct FIKChainLink {
};

// Size: 0x30
class UKismetAnimationLibrary : public UBlueprintFunctionLibrary {

    static float K2_CalculateVelocityFromPositionHistory(float DeltaSeconds, FVector Position, FPositionHistory& History, int32_t NumberOfSamples, float VelocityMin, float VelocityMax);
    static float K2_CalculateVelocityFromSockets(float DeltaSeconds, USkeletalMeshComponent* Component, const FName SocketOrBoneName, const FName ReferenceSocketOrBone, uint8_t SocketSpace, FVector OffsetInBoneSpace, FPositionHistory& History, int32_t NumberOfSamples, float VelocityMin, float VelocityMax, EEasingFuncType EasingType, const FRuntimeFloatCurve& CustomCurve);
    static FVector K2_DirectionBetweenSockets(const USkeletalMeshComponent* Component, const FName SocketOrBoneNameFrom, const FName SocketOrBoneNameTo);
    static float K2_DistanceBetweenTwoSocketsAndMapRange(const USkeletalMeshComponent* Component, const FName SocketOrBoneNameA, uint8_t SocketSpaceA, const FName SocketOrBoneNameB, uint8_t SocketSpaceB, bool bRemapRange, float InRangeMin, float InRangeMax, float OutRangeMin, float OutRangeMax);
    static float K2_EndProfilingTimer(bool bLog, FString LogPrefix);
    static FTransform K2_LookAt(const FTransform& CurrentTransform, const FVector& TargetPosition, FVector LookAtVector, bool bUseUpVector, FVector UpVector, float ClampConeInDegree);
    static float K2_MakePerlinNoiseAndRemap(float Value, float RangeOutMin, float RangeOutMax);
    static FVector K2_MakePerlinNoiseVectorAndRemap(float X, float Y, float Z, float RangeOutMinX, float RangeOutMaxX, float RangeOutMinY, float RangeOutMaxY, float RangeOutMinZ, float RangeOutMaxZ);
    static void K2_StartProfilingTimer();
    static void K2_TwoBoneIK(const FVector& RootPos, const FVector& JointPos, const FVector& EndPos, const FVector& JointTarget, const FVector& Effector, FVector& OutJointPos, FVector& OutEndPos, bool bAllowStretching, float StartStretchRatio, float MaxStretchScale);
};

// Size: 0xb0
class UPlayMontageCallbackProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnCompleted;
    /* 0x0040 */ FMulticastInlineDelegate OnBlendOut;
    /* 0x0050 */ FMulticastInlineDelegate OnInterrupted;
    /* 0x0060 */ FMulticastInlineDelegate OnNotifyBegin;
    /* 0x0070 */ FMulticastInlineDelegate OnNotifyEnd;

    static UPlayMontageCallbackProxy* CreateProxyObjectForPlayMontage(USkeletalMeshComponent* InSkeletalMeshComponent, UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, FName StartingSection);
    void OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted);
    void OnMontageEnded(UAnimMontage* Montage, bool bInterrupted);
    void OnNotifyBeginReceived(FName NotifyName, const FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
    void OnNotifyEndReceived(FName NotifyName, const FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
};

// Size: 0xc0
struct FPoseDriverTarget {
    /* 0x0000 */ TArray<FPoseDriverTransform> BoneTransforms;
    /* 0x0010 */ FRotator TargetRotation;
    /* 0x001c */ float TargetScale;
    /* 0x0020 */ ERBFDistanceMethod DistanceMethod;
    /* 0x0021 */ ERBFFunctionType FunctionType;
    /* 0x0022 */ bool bApplyCustomCurve;
    /* 0x0028 */ FRichCurve CustomCurve;
    /* 0x00a8 */ FName DrivenName;
    /* 0x00bc */ bool bIsHidden;
};

// Size: 0x18
struct FPoseDriverTransform {
    /* 0x0000 */ FVector TargetTranslation;
    /* 0x000c */ FRotator TargetRotation;
};

// Size: 0x30
struct FPositionHistory {
    /* 0x0000 */ TArray<FVector> Positions;
    /* 0x0010 */ float Range;
};

// Size: 0x10
struct FRBFEntry {
    /* 0x0000 */ TArray<float> Values;
};

// Size: 0x2c
struct FRBFParams {
    /* 0x0000 */ int32_t TargetDimensions;
    /* 0x0004 */ ERBFSolverType SolverType;
    /* 0x0008 */ float Radius;
    /* 0x000c */ bool bAutomaticRadius;
    /* 0x000d */ ERBFFunctionType Function;
    /* 0x000e */ ERBFDistanceMethod DistanceMethod;
    /* 0x000f */ uint8_t TwistAxis;
    /* 0x0010 */ float WeightThreshold;
    /* 0x0014 */ ERBFNormalizeMethod NormalizeMethod;
    /* 0x0018 */ FVector MedianReference;
    /* 0x0024 */ float MedianMin;
    /* 0x0028 */ float MedianMax;
};

// Size: 0xa0
struct FRBFTarget : public FRBFEntry {
    /* 0x0010 */ float ScaleFactor;
    /* 0x0014 */ bool bApplyCustomCurve;
    /* 0x0018 */ FRichCurve CustomCurve;
    /* 0x0098 */ ERBFDistanceMethod DistanceMethod;
    /* 0x0099 */ ERBFFunctionType FunctionType;
};

// Size: 0x50
struct FRandomPlayerSequenceEntry {
    /* 0x0000 */ UAnimSequence* Sequence;
    /* 0x0008 */ float ChanceToPlay;
    /* 0x000c */ int32_t MinLoopCount;
    /* 0x0010 */ int32_t MaxLoopCount;
    /* 0x0014 */ float MinPlayRate;
    /* 0x0018 */ float MaxPlayRate;
    /* 0x0020 */ FAlphaBlend BlendIn;
};

// Size: 0x24
struct FReferenceBoneFrame {
    /* 0x0000 */ FBoneReference Bone;
    /* 0x0014 */ FAxis Axis;
};

// Size: 0x18
struct FRotationLimit {
    /* 0x0000 */ FVector LimitMin;
    /* 0x000c */ FVector LimitMax;
};

// Size: 0x130
struct FRotationRetargetingInfo {
    /* 0x0000 */ bool bEnabled;
    /* 0x0010 */ FTransform Source;
    /* 0x0040 */ FTransform Target;
    /* 0x0070 */ ERotationComponent RotationComponent;
    /* 0x0074 */ FVector TwistAxis;
    /* 0x0080 */ bool bUseAbsoluteAngle;
    /* 0x0084 */ float SourceMinimum;
    /* 0x0088 */ float SourceMaximum;
    /* 0x008c */ float TargetMinimum;
    /* 0x0090 */ float TargetMaximum;
    /* 0x0094 */ EEasingFuncType EasingType;
    /* 0x0098 */ FRuntimeFloatCurve CustomCurve;
    /* 0x0120 */ bool bFlipEasing;
    /* 0x0124 */ float EasingWeight;
    /* 0x0128 */ bool bClamp;
};

// Size: 0x30
class ISequencerAnimationSupport : public UInterface {
};

// Size: 0x40
struct FSimSpaceSettings {
    /* 0x0000 */ float MasterAlpha;
    /* 0x0004 */ float VelocityScaleZ;
    /* 0x0008 */ float MaxLinearVelocity;
    /* 0x000c */ float MaxAngularVelocity;
    /* 0x0010 */ float MaxLinearAcceleration;
    /* 0x0014 */ float MaxAngularAcceleration;
    /* 0x0018 */ float ExternalLinearDrag;
    /* 0x001c */ FVector ExternalLinearDragV;
    /* 0x0028 */ FVector ExternalLinearVelocity;
    /* 0x0034 */ FVector ExternalAngularVelocity;
};

// Size: 0x50
struct FSocketReference {
    /* 0x0030 */ FName SocketName;
};

// Size: 0x18
struct FSplineIKCachedBoneData {
    /* 0x0000 */ FBoneReference Bone;
    /* 0x0014 */ int32_t RefSkeletonIndex;
};

// Size: 0x40
struct FAimConstraintDescription : public FConstraintDescriptionEx {
    /* 0x0010 */ FAxis LookAt_Axis;
    /* 0x0020 */ FAxis LookUp_Axis;
    /* 0x0030 */ bool bUseLookUp;
    /* 0x0034 */ FVector LookUpTarget;
};

// Size: 0x80
class UAnimationDataSourceRegistry : public UObject {
    /* 0x0030 */ TMap<FName, TWeakObjectPtr<UObject>> DataSources;
};

// Size: 0x10
struct FAxis {
    /* 0x0000 */ FVector Axis;
    /* 0x000c */ bool bInLocalSpace;
};

// Size: 0x80
struct FCCDIKChainLink {
};

// Size: 0x80
struct FConstraintData {
    /* 0x0000 */ FConstraintDescriptor Constraint;
    /* 0x0010 */ float Weight;
    /* 0x0014 */ bool bMaintainOffset;
    /* 0x0020 */ FTransform Offset;
    /* 0x0050 */ FTransform CurrentTransform;
};

// Size: 0xd
struct FConstraintDescription {
    /* 0x0000 */ bool bTranslation;
    /* 0x0001 */ bool bRotation;
    /* 0x0002 */ bool bScale;
    /* 0x0003 */ bool bParent;
    /* 0x0004 */ FFilterOptionPerAxis TranslationAxes;
    /* 0x0007 */ FFilterOptionPerAxis RotationAxes;
    /* 0x000a */ FFilterOptionPerAxis ScaleAxes;
};

// Size: 0x10
struct FConstraintDescriptionEx {
    /* 0x0008 */ FFilterOptionPerAxis AxesFilterOption;
};

// Size: 0x10
struct FConstraintDescriptor {
    /* 0x0000 */ EConstraintType Type;
};

// Size: 0x60
struct FConstraintOffset {
    /* 0x0000 */ FVector Translation;
    /* 0x0010 */ FQuat Rotation;
    /* 0x0020 */ FVector Scale;
    /* 0x0030 */ FTransform Parent;
};

enum class EConstraintType {
    Transform = 0,
    Aim = 1,
    MAX = 2,
};

enum class ETransformConstraintType {
    Translation = 0,
    Rotation = 1,
    Scale = 2,
    Parent = 3,
    ETransformConstraintType_MAX = 4,
};

// Size: 0x24
struct FEulerTransform {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FRotator Rotation;
    /* 0x0018 */ FVector Scale;
};

// Size: 0x38
struct FFABRIKChainLink {
};

// Size: 0x3
struct FFilterOptionPerAxis {
    /* 0x0000 */ bool bX;
    /* 0x0001 */ bool bY;
    /* 0x0002 */ bool bZ;
};

// Size: 0x10
struct FNodeChain {
    /* 0x0000 */ TArray<FName> Nodes;
};

// Size: 0x70
struct FNodeHierarchyData {
    /* 0x0000 */ TArray<FNodeObject> Nodes;
    /* 0x0010 */ TArray<FTransform> Transforms;
    /* 0x0020 */ TMap<FName, int32_t> NodeNameToIndexMapping;
};

// Size: 0x78
struct FNodeHierarchyWithUserData {
    /* 0x0008 */ FNodeHierarchyData Hierarchy;
};

// Size: 0x18
struct FNodeObject {
    /* 0x0000 */ FName Name;
    /* 0x000c */ FName ParentName;
};

// Size: 0x30
struct FTransformConstraint {
    /* 0x0000 */ FConstraintDescription Operator;
    /* 0x0010 */ FName SourceNode;
    /* 0x001c */ FName TargetNode;
    /* 0x0028 */ float Weight;
    /* 0x002c */ bool bMaintainOffset;
};

// Size: 0x18
struct FTransformConstraintDescription : public FConstraintDescriptionEx {
    /* 0x0010 */ ETransformConstraintType TransformType;
};

// Size: 0x9
struct FTransformFilter {
    /* 0x0000 */ FFilterOptionPerAxis TranslationFilter;
    /* 0x0003 */ FFilterOptionPerAxis RotationFilter;
    /* 0x0006 */ FFilterOptionPerAxis ScaleFilter;
};

// Size: 0x20
struct FTransformNoScale {
    /* 0x0000 */ FVector Location;
    /* 0x0010 */ FQuat Rotation;
};

// Size: 0x30
class UAnimationBlueprintLibrary : public UBlueprintFunctionLibrary {

    static UAnimNotify* AddAnimationNotifyEvent(UAnimSequence* AnimationSequence, FName NotifyTrackName, float StartTime, UClass* NotifyClass);
    static void AddAnimationNotifyEventObject(UAnimSequence* AnimationSequence, float StartTime, const UAnimNotify* Notify, FName NotifyTrackName);
    static UAnimNotifyState* AddAnimationNotifyStateEvent(UAnimSequence* AnimationSequence, FName NotifyTrackName, float StartTime, float Duration, UClass* NotifyStateClass);
    static void AddAnimationNotifyStateEventObject(UAnimSequence* AnimationSequence, float StartTime, float Duration, const UAnimNotifyState* NotifyState, FName NotifyTrackName);
    static void AddAnimationNotifyTrack(UAnimSequence* AnimationSequence, FName NotifyTrackName, FLinearColor TrackColor);
    static void AddAnimationSyncMarker(UAnimSequence* AnimationSequence, FName MarkerName, float Time, FName NotifyTrackName);
    static void AddCurve(UAnimSequence* AnimationSequence, FName CurveName, ERawCurveTrackTypes CurveType, bool bMetaDataCurve);
    static void AddFloatCurveKey(UAnimSequence* AnimationSequence, FName CurveName, const float Time, const float Value);
    static void AddFloatCurveKeys(UAnimSequence* AnimationSequence, FName CurveName, const TArray<float>& Times, const TArray<float>& Values);
    static void AddMetaData(UAnimSequence* AnimationSequence, UClass* MetaDataClass, const UAnimMetaData*& MetaDataInstance);
    static void AddMetaDataObject(UAnimSequence* AnimationSequence, const UAnimMetaData* MetaDataObject);
    static void AddTransformationCurveKey(UAnimSequence* AnimationSequence, FName CurveName, const float Time, const FTransform& Transform);
    static void AddTransformationCurveKeys(UAnimSequence* AnimationSequence, FName CurveName, const TArray<float>& Times, const TArray<FTransform>& Transforms);
    static void AddVectorCurveKey(UAnimSequence* AnimationSequence, FName CurveName, const float Time, const FVector Vector);
    static void AddVectorCurveKeys(UAnimSequence* AnimationSequence, FName CurveName, const TArray<float>& Times, const TArray<FVector>& Vectors);
    static void AddVirtualBone(const UAnimSequence* AnimationSequence, FName SourceBoneName, FName TargetBoneName, FName& VirtualBoneName);
    static bool ContainsMetaDataOfClass(const UAnimSequence* AnimationSequence, UClass* MetaDataClass);
    static void CopyAnimNotifiesFromSequence(UAnimSequence* SrcAnimSequence, UAnimSequence* DestAnimSequence);
    static void DoesBoneNameExist(UAnimSequence* AnimationSequence, FName BoneName, bool& bExists);
    static bool DoesCurveExist(UAnimSequence* AnimationSequence, FName CurveName, ERawCurveTrackTypes CurveType);
    static void FinalizeBoneAnimation(UAnimSequence* AnimationSequence);
    static void FindBonePathToRoot(const UAnimSequence* AnimationSequence, FName BoneName, TArray<FName>& BonePath);
    static void GetAdditiveAnimationType(const UAnimSequence* AnimationSequence, uint8_t& AdditiveAnimationType);
    static void GetAdditiveBasePoseType(const UAnimSequence* AnimationSequence, uint8_t& AdditiveBasePoseType);
    static float GetAnimNotifyEventTriggerTime(const FAnimNotifyEvent& NotifyEvent);
    static void GetAnimationCurveNames(const UAnimSequence* AnimationSequence, ERawCurveTrackTypes CurveType, TArray<FName>& CurveNames);
    static void GetAnimationInterpolationType(const UAnimSequence* AnimationSequence, EAnimInterpolationType& InterpolationType);
    static void GetAnimationNotifyEventNames(const UAnimSequence* AnimationSequence, TArray<FName>& EventNames);
    static void GetAnimationNotifyEvents(const UAnimSequence* AnimationSequence, TArray<FAnimNotifyEvent>& NotifyEvents);
    static void GetAnimationNotifyEventsForTrack(const UAnimSequence* AnimationSequence, FName NotifyTrackName, TArray<FAnimNotifyEvent>& Events);
    static void GetAnimationNotifyTrackNames(const UAnimSequence* AnimationSequence, TArray<FName>& TrackNames);
    static void GetAnimationSyncMarkers(const UAnimSequence* AnimationSequence, TArray<FAnimSyncMarker>& Markers);
    static void GetAnimationSyncMarkersForTrack(const UAnimSequence* AnimationSequence, FName NotifyTrackName, TArray<FAnimSyncMarker>& Markers);
    static void GetAnimationTrackNames(const UAnimSequence* AnimationSequence, TArray<FName>& TrackNames);
    static void GetBoneCompressionSettings(const UAnimSequence* AnimationSequence, UAnimBoneCompressionSettings*& CompressionSettings);
    static void GetBonePoseForFrame(const UAnimSequence* AnimationSequence, FName BoneName, int32_t Frame, bool bExtractRootMotion, FTransform& Pose);
    static void GetBonePoseForTime(const UAnimSequence* AnimationSequence, FName BoneName, float Time, bool bExtractRootMotion, FTransform& Pose);
    static void GetBonePosesForFrame(const UAnimSequence* AnimationSequence, TArray<FName> BoneNames, int32_t Frame, bool bExtractRootMotion, TArray<FTransform>& Poses, const USkeletalMesh* PreviewMesh);
    static void GetBonePosesForTime(const UAnimSequence* AnimationSequence, TArray<FName> BoneNames, float Time, bool bExtractRootMotion, TArray<FTransform>& Poses, const USkeletalMesh* PreviewMesh);
    static void GetCurveCompressionSettings(const UAnimSequence* AnimationSequence, UAnimCurveCompressionSettings*& CompressionSettings);
    static void GetFloatKeys(UAnimSequence* AnimationSequence, FName CurveName, TArray<float>& Times, TArray<float>& Values);
    static void GetFrameAtTime(const UAnimSequence* AnimationSequence, const float Time, int32_t& Frame);
    static void GetMetaData(const UAnimSequence* AnimationSequence, const TArray<UAnimMetaData*>& MetaData);
    static void GetMetaDataOfClass(const UAnimSequence* AnimationSequence, UClass* MetaDataClass, const TArray<UAnimMetaData*>& MetaDataOfClass);
    static void GetNumFrames(const UAnimSequence* AnimationSequence, int32_t& NumFrames);
    static void GetRateScale(const UAnimSequence* AnimationSequence, float& RateScale);
    static void GetRawTrackData(const UAnimSequence* AnimationSequence, const FName TrackName, TArray<FVector>& PositionKeys, TArray<FQuat>& RotationKeys, TArray<FVector>& ScalingKeys);
    static void GetRawTrackPositionData(const UAnimSequence* AnimationSequence, const FName TrackName, TArray<FVector>& PositionData);
    static void GetRawTrackRotationData(const UAnimSequence* AnimationSequence, const FName TrackName, TArray<FQuat>& RotationData);
    static void GetRawTrackScaleData(const UAnimSequence* AnimationSequence, const FName TrackName, TArray<FVector>& ScaleData);
    static void GetRootMotionLockType(const UAnimSequence* AnimationSequence, uint8_t& LockType);
    static void GetSequenceLength(const UAnimSequence* AnimationSequence, float& Length);
    static void GetTimeAtFrame(const UAnimSequence* AnimationSequence, const int32_t Frame, float& Time);
    static void GetTransformationKeys(UAnimSequence* AnimationSequence, FName CurveName, TArray<float>& Times, TArray<FTransform>& Values);
    static void GetUniqueMarkerNames(const UAnimSequence* AnimationSequence, TArray<FName>& MarkerNames);
    static void GetVectorKeys(UAnimSequence* AnimationSequence, FName CurveName, TArray<float>& Times, TArray<FVector>& Values);
    static bool IsRootMotionEnabled(const UAnimSequence* AnimationSequence);
    static bool IsRootMotionLockForced(const UAnimSequence* AnimationSequence);
    static bool IsValidAnimNotifyTrackName(const UAnimSequence* AnimationSequence, FName NotifyTrackName);
    static bool IsValidAnimationSyncMarkerName(const UAnimSequence* AnimationSequence, FName MarkerName);
    static bool IsValidRawAnimationTrackName(const UAnimSequence* AnimationSequence, const FName TrackName);
    static void IsValidTime(const UAnimSequence* AnimationSequence, const float Time, bool& IsValid);
    static void RemoveAllAnimationNotifyTracks(UAnimSequence* AnimationSequence);
    static void RemoveAllAnimationSyncMarkers(UAnimSequence* AnimationSequence);
    static void RemoveAllBoneAnimation(UAnimSequence* AnimationSequence);
    static void RemoveAllCurveData(UAnimSequence* AnimationSequence);
    static void RemoveAllMetaData(UAnimSequence* AnimationSequence);
    static void RemoveAllVirtualBones(const UAnimSequence* AnimationSequence);
    static int32_t RemoveAnimationNotifyEventsByName(UAnimSequence* AnimationSequence, FName NotifyName);
    static int32_t RemoveAnimationNotifyEventsByTrack(UAnimSequence* AnimationSequence, FName NotifyTrackName);
    static void RemoveAnimationNotifyTrack(UAnimSequence* AnimationSequence, FName NotifyTrackName);
    static int32_t RemoveAnimationSyncMarkersByName(UAnimSequence* AnimationSequence, FName MarkerName);
    static int32_t RemoveAnimationSyncMarkersByTrack(UAnimSequence* AnimationSequence, FName NotifyTrackName);
    static void RemoveBoneAnimation(UAnimSequence* AnimationSequence, FName BoneName, bool bIncludeChildren, bool bFinalize);
    static void RemoveCurve(UAnimSequence* AnimationSequence, FName CurveName, bool bRemoveNameFromSkeleton);
    static void RemoveMetaData(UAnimSequence* AnimationSequence, const UAnimMetaData* MetaDataObject);
    static void RemoveMetaDataOfClass(UAnimSequence* AnimationSequence, UClass* MetaDataClass);
    static void RemoveVirtualBone(const UAnimSequence* AnimationSequence, FName VirtualBoneName);
    static void RemoveVirtualBones(const UAnimSequence* AnimationSequence, TArray<FName> VirtualBoneNames);
    static void ReplaceAnimNotifies(UAnimSequenceBase* AnimationSequence, UClass* OldNotifyClass, UClass* NewNotifyClass, FDelegate OnNotifyReplaced);
    static void ReplaceAnimNotifyStates(UAnimSequenceBase* AnimationSequence, UClass* OldNotifyClass, UClass* NewNotifyClass, FDelegate OnNotifyStateReplaced);
    static void SetAdditiveAnimationType(UAnimSequence* AnimationSequence, const uint8_t AdditiveAnimationType);
    static void SetAdditiveBasePoseType(UAnimSequence* AnimationSequence, const uint8_t AdditiveBasePoseType);
    static void SetAnimationInterpolationType(UAnimSequence* AnimationSequence, EAnimInterpolationType InterpolationType);
    static void SetBoneCompressionSettings(UAnimSequence* AnimationSequence, UAnimBoneCompressionSettings* CompressionSettings);
    static void SetCurveCompressionSettings(UAnimSequence* AnimationSequence, UAnimCurveCompressionSettings* CompressionSettings);
    static void SetIsRootMotionLockForced(UAnimSequence* AnimationSequence, bool bForced);
    static void SetRateScale(UAnimSequence* AnimationSequence, float RateScale);
    static void SetRootMotionEnabled(UAnimSequence* AnimationSequence, bool bEnabled);
    static void SetRootMotionLockType(UAnimSequence* AnimationSequence, uint8_t RootMotionLockType);
};

// Size: 0x70
class UAnimationModifier : public UObject {
    /* 0x0040 */ FGuid RevisionGuid;
    /* 0x0050 */ FGuid AppliedGuid;
    /* 0x0060 */ int32_t StoredNativeRevision;
    /* 0x0068 */ UAnimationModifier* PreviouslyAppliedModifier;

    void OnApply(UAnimSequence* AnimationSequence);
    void OnRevert(UAnimSequence* AnimationSequence);
};

// Size: 0x40
class UAnimationModifiersAssetUserData : public UAssetUserData {
    /* 0x0030 */ TArray<UAnimationModifier*> AnimationModifierInstances;
};

enum class ESmartNameContainerType {
    SNCT_CurveMapping = 0,
    SNCT_TrackCurveMapping = 1,
    SNCT_MAX = 2,
};

// Size: 0x310
class UAnimSharingAdditiveInstance : public UAnimInstance {
    /* 0x02f8 */ TWeakObjectPtr<USkeletalMeshComponent> BaseComponent;
    /* 0x0300 */ TWeakObjectPtr<UAnimSequence> AdditiveAnimation;
    /* 0x0308 */ float Alpha;
    /* 0x030c */ bool bStateBool;
};

// Size: 0x120
class UAnimSharingInstance : public UObject {
    /* 0x0030 */ TArray<AActor*> RegisteredActors;
    /* 0x0090 */ UAnimationSharingStateProcessor* StateProcessor;
    /* 0x00d0 */ TArray<UAnimSequence*> UsedAnimationSequences;
    /* 0x00f0 */ UEnum* StateEnum;
    /* 0x00f8 */ AActor* SharingActor;
};

// Size: 0x320
class UAnimSharingStateInstance : public UAnimInstance {
    /* 0x02f8 */ UAnimSequence* AnimationToPlay;
    /* 0x0300 */ float PermutationTimeOffset;
    /* 0x0304 */ float PlayRate;
    /* 0x0308 */ bool bStateBool;
    /* 0x0310 */ UAnimSharingInstance* Instance;

    void GetInstancedActors(TArray<AActor*>& Actors);
};

// Size: 0x310
class UAnimSharingTransitionInstance : public UAnimInstance {
    /* 0x02f8 */ TWeakObjectPtr<USkeletalMeshComponent> FromComponent;
    /* 0x0300 */ TWeakObjectPtr<USkeletalMeshComponent> ToComponent;
    /* 0x0308 */ float BlendTime;
    /* 0x030c */ bool bBlendBool;
};

// Size: 0xc0
struct FAnimationSetup {
    /* 0x0000 */ UAnimSequence* AnimSequence;
    /* 0x0008 */ UClass* AnimBlueprint;
    /* 0x0010 */ FPerPlatformInt NumRandomizedInstances;
    /* 0x0068 */ FPerPlatformBool Enabled;
};

// Size: 0x1e0
class UAnimationSharingManager : public UObject {
    /* 0x0030 */ TArray<USkeleton*> Skeletons;
    /* 0x0040 */ TArray<UAnimSharingInstance*> PerSkeletonData;

    static bool AnimationSharingEnabled();
    static bool CreateAnimationSharingManager(UObject* WorldContextObject, const UAnimationSharingSetup* Setup);
    static UAnimationSharingManager* GetAnimationSharingManager(UObject* WorldContextObject);
    void RegisterActorWithSkeletonBP(AActor* InActor, const USkeleton* SharingSkeleton);
};

// Size: 0x160
struct FAnimationSharingScalability {
    /* 0x0000 */ FPerPlatformBool UseBlendTransitions;
    /* 0x0058 */ FPerPlatformFloat BlendSignificanceValue;
    /* 0x00b0 */ FPerPlatformInt MaximumNumberConcurrentBlends;
    /* 0x0108 */ FPerPlatformFloat TickSignificanceValue;
};

// Size: 0x1a0
class UAnimationSharingSetup : public UObject {
    /* 0x0030 */ TArray<FPerSkeletonAnimationSharingSetup> SkeletonSetups;
    /* 0x0040 */ FAnimationSharingScalability ScalabilitySettings;
};

// Size: 0x60
class UAnimationSharingStateProcessor : public UObject {
    /* 0x0030 */ TSoftObjectPtr<UEnum> AnimationStateEnum;

    UEnum* GetAnimationStateEnum();
    void ProcessActorState(int32_t& OutState, AActor* InActor, uint8_t CurrentState, uint8_t OnDemandState, bool& bShouldProcess);
};

// Size: 0x88
struct FAnimationStateEntry {
    /* 0x0000 */ uint8_t State;
    /* 0x0008 */ TArray<FAnimationSetup> AnimationSetups;
    /* 0x0018 */ bool bOnDemand;
    /* 0x0019 */ bool bAdditive;
    /* 0x001c */ float BlendTime;
    /* 0x0020 */ bool bReturnToPreviousState;
    /* 0x0021 */ bool bSetNextState;
    /* 0x0022 */ uint8_t NextState;
    /* 0x0028 */ FPerPlatformInt MaximumNumberOfConcurrentInstances;
    /* 0x0080 */ float WiggleTimePercentage;
    /* 0x0084 */ bool bRequiresCurves;
};

// Size: 0x38
struct FPerSkeletonAnimationSharingSetup {
    /* 0x0000 */ USkeleton* Skeleton;
    /* 0x0008 */ USkeletalMesh* SkeletalMesh;
    /* 0x0010 */ UClass* BlendAnimBlueprint;
    /* 0x0018 */ UClass* AdditiveAnimBlueprint;
    /* 0x0020 */ UClass* StateProcessorClass;
    /* 0x0028 */ TArray<FAnimationStateEntry> AnimationStates;
};

// Size: 0x30
struct FTickAnimationSharingFunction : public FTickFunction {
};

// Size: 0x88
class UAnimationSharingSetupFactory : public UFactory {
};

// Size: 0x30
class IAppleImageInterface : public UInterface {
};

// Size: 0x90
class UAppleImageUtilsBaseAsyncTaskBlueprintProxy : public UObject {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;
    /* 0x0068 */ FAppleImageUtilsImageConversionResult ConversionResult;

    static UAppleImageUtilsBaseAsyncTaskBlueprintProxy* CreateProxyObjectForConvertToHEIF(UTexture* SourceImage, int32_t Quality, bool bWantColor, bool bUseGpu, float Scale, ETextureRotationDirection Rotate);
    static UAppleImageUtilsBaseAsyncTaskBlueprintProxy* CreateProxyObjectForConvertToJPEG(UTexture* SourceImage, int32_t Quality, bool bWantColor, bool bUseGpu, float Scale, ETextureRotationDirection Rotate);
    static UAppleImageUtilsBaseAsyncTaskBlueprintProxy* CreateProxyObjectForConvertToPNG(UTexture* SourceImage, bool bWantColor, bool bUseGpu, float Scale, ETextureRotationDirection Rotate);
    static UAppleImageUtilsBaseAsyncTaskBlueprintProxy* CreateProxyObjectForConvertToTIFF(UTexture* SourceImage, bool bWantColor, bool bUseGpu, float Scale, ETextureRotationDirection Rotate);
};

// Size: 0x20
struct FAppleImageUtilsImageConversionResult {
    /* 0x0000 */ FString Error;
    /* 0x0010 */ TArray<uint8_t> ImageData;
};

enum class EAppleTextureType {
    Unknown = 0,
    Image = 1,
    PixelBuffer = 2,
    Surface = 3,
    MetalTexture = 4,
    EAppleTextureType_MAX = 5,
};

enum class ETextureRotationDirection {
    None = 0,
    Left = 1,
    Right = 2,
    Down = 3,
    LeftMirrored = 4,
    RightMirrored = 5,
    DownMirrored = 6,
    UpMirrored = 7,
    ETextureRotationDirection_MAX = 8,
};

// Size: 0xf8
class UK2Node_ConvertToHEIF : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_ConvertToJPEG : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_ConvertToPNG : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_ConvertToTIFF : public UK2Node_BaseAsyncTask {
};

// Size: 0xb50
class UArchVisCharMovementComponent : public UCharacterMovementComponent {
    /* 0x0b00 */ FRotator RotationalAcceleration;
    /* 0x0b0c */ FRotator RotationalDeceleration;
    /* 0x0b18 */ FRotator MaxRotationalVelocity;
    /* 0x0b24 */ float MinPitch;
    /* 0x0b28 */ float MaxPitch;
    /* 0x0b2c */ float WalkingFriction;
    /* 0x0b30 */ float WalkingSpeed;
    /* 0x0b34 */ float WalkingAcceleration;
};

// Size: 0x600
class AArchVisCharacter : public ACharacter {
    /* 0x0598 */ FString LookUpAxisName;
    /* 0x05a8 */ FString LookUpAtRateAxisName;
    /* 0x05b8 */ FString TurnAxisName;
    /* 0x05c8 */ FString TurnAtRateAxisName;
    /* 0x05d8 */ FString MoveForwardAxisName;
    /* 0x05e8 */ FString MoveRightAxisName;
    /* 0x05f8 */ float MouseSensitivityScale_Pitch;
    /* 0x05fc */ float MouseSensitivityScale_Yaw;
};

// Size: 0x180
class UEdGraphNode_Reference : public UEdGraphNode {
};

// Size: 0x180
class UEdGraph_ReferenceViewer : public UEdGraph {
};

// Size: 0x30
class UReferenceViewerSchema : public UEdGraphSchema {
};

// Size: 0x30
class IAssetRegistry : public UInterface {

    bool GetAllAssets(TArray<FAssetData>& OutAssetData, bool bIncludeOnlyOnDiskAssets) const;
    void GetAllCachedPaths(TArray<FString>& OutPathList) const;
    FAssetData GetAssetByObjectPath(const FName ObjectPath, bool bIncludeOnlyOnDiskAssets) const;
    bool GetAssets(const FARFilter& Filter, TArray<FAssetData>& OutAssetData) const;
    bool GetAssetsByClass(FName ClassName, TArray<FAssetData>& OutAssetData, bool bSearchSubClasses) const;
    bool GetAssetsByPackageName(FName PackageName, TArray<FAssetData>& OutAssetData, bool bIncludeOnlyOnDiskAssets) const;
    bool GetAssetsByPath(FName PackagePath, TArray<FAssetData>& OutAssetData, bool bRecursive, bool bIncludeOnlyOnDiskAssets) const;
    void GetSubPaths(FString InBasePath, TArray<FString>& OutPathList, bool bInRecurse) const;
    bool HasAssets(const FName PackagePath, const bool bRecursive) const;
    bool IsLoadingAssets() const;
    bool K2_GetDependencies(FName PackageName, const FAssetRegistryDependencyOptions& DependencyOptions, TArray<FName>& OutDependencies) const;
    bool K2_GetReferencers(FName PackageName, const FAssetRegistryDependencyOptions& ReferenceOptions, TArray<FName>& OutReferencers) const;
    void PrioritizeSearchPath(FString PathToPrioritize);
    void RunAssetsThroughFilter(TArray<FAssetData>& AssetDataList, const FARFilter& Filter) const;
    void ScanFilesSynchronous(const TArray<FString>& InFilePaths, bool bForceRescan);
    void ScanModifiedAssetFiles(const TArray<FString>& InFilePaths);
    void ScanPathsSynchronous(const TArray<FString>& InPaths, bool bForceRescan);
    void SearchAllAssets(bool bSynchronousSearch);
    void UseFilterToExcludeAssets(TArray<FAssetData>& AssetDataList, const FARFilter& Filter) const;
    void WaitForCompletion();
};

// Size: 0x5
struct FAssetRegistryDependencyOptions {
    /* 0x0000 */ bool bIncludeSoftPackageReferences;
    /* 0x0001 */ bool bIncludeHardPackageReferences;
    /* 0x0002 */ bool bIncludeSearchableNames;
    /* 0x0003 */ bool bIncludeSoftManagementReferences;
    /* 0x0004 */ bool bIncludeHardManagementReferences;
};

// Size: 0x30
class UAssetRegistryHelpers : public UObject {

    static FAssetData CreateAssetData(const UObject* InAsset, bool bAllowBlueprintClass);
    static UObject* GetAsset(const FAssetData& InAssetData);
    static TScriptInterface<IAssetRegistry> GetAssetRegistry();
    static UClass* GetClass(const FAssetData& InAssetData);
    static FString GetExportTextName(const FAssetData& InAssetData);
    static FString GetFullName(const FAssetData& InAssetData);
    static bool GetTagValue(const FAssetData& InAssetData, const FName& InTagName, FString& OutTagValue);
    static bool IsAssetLoaded(const FAssetData& InAssetData);
    static bool IsRedirector(const FAssetData& InAssetData);
    static bool IsUAsset(const FAssetData& InAssetData);
    static bool IsValid(const FAssetData& InAssetData);
    static FARFilter SetFilterTagsAndValues(const FARFilter& InFilter, const TArray<FTagAndValue>& InTagsAndValues);
    static FSoftObjectPath ToSoftObjectPath(const FAssetData& InAssetData);
};

// Size: 0x8c8
class UAssetRegistryImpl : public UObject {
};

// Size: 0x20
struct FTagAndValue {
    /* 0x0000 */ FName Tag;
    /* 0x0010 */ FString Value;
};

// Size: 0x38
class UAssetTagsSubsystem : public UEngineSubsystem {

    bool AddAssetDataToCollection(const FName Name, const FAssetData& AssetData);
    bool AddAssetDatasToCollection(const FName Name, const TArray<FAssetData>& AssetDatas);
    bool AddAssetPtrToCollection(const FName Name, const UObject* AssetPtr);
    bool AddAssetPtrsToCollection(const FName Name, const TArray<UObject*>& AssetPtrs);
    bool AddAssetToCollection(const FName Name, const FName AssetPathName);
    bool AddAssetsToCollection(const FName Name, const TArray<FName>& AssetPathNames);
    bool CollectionExists(const FName Name);
    bool CreateCollection(const FName Name, const ECollectionScriptingShareType ShareType);
    bool DestroyCollection(const FName Name);
    bool EmptyCollection(const FName Name);
    TArray<FAssetData> GetAssetsInCollection(const FName Name);
    TArray<FName> GetCollections();
    TArray<FName> GetCollectionsContainingAsset(const FName AssetPathName);
    TArray<FName> GetCollectionsContainingAssetData(const FAssetData& AssetData);
    TArray<FName> GetCollectionsContainingAssetPtr(const UObject* AssetPtr);
    bool RemoveAssetDataFromCollection(const FName Name, const FAssetData& AssetData);
    bool RemoveAssetDatasFromCollection(const FName Name, const TArray<FAssetData>& AssetDatas);
    bool RemoveAssetFromCollection(const FName Name, const FName AssetPathName);
    bool RemoveAssetPtrFromCollection(const FName Name, const UObject* AssetPtr);
    bool RemoveAssetPtrsFromCollection(const FName Name, const TArray<UObject*>& AssetPtrs);
    bool RemoveAssetsFromCollection(const FName Name, const TArray<FName>& AssetPathNames);
    bool RenameCollection(const FName Name, const FName NewName);
    bool ReparentCollection(const FName Name, const FName NewParentName);
};

enum class ECollectionScriptingShareType {
    Local = 0,
    Private = 1,
    Shared = 2,
    ECollectionScriptingShareType_MAX = 3,
};

// Size: 0x138
class UAdvancedCopyCustomization : public UObject {
};

// Size: 0x40
struct FAdvancedCopyMap {
    /* 0x0000 */ FSoftClassPath ClassToCopy;
    /* 0x0020 */ FSoftClassPath AdvancedCopyCustomization;
};

// Size: 0x38
struct FAdvancedCopyParams {
};

// Size: 0x70
struct FAssetRenameData {
    /* 0x0000 */ TWeakObjectPtr<UObject> Asset;
    /* 0x0008 */ FString NewPackagePath;
    /* 0x0018 */ FString NewName;
    /* 0x0028 */ FSoftObjectPath OldObjectPath;
    /* 0x0048 */ FSoftObjectPath NewObjectPath;
    /* 0x0068 */ bool bOnlyFixSoftReferences;
};

// Size: 0x30
class IAssetTools : public UInterface {

    UObject* CreateAsset(FString AssetName, FString PackagePath, UClass* AssetClass, UFactory* Factory, FName CallingContext);
    UObject* CreateAssetWithDialog(FString AssetName, FString PackagePath, UClass* AssetClass, UFactory* Factory, FName CallingContext);
    void CreateUniqueAssetName(FString InBasePackageName, FString InSuffix, FString& OutPackageName, FString& OutAssetName);
    UObject* DuplicateAsset(FString AssetName, FString PackagePath, UObject* OriginalObject);
    UObject* DuplicateAssetWithDialog(FString AssetName, FString PackagePath, UObject* OriginalObject);
    UObject* DuplicateAssetWithDialogAndTitle(FString AssetName, FString PackagePath, UObject* OriginalObject, FText DialogTitle);
    void ExportAssets(const TArray<FString>& AssetsToExport, FString ExportPath);
    void ExportAssetsWithDialog(const TArray<FString>& AssetsToExport, bool bPromptForIndividualFilenames);
    void FindSoftReferencesToObject(FSoftObjectPath TargetObject, TArray<UObject*>& ReferencingObjects);
    void ImportAssetTasks(const TArray<UAssetImportTask*>& ImportTasks);
    TArray<UObject*> ImportAssetsAutomated(const UAutomatedAssetImportData* ImportData);
    TArray<UObject*> ImportAssetsWithDialog(FString DestinationPath);
    void OpenEditorForAssets(const TArray<UObject*>& Assets);
    bool RenameAssets(const TArray<FAssetRenameData>& AssetsAndNames);
    EAssetRenameResult RenameAssetsWithDialog(const TArray<FAssetRenameData>& AssetsAndNames, bool bAutoCheckout);
    void RenameReferencingSoftObjectPaths(const TArray<UPackage*> PackagesToCheck, const TMap<FSoftObjectPath, FSoftObjectPath>& AssetRedirectorMap);
};

// Size: 0x30
class UAssetToolsHelpers : public UObject {

    static TScriptInterface<IAssetTools> GetAssetTools();
};

// Size: 0x110
class UAssetToolsImpl : public UObject {
};

// Size: 0x70
class UAssetToolsSettings : public UDeveloperSettings {
    /* 0x0060 */ TArray<FAdvancedCopyMap> AdvancedCopyCustomizations;
};

enum class EAssetRenameResult {
    Failure = 0,
    Success = 1,
    Pending = 2,
    EAssetRenameResult_MAX = 3,
};

// Size: 0x30
class UAudioAnalyzerAsset : public UObject {
};

// Size: 0xd0
class UAudioAnalyzerNRT : public UAudioAnalyzerAsset {
    /* 0x0030 */ USoundWave* Sound;
    /* 0x0038 */ float DurationInSeconds;

    void AnalyzeAudio();
};

// Size: 0x48
class UAudioAnalyzerNRTSettings : public UAudioAnalyzerAsset {
};

// Size: 0xb8
class UAudioCapture : public UAudioGenerator {

    bool GetAudioCaptureDeviceInfo(FAudioCaptureDeviceInfo& OutInfo);
    bool IsCapturingAudio();
    void StartCapturingAudio();
    void StopCapturingAudio();
};

// Size: 0x7e0
class UAudioCaptureComponent : public USynthComponent {
    /* 0x0720 */ int32_t JitterLatencyFrames;
};

// Size: 0x14
struct FAudioCaptureDeviceInfo {
    /* 0x0000 */ FName DeviceName;
    /* 0x000c */ int32_t NumInputChannels;
    /* 0x0010 */ int32_t SampleRate;
};

// Size: 0x30
class UAudioCaptureFunctionLibrary : public UBlueprintFunctionLibrary {

    static UAudioCapture* CreateAudioCapture();
};

// Size: 0x88
class UAudioBusFactory : public UFactory {
};

// Size: 0x88
class UDialogueVoiceFactory : public UFactory {
};

// Size: 0xb0
class UDialogueWaveFactory : public UFactory {
    /* 0x0088 */ USoundWave* InitialSoundWave;
    /* 0x0090 */ UDialogueVoice* InitialSpeakerVoice;
    /* 0x0098 */ bool HasSetInitialTargetVoice;
    /* 0x00a0 */ TArray<UDialogueVoice*> InitialTargetVoices;
};

// Size: 0x88
class UEndpointSubmixFactory : public UFactory {
};

// Size: 0xd8
class UReimportSoundFactory : public USoundFactory {
};

// Size: 0x88
class UReverbEffectFactory : public UFactory {
};

// Size: 0x88
class USoundAttenuationFactory : public UFactory {
};

// Size: 0x88
class USoundClassFactory : public UFactory {
};

// Size: 0xb8
class USoundClassGraph : public UEdGraph {
};

// Size: 0xe0
class USoundClassGraphNode : public UEdGraphNode {
    /* 0x00c8 */ USoundClass* SoundClass;
};

// Size: 0x30
class USoundClassGraphSchema : public UEdGraphSchema {
};

// Size: 0x110
struct FSoundClassGraphSchemaAction_NewNode : public FEdGraphSchemaAction {
};

// Size: 0x88
class USoundConcurrencyFactory : public UFactory {
};

// Size: 0xb8
class USoundCueFactoryNew : public UFactory {
    /* 0x0088 */ USoundWave* InitialSoundWave;
    /* 0x0090 */ TArray<TWeakObjectPtr<USoundWave>> InitialSoundWaves;
    /* 0x00a0 */ UDialogueWave* InitialDialogueWave;
    /* 0x00a8 */ TArray<TWeakObjectPtr<UDialogueWave>> InitialDialogueWaves;
};

// Size: 0xb0
class USoundCueGraph : public UEdGraph {
};

// Size: 0xd0
class USoundCueGraphNode : public USoundCueGraphNode_Base {
    /* 0x00c8 */ USoundNode* SoundNode;
};

// Size: 0xc8
class USoundCueGraphNode_Base : public UEdGraphNode {
};

// Size: 0xc8
class USoundCueGraphNode_Root : public USoundCueGraphNode_Base {
};

// Size: 0x30
class USoundCueGraphSchema : public UEdGraphSchema {
};

// Size: 0x100
struct FSoundCueGraphSchemaAction_NewComment : public FEdGraphSchemaAction {
};

// Size: 0x108
struct FSoundCueGraphSchemaAction_NewFromSelected : public FSoundCueGraphSchemaAction_NewNode {
};

// Size: 0x108
struct FSoundCueGraphSchemaAction_NewNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UClass* SoundNodeClass;
};

// Size: 0x100
struct FSoundCueGraphSchemaAction_Paste : public FEdGraphSchemaAction {
};

// Size: 0x400
class USoundEffectPresetUserWidget : public UUserWidget {
    /* 0x03f8 */ USoundEffectPreset* Preset;

    void OnPresetChanged(FName PropertyName);
};

// Size: 0x38
class USoundEffectSourcePresetClassTemplate : public UClassTemplate {
};

// Size: 0x38
class USoundEffectSubmixPresetClassTemplate : public UClassTemplate {
};

// Size: 0xb0
class USoundFactory : public UFactory {
    /* 0x0088 */ bool bAutoCreateCue;
    /* 0x0088 */ bool bIncludeAttenuationNode;
    /* 0x0088 */ bool bIncludeLoopingNode;
    /* 0x0088 */ bool bIncludeModulatorNode;
    /* 0x008c */ float CueVolume;
    /* 0x0090 */ FString CuePackageSuffix;
};

// Size: 0x88
class USoundMixFactory : public UFactory {
};

// Size: 0x88
class USoundSourceBusFactory : public UFactory {
};

// Size: 0x88
class USoundSourceEffectChainFactory : public UFactory {
};

// Size: 0x90
class USoundSourceEffectFactory : public UFactory {
    /* 0x0088 */ UClass* SoundEffectSourcepresetClass;
};

// Size: 0x90
class USoundSubmixEffectFactory : public UFactory {
    /* 0x0088 */ UClass* SoundEffectSubmixPresetClass;
};

// Size: 0x88
class USoundSubmixFactory : public UFactory {
};

// Size: 0xc8
class USoundSubmixGraph : public UEdGraph {
    /* 0x00b0 */ USoundSubmixBase* RootSoundSubmix;
    /* 0x00b8 */ TArray<USoundSubmixBase*> StaleRoots;
};

// Size: 0xe0
class USoundSubmixGraphNode : public UEdGraphNode {
    /* 0x00c8 */ USoundSubmixBase* SoundSubmix;
};

// Size: 0x30
class USoundSubmixGraphSchema : public UEdGraphSchema {
};

// Size: 0x110
struct FSoundSubmixGraphSchemaAction_NewNode : public FEdGraphSchemaAction {
};

// Size: 0x88
class USoundfieldEndpointSubmixFactory : public UFactory {
};

// Size: 0x88
class USoundfieldSubmixFactory : public UFactory {
};

// Size: 0x38
class USynthComponentClassTemplate : public UClassTemplate {
};

// Size: 0x30
class UAudioEndpointSettingsBase : public UObject {
};

// Size: 0x30
class UDummyEndpointSettings : public UAudioEndpointSettingsBase {
};

// Size: 0x30
class UOcclusionPluginSourceSettingsBase : public UObject {
};

// Size: 0x30
class UReverbPluginSourceSettingsBase : public UObject {
};

// Size: 0x30
class USoundModulatorBase : public UObject {
};

// Size: 0x38
class USoundfieldEffectBase : public UObject {
    /* 0x0030 */ USoundfieldEffectSettingsBase* Settings;
};

// Size: 0x30
class USoundfieldEffectSettingsBase : public UObject {
};

// Size: 0x30
class USoundfieldEncodingSettingsBase : public UObject {
};

// Size: 0x30
class USoundfieldEndpointSettingsBase : public UObject {
};

// Size: 0x30
class USpatializationPluginSourceSettingsBase : public UObject {
};

// Size: 0xb0
class UAudioGenerator : public UObject {
};

// Size: 0x30
class UAudioMixerBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void AddMasterSubmixEffect(const UObject* WorldContextObject, USoundEffectSubmixPreset* SubmixEffectPreset);
    static void AddSourceEffectToPresetChain(const UObject* WorldContextObject, USoundEffectSourcePresetChain* PresetChain, FSourceEffectChainEntry Entry);
    static int32_t AddSubmixEffect(const UObject* WorldContextObject, USoundSubmix* SoundSubmix, USoundEffectSubmixPreset* SubmixEffectPreset);
    static void ClearMasterSubmixEffects(const UObject* WorldContextObject);
    static void ClearSubmixEffectChainOverride(const UObject* WorldContextObject, USoundSubmix* SoundSubmix, float FadeTimeSec);
    static void ClearSubmixEffects(const UObject* WorldContextObject, USoundSubmix* SoundSubmix);
    static void GetMagnitudeForFrequencies(const UObject* WorldContextObject, const TArray<float>& Frequencies, TArray<float>& Magnitudes, USoundSubmix* SubmixToAnalyze);
    static int32_t GetNumberOfEntriesInSourceEffectChain(const UObject* WorldContextObject, USoundEffectSourcePresetChain* PresetChain);
    static void GetPhaseForFrequencies(const UObject* WorldContextObject, const TArray<float>& Frequencies, TArray<float>& Phases, USoundSubmix* SubmixToAnalyze);
    static bool IsAudioBusActive(const UObject* WorldContextObject, UAudioBus* AudioBus);
    static TArray<FSoundSubmixSpectralAnalysisBandSettings> MakeFullSpectrumSpectralAnalysisBandSettings(int32_t InNumBands, float InMinimumFrequency, float InMaximumFrequency, int32_t InAttackTimeMsec, int32_t InReleaseTimeMsec);
    static TArray<FSoundSubmixSpectralAnalysisBandSettings> MakeMusicalSpectralAnalysisBandSettings(int32_t InNumSemitones, EMusicalNoteName InStartingMusicalNote, int32_t InStartingOctave, int32_t InAttackTimeMsec, int32_t InReleaseTimeMsec);
    static TArray<FSoundSubmixSpectralAnalysisBandSettings> MakePresetSpectralAnalysisBandSettings(EAudioSpectrumBandPresetType InBandPresetType, int32_t InNumBands, int32_t InAttackTimeMsec, int32_t InReleaseTimeMsec);
    static void PauseRecordingOutput(const UObject* WorldContextObject, USoundSubmix* SubmixToPause);
    static void PrimeSoundCueForPlayback(USoundCue* SoundCue);
    static void PrimeSoundForPlayback(USoundWave* SoundWave, const FDelegate OnLoadCompletion);
    static void RemoveMasterSubmixEffect(const UObject* WorldContextObject, USoundEffectSubmixPreset* SubmixEffectPreset);
    static void RemoveSourceEffectFromPresetChain(const UObject* WorldContextObject, USoundEffectSourcePresetChain* PresetChain, int32_t EntryIndex);
    static void RemoveSubmixEffect(const UObject* WorldContextObject, USoundSubmix* SoundSubmix, USoundEffectSubmixPreset* SubmixEffectPreset);
    static void RemoveSubmixEffectAtIndex(const UObject* WorldContextObject, USoundSubmix* SoundSubmix, int32_t SubmixChainIndex);
    static void RemoveSubmixEffectPreset(const UObject* WorldContextObject, USoundSubmix* SoundSubmix, USoundEffectSubmixPreset* SubmixEffectPreset);
    static void RemoveSubmixEffectPresetAtIndex(const UObject* WorldContextObject, USoundSubmix* SoundSubmix, int32_t SubmixChainIndex);
    static void ReplaceSoundEffectSubmix(const UObject* WorldContextObject, USoundSubmix* InSoundSubmix, int32_t SubmixChainIndex, USoundEffectSubmixPreset* SubmixEffectPreset);
    static void ReplaceSubmixEffect(const UObject* WorldContextObject, USoundSubmix* InSoundSubmix, int32_t SubmixChainIndex, USoundEffectSubmixPreset* SubmixEffectPreset);
    static void ResumeRecordingOutput(const UObject* WorldContextObject, USoundSubmix* SubmixToPause);
    static void SetBypassSourceEffectChainEntry(const UObject* WorldContextObject, USoundEffectSourcePresetChain* PresetChain, int32_t EntryIndex, bool bBypassed);
    static void SetSubmixEffectChainOverride(const UObject* WorldContextObject, USoundSubmix* SoundSubmix, TArray<USoundEffectSubmixPreset*> SubmixEffectPresetChain, float FadeTimeSec);
    static void StartAnalyzingOutput(const UObject* WorldContextObject, USoundSubmix* SubmixToAnalyze, EFFTSize FFTSize, EFFTPeakInterpolationMethod InterpolationMethod, EFFTWindowType WindowType, float HopSize, EAudioSpectrumType SpectrumType);
    static void StartAudioBus(const UObject* WorldContextObject, UAudioBus* AudioBus);
    static void StartRecordingOutput(const UObject* WorldContextObject, float ExpectedDuration, USoundSubmix* SubmixToRecord);
    static void StopAnalyzingOutput(const UObject* WorldContextObject, USoundSubmix* SubmixToStopAnalyzing);
    static void StopAudioBus(const UObject* WorldContextObject, UAudioBus* AudioBus);
    static USoundWave* StopRecordingOutput(const UObject* WorldContextObject, EAudioRecordingExportType ExportType, FString Name, FString Path, USoundSubmix* SubmixToRecord, USoundWave* ExistingSoundWaveToOverwrite);
    static float TrimAudioCache(float InMegabytesToFree);
};

enum class EMusicalNoteName {
    C = 0,
    Db = 1,
    D = 2,
    Eb = 3,
    E = 4,
    F = 5,
    Gb = 6,
    G = 7,
    Ab = 8,
    A = 9,
    Bb = 10,
    B = 11,
    EMusicalNoteName_MAX = 12,
};

enum class EQuarztClockManagerType {
    AudioEngine = 0,
    QuartzSubsystem = 1,
    Count = 2,
    EQuarztClockManagerType_MAX = 3,
};

enum class ESubmixEffectDynamicsChannelLinkMode {
    Disabled = 0,
    Average = 1,
    Peak = 2,
    Count = 3,
    ESubmixEffectDynamicsChannelLinkMode_MAX = 4,
};

enum class ESubmixEffectDynamicsKeySource {
    Default = 0,
    AudioBus = 1,
    Submix = 2,
    Count = 3,
    ESubmixEffectDynamicsKeySource_MAX = 4,
};

enum class ESubmixEffectDynamicsPeakMode {
    MeanSquared = 0,
    RootMeanSquared = 1,
    Peak = 2,
    Count = 3,
    ESubmixEffectDynamicsPeakMode_MAX = 4,
};

enum class ESubmixEffectDynamicsProcessorType {
    Compressor = 0,
    Limiter = 1,
    Expander = 2,
    Gate = 3,
    Count = 4,
    ESubmixEffectDynamicsProcessorType_MAX = 5,
};

// Size: 0x1a0
class UQuartzClockHandle : public UObject {
    /* 0x0170 */ UQuartzSubsystem* QuartzSubsystem;
    /* 0x0198 */ UWorld* WorldPtr;

    float GetBeatsPerMinute(const UObject* WorldContextObject) const;
    FQuartzTransportTimeStamp GetCurrentTimestamp(const UObject* WorldContextObject);
    float GetDurationOfQuantizationTypeInSeconds(const UObject* WorldContextObject, const EQuartzCommandQuantization& QuantizationType, float Multiplier);
    float GetEstimatedRunTime(const UObject* WorldContextObject);
    float GetMillisecondsPerTick(const UObject* WorldContextObject) const;
    float GetSecondsPerTick(const UObject* WorldContextObject) const;
    float GetThirtySecondNotesPerMinute(const UObject* WorldContextObject) const;
    float GetTicksPerSecond(const UObject* WorldContextObject) const;
    bool IsClockRunning(const UObject* WorldContextObject);
    void PauseClock(const UObject* WorldContextObject, UQuartzClockHandle*& ClockHandle);
    void ResetTransport(const UObject* WorldContextObject, const FDelegate& InDelegate);
    void ResetTransportQuantized(const UObject* WorldContextObject, FQuartzQuantizationBoundary InQuantizationBoundary, const FDelegate& InDelegate, UQuartzClockHandle*& ClockHandle);
    void ResumeClock(const UObject* WorldContextObject, UQuartzClockHandle*& ClockHandle);
    void SetBeatsPerMinute(const UObject* WorldContextObject, const FQuartzQuantizationBoundary& QuantizationBoundary, const FDelegate& delegate, UQuartzClockHandle*& ClockHandle, float BeatsPerMinute);
    void SetMillisecondsPerTick(const UObject* WorldContextObject, const FQuartzQuantizationBoundary& QuantizationBoundary, const FDelegate& delegate, UQuartzClockHandle*& ClockHandle, float MillisecondsPerTick);
    void SetSecondsPerTick(const UObject* WorldContextObject, const FQuartzQuantizationBoundary& QuantizationBoundary, const FDelegate& delegate, UQuartzClockHandle*& ClockHandle, float SecondsPerTick);
    void SetThirtySecondNotesPerMinute(const UObject* WorldContextObject, const FQuartzQuantizationBoundary& QuantizationBoundary, const FDelegate& delegate, UQuartzClockHandle*& ClockHandle, float ThirtySecondsNotesPerMinute);
    void SetTicksPerSecond(const UObject* WorldContextObject, const FQuartzQuantizationBoundary& QuantizationBoundary, const FDelegate& delegate, UQuartzClockHandle*& ClockHandle, float TicksPerSecond);
    void StartClock(const UObject* WorldContextObject, UQuartzClockHandle*& ClockHandle);
    void StartOtherClock(const UObject* WorldContextObject, FName OtherClockName, FQuartzQuantizationBoundary InQuantizationBoundary, const FDelegate& InDelegate);
    void StopClock(const UObject* WorldContextObject, bool CancelPendingEvents, UQuartzClockHandle*& ClockHandle);
    void SubscribeToAllQuantizationEvents(const UObject* WorldContextObject, const FDelegate& OnQuantizationEvent, UQuartzClockHandle*& ClockHandle);
    void SubscribeToQuantizationEvent(const UObject* WorldContextObject, EQuartzCommandQuantization InQuantizationBoundary, const FDelegate& OnQuantizationEvent, UQuartzClockHandle*& ClockHandle);
    void UnsubscribeFromAllTimeDivisions(const UObject* WorldContextObject, UQuartzClockHandle*& ClockHandle);
    void UnsubscribeFromTimeDivision(const UObject* WorldContextObject, EQuartzCommandQuantization InQuantizationBoundary, UQuartzClockHandle*& ClockHandle);
};

// Size: 0x160
class UQuartzSubsystem : public UTickableWorldSubsystem {

    UQuartzClockHandle* CreateNewClock(const UObject* WorldContextObject, FName ClockName, FQuartzClockSettings InSettings, bool bOverrideSettingsIfClockExists, bool bUseAudioEngineClockManager);
    void DeleteClockByHandle(const UObject* WorldContextObject, UQuartzClockHandle*& InClockHandle);
    void DeleteClockByName(const UObject* WorldContextObject, FName ClockName);
    bool DoesClockExist(const UObject* WorldContextObject, FName ClockName);
    float GetAudioRenderThreadToGameThreadAverageLatency();
    float GetAudioRenderThreadToGameThreadMaxLatency();
    float GetAudioRenderThreadToGameThreadMinLatency();
    FQuartzTransportTimeStamp GetCurrentClockTimestamp(const UObject* WorldContextObject, const FName& InClockName);
    float GetDurationOfQuantizationTypeInSeconds(const UObject* WorldContextObject, FName ClockName, const EQuartzCommandQuantization& QuantizationType, float Multiplier);
    float GetEstimatedClockRunTime(const UObject* WorldContextObject, const FName& InClockName);
    float GetGameThreadToAudioRenderThreadAverageLatency(const UObject* WorldContextObject);
    float GetGameThreadToAudioRenderThreadMaxLatency(const UObject* WorldContextObject);
    float GetGameThreadToAudioRenderThreadMinLatency(const UObject* WorldContextObject);
    UQuartzClockHandle* GetHandleForClock(const UObject* WorldContextObject, FName ClockName);
    float GetRoundTripAverageLatency(const UObject* WorldContextObject);
    float GetRoundTripMaxLatency(const UObject* WorldContextObject);
    float GetRoundTripMinLatency(const UObject* WorldContextObject);
    bool IsClockRunning(const UObject* WorldContextObject, FName ClockName);
    bool IsQuartzEnabled();
};

// Size: 0xc
struct FSubmixEffectDynamicProcessorFilterSettings {
    /* 0x0000 */ bool bEnabled;
    /* 0x0004 */ float Cutoff;
    /* 0x0008 */ float GainDb;
};

// Size: 0x158
class USubmixEffectDynamicsProcessorPreset : public USoundEffectSubmixPreset {
    /* 0x00f8 */ FSubmixEffectDynamicsProcessorSettings Settings;

    void ResetKey();
    void SetAudioBus(UAudioBus* AudioBus);
    void SetExternalSubmix(USoundSubmix* Submix);
    void SetSettings(const FSubmixEffectDynamicsProcessorSettings& Settings);
};

// Size: 0x60
struct FSubmixEffectDynamicsProcessorSettings {
    /* 0x0000 */ ESubmixEffectDynamicsProcessorType DynamicsProcessorType;
    /* 0x0001 */ ESubmixEffectDynamicsPeakMode PeakMode;
    /* 0x0002 */ ESubmixEffectDynamicsChannelLinkMode LinkMode;
    /* 0x0004 */ float InputGainDb;
    /* 0x0008 */ float ThresholdDb;
    /* 0x000c */ float Ratio;
    /* 0x0010 */ float KneeBandwidthDb;
    /* 0x0014 */ float LookAheadMsec;
    /* 0x0018 */ float AttackTimeMsec;
    /* 0x001c */ float ReleaseTimeMsec;
    /* 0x0020 */ ESubmixEffectDynamicsKeySource KeySource;
    /* 0x0028 */ UAudioBus* ExternalAudioBus;
    /* 0x0030 */ USoundSubmix* ExternalSubmix;
    /* 0x0038 */ bool bChannelLinked;
    /* 0x0038 */ bool bAnalogMode;
    /* 0x0038 */ bool bBypass;
    /* 0x0038 */ bool bKeyAudition;
    /* 0x003c */ float KeyGainDb;
    /* 0x0040 */ float OutputGainDb;
    /* 0x0044 */ FSubmixEffectDynamicProcessorFilterSettings KeyHighshelf;
    /* 0x0050 */ FSubmixEffectDynamicProcessorFilterSettings KeyLowshelf;
};

// Size: 0x10
struct FSubmixEffectEQBand {
    /* 0x0000 */ float Frequency;
    /* 0x0004 */ float Bandwidth;
    /* 0x0008 */ float GainDb;
    /* 0x000c */ bool bEnabled;
};

// Size: 0x118
class USubmixEffectReverbPreset : public USoundEffectSubmixPreset {
    /* 0x00d8 */ FSubmixEffectReverbSettings Settings;

    void SetSettings(const FSubmixEffectReverbSettings& InSettings);
    void SetSettingsWithReverbEffect(const UReverbEffect* InReverbEffect, const float WetLevel, const float DryLevel);
};

// Size: 0x40
struct FSubmixEffectReverbSettings {
    /* 0x0000 */ bool bBypassEarlyReflections;
    /* 0x0004 */ float ReflectionsDelay;
    /* 0x0008 */ float GainHF;
    /* 0x000c */ float ReflectionsGain;
    /* 0x0010 */ bool bBypassLateReflections;
    /* 0x0014 */ float LateDelay;
    /* 0x0018 */ float DecayTime;
    /* 0x001c */ float Density;
    /* 0x0020 */ float Diffusion;
    /* 0x0024 */ float AirAbsorptionGainHF;
    /* 0x0028 */ float DecayHFRatio;
    /* 0x002c */ float LateGain;
    /* 0x0030 */ float Gain;
    /* 0x0034 */ float WetLevel;
    /* 0x0038 */ float DryLevel;
    /* 0x003c */ bool bBypass;
};

// Size: 0xb8
class USubmixEffectSubmixEQPreset : public USoundEffectSubmixPreset {
    /* 0x00a8 */ FSubmixEffectSubmixEQSettings Settings;

    void SetSettings(const FSubmixEffectSubmixEQSettings& InSettings);
};

// Size: 0x10
struct FSubmixEffectSubmixEQSettings {
    /* 0x0000 */ TArray<FSubmixEffectEQBand> EQBands;
};

// Size: 0x720
class USynthComponent : public USceneComponent {
    /* 0x0228 */ bool bAutoDestroy;
    /* 0x0228 */ bool bStopWhenOwnerDestroyed;
    /* 0x0228 */ bool bAllowSpatialization;
    /* 0x0228 */ bool bOverrideAttenuation;
    /* 0x022c */ bool bOutputToBusOnly;
    /* 0x022c */ bool bEnableBusSends;
    /* 0x022c */ bool bEnableBaseSubmix;
    /* 0x022c */ bool bEnableSubmixSends;
    /* 0x0230 */ USoundAttenuation* AttenuationSettings;
    /* 0x0238 */ FSoundAttenuationSettings AttenuationOverrides;
    /* 0x0600 */ USoundConcurrency* ConcurrencySettings;
    /* 0x0608 */ TSet<USoundConcurrency*> ConcurrencySet;
    /* 0x0658 */ USoundClass* SoundClass;
    /* 0x0660 */ USoundEffectSourcePresetChain* SourceEffectChain;
    /* 0x0668 */ USoundSubmixBase* SoundSubmix;
    /* 0x0670 */ TArray<FSoundSubmixSendInfo> SoundSubmixSends;
    /* 0x0680 */ TArray<FSoundSourceBusSendInfo> BusSends;
    /* 0x0690 */ TArray<FSoundSourceBusSendInfo> PreEffectBusSends;
    /* 0x06a0 */ bool bIsUISound;
    /* 0x06a0 */ bool bIsPreviewSound;
    /* 0x06a4 */ int32_t EnvelopeFollowerAttackTime;
    /* 0x06a8 */ int32_t EnvelopeFollowerReleaseTime;
    /* 0x06b0 */ FMulticastInlineDelegate OnAudioEnvelopeValue;
    /* 0x06e0 */ USynthSound* Synth;
    /* 0x06e8 */ UAudioComponent* AudioComponent;

    bool IsPlaying() const;
    void SetLowPassFilterEnabled(bool InLowPassFilterEnabled);
    void SetLowPassFilterFrequency(float InLowPassFilterFrequency);
    void SetOutputToBusOnly(bool bInOutputToBusOnly);
    void SetSubmixSend(USoundSubmixBase* Submix, float SendLevel);
    void SetVolumeMultiplier(float VolumeMultiplier);
    void Start();
    void Stop();
};

// Size: 0x570
class USynthSound : public USoundWaveProcedural {
    /* 0x0550 */ USynthComponent* OwningSynthComponent;
};

enum class ESoundwaveSampleRateSettings {
    Max = 0,
    High = 1,
    Medium = 2,
    Low = 3,
    Min = 4,
    MatchDevice = 5,
    ESoundwaveSampleRateSettings_MAX = 6,
};

// Size: 0x10
struct FPlatformRuntimeAudioCompressionOverrides {
    /* 0x0000 */ bool bOverrideCompressionTimes;
    /* 0x0004 */ float DurationThreshold;
    /* 0x0008 */ int32_t MaxNumRandomBranches;
    /* 0x000c */ int32_t SoundCueQualityIndex;
};

// Size: 0xd0
class UAudioSynesthesiaNRT : public UAudioAnalyzerNRT {
};

// Size: 0x48
class UAudioSynesthesiaNRTSettings : public UAudioAnalyzerNRTSettings {
};

// Size: 0xd8
class UConstantQNRT : public UAudioSynesthesiaNRT {
    /* 0x00d0 */ UConstantQNRTSettings* Settings;

    void GetChannelConstantQAtTime(const float InSeconds, const int32_t InChannel, TArray<float>& OutConstantQ) const;
    void GetNormalizedChannelConstantQAtTime(const float InSeconds, const int32_t InChannel, TArray<float>& OutConstantQ) const;
};

// Size: 0x68
class UConstantQNRTSettings : public UAudioSynesthesiaNRTSettings {
    /* 0x0048 */ float StartingFrequency;
    /* 0x004c */ int32_t NumBands;
    /* 0x0050 */ float NumBandsPerOctave;
    /* 0x0054 */ float AnalysisPeriod;
    /* 0x0058 */ bool bDownmixToMono;
    /* 0x0059 */ EConstantQFFTSizeEnum FFTSize;
    /* 0x005a */ EFFTWindowType WindowType;
    /* 0x005b */ EAudioSpectrumType SpectrumType;
    /* 0x005c */ float BandWidthStretch;
    /* 0x0060 */ EConstantQNormalizationEnum CQTNormalization;
    /* 0x0064 */ float NoiseFloorDb;
};

enum class EConstantQFFTSizeEnum {
    Min = 0,
    XXSmall = 1,
    XSmall = 2,
    Small = 3,
    Medium = 4,
    Large = 5,
    XLarge = 6,
    XXLarge = 7,
    Max = 8,
    EConstantQFFTSizeEnum_MAX = 9,
};

enum class EConstantQNormalizationEnum {
    EqualEuclideanNorm = 0,
    EqualEnergy = 1,
    EqualAmplitude = 2,
    EConstantQNormalizationEnum_MAX = 3,
};

enum class ELoudnessNRTCurveTypeEnum {
    A = 0,
    B = 1,
    C = 2,
    D = 3,
    None = 4,
    ELoudnessNRTCurveTypeEnum_MAX = 5,
};

// Size: 0xd8
class ULoudnessNRT : public UAudioSynesthesiaNRT {
    /* 0x00d0 */ ULoudnessNRTSettings* Settings;

    void GetChannelLoudnessAtTime(const float InSeconds, const int32_t InChannel, float& OutLoudness) const;
    void GetLoudnessAtTime(const float InSeconds, float& OutLoudness) const;
    void GetNormalizedChannelLoudnessAtTime(const float InSeconds, const int32_t InChannel, float& OutLoudness) const;
    void GetNormalizedLoudnessAtTime(const float InSeconds, float& OutLoudness) const;
};

// Size: 0x60
class ULoudnessNRTSettings : public UAudioSynesthesiaNRTSettings {
    /* 0x0048 */ float AnalysisPeriod;
    /* 0x004c */ float MinimumFrequency;
    /* 0x0050 */ float MaximumFrequency;
    /* 0x0054 */ ELoudnessNRTCurveTypeEnum CurveType;
    /* 0x0058 */ float NoiseFloorDb;
};

// Size: 0xd8
class UOnsetNRT : public UAudioSynesthesiaNRT {
    /* 0x00d0 */ UOnsetNRTSettings* Settings;

    void GetChannelOnsetsBetweenTimes(const float InStartSeconds, const float InEndSeconds, const int32_t InChannel, TArray<float>& OutOnsetTimestamps, TArray<float>& OutOnsetStrengths) const;
    void GetNormalizedChannelOnsetsBetweenTimes(const float InStartSeconds, const float InEndSeconds, const int32_t InChannel, TArray<float>& OutOnsetTimestamps, TArray<float>& OutOnsetStrengths) const;
};

// Size: 0x60
class UOnsetNRTSettings : public UAudioSynesthesiaNRTSettings {
    /* 0x0048 */ bool bDownmixToMono;
    /* 0x004c */ float GranularityInSeconds;
    /* 0x0050 */ float Sensitivity;
    /* 0x0054 */ float MinimumFrequency;
    /* 0x0058 */ float MaximumFrequency;
};

// Size: 0x90
class UAudioSynesthesiaNRTFactory : public UFactory {
    /* 0x0088 */ UClass* AudioSynesthesiaNRTClass;
};

// Size: 0x90
class UAudioSynesthesiaNRTSettingsFactory : public UFactory {
    /* 0x0088 */ UClass* AudioSynesthesiaNRTSettingsClass;
};

// Size: 0x2f8
class AARActor : public AActor {

    UARComponent* AddARComponent(UClass* InComponentClass, const FGuid& NativeID);
};

// Size: 0x58
class UARBaseAsyncTaskBlueprintProxy : public UBlueprintAsyncActionBase {
};

// Size: 0x48
class UARBasicLightEstimate : public UARLightEstimate {
    /* 0x0030 */ float AmbientIntensityLumens;
    /* 0x0034 */ float AmbientColorTemperatureKelvin;
    /* 0x0038 */ FLinearColor AmbientColor;

    FLinearColor GetAmbientColor() const;
    float GetAmbientColorTemperatureKelvin() const;
    float GetAmbientIntensityLumens() const;
};

// Size: 0x30
class UARBlueprintLibrary : public UBlueprintFunctionLibrary {

    static bool AddManualEnvironmentCaptureProbe(FVector Location, FVector Extent);
    static UARCandidateImage* AddRuntimeCandidateImage(UARSessionConfig* SessionConfig, UTexture2D* CandidateTexture, FString FriendlyName, float PhysicalWidth);
    static bool AddTrackedPointWithName(const FTransform& WorldTransform, FString PointName, bool bDeletePointsWithSameName);
    static void CalculateAlignmentTransform(const FTransform& TransformInFirstCoordinateSystem, const FTransform& TransformInSecondCoordinateSystem, FTransform& AlignmentTransform);
    static void CalculateClosestIntersection(const TArray<FVector>& StartPoints, const TArray<FVector>& EndPoints, FVector& ClosestIntersection);
    static void DebugDrawPin(UARPin* ARPin, UObject* WorldContextObject, FLinearColor Color, float Scale, float PersistForSeconds);
    static void DebugDrawTrackedGeometry(UARTrackedGeometry* TrackedGeometry, UObject* WorldContextObject, FLinearColor Color, float OutlineThickness, float PersistForSeconds);
    static TArray<UARTrackedPoint*> FindTrackedPointsByName(FString PointName);
    static FARSessionStatus GetARSessionStatus();
    static UARTexture* GetARTexture(EARTextureType TextureType);
    static float GetARWorldScale();
    static FTransform GetAlignmentTransform();
    static TArray<UARTrackedGeometry*> GetAllGeometries();
    static TArray<UARTrackedGeometry*> GetAllGeometriesByClass(UClass* GeometryClass);
    static TArray<UARPin*> GetAllPins();
    static TArray<FARPose2D> GetAllTracked2DPoses();
    static TArray<UAREnvironmentCaptureProbe*> GetAllTrackedEnvironmentCaptureProbes();
    static TArray<UARTrackedImage*> GetAllTrackedImages();
    static TArray<UARPlaneGeometry*> GetAllTrackedPlanes();
    static TArray<UARTrackedPoint*> GetAllTrackedPoints();
    static TArray<UARTrackedPose*> GetAllTrackedPoses();
    static UARTextureCameraDepth* GetCameraDepth();
    static UARTextureCameraImage* GetCameraImage();
    static bool GetCameraIntrinsics(FARCameraIntrinsics& OutCameraIntrinsics);
    static UARLightEstimate* GetCurrentLightEstimate();
    static int32_t GetNumberOfTrackedFacesSupported();
    static bool GetObjectClassificationAtLocation(const FVector& InWorldLocation, EARObjectClassification& OutClassification, FVector& OutClassificationLocation, float MaxLocationDiff);
    static UARTexture* GetPersonSegmentationDepthImage();
    static UARTexture* GetPersonSegmentationImage();
    static TArray<FVector> GetPointCloud();
    static UARSessionConfig* GetSessionConfig();
    static TArray<FARVideoFormat> GetSupportedVideoFormats(EARSessionType SessionType);
    static EARTrackingQuality GetTrackingQuality();
    static EARTrackingQualityReason GetTrackingQualityReason();
    static EARWorldMappingState GetWorldMappingStatus();
    static bool IsARPinLocalStoreReady();
    static bool IsARPinLocalStoreSupported();
    static bool IsARSupported();
    static bool IsSceneReconstructionSupported(EARSessionType SessionType, EARSceneReconstruction SceneReconstructionMethod);
    static bool IsSessionTrackingFeatureSupported(EARSessionType SessionType, EARSessionTrackingFeature SessionTrackingFeature);
    static bool IsSessionTypeSupported(EARSessionType SessionType);
    static TArray<FARTraceResult> LineTraceTrackedObjects(const FVector2D ScreenCoord, bool bTestFeaturePoints, bool bTestGroundPlane, bool bTestPlaneExtents, bool bTestPlaneBoundaryPolygon);
    static TArray<FARTraceResult> LineTraceTrackedObjects3D(const FVector Start, const FVector End, bool bTestFeaturePoints, bool bTestGroundPlane, bool bTestPlaneExtents, bool bTestPlaneBoundaryPolygon);
    static TMap<FName, UARPin*> LoadARPinsFromLocalStore();
    static void PauseARSession();
    static UARPin* PinComponent(USceneComponent* ComponentToPin, const FTransform& PinToWorldTransform, UARTrackedGeometry* TrackedGeometry, const FName DebugName);
    static bool PinComponentToARPin(USceneComponent* ComponentToPin, UARPin* Pin);
    static UARPin* PinComponentToTraceResult(USceneComponent* ComponentToPin, const FARTraceResult& TraceResult, const FName DebugName);
    static void RemoveARPinFromLocalStore(FName InSaveName);
    static void RemoveAllARPinsFromLocalStore();
    static void RemovePin(UARPin* PinToRemove);
    static FIntPoint ResizeXRCamera(const FIntPoint& InSize);
    static bool SaveARPinToLocalStore(FName InSaveName, UARPin* InPin);
    static void SetARWorldOriginLocationAndRotation(FVector OriginLocation, FRotator OriginRotation, bool bIsTransformInWorldSpace, bool bMaintainUpDirection);
    static void SetARWorldScale(float InWorldScale);
    static void SetAlignmentTransform(const FTransform& InAlignmentTransform);
    static void SetEnabledXRCamera(bool bOnOff);
    static void StartARSession(UARSessionConfig* SessionConfig);
    static void StopARSession();
    static bool ToggleARCapture(const bool bOnOff, const EARCaptureType CaptureType);
    static void UnpinComponent(USceneComponent* ComponentToUnpin);
};

// Size: 0x18
struct FARCameraIntrinsics {
    /* 0x0000 */ FIntPoint ImageResolution;
    /* 0x0008 */ FVector2D FocalLength;
    /* 0x0010 */ FVector2D PrincipalPoint;
};

// Size: 0x60
class UARCandidateImage : public UDataAsset {
    /* 0x0038 */ UTexture2D* CandidateTexture;
    /* 0x0040 */ FString FriendlyName;
    /* 0x0050 */ float Width;
    /* 0x0054 */ float Height;
    /* 0x0058 */ EARCandidateImageOrientation Orientation;

    UTexture2D* GetCandidateTexture() const;
    FString GetFriendlyName() const;
    EARCandidateImageOrientation GetOrientation() const;
    float GetPhysicalHeight() const;
    float GetPhysicalWidth() const;
};

// Size: 0x78
class UARCandidateObject : public UDataAsset {
    /* 0x0038 */ TArray<uint8_t> CandidateObjectData;
    /* 0x0048 */ FString FriendlyName;
    /* 0x0058 */ FBox BoundingBox;

    FBox GetBoundingBox() const;
    TArray<uint8_t> GetCandidateObjectData() const;
    FString GetFriendlyName() const;
    void SetBoundingBox(const FBox& InBoundingBox);
    void SetCandidateObjectData(const TArray<uint8_t>& InCandidateObject);
    void SetFriendlyName(FString NewName);
};

// Size: 0x2b0
class UARComponent : public USceneComponent {
    /* 0x0228 */ FGuid NativeID;
    /* 0x0268 */ bool bUseDefaultReplication;
    /* 0x0270 */ UMaterialInterface* DefaultMeshMaterial;
    /* 0x0278 */ UMaterialInterface* DefaultWireframeMeshMaterial;
    /* 0x0280 */ UMRMeshComponent* MRMeshComponent;
    /* 0x0288 */ UARTrackedGeometry* MyTrackedGeometry;

    UMRMeshComponent* GetMRMesh();
    void OnRep_Payload();
    void ReceiveRemove();
    void SetNativeID(FGuid NativeID);
    void UpdateVisualization();
};

// Size: 0x30
class UARDependencyHandler : public UObject {

    void CheckARServiceAvailability(UObject* WorldContextObject, FLatentActionInfo LatentInfo, EARServiceAvailability& OutAvailability);
    static UARDependencyHandler* GetARDependencyHandler();
    void InstallARService(UObject* WorldContextObject, FLatentActionInfo LatentInfo, EARServiceInstallRequestResult& OutInstallResult);
    void RequestARSessionPermission(UObject* WorldContextObject, UARSessionConfig* SessionConfig, FLatentActionInfo LatentInfo, EARServicePermissionRequestResult& OutPermissionResult);
    void StartARSessionLatent(UObject* WorldContextObject, UARSessionConfig* SessionConfig, FLatentActionInfo LatentInfo);
};

// Size: 0x120
class UAREnvironmentCaptureProbe : public UARTrackedGeometry {
    /* 0x0100 */ FVector Extent;
    /* 0x0110 */ UAREnvironmentCaptureProbeTexture* EnvironmentCaptureTexture;

    UAREnvironmentCaptureProbeTexture* GetEnvironmentCaptureTexture();
    FVector GetExtent() const;
};

// Size: 0x410
class UAREnvironmentCaptureProbeTexture : public UTextureCube {
    /* 0x03f0 */ EARTextureType TextureType;
    /* 0x03f4 */ float Timestamp;
    /* 0x03f8 */ FGuid ExternalTextureGuid;
    /* 0x0408 */ FVector2D Size;
};

// Size: 0x2e0
class UAREnvironmentProbeComponent : public UARComponent {
    /* 0x02b0 */ FAREnvironmentProbeUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FAREnvironmentProbeUpdatePayload& Payload);
    void ReceiveUpdate(const FAREnvironmentProbeUpdatePayload& Payload);
    void ServerUpdatePayload(const FAREnvironmentProbeUpdatePayload NewPayload);
};

// Size: 0x30
struct FAREnvironmentProbeUpdatePayload {
    /* 0x0000 */ FTransform WorldTransform;
};

// Size: 0x310
class UARFaceComponent : public UARComponent {
    /* 0x02a8 */ EARFaceTransformMixing TransformSetting;
    /* 0x02a9 */ bool bUpdateVertexNormal;
    /* 0x02aa */ bool bFaceOutOfScreen;
    /* 0x02b0 */ FARFaceUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FARFaceUpdatePayload& Payload);
    void ReceiveUpdate(const FARFaceUpdatePayload& Payload);
    void ServerUpdatePayload(const FARFaceUpdatePayload NewPayload);
    static void SetFaceComponentDebugMode(EFaceComponentDebugMode NewDebugMode);
};

// Size: 0x1f0
class UARFaceGeometry : public UARTrackedGeometry {
    /* 0x0100 */ FVector LookAtTarget;
    /* 0x010c */ bool bIsTracked;
    /* 0x0110 */ TMap<EARFaceBlendShape, float> BlendShapes;
    /* 0x0190 */ FTransform LeftEyeTransform;
    /* 0x01c0 */ FTransform RightEyeTransform;

    float GetBlendShapeValue(EARFaceBlendShape BlendShape) const;
    TMap<EARFaceBlendShape, float> GetBlendShapes() const;
    FTransform GetLocalSpaceEyeTransform(EAREye Eye) const;
    FTransform GetWorldSpaceEyeTransform(EAREye Eye) const;
};

// Size: 0x40
struct FARFaceUpdatePayload {
    /* 0x0000 */ FARSessionPayload SessionPayload;
    /* 0x0018 */ FVector LeftEyePosition;
    /* 0x0024 */ FVector RightEyePosition;
    /* 0x0030 */ FVector LookAtTarget;
};

// Size: 0x110
class UARGeoAnchor : public UARTrackedGeometry {

    float GetAltitudeMeters() const;
    EARAltitudeSource GetAltitudeSource() const;
    float GetLatitude() const;
    float GetLongitude() const;
};

// Size: 0x320
class UARGeoAnchorComponent : public UARComponent {
    /* 0x02b0 */ FARGeoAnchorUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FARGeoAnchorUpdatePayload& Payload);
    void ReceiveUpdate(const FARGeoAnchorUpdatePayload& Payload);
    void ServerUpdatePayload(const FARGeoAnchorUpdatePayload NewPayload);
    static void SetGeoAnchorComponentDebugMode(EGeoAnchorComponentDebugMode NewDebugMode);
};

// Size: 0x70
struct FARGeoAnchorUpdatePayload {
    /* 0x0000 */ FARSessionPayload SessionPayload;
    /* 0x0020 */ FTransform WorldTransform;
    /* 0x0050 */ float Longitude;
    /* 0x0054 */ float Latitude;
    /* 0x0058 */ float AltitudeMeters;
    /* 0x005c */ EARAltitudeSource AltitudeSource;
    /* 0x0060 */ FString AnchorName;
};

// Size: 0x30
class UARGeoTrackingSupport : public UObject {

    bool AddGeoAnchorAtLocation(float Longitude, float Latitude, FString OptionalAnchorName);
    bool AddGeoAnchorAtLocationWithAltitude(float Longitude, float Latitude, float AltitudeMeters, FString OptionalAnchorName);
    EARGeoTrackingAccuracy GetGeoTrackingAccuracy() const;
    EARGeoTrackingState GetGeoTrackingState() const;
    EARGeoTrackingStateReason GetGeoTrackingStateReason() const;
    static UARGeoTrackingSupport* GetGeoTrackingSupport();
};

// Size: 0xa0
class UARGetCandidateObjectAsyncTaskBlueprintProxy : public UARBaseAsyncTaskBlueprintProxy {
    /* 0x0058 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0068 */ FMulticastInlineDelegate OnFailed;

    static UARGetCandidateObjectAsyncTaskBlueprintProxy* ARGetCandidateObject(UObject* WorldContextObject, FVector Location, FVector Extent);
};

// Size: 0x310
class UARImageComponent : public UARComponent {
    /* 0x02b0 */ FARImageUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FARImageUpdatePayload& Payload);
    void ReceiveUpdate(const FARImageUpdatePayload& Payload);
    void ServerUpdatePayload(const FARImageUpdatePayload NewPayload);
    static void SetImageComponentDebugMode(EImageComponentDebugMode NewDebugMode);
};

// Size: 0x60
struct FARImageUpdatePayload {
    /* 0x0000 */ FARSessionPayload SessionPayload;
    /* 0x0020 */ FTransform WorldTransform;
    /* 0x0050 */ UARCandidateImage* DetectedImage;
    /* 0x0058 */ FVector2D EstimatedSize;
};

// Size: 0x260
class UARLifeCycleComponent : public USceneComponent {
    /* 0x0228 */ FMulticastInlineDelegate OnARActorSpawnedDelegate;
    /* 0x0238 */ FMulticastInlineDelegate OnARActorToBeDestroyedDelegate;

    void InstanceARActorSpawnedDelegate__DelegateSignature(UClass* ComponentClass, FGuid NativeID, AARActor* SpawnedActor);
    void InstanceARActorToBeDestroyedDelegate__DelegateSignature(AARActor* Actor);
    void ServerDestroyARActor(AARActor* Actor);
    void ServerSpawnARActor(UClass* ComponentClass, FGuid NativeID);
};

// Size: 0x30
class UARLightEstimate : public UObject {
};

// Size: 0x310
class UARMeshComponent : public UARComponent {
    /* 0x02b0 */ FARMeshUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FARMeshUpdatePayload& Payload);
    void ReceiveUpdate(const FARMeshUpdatePayload& Payload);
    void ServerUpdatePayload(const FARMeshUpdatePayload NewPayload);
};

// Size: 0x100
class UARMeshGeometry : public UARTrackedGeometry {

    bool GetObjectClassificationAtLocation(const FVector& InWorldLocation, EARObjectClassification& OutClassification, FVector& OutClassificationLocation, float MaxLocationDiff);
};

// Size: 0x60
struct FARMeshUpdatePayload {
    /* 0x0000 */ FARSessionPayload SessionPayload;
    /* 0x0020 */ FTransform WorldTransform;
    /* 0x0050 */ EARObjectClassification ObjectClassification;
};

// Size: 0x2e0
class UARObjectComponent : public UARComponent {
    /* 0x02b0 */ FARObjectUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FARObjectUpdatePayload& Payload);
    void ReceiveUpdate(const FARObjectUpdatePayload& Payload);
    void ServerUpdatePayload(const FARObjectUpdatePayload NewPayload);
};

// Size: 0x30
struct FARObjectUpdatePayload {
    /* 0x0000 */ FTransform WorldTransform;
};

// Size: 0x2f8
class AAROriginActor : public AActor {
};

// Size: 0xf0
class UARPin : public UObject {
    /* 0x0030 */ UARTrackedGeometry* TrackedGeometry;
    /* 0x0038 */ USceneComponent* PinnedComponent;
    /* 0x0040 */ FTransform LocalToTrackingTransform;
    /* 0x0070 */ FTransform LocalToAlignedTrackingTransform;
    /* 0x00a0 */ EARTrackingState TrackingState;
    /* 0x00c8 */ FMulticastInlineDelegate OnARTrackingStateChanged;
    /* 0x00d8 */ FMulticastInlineDelegate OnARTransformUpdated;

    void DebugDraw(UWorld* World, const FLinearColor& Color, float Scale, float PersistForSeconds) const;
    FName GetDebugName() const;
    FTransform GetLocalToTrackingTransform() const;
    FTransform GetLocalToWorldTransform() const;
    USceneComponent* GetPinnedComponent() const;
    UARTrackedGeometry* GetTrackedGeometry() const;
    EARTrackingState GetTrackingState() const;
};

// Size: 0x330
class UARPlaneComponent : public UARComponent {
    /* 0x02b0 */ FARPlaneUpdatePayload ReplicatedPayload;

    static TMap<EARObjectClassification, FLinearColor> GetObjectClassificationDebugColors();
    void ReceiveAdd(const FARPlaneUpdatePayload& Payload);
    void ReceiveUpdate(const FARPlaneUpdatePayload& Payload);
    void ServerUpdatePayload(const FARPlaneUpdatePayload NewPayload);
    static void SetObjectClassificationDebugColors(const TMap<EARObjectClassification, FLinearColor>& InColors);
    static void SetPlaneComponentDebugMode(EPlaneComponentDebugMode NewDebugMode);
};

// Size: 0x140
class UARPlaneGeometry : public UARTrackedGeometry {
    /* 0x0100 */ EARPlaneOrientation Orientation;
    /* 0x0104 */ FVector Center;
    /* 0x0110 */ FVector Extent;
    /* 0x0120 */ TArray<FVector> BoundaryPolygon;
    /* 0x0130 */ UARPlaneGeometry* SubsumedBy;

    TArray<FVector> GetBoundaryPolygonInLocalSpace() const;
    FVector GetCenter() const;
    FVector GetExtent() const;
    EARPlaneOrientation GetOrientation() const;
    UARPlaneGeometry* GetSubsumedBy() const;
};

// Size: 0x80
struct FARPlaneUpdatePayload {
    /* 0x0000 */ FARSessionPayload SessionPayload;
    /* 0x0020 */ FTransform WorldTransform;
    /* 0x0050 */ FVector Center;
    /* 0x005c */ FVector Extents;
    /* 0x0068 */ TArray<FVector> BoundaryVertices;
    /* 0x0078 */ EARObjectClassification ObjectClassification;
};

// Size: 0x2b0
class UARPointComponent : public UARComponent {
    /* 0x02a8 */ FARPointUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FARPointUpdatePayload& Payload);
    void ReceiveUpdate(const FARPointUpdatePayload& Payload);
    void ServerUpdatePayload(const FARPointUpdatePayload NewPayload);
};

// Size: 0x1
struct FARPointUpdatePayload {
};

// Size: 0x48
struct FARPose2D {
    /* 0x0000 */ FARSkeletonDefinition SkeletonDefinition;
    /* 0x0028 */ TArray<FVector2D> JointLocations;
    /* 0x0038 */ TArray<bool> IsJointTracked;
};

// Size: 0x50
struct FARPose3D {
    /* 0x0000 */ FARSkeletonDefinition SkeletonDefinition;
    /* 0x0028 */ TArray<FTransform> JointTransforms;
    /* 0x0038 */ TArray<bool> IsJointTracked;
    /* 0x0048 */ EARJointTransformSpace JointTransformSpace;
};

// Size: 0x2f0
class UARPoseComponent : public UARComponent {
    /* 0x02b0 */ FARPoseUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FARPoseUpdatePayload& Payload);
    void ReceiveUpdate(const FARPoseUpdatePayload& Payload);
    void ServerUpdatePayload(const FARPoseUpdatePayload NewPayload);
    static void SetPoseComponentDebugMode(EPoseComponentDebugMode NewDebugMode);
};

// Size: 0x40
struct FARPoseUpdatePayload {
    /* 0x0000 */ FTransform WorldTransform;
    /* 0x0030 */ TArray<FTransform> JointTransforms;
};

// Size: 0x320
class UARQRCodeComponent : public UARComponent {
    /* 0x02b0 */ FARQRCodeUpdatePayload ReplicatedPayload;

    void ReceiveAdd(const FARQRCodeUpdatePayload& Payload);
    void ReceiveUpdate(const FARQRCodeUpdatePayload& Payload);
    void ServerUpdatePayload(const FARQRCodeUpdatePayload NewPayload);
    static void SetQRCodeComponentDebugMode(EQRCodeComponentDebugMode NewDebugMode);
};

// Size: 0x70
struct FARQRCodeUpdatePayload {
    /* 0x0000 */ FARSessionPayload SessionPayload;
    /* 0x0020 */ FTransform WorldTransform;
    /* 0x0050 */ FVector Extents;
    /* 0x0060 */ FString QRCode;
};

// Size: 0x88
class UARSaveWorldAsyncTaskBlueprintProxy : public UARBaseAsyncTaskBlueprintProxy {
    /* 0x0058 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0068 */ FMulticastInlineDelegate OnFailed;

    static UARSaveWorldAsyncTaskBlueprintProxy* ARSaveWorld(UObject* WorldContextObject);
};

// Size: 0x118
class UARSessionConfig : public UDataAsset {
    /* 0x0038 */ bool bGenerateMeshDataFromTrackedGeometry;
    /* 0x0039 */ bool bGenerateCollisionForMeshData;
    /* 0x003a */ bool bGenerateNavMeshForMeshData;
    /* 0x003b */ bool bUseMeshDataForOcclusion;
    /* 0x003c */ bool bRenderMeshDataInWireframe;
    /* 0x003d */ bool bTrackSceneObjects;
    /* 0x003e */ bool bUsePersonSegmentationForOcclusion;
    /* 0x003f */ bool bUseSceneDepthForOcclusion;
    /* 0x0040 */ bool bUseAutomaticImageScaleEstimation;
    /* 0x0041 */ bool bUseStandardOnboardingUX;
    /* 0x0042 */ EARWorldAlignment WorldAlignment;
    /* 0x0043 */ EARSessionType SessionType;
    /* 0x0044 */ EARPlaneDetectionMode PlaneDetectionMode;
    /* 0x0045 */ bool bHorizontalPlaneDetection;
    /* 0x0046 */ bool bVerticalPlaneDetection;
    /* 0x0047 */ bool bEnableAutoFocus;
    /* 0x0048 */ EARLightEstimationMode LightEstimationMode;
    /* 0x0049 */ EARFrameSyncMode FrameSyncMode;
    /* 0x004a */ bool bEnableAutomaticCameraOverlay;
    /* 0x004b */ bool bEnableAutomaticCameraTracking;
    /* 0x004c */ bool bResetCameraTracking;
    /* 0x004d */ bool bResetTrackedObjects;
    /* 0x0050 */ TArray<UARCandidateImage*> CandidateImages;
    /* 0x0060 */ int32_t MaxNumSimultaneousImagesTracked;
    /* 0x0064 */ EAREnvironmentCaptureProbeType EnvironmentCaptureProbeType;
    /* 0x0068 */ TArray<uint8_t> WorldMapData;
    /* 0x0078 */ TArray<UARCandidateObject*> CandidateObjects;
    /* 0x0088 */ FARVideoFormat DesiredVideoFormat;
    /* 0x0094 */ bool bUseOptimalVideoFormat;
    /* 0x0095 */ EARFaceTrackingDirection FaceTrackingDirection;
    /* 0x0096 */ EARFaceTrackingUpdate FaceTrackingUpdate;
    /* 0x0098 */ int32_t MaxNumberOfTrackedFaces;
    /* 0x00a0 */ TArray<uint8_t> SerializedARCandidateImageDatabase;
    /* 0x00b0 */ EARSessionTrackingFeature EnabledSessionTrackingFeature;
    /* 0x00b1 */ EARSceneReconstruction SceneReconstructionMethod;
    /* 0x00b8 */ UClass* PlaneComponentClass;
    /* 0x00c0 */ UClass* PointComponentClass;
    /* 0x00c8 */ UClass* FaceComponentClass;
    /* 0x00d0 */ UClass* ImageComponentClass;
    /* 0x00d8 */ UClass* QRCodeComponentClass;
    /* 0x00e0 */ UClass* PoseComponentClass;
    /* 0x00e8 */ UClass* EnvironmentProbeComponentClass;
    /* 0x00f0 */ UClass* ObjectComponentClass;
    /* 0x00f8 */ UClass* MeshComponentClass;
    /* 0x0100 */ UClass* GeoAnchorComponentClass;
    /* 0x0108 */ UMaterialInterface* DefaultMeshMaterial;
    /* 0x0110 */ UMaterialInterface* DefaultWireframeMeshMaterial;

    void AddCandidateImage(UARCandidateImage* NewCandidateImage);
    void AddCandidateObject(UARCandidateObject* CandidateObject);
    TArray<UARCandidateImage*> GetCandidateImageList() const;
    TArray<UARCandidateObject*> GetCandidateObjectList() const;
    FARVideoFormat GetDesiredVideoFormat() const;
    EARSessionTrackingFeature GetEnabledSessionTrackingFeature() const;
    EAREnvironmentCaptureProbeType GetEnvironmentCaptureProbeType() const;
    EARFaceTrackingDirection GetFaceTrackingDirection() const;
    EARFaceTrackingUpdate GetFaceTrackingUpdate() const;
    EARFrameSyncMode GetFrameSyncMode() const;
    EARLightEstimationMode GetLightEstimationMode() const;
    int32_t GetMaxNumSimultaneousImagesTracked() const;
    EARPlaneDetectionMode GetPlaneDetectionMode() const;
    EARSceneReconstruction GetSceneReconstructionMethod() const;
    EARSessionType GetSessionType() const;
    EARWorldAlignment GetWorldAlignment() const;
    TArray<uint8_t> GetWorldMapData() const;
    void SetCandidateObjectList(const TArray<UARCandidateObject*>& InCandidateObjects);
    void SetDesiredVideoFormat(FARVideoFormat NewFormat);
    void SetEnableAutoFocus(bool bNewValue);
    void SetFaceTrackingDirection(EARFaceTrackingDirection InDirection);
    void SetFaceTrackingUpdate(EARFaceTrackingUpdate InUpdate);
    void SetResetCameraTracking(bool bNewValue);
    void SetResetTrackedObjects(bool bNewValue);
    void SetSceneReconstructionMethod(EARSceneReconstruction InSceneReconstructionMethod);
    void SetSessionTrackingFeatureToEnable(EARSessionTrackingFeature InSessionTrackingFeature);
    void SetWorldMapData(TArray<uint8_t> WorldMapData);
    bool ShouldEnableAutoFocus() const;
    bool ShouldEnableCameraTracking() const;
    bool ShouldRenderCameraOverlay() const;
    bool ShouldResetCameraTracking() const;
    bool ShouldResetTrackedObjects() const;
};

// Size: 0x18
struct FARSessionPayload {
    /* 0x0000 */ int32_t ConfigFlags;
    /* 0x0008 */ UMaterialInterface* DefaultMeshMaterial;
    /* 0x0010 */ UMaterialInterface* DefaultWireframeMeshMaterial;
};

// Size: 0x18
struct FARSessionStatus {
    /* 0x0000 */ FString AdditionalInfo;
    /* 0x0010 */ EARSessionStatus Status;
};

// Size: 0x458
class AARSharedWorldGameMode : public AGameMode {
    /* 0x03f0 */ int32_t BufferSizePerChunk;

    AARSharedWorldGameState* GetARSharedWorldGameState();
    void SetARSharedWorldData(TArray<uint8_t> ARWorldData);
    void SetARWorldSharingIsReady();
    void SetPreviewImageData(TArray<uint8_t> ImageData);
};

// Size: 0x3b0
class AARSharedWorldGameState : public AGameState {
    /* 0x0378 */ TArray<uint8_t> PreviewImageData;
    /* 0x0388 */ TArray<uint8_t> ARWorldData;
    /* 0x0398 */ int32_t PreviewImageBytesTotal;
    /* 0x039c */ int32_t ARWorldBytesTotal;
    /* 0x03a0 */ int32_t PreviewImageBytesDelivered;
    /* 0x03a4 */ int32_t ARWorldBytesDelivered;

    void K2_OnARWorldMapIsReady();
};

// Size: 0x668
class AARSharedWorldPlayerController : public APlayerController {

    void ClientInitSharedWorld(int32_t PreviewImageSize, int32_t ARWorldDataSize);
    void ClientUpdateARWorldData(int32_t Offset, const TArray<uint8_t> Buffer);
    void ClientUpdatePreviewImageData(int32_t Offset, const TArray<uint8_t> Buffer);
    void ServerMarkReadyForReceiving();
};

// Size: 0x8
struct FARSharedWorldReplicationState {
    /* 0x0000 */ int32_t PreviewImageOffset;
    /* 0x0004 */ int32_t ARWorldOffset;
};

// Size: 0x28
struct FARSkeletonDefinition {
    /* 0x0000 */ int32_t NumJoints;
    /* 0x0008 */ TArray<FName> JointNames;
    /* 0x0018 */ TArray<int32_t> ParentIndices;
};

// Size: 0x320
class AARSkyLight : public ASkyLight {
    /* 0x0310 */ UAREnvironmentCaptureProbe* CaptureProbe;

    void SetEnvironmentCaptureProbe(UAREnvironmentCaptureProbe* InCaptureProbe);
};

// Size: 0x3c0
class UARTexture : public UTexture {
    /* 0x0398 */ EARTextureType TextureType;
    /* 0x039c */ float Timestamp;
    /* 0x03a0 */ FGuid ExternalTextureGuid;
    /* 0x03b0 */ FVector2D Size;
};

// Size: 0x3c0
class UARTextureCameraDepth : public UARTexture {
    /* 0x03b8 */ EARDepthQuality DepthQuality;
    /* 0x03b9 */ EARDepthAccuracy DepthAccuracy;
    /* 0x03ba */ bool bIsTemporallySmoothed;
};

// Size: 0x3c0
class UARTextureCameraImage : public UARTexture {
};

// Size: 0x60
struct FARTraceResult {
    /* 0x0000 */ float DistanceFromCamera;
    /* 0x0004 */ EARLineTraceChannels TraceChannel;
    /* 0x0010 */ FTransform LocalTransform;
    /* 0x0040 */ UARTrackedGeometry* TrackedGeometry;
};

// Size: 0x30
class UARTraceResultDummy : public UObject {
};

// Size: 0x30
class UARTraceResultLibrary : public UBlueprintFunctionLibrary {

    static float GetDistanceFromCamera(const FARTraceResult& TraceResult);
    static FTransform GetLocalToTrackingTransform(const FARTraceResult& TraceResult);
    static FTransform GetLocalToWorldTransform(const FARTraceResult& TraceResult);
    static FTransform GetLocalTransform(const FARTraceResult& TraceResult);
    static EARLineTraceChannels GetTraceChannel(const FARTraceResult& TraceResult);
    static UARTrackedGeometry* GetTrackedGeometry(const FARTraceResult& TraceResult);
};

// Size: 0x210
class UARTrackableNotifyComponent : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate OnAddTrackedGeometry;
    /* 0x00d0 */ FMulticastInlineDelegate OnUpdateTrackedGeometry;
    /* 0x00e0 */ FMulticastInlineDelegate OnRemoveTrackedGeometry;
    /* 0x00f0 */ FMulticastInlineDelegate OnAddTrackedPlane;
    /* 0x0100 */ FMulticastInlineDelegate OnUpdateTrackedPlane;
    /* 0x0110 */ FMulticastInlineDelegate OnRemoveTrackedPlane;
    /* 0x0120 */ FMulticastInlineDelegate OnAddTrackedPoint;
    /* 0x0130 */ FMulticastInlineDelegate OnUpdateTrackedPoint;
    /* 0x0140 */ FMulticastInlineDelegate OnRemoveTrackedPoint;
    /* 0x0150 */ FMulticastInlineDelegate OnAddTrackedImage;
    /* 0x0160 */ FMulticastInlineDelegate OnUpdateTrackedImage;
    /* 0x0170 */ FMulticastInlineDelegate OnRemoveTrackedImage;
    /* 0x0180 */ FMulticastInlineDelegate OnAddTrackedFace;
    /* 0x0190 */ FMulticastInlineDelegate OnUpdateTrackedFace;
    /* 0x01a0 */ FMulticastInlineDelegate OnRemoveTrackedFace;
    /* 0x01b0 */ FMulticastInlineDelegate OnAddTrackedEnvProbe;
    /* 0x01c0 */ FMulticastInlineDelegate OnUpdateTrackedEnvProbe;
    /* 0x01d0 */ FMulticastInlineDelegate OnRemoveTrackedEnvProbe;
    /* 0x01e0 */ FMulticastInlineDelegate OnAddTrackedObject;
    /* 0x01f0 */ FMulticastInlineDelegate OnUpdateTrackedObject;
    /* 0x0200 */ FMulticastInlineDelegate OnRemoveTrackedObject;
};

// Size: 0x100
class UARTrackedGeometry : public UObject {
    /* 0x0030 */ FGuid UniqueId;
    /* 0x0040 */ FTransform LocalToTrackingTransform;
    /* 0x0070 */ FTransform LocalToAlignedTrackingTransform;
    /* 0x00a0 */ EARTrackingState TrackingState;
    /* 0x00b0 */ UMRMeshComponent* UnderlyingMesh;
    /* 0x00b8 */ EARObjectClassification ObjectClassification;
    /* 0x00b9 */ EARSpatialMeshUsageFlags SpatialMeshUsageFlags;
    /* 0x00d0 */ int32_t LastUpdateFrameNumber;
    /* 0x00e0 */ FName DebugName;

    FName GetDebugName() const;
    int32_t GetLastUpdateFrameNumber() const;
    float GetLastUpdateTimestamp() const;
    FTransform GetLocalToTrackingTransform() const;
    FTransform GetLocalToWorldTransform() const;
    FString GetName() const;
    EARObjectClassification GetObjectClassification() const;
    EARTrackingState GetTrackingState() const;
    UMRMeshComponent* GetUnderlyingMesh();
    bool HasSpatialMeshUsageFlag(const EARSpatialMeshUsageFlags InFlag) const;
    bool IsTracked() const;
};

// Size: 0x110
class UARTrackedImage : public UARTrackedGeometry {
    /* 0x0100 */ UARCandidateImage* DetectedImage;
    /* 0x0108 */ FVector2D EstimatedSize;

    UARCandidateImage* GetDetectedImage() const;
    FVector2D GetEstimateSize();
};

// Size: 0x110
class UARTrackedObject : public UARTrackedGeometry {
    /* 0x0100 */ UARCandidateObject* DetectedObject;

    UARCandidateObject* GetDetectedObject() const;
};

// Size: 0x100
class UARTrackedPoint : public UARTrackedGeometry {
};

// Size: 0x150
class UARTrackedPose : public UARTrackedGeometry {
    /* 0x0100 */ FARPose3D TrackedPose;

    FARPose3D GetTrackedPoseData() const;
};

// Size: 0x130
class UARTrackedQRCode : public UARTrackedImage {
    /* 0x0110 */ FString QRCode;
    /* 0x0120 */ int32_t Version;
};

// Size: 0x30
class UARTypesDummyClass : public UObject {
};

// Size: 0xc
struct FARVideoFormat {
    /* 0x0000 */ int32_t FPS;
    /* 0x0004 */ int32_t Width;
    /* 0x0008 */ int32_t Height;
};

// Size: 0xa8
class UCheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy : public UARBaseAsyncTaskBlueprintProxy {
    /* 0x0058 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0068 */ FMulticastInlineDelegate OnFailed;

    static UCheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy* CheckGeoTrackingAvailability(UObject* WorldContextObject);
    static UCheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy* CheckGeoTrackingAvailabilityAtLocation(UObject* WorldContextObject, float Longitude, float Latitude);
    void GeoTrackingAvailabilityDelegate__DelegateSignature(bool bIsAvailable, FString Error);
};

enum class EARAltitudeSource {
    Precise = 0,
    Coarse = 1,
    UserDefined = 2,
    Unknown = 3,
    EARAltitudeSource_MAX = 4,
};

enum class EARCandidateImageOrientation {
    Landscape = 0,
    Portrait = 1,
    EARCandidateImageOrientation_MAX = 2,
};

enum class EARCaptureType {
    Camera = 0,
    QRCode = 1,
    SpatialMapping = 2,
    SceneUnderstanding = 3,
    HandMesh = 4,
    EARCaptureType_MAX = 5,
};

enum class EARDepthAccuracy {
    Unkown = 0,
    Approximate = 1,
    Accurate = 2,
    EARDepthAccuracy_MAX = 3,
};

enum class EARDepthQuality {
    Unkown = 0,
    Low = 1,
    High = 2,
    EARDepthQuality_MAX = 3,
};

enum class EAREnvironmentCaptureProbeType {
    None = 0,
    Manual = 1,
    Automatic = 2,
    EAREnvironmentCaptureProbeType_MAX = 3,
};

enum class EAREye {
    LeftEye = 0,
    RightEye = 1,
    EAREye_MAX = 2,
};

enum class EARFaceBlendShape {
    EyeBlinkLeft = 0,
    EyeLookDownLeft = 1,
    EyeLookInLeft = 2,
    EyeLookOutLeft = 3,
    EyeLookUpLeft = 4,
    EyeSquintLeft = 5,
    EyeWideLeft = 6,
    EyeBlinkRight = 7,
    EyeLookDownRight = 8,
    EyeLookInRight = 9,
    EyeLookOutRight = 10,
    EyeLookUpRight = 11,
    EyeSquintRight = 12,
    EyeWideRight = 13,
    JawForward = 14,
    JawLeft = 15,
    JawRight = 16,
    JawOpen = 17,
    MouthClose = 18,
    MouthFunnel = 19,
    MouthPucker = 20,
    MouthLeft = 21,
    MouthRight = 22,
    MouthSmileLeft = 23,
    MouthSmileRight = 24,
    MouthFrownLeft = 25,
    MouthFrownRight = 26,
    MouthDimpleLeft = 27,
    MouthDimpleRight = 28,
    MouthStretchLeft = 29,
    MouthStretchRight = 30,
    MouthRollLower = 31,
    MouthRollUpper = 32,
    MouthShrugLower = 33,
    MouthShrugUpper = 34,
    MouthPressLeft = 35,
    MouthPressRight = 36,
    MouthLowerDownLeft = 37,
    MouthLowerDownRight = 38,
    MouthUpperUpLeft = 39,
    MouthUpperUpRight = 40,
    BrowDownLeft = 41,
    BrowDownRight = 42,
    BrowInnerUp = 43,
    BrowOuterUpLeft = 44,
    BrowOuterUpRight = 45,
    CheekPuff = 46,
    CheekSquintLeft = 47,
    CheekSquintRight = 48,
    NoseSneerLeft = 49,
    NoseSneerRight = 50,
    TongueOut = 51,
    HeadYaw = 52,
    HeadPitch = 53,
    HeadRoll = 54,
    LeftEyeYaw = 55,
    LeftEyePitch = 56,
    LeftEyeRoll = 57,
    RightEyeYaw = 58,
    RightEyePitch = 59,
    RightEyeRoll = 60,
    MAX = 61,
};

enum class EARFaceTrackingDirection {
    FaceRelative = 0,
    FaceMirrored = 1,
    EARFaceTrackingDirection_MAX = 2,
};

enum class EARFaceTrackingUpdate {
    CurvesAndGeo = 0,
    CurvesOnly = 1,
    EARFaceTrackingUpdate_MAX = 2,
};

enum class EARFaceTransformMixing {
    ComponentOnly = 0,
    ComponentLocationTrackedRotation = 1,
    ComponentWithTracked = 2,
    TrackingOnly = 3,
    EARFaceTransformMixing_MAX = 4,
};

enum class EARFrameSyncMode {
    SyncTickWithCameraImage = 0,
    SyncTickWithoutCameraImage = 1,
    EARFrameSyncMode_MAX = 2,
};

enum class EARGeoTrackingAccuracy {
    Undetermined = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    EARGeoTrackingAccuracy_MAX = 4,
};

enum class EARGeoTrackingState {
    Initializing = 0,
    Localized = 1,
    Localizing = 2,
    NotAvailable = 3,
    EARGeoTrackingState_MAX = 4,
};

enum class EARGeoTrackingStateReason {
    None = 0,
    NotAvailableAtLocation = 1,
    NeedLocationPermissions = 2,
    DevicePointedTooLow = 3,
    WorldTrackingUnstable = 4,
    WaitingForLocation = 5,
    GeoDataNotLoaded = 6,
    VisualLocalizationFailed = 7,
    WaitingForAvailabilityCheck = 8,
    EARGeoTrackingStateReason_MAX = 9,
};

enum class EARJointTransformSpace {
    Model = 0,
    ParentJoint = 1,
    EARJointTransformSpace_MAX = 2,
};

enum class EARLightEstimationMode {
    None = 0,
    AmbientLightEstimate = 1,
    DirectionalLightEstimate = 2,
    EARLightEstimationMode_MAX = 3,
};

enum class EARLineTraceChannels {
    None = 0,
    FeaturePoint = 1,
    GroundPlane = 2,
    PlaneUsingExtent = 4,
    PlaneUsingBoundaryPolygon = 8,
    EARLineTraceChannels_MAX = 9,
};

enum class EARObjectClassification {
    NotApplicable = 0,
    Unknown = 1,
    Wall = 2,
    Ceiling = 3,
    Floor = 4,
    Table = 5,
    Seat = 6,
    Face = 7,
    Image = 8,
    World = 9,
    SceneObject = 10,
    HandMesh = 11,
    Door = 12,
    Window = 13,
    EARObjectClassification_MAX = 14,
};

enum class EARPlaneDetectionMode {
    None = 0,
    HorizontalPlaneDetection = 1,
    VerticalPlaneDetection = 2,
    EARPlaneDetectionMode_MAX = 3,
};

enum class EARPlaneOrientation {
    Horizontal = 0,
    Vertical = 1,
    Diagonal = 2,
    EARPlaneOrientation_MAX = 3,
};

enum class EARSceneReconstruction {
    None = 0,
    MeshOnly = 1,
    MeshWithClassification = 2,
    EARSceneReconstruction_MAX = 3,
};

enum class EARServiceAvailability {
    UnknownError = 0,
    UnknownChecking = 1,
    UnknownTimedOut = 2,
    UnsupportedDeviceNotCapable = 3,
    SupportedNotInstalled = 4,
    SupportedVersionTooOld = 5,
    SupportedInstalled = 6,
    EARServiceAvailability_MAX = 7,
};

enum class EARServiceInstallRequestResult {
    Installed = 0,
    DeviceNotCompatible = 1,
    UserDeclinedInstallation = 2,
    FatalError = 3,
    EARServiceInstallRequestResult_MAX = 4,
};

enum class EARServicePermissionRequestResult {
    Granted = 0,
    Denied = 1,
    EARServicePermissionRequestResult_MAX = 2,
};

enum class EARSessionConfigFlags {
    None = 0,
    GenerateMeshData = 1,
    RenderMeshDataInWireframe = 2,
    GenerateCollisionForMeshData = 4,
    GenerateNavMeshForMeshData = 8,
    UseMeshDataForOcclusion = 16,
    EARSessionConfigFlags_MAX = 17,
};

enum class EARSessionStatus {
    NotStarted = 0,
    Running = 1,
    NotSupported = 2,
    FatalError = 3,
    PermissionNotGranted = 4,
    UnsupportedConfiguration = 5,
    Other = 6,
    EARSessionStatus_MAX = 7,
};

enum class EARSessionTrackingFeature {
    None = 0,
    PoseDetection2D = 1,
    PersonSegmentation = 2,
    PersonSegmentationWithDepth = 3,
    SceneDepth = 4,
    SmoothedSceneDepth = 5,
    EARSessionTrackingFeature_MAX = 6,
};

enum class EARSessionType {
    None = 0,
    Orientation = 1,
    World = 2,
    Face = 3,
    Image = 4,
    ObjectScanning = 5,
    PoseTracking = 6,
    GeoTracking = 7,
    EARSessionType_MAX = 8,
};

enum class EARSpatialMeshUsageFlags {
    NotApplicable = 0,
    Visible = 1,
    Collision = 2,
    EARSpatialMeshUsageFlags_MAX = 3,
};

enum class EARTextureType {
    Unknown = 0,
    CameraImage = 1,
    CameraDepth = 2,
    EnvironmentCapture = 3,
    PersonSegmentationImage = 4,
    PersonSegmentationDepth = 5,
    SceneDepthMap = 6,
    SceneDepthConfidenceMap = 7,
    EARTextureType_MAX = 8,
};

enum class EARTrackingQuality {
    NotTracking = 0,
    OrientationOnly = 1,
    OrientationAndPosition = 2,
    EARTrackingQuality_MAX = 3,
};

enum class EARTrackingQualityReason {
    None = 0,
    Initializing = 1,
    Relocalizing = 2,
    ExcessiveMotion = 3,
    InsufficientFeatures = 4,
    InsufficientLight = 5,
    BadState = 6,
    EARTrackingQualityReason_MAX = 7,
};

enum class EARTrackingState {
    Unknown = 0,
    Tracking = 1,
    NotTracking = 2,
    StoppedTracking = 3,
    EARTrackingState_MAX = 4,
};

enum class EARWorldAlignment {
    Gravity = 0,
    GravityAndHeading = 1,
    Camera = 2,
    EARWorldAlignment_MAX = 3,
};

enum class EARWorldMappingState {
    NotAvailable = 0,
    StillMappingNotRelocalizable = 1,
    StillMappingRelocalizable = 2,
    Mapped = 3,
    EARWorldMappingState_MAX = 4,
};

enum class EFaceComponentDebugMode {
    None = 0,
    ShowEyeVectors = 1,
    ShowFaceMesh = 2,
    EFaceComponentDebugMode_MAX = 3,
};

enum class EGeoAnchorComponentDebugMode {
    None = 0,
    ShowGeoData = 1,
    EGeoAnchorComponentDebugMode_MAX = 2,
};

enum class EImageComponentDebugMode {
    None = 0,
    ShowDetectedImage = 1,
    EImageComponentDebugMode_MAX = 2,
};

enum class EPlaneComponentDebugMode {
    None = 0,
    ShowNetworkRole = 1,
    ShowClassification = 2,
    EPlaneComponentDebugMode_MAX = 3,
};

enum class EPoseComponentDebugMode {
    None = 0,
    ShowSkeleton = 1,
    EPoseComponentDebugMode_MAX = 2,
};

enum class EQRCodeComponentDebugMode {
    None = 0,
    ShowQRCode = 1,
    EQRCodeComponentDebugMode_MAX = 2,
};

// Size: 0xa8
class UGetGeoLocationAsyncTaskBlueprintProxy : public UARBaseAsyncTaskBlueprintProxy {
    /* 0x0058 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0068 */ FMulticastInlineDelegate OnFailed;

    static UGetGeoLocationAsyncTaskBlueprintProxy* GetGeoLocationAtWorldPosition(UObject* WorldContextObject, const FVector& WorldPosition);
    void GetGeoLocationDelegate__DelegateSignature(float Longitude, float Latitude, float Altitude, FString Error);
};

// Size: 0x18
struct FTrackedGeometryGroup {
    /* 0x0000 */ AARActor* ARActor;
    /* 0x0008 */ UARComponent* ARComponent;
    /* 0x0010 */ UARTrackedGeometry* TrackedGeometry;
};

// Size: 0x18
struct FAutomatedTestFilter {
    /* 0x0000 */ FString Contains;
    /* 0x0010 */ bool MatchFromStart;
};

// Size: 0x20
struct FAutomatedTestGroup {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ TArray<FAutomatedTestFilter> Filters;
};

// Size: 0xb0
struct FAutomatedTestPassResults {
    /* 0x0000 */ FString ClientDescriptor;
    /* 0x0010 */ FDateTime ReportCreatedOn;
    /* 0x0018 */ int32_t Succeeded;
    /* 0x001c */ int32_t SucceededWithWarnings;
    /* 0x0020 */ int32_t Failed;
    /* 0x0024 */ int32_t NotRun;
    /* 0x0028 */ int32_t InProcess;
    /* 0x002c */ float TotalDuration;
    /* 0x0030 */ bool ComparisonExported;
    /* 0x0038 */ FString ComparisonExportDirectory;
    /* 0x0048 */ TArray<FAutomatedTestResult> Tests;
};

// Size: 0x60
struct FAutomatedTestResult {
    /* 0x0010 */ FString TestDisplayName;
    /* 0x0020 */ FString FullTestPath;
    /* 0x0030 */ EAutomationState State;
    /* 0x0038 */ TArray<FAutomationExecutionEntry> Entries;
    /* 0x0048 */ int32_t Warnings;
    /* 0x004c */ int32_t Errors;
    /* 0x0050 */ TArray<FAutomationArtifact> Artifacts;
};

// Size: 0xc8
struct FAutomationArtifact {
    /* 0x0000 */ FGuid ID;
    /* 0x0010 */ FString Name;
    /* 0x0020 */ EAutomationArtifactType Type;
    /* 0x0028 */ TMap<FString, FString> Files;
};

// Size: 0x50
class UAutomationControllerSettings : public UObject {
    /* 0x0030 */ TArray<FAutomatedTestGroup> Groups;
    /* 0x0040 */ bool bSuppressLogErrors;
    /* 0x0041 */ bool bSuppressLogWarnings;
    /* 0x0042 */ bool bTreatLogWarningsAsTestErrors;
    /* 0x0044 */ float CheckTestIntervalSeconds;
    /* 0x0048 */ float GameInstanceLostTimerSeconds;
};

enum class EAutomationArtifactType {
    None = 0,
    Image = 1,
    Comparison = 2,
    EAutomationArtifactType_MAX = 3,
};

enum class EAutomationState {
    NotRun = 0,
    InProcess = 1,
    Fail = 2,
    Success = 3,
    NotEnoughParticipants = 4,
    EAutomationState_MAX = 5,
};

// Size: 0x128
struct FAutomationScreenshotMetadata {
    /* 0x0000 */ FString ScreenShotName;
    /* 0x0010 */ FString Context;
    /* 0x0020 */ FString TestName;
    /* 0x0030 */ FString Notes;
    /* 0x0040 */ FGuid ID;
    /* 0x0050 */ FString Commit;
    /* 0x0060 */ int32_t Width;
    /* 0x0064 */ int32_t Height;
    /* 0x0068 */ FString RHI;
    /* 0x0078 */ FString Platform;
    /* 0x0088 */ FString FeatureLevel;
    /* 0x0098 */ bool bIsStereo;
    /* 0x00a0 */ FString Vendor;
    /* 0x00b0 */ FString AdapterName;
    /* 0x00c0 */ FString AdapterInternalDriverVersion;
    /* 0x00d0 */ FString AdapterUserDriverVersion;
    /* 0x00e0 */ FString UniqueDeviceId;
    /* 0x00f0 */ float ResolutionQuality;
    /* 0x00f4 */ int32_t ViewDistanceQuality;
    /* 0x00f8 */ int32_t AntiAliasingQuality;
    /* 0x00fc */ int32_t ShadowQuality;
    /* 0x0100 */ int32_t PostProcessQuality;
    /* 0x0104 */ int32_t TextureQuality;
    /* 0x0108 */ int32_t EffectsQuality;
    /* 0x010c */ int32_t FoliageQuality;
    /* 0x0110 */ int32_t ShadingQuality;
    /* 0x0114 */ bool bHasComparisonRules;
    /* 0x0115 */ uint8_t ToleranceRed;
    /* 0x0116 */ uint8_t ToleranceGreen;
    /* 0x0117 */ uint8_t ToleranceBlue;
    /* 0x0118 */ uint8_t ToleranceAlpha;
    /* 0x0119 */ uint8_t ToleranceMinBrightness;
    /* 0x011a */ uint8_t ToleranceMaxBrightness;
    /* 0x011c */ float MaximumLocalError;
    /* 0x0120 */ float MaximumGlobalError;
    /* 0x0124 */ bool bIgnoreAntiAliasing;
    /* 0x0125 */ bool bIgnoreColors;
};

// Size: 0x38
struct FAutomationWorkerFindWorkers {
    /* 0x0000 */ int32_t Changelist;
    /* 0x0008 */ FString GameName;
    /* 0x0018 */ FString ProcessName;
    /* 0x0028 */ FGuid SessionId;
};

// Size: 0x98
struct FAutomationWorkerFindWorkersResponse {
    /* 0x0000 */ FString DeviceName;
    /* 0x0010 */ FString InstanceName;
    /* 0x0020 */ FString Platform;
    /* 0x0030 */ FString OSVersionName;
    /* 0x0040 */ FString ModelName;
    /* 0x0050 */ FString GPUName;
    /* 0x0060 */ FString CPUModelName;
    /* 0x0070 */ uint32_t RAMInGB;
    /* 0x0078 */ FString RenderModeName;
    /* 0x0088 */ FGuid SessionId;
};

// Size: 0x38
struct FAutomationWorkerImageComparisonResults {
    /* 0x0000 */ FGuid UniqueId;
    /* 0x0010 */ bool bNew;
    /* 0x0011 */ bool bSimilar;
    /* 0x0018 */ double MaxLocalDifference;
    /* 0x0020 */ double GlobalDifference;
    /* 0x0028 */ FString ErrorMessage;
};

// Size: 0x1
struct FAutomationWorkerNextNetworkCommandReply {
};

// Size: 0x40
struct FAutomationWorkerPerformanceDataRequest {
    /* 0x0000 */ FString Platform;
    /* 0x0010 */ FString Hardware;
    /* 0x0020 */ FString TestName;
    /* 0x0030 */ TArray<double> DataPoints;
};

// Size: 0x18
struct FAutomationWorkerPerformanceDataResponse {
    /* 0x0000 */ bool bSuccess;
    /* 0x0008 */ FString ErrorMessage;
};

// Size: 0x1
struct FAutomationWorkerPing {
};

// Size: 0x1
struct FAutomationWorkerPong {
};

// Size: 0x4
struct FAutomationWorkerRequestNextNetworkCommand {
    /* 0x0000 */ uint32_t ExecutionCount;
};

// Size: 0x8
struct FAutomationWorkerRequestTests {
    /* 0x0000 */ bool DeveloperDirectoryIncluded;
    /* 0x0004 */ uint32_t RequestedTestFlags;
};

// Size: 0x10
struct FAutomationWorkerRequestTestsReplyComplete {
    /* 0x0000 */ TArray<FAutomationWorkerSingleTestReply> Tests;
};

// Size: 0x1
struct FAutomationWorkerResetTests {
};

// Size: 0x30
struct FAutomationWorkerRunTests {
    /* 0x0000 */ uint32_t ExecutionCount;
    /* 0x0004 */ int32_t RoleIndex;
    /* 0x0008 */ FString TestName;
    /* 0x0018 */ FString BeautifiedTestName;
    /* 0x0028 */ bool bSendAnalytics;
};

// Size: 0x38
struct FAutomationWorkerRunTestsReply {
    /* 0x0000 */ FString TestName;
    /* 0x0010 */ TArray<FAutomationExecutionEntry> Entries;
    /* 0x0020 */ int32_t WarningTotal;
    /* 0x0024 */ int32_t ErrorTotal;
    /* 0x0028 */ float Duration;
    /* 0x002c */ uint32_t ExecutionCount;
    /* 0x0030 */ bool Success;
};

// Size: 0x158
struct FAutomationWorkerScreenImage {
    /* 0x0000 */ TArray<uint8_t> ScreenImage;
    /* 0x0010 */ TArray<uint8_t> FrameTrace;
    /* 0x0020 */ FString ScreenShotName;
    /* 0x0030 */ FAutomationScreenshotMetadata MetaData;
};

// Size: 0x80
struct FAutomationWorkerSingleTestReply {
    /* 0x0000 */ FString DisplayName;
    /* 0x0010 */ FString FullTestPath;
    /* 0x0020 */ FString TestName;
    /* 0x0030 */ FString TestParameter;
    /* 0x0040 */ FString SourceFile;
    /* 0x0050 */ int32_t SourceFileLine;
    /* 0x0058 */ FString AssetPath;
    /* 0x0068 */ FString OpenCommand;
    /* 0x0078 */ uint32_t TestFlags;
    /* 0x007c */ uint32_t NumParticipantsRequired;
};

// Size: 0x1
struct FAutomationWorkerStopTests {
};

// Size: 0x50
struct FAutomationWorkerTestDataRequest {
    /* 0x0000 */ FString DataType;
    /* 0x0010 */ FString DataPlatform;
    /* 0x0020 */ FString DataTestName;
    /* 0x0030 */ FString DataName;
    /* 0x0040 */ FString JsonData;
};

// Size: 0x18
struct FAutomationWorkerTestDataResponse {
    /* 0x0000 */ FString JsonData;
    /* 0x0010 */ bool bIsNew;
};

// Size: 0x1
struct FAutomationWorkerWorkerOffline {
};

// Size: 0x30
class UAutomationUtilsBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void TakeGameplayAutomationScreenshot(const FString ScreenShotName, float MaxGlobalError, float MaxLocalError, FString MapNameOverride);
};

// Size: 0x88
class UScreenshotComparisonCommandlet : public UCommandlet {
};

// Size: 0x40
struct FAutomationTestPreset {
    /* 0x0008 */ FName ID;
    /* 0x0018 */ FText Name;
    /* 0x0030 */ TArray<FString> EnabledTests;
};

// Size: 0x88
class UAvfFileMediaSourceFactory : public UFactory {
};

// Size: 0x38
class UAvfMediaSettings : public UObject {
    /* 0x0030 */ bool NativeAudioOut;
};

// Size: 0xb0
class UBehaviorTreeDecoratorGraph : public UEdGraph {
};

// Size: 0xd0
class UBehaviorTreeDecoratorGraphNode : public UEdGraphNode {
};

// Size: 0x140
class UBehaviorTreeDecoratorGraphNode_Decorator : public UBehaviorTreeDecoratorGraphNode {
    /* 0x00d0 */ UObject* NodeInstance;
    /* 0x00d8 */ FGraphNodeClassData ClassData;
};

// Size: 0xd8
class UBehaviorTreeDecoratorGraphNode_Logic : public UBehaviorTreeDecoratorGraphNode {
    /* 0x00d0 */ uint8_t LogicMode;
};

// Size: 0x30
class UBehaviorTreeEditorTypes : public UObject {
};

// Size: 0x88
class UBehaviorTreeFactory : public UFactory {
};

// Size: 0xc0
class UBehaviorTreeGraph : public UAIGraph {
    /* 0x00b8 */ int32_t ModCounter;
    /* 0x00bc */ bool bIsUsingModCounter;
};

// Size: 0x1a8
class UBehaviorTreeGraphNode : public UAIGraphNode {
    /* 0x0168 */ TArray<UBehaviorTreeGraphNode*> Decorators;
    /* 0x0178 */ TArray<UBehaviorTreeGraphNode*> Services;
    /* 0x0188 */ bool bInjectedNode;
};

// Size: 0x1a8
class UBehaviorTreeGraphNode_Composite : public UBehaviorTreeGraphNode {
};

// Size: 0x1e8
class UBehaviorTreeGraphNode_CompositeDecorator : public UBehaviorTreeGraphNode {
    /* 0x01a8 */ UEdGraph* BoundGraph;
    /* 0x01b0 */ FString CompositeName;
    /* 0x01c0 */ bool bShowOperations;
    /* 0x01c0 */ bool bCanAbortFlow;
    /* 0x01c8 */ UBTCompositeNode* ParentNodeInstance;
    /* 0x01d8 */ FString CachedDescription;
};

// Size: 0x1a8
class UBehaviorTreeGraphNode_Decorator : public UBehaviorTreeGraphNode {
};

// Size: 0x1b0
class UBehaviorTreeGraphNode_Root : public UBehaviorTreeGraphNode {
    /* 0x01a8 */ UBlackboardData* BlackboardAsset;
};

// Size: 0x1a8
class UBehaviorTreeGraphNode_Service : public UBehaviorTreeGraphNode {
};

// Size: 0x1a8
class UBehaviorTreeGraphNode_SimpleParallel : public UBehaviorTreeGraphNode_Composite {
};

// Size: 0x1c0
class UBehaviorTreeGraphNode_SubtreeTask : public UBehaviorTreeGraphNode_Task {
};

// Size: 0x1a8
class UBehaviorTreeGraphNode_Task : public UBehaviorTreeGraphNode {
};

// Size: 0x100
struct FBehaviorTreeSchemaAction_AutoArrange : public FEdGraphSchemaAction {
};

// Size: 0x88
class UBlackboardDataFactory : public UFactory {
};

// Size: 0x108
struct FDecoratorSchemaAction_NewNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UBehaviorTreeDecoratorGraphNode* NodeTemplate;
};

enum class EDecoratorLogicMode {
    Sink = 0,
    And = 1,
    Or = 2,
    Not = 3,
    EDecoratorLogicMode_MAX = 4,
};

// Size: 0x30
class UEdGraphSchema_BehaviorTree : public UAIGraphSchema {
};

// Size: 0x40
class UEdGraphSchema_BehaviorTreeDecorator : public UEdGraphSchema {
    /* 0x0030 */ FString PC_Boolean;
};

// Size: 0x3a0
class ABlank4_27GameModeBase : public AGameModeBase {
};

// Size: 0x160
class UBlueprintBoundEventNodeSpawner : public UBlueprintEventNodeSpawner {
    /* 0x0130 */ FFieldPath EventDelegate;
};

// Size: 0x148
class UBlueprintBoundNodeSpawner : public UBlueprintNodeSpawner {
};

// Size: 0x50
struct FBlueprintCallableFunctionRedirect {
    /* 0x0000 */ FString ClassName;
    /* 0x0010 */ FString OldFunctionName;
    /* 0x0020 */ FString NewFunctionName;
    /* 0x0030 */ FString BlueprintParamName;
    /* 0x0040 */ FString ClassParamName;
};

// Size: 0x140
class UBlueprintComponentNodeSpawner : public UBlueprintNodeSpawner {
    /* 0x0118 */ UClass* ComponentClass;
    /* 0x0120 */ FString ComponentName;
    /* 0x0130 */ FString ComponentAssetName;
};

// Size: 0x168
class UBlueprintDelegateNodeSpawner : public UBlueprintFieldNodeSpawner {
};

// Size: 0x128
class UBlueprintEditorSettings : public UObject {
    /* 0x0030 */ bool bDrawMidpointArrowsInBlueprints;
    /* 0x0031 */ bool bShowGraphInstructionText;
    /* 0x0032 */ bool bHideUnrelatedNodes;
    /* 0x0033 */ bool bShowShortTooltips;
    /* 0x0034 */ bool bSplitContextTargetSettings;
    /* 0x0035 */ bool bExposeAllMemberComponentFunctions;
    /* 0x0036 */ bool bShowContextualFavorites;
    /* 0x0037 */ bool bExposeDeprecatedFunctions;
    /* 0x0038 */ bool bCompactCallOnMemberNodes;
    /* 0x0039 */ bool bFlattenFavoritesMenus;
    /* 0x003a */ bool bFavorPureCastNodes;
    /* 0x003b */ bool bAutoCastObjectConnections;
    /* 0x003c */ bool bShowViewportOnSimulate;
    /* 0x003d */ bool bShowInheritedVariables;
    /* 0x003e */ bool bAlwaysShowInterfacesInOverrides;
    /* 0x003f */ bool bShowParentClassInOverrides;
    /* 0x0040 */ bool bShowEmptySections;
    /* 0x0041 */ bool bShowAccessSpecifier;
    /* 0x0042 */ bool bSpawnDefaultBlueprintNodes;
    /* 0x0043 */ bool bHideConstructionScriptComponentsInDetailsView;
    /* 0x0044 */ bool bHostFindInBlueprintsInGlobalTab;
    /* 0x0045 */ bool bNavigateToNativeFunctionsFromCallNodes;
    /* 0x0048 */ TMap<FGuid, FEditedDocumentInfo> Bookmarks;
    /* 0x0098 */ TArray<FBPEditorBookmarkNode> BookmarkNodes;
    /* 0x00a8 */ bool bIncludeCommentNodesInBookmarksTab;
    /* 0x00a9 */ bool bShowBookmarksForCurrentDocumentOnlyInTab;
    /* 0x00b0 */ TMap<int32_t, FEditedDocumentInfo> GraphEditorQuickJumps;
    /* 0x0100 */ uint8_t SaveOnCompile;
    /* 0x0101 */ bool bJumpToNodeErrors;
    /* 0x0102 */ bool bAllowExplicitImpureNodeDisabling;
    /* 0x0103 */ bool bShowActionMenuItemSignatures;
    /* 0x0104 */ bool bBlueprintNodeUniqueNames;
    /* 0x0108 */ TArray<FString> NamespacesToAlwaysInclude;
    /* 0x0118 */ bool bShowDetailedCompileResults;
    /* 0x011c */ int32_t CompileEventDisplayThresholdMs;
    /* 0x0120 */ float NodeTemplateCacheCapMB;
};

// Size: 0x130
class UBlueprintEventNodeSpawner : public UBlueprintNodeSpawner {
    /* 0x0118 */ UFunction* EventFunc;
    /* 0x0120 */ FName CustomEventName;
};

// Size: 0x168
class UBlueprintFieldNodeSpawner : public UBlueprintNodeSpawner {
    /* 0x0128 */ UClass* OwnerClass;
    /* 0x0130 */ UField* Field;
    /* 0x0138 */ FFieldPath Property;
};

// Size: 0x168
class UBlueprintFunctionNodeSpawner : public UBlueprintFieldNodeSpawner {
};

// Size: 0x118
class UBlueprintNodeSpawner : public UObject {
    /* 0x0038 */ UClass* NodeClass;
};

// Size: 0x260
class UBlueprintVariableNodeSpawner : public UBlueprintFieldNodeSpawner {
    /* 0x0168 */ UEdGraph* LocalVarOuter;
    /* 0x0170 */ FBPVariableDescription LocalVarDesc;
};

// Size: 0x1c
struct FCustomPin {
    /* 0x0000 */ FName PinName;
    /* 0x000c */ FName CallFuncPinName;
    /* 0x0018 */ bool bValuePin;
};

enum class EEdGraphSchemaAction_K2Graph {
    Graph = 0,
    Subgraph = 1,
    Function = 2,
    Interface = 3,
    Macro = 4,
    MAX = 5,
};

enum class ESaveOnCompile {
    SoC_Never = 0,
    SoC_SuccessOnly = 1,
    SoC_Always = 2,
    SoC_MAX = 3,
};

enum class ESelfContextInfo {
    Unspecified = 0,
    NotSelfContext = 1,
    ESelfContextInfo_MAX = 2,
};

enum class ETunnelBoundaryType {
    Unknown = 0,
    EntrySite = 1,
    InputSite = 2,
    OutputSite = 3,
    ETunnelBoundaryType_MAX = 4,
};

// Size: 0x118
struct FEdGraphSchemaAction_BlueprintVariableBase : public FEdGraphSchemaAction {
};

// Size: 0x108
struct FEdGraphSchemaAction_EventFromFunction : public FEdGraphSchemaAction {
    /* 0x0100 */ UFunction* SignatureFunction;
};

// Size: 0x120
struct FEdGraphSchemaAction_K2AddCallOnActor : public FEdGraphSchemaAction_K2NewNode {
    /* 0x0110 */ TArray<AActor*> LevelActors;
};

// Size: 0x100
struct FEdGraphSchemaAction_K2AddComment : public FEdGraphSchemaAction {
};

// Size: 0x120
struct FEdGraphSchemaAction_K2AddComponent : public FEdGraphSchemaAction_K2NewNode {
    /* 0x0110 */ UClass* ComponentClass;
    /* 0x0118 */ UObject* ComponentAsset;
};

// Size: 0x110
struct FEdGraphSchemaAction_K2AddCustomEvent : public FEdGraphSchemaAction_K2NewNode {
};

// Size: 0x110
struct FEdGraphSchemaAction_K2AddEvent : public FEdGraphSchemaAction_K2NewNode {
};

// Size: 0x110
struct FEdGraphSchemaAction_K2AssignDelegate : public FEdGraphSchemaAction_K2NewNode {
};

// Size: 0x120
struct FEdGraphSchemaAction_K2Delegate : public FEdGraphSchemaAction_BlueprintVariableBase {
};

// Size: 0x108
struct FEdGraphSchemaAction_K2Enum : public FEdGraphSchemaAction {
};

// Size: 0x110
struct FEdGraphSchemaAction_K2Event : public FEdGraphSchemaAction_K2TargetNode {
};

// Size: 0x118
struct FEdGraphSchemaAction_K2Graph : public FEdGraphSchemaAction {
};

// Size: 0x110
struct FEdGraphSchemaAction_K2InputAction : public FEdGraphSchemaAction_K2TargetNode {
};

// Size: 0x118
struct FEdGraphSchemaAction_K2LocalVar : public FEdGraphSchemaAction_BlueprintVariableBase {
};

// Size: 0x110
struct FEdGraphSchemaAction_K2NewNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UK2Node* NodeTemplate;
    /* 0x0108 */ bool bGotoNode;
};

// Size: 0x100
struct FEdGraphSchemaAction_K2PasteHere : public FEdGraphSchemaAction {
};

// Size: 0x108
struct FEdGraphSchemaAction_K2Struct : public FEdGraphSchemaAction {
};

// Size: 0x110
struct FEdGraphSchemaAction_K2TargetNode : public FEdGraphSchemaAction_K2NewNode {
};

// Size: 0x118
struct FEdGraphSchemaAction_K2Var : public FEdGraphSchemaAction_BlueprintVariableBase {
};

// Size: 0x108
struct FEdGraphSchemaAction_K2ViewNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UK2Node* NodePtr;
};

// Size: 0x40
class UEdGraphSchema_K2 : public UEdGraphSchema {
    /* 0x0030 */ TArray<FBlueprintCallableFunctionRedirect> EditoronlyBPFunctionRedirects;
};

// Size: 0xc8
class UK2Node : public UEdGraphNode {
};

// Size: 0x1b0
class UK2Node_ActorBoundEvent : public UK2Node_Event {
    /* 0x0170 */ FName DelegatePropertyName;
    /* 0x0180 */ UClass* DelegateOwnerClass;
    /* 0x0188 */ AActor* EventOwner;
};

// Size: 0x178
class UK2Node_AddComponent : public UK2Node_CallFunction {
    /* 0x0158 */ bool bHasExposedVariable;
    /* 0x0160 */ FString TemplateBlueprint;
    /* 0x0170 */ UClass* TemplateType;
};

// Size: 0x100
class UK2Node_AddComponentByClass : public UK2Node_ConstructObjectFromClass {
};

// Size: 0x120
class UK2Node_AddDelegate : public UK2Node_BaseMCDelegate {
};

// Size: 0x30
class IK2Node_AddPinInterface : public UInterface {
};

// Size: 0x140
class UK2Node_AssignDelegate : public UK2Node_AddDelegate {
};

// Size: 0xc8
class UK2Node_AssignmentStatement : public UK2Node {
};

// Size: 0xf8
class UK2Node_AsyncAction : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_BaseAsyncTask : public UK2Node {
    /* 0x00c8 */ FName ProxyFactoryFunctionName;
    /* 0x00d8 */ UClass* ProxyFactoryClass;
    /* 0x00e0 */ UClass* ProxyClass;
    /* 0x00e8 */ FName ProxyActivateFunctionName;
};

// Size: 0x120
class UK2Node_BaseMCDelegate : public UK2Node {
    /* 0x00c8 */ FMemberReference DelegateReference;
};

// Size: 0xd8
class UK2Node_BitmaskLiteral : public UK2Node {
    /* 0x00d0 */ UEnum* BitflagsEnum;
};

// Size: 0x1d0
class UK2Node_BreakStruct : public UK2Node_StructMemberGet {
    /* 0x0188 */ bool bMadeAfterOverridePinRemoval;
};

// Size: 0x158
class UK2Node_CallArrayFunction : public UK2Node_CallFunction {
};

// Size: 0x158
class UK2Node_CallDataTableFunction : public UK2Node_CallFunction {
};

// Size: 0x120
class UK2Node_CallDelegate : public UK2Node_BaseMCDelegate {
};

// Size: 0x158
class UK2Node_CallFunction : public UK2Node {
    /* 0x00c8 */ bool bIsPureFunc;
    /* 0x00c8 */ bool bIsConstFunc;
    /* 0x00c8 */ bool bWantsEnumToExecExpansion;
    /* 0x00c8 */ bool bIsInterfaceCall;
    /* 0x00c8 */ bool bIsFinalFunction;
    /* 0x00c8 */ bool bIsBeadFunction;
    /* 0x00d0 */ FMemberReference FunctionReference;
    /* 0x0108 */ FName CallFunctionName;
    /* 0x0118 */ UClass* CallFunctionClass;
};

// Size: 0x190
class UK2Node_CallFunctionOnMember : public UK2Node_CallFunction {
    /* 0x0158 */ FMemberReference MemberVariableToCallOn;
};

// Size: 0x158
class UK2Node_CallMaterialParameterCollectionFunction : public UK2Node_CallFunction {
};

// Size: 0x158
class UK2Node_CallParentFunction : public UK2Node_CallFunction {
};

// Size: 0xf8
class UK2Node_CastByteToEnum : public UK2Node {
    /* 0x00c8 */ UEnum* Enum;
    /* 0x00d0 */ bool bSafe;
};

// Size: 0xf8
class UK2Node_ClassDynamicCast : public UK2Node_DynamicCast {
};

// Size: 0x120
class UK2Node_ClearDelegate : public UK2Node_BaseMCDelegate {
};

// Size: 0x168
class UK2Node_CommutativeAssociativeBinaryOperator : public UK2Node_CallFunction {
    /* 0x0160 */ int32_t NumAdditionalInputs;
};

// Size: 0x1d0
class UK2Node_ComponentBoundEvent : public UK2Node_Event {
    /* 0x0170 */ FName DelegatePropertyName;
    /* 0x0180 */ UClass* DelegateOwnerClass;
    /* 0x0188 */ FName ComponentPropertyName;
    /* 0x0198 */ FText DelegatePropertyDisplayName;
};

// Size: 0x1b8
class UK2Node_Composite : public UK2Node_Tunnel {
    /* 0x0190 */ UEdGraph* BoundGraph;
};

// Size: 0x100
class UK2Node_ConstructObjectFromClass : public UK2Node {
};

// Size: 0xc8
class UK2Node_ConvertAsset : public UK2Node {
};

// Size: 0xc8
class UK2Node_Copy : public UK2Node {
};

// Size: 0xe8
class UK2Node_CreateDelegate : public UK2Node {
    /* 0x00c8 */ FName SelectedFunctionName;
    /* 0x00d4 */ FGuid SelectedFunctionGuid;
};

// Size: 0x230
class UK2Node_CustomEvent : public UK2Node_Event {
    /* 0x0170 */ FString DeprecationMessage;
    /* 0x0180 */ bool bIsDeprecated;
    /* 0x0181 */ bool bCallInEditor;
    /* 0x01a8 */ FKismetUserDeclaredFunctionMetadata MetaData;
};

// Size: 0xc8
class UK2Node_DeadClass : public UK2Node {
};

// Size: 0x120
class UK2Node_DelegateSet : public UK2Node {
    /* 0x00c8 */ FName DelegatePropertyName;
    /* 0x00d8 */ UClass* DelegatePropertyClass;
};

// Size: 0xe0
class UK2Node_DoOnceMultiInput : public UK2Node {
    /* 0x00d0 */ int32_t NumAdditionalInputs;
    /* 0x00d8 */ UK2Node_TemporaryVariable* DataNode;
};

// Size: 0xf8
class UK2Node_DynamicCast : public UK2Node {
    /* 0x00c8 */ UClass* TargetType;
    /* 0x00f0 */ bool bIsPureCast;
};

// Size: 0xf8
class UK2Node_EaseFunction : public UK2Node {
    /* 0x00c8 */ FName EaseFunctionName;
};

// Size: 0xe0
class UK2Node_EditablePinBase : public UK2Node {
    /* 0x00c8 */ bool bIsEditable;
};

// Size: 0x158
class UK2Node_EditorPropertyAccessBase : public UK2Node_CallFunction {
};

// Size: 0xc8
class UK2Node_EnumEquality : public UK2Node {
};

// Size: 0xc8
class UK2Node_EnumInequality : public UK2Node_EnumEquality {
};

// Size: 0xf8
class UK2Node_EnumLiteral : public UK2Node {
    /* 0x00d0 */ UEnum* Enum;
};

// Size: 0x170
class UK2Node_Event : public UK2Node_EditablePinBase {
    /* 0x00e8 */ FName EventSignatureName;
    /* 0x00f8 */ UClass* EventSignatureClass;
    /* 0x0100 */ FMemberReference EventReference;
    /* 0x0138 */ bool bOverrideFunction;
    /* 0x0138 */ bool bInternalEvent;
    /* 0x013c */ FName CustomFunctionName;
    /* 0x0148 */ uint32_t FunctionFlags;
};

// Size: 0x30
class IK2Node_EventNodeInterface : public UInterface {
};

// Size: 0xd0
class UK2Node_ExecutionSequence : public UK2Node {
};

// Size: 0xf0
class UK2Node_ForEachElementInEnum : public UK2Node {
    /* 0x00c8 */ UEnum* Enum;
};

// Size: 0xf8
class UK2Node_FormatText : public UK2Node {
    /* 0x00c8 */ TArray<FName> PinNames;
};

// Size: 0x1f8
class UK2Node_FunctionEntry : public UK2Node_FunctionTerminator {
    /* 0x0130 */ FName CustomGeneratedFunctionName;
    /* 0x0140 */ FKismetUserDeclaredFunctionMetadata MetaData;
    /* 0x01c8 */ TArray<FBPVariableDescription> LocalVariables;
    /* 0x01d8 */ bool bEnforceConstCorrectness;
    /* 0x01dc */ int32_t ExtraFlags;
};

// Size: 0x130
class UK2Node_FunctionResult : public UK2Node_FunctionTerminator {
};

// Size: 0x130
class UK2Node_FunctionTerminator : public UK2Node_EditablePinBase {
    /* 0x00e0 */ FMemberReference FunctionReference;
    /* 0x0118 */ UClass* SignatureClass;
    /* 0x0120 */ FName SignatureName;
};

// Size: 0x100
class UK2Node_GenericCreateObject : public UK2Node_ConstructObjectFromClass {
};

// Size: 0xd0
class UK2Node_GetArrayItem : public UK2Node {
    /* 0x00c8 */ bool bReturnByRefDesired;
};

// Size: 0x108
class UK2Node_GetClassDefaults : public UK2Node {
    /* 0x00c8 */ UBlueprint* BlueprintSubscribedTo;
    /* 0x00e0 */ TArray<FOptionalPinFromProperty> ShowPinForProperties;
    /* 0x0100 */ bool bExcludeObjectContainers;
    /* 0x0101 */ bool bExcludeObjectArrays;
};

// Size: 0x100
class UK2Node_GetDataTableRow : public UK2Node {
};

// Size: 0x158
class UK2Node_GetEditorProperty : public UK2Node_EditorPropertyAccessBase {
};

// Size: 0xd0
class UK2Node_GetEditorSubsystem : public UK2Node_GetSubsystem {
};

// Size: 0xd0
class UK2Node_GetEngineSubsystem : public UK2Node_GetSubsystem {
};

// Size: 0xc8
class UK2Node_GetEnumeratorName : public UK2Node {
};

// Size: 0xc8
class UK2Node_GetEnumeratorNameAsString : public UK2Node_GetEnumeratorName {
};

// Size: 0x1c0
class UK2Node_GetInputAxisKeyValue : public UK2Node_CallFunction {
    /* 0x0158 */ FKey InputAxisKey;
    /* 0x0178 */ bool bConsumeInput;
    /* 0x0178 */ bool bExecuteWhenPaused;
};

// Size: 0x1a8
class UK2Node_GetInputAxisValue : public UK2Node_CallFunction {
    /* 0x0158 */ FName InputAxisName;
    /* 0x0164 */ bool bConsumeInput;
    /* 0x0164 */ bool bExecuteWhenPaused;
};

// Size: 0x1c0
class UK2Node_GetInputVectorAxisValue : public UK2Node_GetInputAxisKeyValue {
};

// Size: 0x118
class UK2Node_GetNumEnumEntries : public UK2Node {
    /* 0x00d0 */ UEnum* Enum;
};

// Size: 0xd0
class UK2Node_GetSubsystem : public UK2Node {
    /* 0x00c8 */ UClass* CustomClass;
};

// Size: 0xd0
class UK2Node_GetSubsystemFromPC : public UK2Node_GetSubsystem {
};

// Size: 0xc8
class UK2Node_IfThenElse : public UK2Node {
};

// Size: 0x120
class UK2Node_InputAction : public UK2Node {
    /* 0x00d0 */ FName InputActionName;
    /* 0x00dc */ bool bConsumeInput;
    /* 0x00dc */ bool bExecuteWhenPaused;
    /* 0x00dc */ bool bOverrideParentBinding;
};

// Size: 0x188
class UK2Node_InputActionEvent : public UK2Node_Event {
    /* 0x0170 */ FName InputActionName;
    /* 0x017c */ uint8_t InputKeyEvent;
    /* 0x0180 */ bool bConsumeInput;
    /* 0x0180 */ bool bExecuteWhenPaused;
    /* 0x0180 */ bool bOverrideParentBinding;
};

// Size: 0x1c0
class UK2Node_InputAxisEvent : public UK2Node_Event {
    /* 0x0170 */ FName InputAxisName;
    /* 0x017c */ bool bConsumeInput;
    /* 0x017c */ bool bExecuteWhenPaused;
    /* 0x017c */ bool bOverrideParentBinding;
};

// Size: 0x1b8
class UK2Node_InputAxisKeyEvent : public UK2Node_Event {
    /* 0x0170 */ FKey AxisKey;
    /* 0x0190 */ bool bConsumeInput;
    /* 0x0190 */ bool bExecuteWhenPaused;
    /* 0x0190 */ bool bOverrideParentBinding;
};

// Size: 0x138
class UK2Node_InputKey : public UK2Node {
    /* 0x00d0 */ FKey InputKey;
    /* 0x00f0 */ bool bConsumeInput;
    /* 0x00f0 */ bool bExecuteWhenPaused;
    /* 0x00f0 */ bool bOverrideParentBinding;
    /* 0x00f0 */ bool bControl;
    /* 0x00f0 */ bool bAlt;
    /* 0x00f0 */ bool bShift;
    /* 0x00f0 */ bool bCommand;
};

// Size: 0x1a0
class UK2Node_InputKeyEvent : public UK2Node_Event {
    /* 0x0170 */ FInputChord InputChord;
    /* 0x0198 */ uint8_t InputKeyEvent;
    /* 0x019c */ bool bConsumeInput;
    /* 0x019c */ bool bExecuteWhenPaused;
    /* 0x019c */ bool bOverrideParentBinding;
};

// Size: 0xd8
class UK2Node_InputTouch : public UK2Node {
    /* 0x00d0 */ bool bConsumeInput;
    /* 0x00d0 */ bool bExecuteWhenPaused;
    /* 0x00d0 */ bool bOverrideParentBinding;
};

// Size: 0x178
class UK2Node_InputTouchEvent : public UK2Node_Event {
    /* 0x0170 */ uint8_t InputKeyEvent;
    /* 0x0171 */ bool bConsumeInput;
    /* 0x0171 */ bool bExecuteWhenPaused;
    /* 0x0171 */ bool bOverrideParentBinding;
};

// Size: 0x1b8
class UK2Node_InputVectorAxisEvent : public UK2Node_InputAxisKeyEvent {
};

// Size: 0xd0
class UK2Node_Knot : public UK2Node {
};

// Size: 0xd0
class UK2Node_Literal : public UK2Node {
    /* 0x00c8 */ UObject* ObjectRef;
};

// Size: 0xc8
class UK2Node_LoadAsset : public UK2Node {
};

// Size: 0xc8
class UK2Node_LoadAssetClass : public UK2Node_LoadAsset {
};

// Size: 0x1a8
class UK2Node_LocalVariable : public UK2Node_TemporaryVariable {
    /* 0x0180 */ FName CustomVariableName;
    /* 0x0190 */ FText VariableTooltip;
};

// Size: 0x250
class UK2Node_MacroInstance : public UK2Node_Tunnel {
    /* 0x0190 */ UEdGraph* MacroGraph;
    /* 0x0198 */ FGraphReference MacroGraphReference;
    /* 0x01b8 */ FEdGraphPinType ResolvedWildcardType;
};

// Size: 0xd8
class UK2Node_MakeArray : public UK2Node_MakeContainer {
};

// Size: 0xd8
class UK2Node_MakeContainer : public UK2Node {
    /* 0x00d0 */ int32_t NumInputs;
};

// Size: 0xd8
class UK2Node_MakeMap : public UK2Node_MakeContainer {
};

// Size: 0xd8
class UK2Node_MakeSet : public UK2Node_MakeContainer {
};

// Size: 0x1d0
class UK2Node_MakeStruct : public UK2Node_StructMemberSet {
    /* 0x0188 */ bool bMadeAfterOverridePinRemoval;
};

// Size: 0x1b8
class UK2Node_MakeVariable : public UK2Node {
    /* 0x00c8 */ FBPVariableDescription VariableType;
};

// Size: 0x220
class UK2Node_MathExpression : public UK2Node_Composite {
    /* 0x01b8 */ FString Expression;
    /* 0x01c8 */ bool bMadeAfterRotChange;
};

// Size: 0xd0
class UK2Node_MatineeController : public UK2Node {
    /* 0x00c8 */ AMatineeActor* MatineeActor;
};

// Size: 0x1d8
class UK2Node_Message : public UK2Node_CallFunction {
};

// Size: 0xd8
class UK2Node_MultiGate : public UK2Node_ExecutionSequence {
    /* 0x00d0 */ UK2Node_TemporaryVariable* DataNode;
};

// Size: 0xc8
class UK2Node_PureAssignmentStatement : public UK2Node {
};

// Size: 0x120
class UK2Node_RemoveDelegate : public UK2Node_BaseMCDelegate {
};

// Size: 0x180
class UK2Node_Select : public UK2Node {
    /* 0x00d8 */ int32_t NumOptionPins;
    /* 0x00e0 */ FEdGraphPinType IndexPinType;
    /* 0x0150 */ UEnum* Enum;
    /* 0x0158 */ TArray<FName> EnumEntries;
    /* 0x0168 */ TArray<FText> EnumEntryFriendlyNames;
    /* 0x0178 */ bool bReconstructNode;
};

// Size: 0xc8
class UK2Node_Self : public UK2Node {
};

// Size: 0x158
class UK2Node_SetEditorProperty : public UK2Node_EditorPropertyAccessBase {
};

// Size: 0x218
class UK2Node_SetFieldsInStruct : public UK2Node_MakeStruct {
};

// Size: 0xc8
class UK2Node_SetVariableOnPersistentFrame : public UK2Node {
};

// Size: 0x100
class UK2Node_SpawnActor : public UK2Node {
};

// Size: 0x100
class UK2Node_SpawnActorFromClass : public UK2Node_ConstructObjectFromClass {
};

// Size: 0x188
class UK2Node_StructMemberGet : public UK2Node_StructOperation {
    /* 0x0128 */ TArray<FOptionalPinFromProperty> ShowPinForProperties;
};

// Size: 0x188
class UK2Node_StructMemberSet : public UK2Node_StructOperation {
    /* 0x0128 */ TArray<FOptionalPinFromProperty> ShowPinForProperties;
};

// Size: 0x128
class UK2Node_StructOperation : public UK2Node_Variable {
    /* 0x0120 */ UScriptStruct* StructType;
};

// Size: 0xe8
class UK2Node_Switch : public UK2Node {
    /* 0x00c8 */ bool bHasDefaultPin;
    /* 0x00cc */ FName FunctionName;
    /* 0x00d8 */ UClass* FunctionClass;
};

// Size: 0x138
class UK2Node_SwitchEnum : public UK2Node_Switch {
    /* 0x00f0 */ UEnum* Enum;
    /* 0x00f8 */ TArray<FName> EnumEntries;
    /* 0x0108 */ TArray<FText> EnumFriendlyNames;
};

// Size: 0xf0
class UK2Node_SwitchInteger : public UK2Node_Switch {
    /* 0x00e8 */ int32_t StartIndex;
};

// Size: 0xf8
class UK2Node_SwitchName : public UK2Node_Switch {
    /* 0x00e8 */ TArray<FName> PinNames;
};

// Size: 0x100
class UK2Node_SwitchString : public UK2Node_Switch {
    /* 0x00e8 */ TArray<FName> PinNames;
    /* 0x00f8 */ bool bIsCaseSensitive;
};

// Size: 0x180
class UK2Node_TemporaryVariable : public UK2Node {
    /* 0x00c8 */ FEdGraphPinType VariableType;
    /* 0x0138 */ bool bIsPersistent;
};

// Size: 0xf0
class UK2Node_Timeline : public UK2Node {
    /* 0x00c8 */ FName TimelineName;
    /* 0x00d4 */ bool bAutoPlay;
    /* 0x00d8 */ FGuid TimelineGuid;
    /* 0x00e8 */ bool bLoop;
    /* 0x00e8 */ bool bReplicated;
    /* 0x00e8 */ bool bIgnoreTimeDilation;
};

// Size: 0x190
class UK2Node_Tunnel : public UK2Node_EditablePinBase {
    /* 0x00e0 */ UK2Node_Tunnel* OutputSourceNode;
    /* 0x00e8 */ UK2Node_Tunnel* InputSinkNode;
    /* 0x00f0 */ bool bCanHaveInputs;
    /* 0x00f0 */ bool bCanHaveOutputs;
    /* 0x00f8 */ FKismetUserDeclaredFunctionMetadata MetaData;
};

// Size: 0xd8
class UK2Node_TunnelBoundary : public UK2Node {
    /* 0x00c8 */ FName BaseName;
    /* 0x00d4 */ ETunnelBoundaryType TunnelBoundaryType;
};

// Size: 0x120
class UK2Node_Variable : public UK2Node {
    /* 0x00c8 */ FMemberReference VariableReference;
    /* 0x0100 */ uint8_t SelfContextInfo;
    /* 0x0108 */ UClass* VariableSourceClass;
    /* 0x0110 */ FName VariableName;
    /* 0x011c */ bool bSelfContext;
};

// Size: 0x168
class UK2Node_VariableGet : public UK2Node_Variable {
    /* 0x0160 */ bool bIsPureGet;
};

// Size: 0x160
class UK2Node_VariableSet : public UK2Node_Variable {
};

// Size: 0xe8
class UK2Node_VariableSetRef : public UK2Node {
};

// Size: 0x88
struct FKismetUserDeclaredFunctionMetadata {
    /* 0x0000 */ FText Tooltip;
    /* 0x0018 */ FText Category;
    /* 0x0030 */ FText Keywords;
    /* 0x0048 */ FText CompactNodeTitle;
    /* 0x0060 */ FLinearColor InstanceTitleColor;
    /* 0x0070 */ FString DeprecationMessage;
    /* 0x0080 */ bool bIsDeprecated;
    /* 0x0081 */ bool bCallInEditor;
    /* 0x0082 */ int8_t HasLatentFunctions;
};

// Size: 0x30
class INodeDependingOnEnumInterface : public UInterface {
};

// Size: 0x48
struct FOptionalPinFromProperty {
    /* 0x0000 */ FName PropertyName;
    /* 0x0010 */ FString PropertyFriendlyName;
    /* 0x0020 */ FText PropertyTooltip;
    /* 0x0038 */ FName CategoryName;
    /* 0x0044 */ bool bShowPin;
    /* 0x0044 */ bool bCanToggleVisibility;
    /* 0x0044 */ bool bPropertyIsCustomized;
    /* 0x0044 */ bool bHasOverridePin;
    /* 0x0044 */ bool bIsMarkedForAdvancedDisplay;
    /* 0x0044 */ bool bIsOverrideEnabled;
    /* 0x0044 */ bool bIsSetValuePinVisible;
    /* 0x0044 */ bool bIsOverridePinVisible;
};

// Size: 0x98
struct FUserPinInfo {
    /* 0x0000 */ FName PinName;
    /* 0x0010 */ FEdGraphPinType PinType;
    /* 0x0080 */ uint8_t DesiredPinDirection;
    /* 0x0088 */ FString PinDefaultValue;
};

// Size: 0x158
struct FBlueprintNativeCodeGenManifest {
    /* 0x0000 */ int32_t ManifestChunkId;
    /* 0x0008 */ FString PluginName;
    /* 0x0018 */ FString OutputDir;
    /* 0x0028 */ TArray<UPackage*> ModuleDependencies;
    /* 0x0038 */ TMap<FName, FConvertedAssetRecord> ConvertedAssets;
    /* 0x0088 */ TMap<FName, FUnconvertedDependencyRecord> UnconvertedDependencies;
    /* 0x00d8 */ FCompilerNativizationOptions NativizationOptions;
};

// Size: 0x38
struct FConvertedAssetRecord {
    /* 0x0000 */ UClass* AssetType;
    /* 0x0008 */ FString TargetObjPath;
    /* 0x0018 */ FString GeneratedHeaderPath;
    /* 0x0028 */ FString GeneratedCppPath;
};

// Size: 0x10
struct FUnconvertedDependencyRecord {
    /* 0x0000 */ FString GeneratedWrapperPath;
};

// Size: 0x38
class UActorActionUtility : public UEditorUtilityObject {

    UClass* GetSupportedClass() const;
};

// Size: 0x38
class UAssetActionUtility : public UEditorUtilityObject {

    UClass* GetSupportedClass() const;
    bool IsActionForBlueprints() const;
};

// Size: 0x58
class UAsyncEditorDelay : public UEditorUtilityBlueprintAsyncActionBase {
    /* 0x0038 */ FMulticastInlineDelegate Complete;

    static UAsyncEditorDelay* AsyncEditorDelay(float Seconds, int32_t MinimumFrames);
};

// Size: 0x78
class UAsyncEditorOpenMapAndFocusActor : public UEditorUtilityBlueprintAsyncActionBase {
    /* 0x0038 */ FMulticastInlineDelegate Complete;

    static UAsyncEditorOpenMapAndFocusActor* AsyncEditorOpenMapAndFocusActor(FSoftObjectPath Map, FString FocusActorName);
};

// Size: 0x50
class UAsyncEditorWaitForGameWorld : public UEditorUtilityBlueprintAsyncActionBase {
    /* 0x0038 */ FMulticastInlineDelegate Complete;

    static UAsyncEditorWaitForGameWorld* AsyncWaitForGameWorld(int32_t index, bool Server);
};

// Size: 0x2f8
class AEditorUtilityActor : public AActor {

    void Run();
};

// Size: 0xc0
class UEditorUtilityActorComponent : public UActorComponent {
};

// Size: 0x4d8
class UEditorUtilityBlueprint : public UBlueprint {
};

// Size: 0x38
class UEditorUtilityBlueprintAsyncActionBase : public UBlueprintAsyncActionBase {
};

// Size: 0xa0
class UEditorUtilityBlueprintFactory : public UFactory {
    /* 0x0088 */ UClass* ParentClass;
};

// Size: 0x8c0
class AEditorUtilityCamera : public ACameraActor {
};

// Size: 0x30
class IEditorUtilityExtension : public UInterface {
};

// Size: 0x30
class UEditorUtilityLibrary : public UBlueprintFunctionLibrary {

    AActor* GetActorReference(FString PathToActor);
    static TArray<FAssetData> GetSelectedAssetData();
    static TArray<UObject*> GetSelectedAssets();
    static TArray<UClass*> GetSelectedBlueprintClasses();
    static void GetSelectionBounds(FVector& Origin, FVector& BoxExtent, float& SphereRadius);
    static TArray<AActor*> GetSelectionSet();
    static void RenameAsset(UObject* Asset, FString NewName);
};

// Size: 0x30
class UEditorUtilityObject : public UObject {

    void Run();
};

// Size: 0x190
class UEditorUtilitySubsystem : public UEditorSubsystem {
    /* 0x0038 */ TArray<FSoftObjectPath> LoadedUIs;
    /* 0x0048 */ TArray<FSoftObjectPath> StartupObjects;
    /* 0x00b8 */ TMap<UObject*, UObject*> ObjectInstances;
    /* 0x0120 */ TArray<UEditorUtilityTask*> PendingTasks;
    /* 0x0130 */ UEditorUtilityTask* ActiveTask;
    /* 0x0140 */ TSet<UObject*> ReferencedObjects;

    bool CanRun(UObject* Asset) const;
    bool CloseTabByID(FName NewTabID);
    bool DoesTabExist(FName NewTabID);
    UEditorUtilityWidget* FindUtilityWidgetFromBlueprint(UEditorUtilityWidgetBlueprint* InBlueprint);
    void RegisterAndExecuteTask(UEditorUtilityTask* NewTask);
    void RegisterTabAndGetID(UEditorUtilityWidgetBlueprint* InBlueprint, FName& NewTabID);
    void ReleaseInstanceOfAsset(UObject* Asset);
    UEditorUtilityWidget* SpawnAndRegisterTab(UEditorUtilityWidgetBlueprint* InBlueprint);
    UEditorUtilityWidget* SpawnAndRegisterTabAndGetID(UEditorUtilityWidgetBlueprint* InBlueprint, FName& NewTabID);
    bool SpawnRegisteredTabByID(FName NewTabID);
    bool TryRun(UObject* Asset);
};

// Size: 0x48
class UEditorUtilityTask : public UObject {
    /* 0x0030 */ UEditorUtilitySubsystem* MyTaskManager;
    /* 0x0038 */ bool bCancelRequested;

    void FinishExecutingTask();
    void ReceiveBeginExecution();
    void Run();
    void SetTaskNotificationText(const FText& text);
};

// Size: 0xe0
class UEditorUtilityToolMenuEntry : public UToolMenuEntryScript {
};

// Size: 0x30
class UEditorUtilityToolMenuSection : public UToolMenuSectionDynamic {
};

// Size: 0x410
class UEditorUtilityWidget : public UUserWidget {
    /* 0x03f8 */ FString HelpText;
    /* 0x0408 */ bool bAlwaysReregisterWithWindowsMenu;
    /* 0x0409 */ bool bAutoRunDefaultAction;

    void Run();
};

// Size: 0x568
class UEditorUtilityWidgetBlueprint : public UWidgetBlueprint {
    /* 0x0560 */ UEditorUtilityWidget* CreatedUMGWidget;
};

// Size: 0xa0
class UEditorUtilityWidgetBlueprintFactory : public UFactory {
    /* 0x0088 */ uint8_t BlueprintType;
    /* 0x0090 */ UClass* ParentClass;
};

// Size: 0x68
class UGlobalEditorUtilityBase : public UObject {
    /* 0x0030 */ FString HelpText;
    /* 0x0040 */ bool bDirtiedSelectionSet;
    /* 0x0041 */ bool bAutoRunDefaultAction;
    /* 0x0048 */ FMulticastInlineDelegate OnEachSelectedActor;
    /* 0x0058 */ FMulticastInlineDelegate OnEachSelectedAsset;

    void ClearActorSelectionSet();
    void ForEachSelectedActor();
    void ForEachSelectedAsset();
    AActor* GetActorReference(FString PathToActor);
    UEditorPerProjectUserSettings* GetEditorUserSettings();
    TArray<UObject*> GetSelectedAssets();
    void GetSelectionBounds(FVector& Origin, FVector& BoxExtent, float& SphereRadius);
    TArray<AActor*> GetSelectionSet();
    void OnDefaultActionClicked();
    void RenameAsset(UObject* Asset, FString NewName);
    void SelectNothing();
    void SetActorSelectionState(AActor* Actor, bool bShouldBeSelected);
};

// Size: 0x308
class APlacedEditorUtilityBase : public AActor {
    /* 0x02f8 */ FString HelpText;

    void ClearActorSelectionSet();
    AActor* GetActorReference(FString PathToActor);
    bool GetLevelViewportCameraInfo(FVector& CameraLocation, FRotator& CameraRotation);
    TArray<AActor*> GetSelectionSet();
    void SelectNothing();
    void SetActorSelectionState(AActor* Actor, bool bShouldBeSelected);
    void SetLevelViewportCameraInfo(FVector CameraLocation, FRotator CameraRotation);
};

// Size: 0x128
class UBuildPatchManifest : public UObject {
    /* 0x0030 */ uint8_t ManifestFileVersion;
    /* 0x0031 */ bool bIsFileData;
    /* 0x0034 */ uint32_t AppID;
    /* 0x0038 */ FString AppName;
    /* 0x0048 */ FString BuildVersion;
    /* 0x0058 */ FString LaunchExe;
    /* 0x0068 */ FString LaunchCommand;
    /* 0x0078 */ TSet<FString> PrereqIds;
    /* 0x00c8 */ FString PrereqName;
    /* 0x00d8 */ FString PrereqPath;
    /* 0x00e8 */ FString PrereqArgs;
    /* 0x00f8 */ TArray<FFileManifestData> FileManifestList;
    /* 0x0108 */ TArray<FChunkInfoData> ChunkList;
    /* 0x0118 */ TArray<FCustomFieldData> CustomFields;
};

// Size: 0x40
struct FChunkInfoData {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ uint64_t Hash;
    /* 0x0018 */ FSHAHashData ShaHash;
    /* 0x0030 */ int64_t FileSize;
    /* 0x0038 */ uint8_t GroupNumber;
};

// Size: 0x18
struct FChunkPartData {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ uint32_t Offset;
    /* 0x0014 */ uint32_t Size;
};

// Size: 0x20
struct FCustomFieldData {
    /* 0x0000 */ FString Key;
    /* 0x0010 */ FString Value;
};

// Size: 0x68
struct FFileManifestData {
    /* 0x0000 */ FString Filename;
    /* 0x0010 */ FSHAHashData FileHash;
    /* 0x0028 */ TArray<FChunkPartData> FileChunkParts;
    /* 0x0038 */ TArray<FString> InstallTags;
    /* 0x0048 */ bool bIsUnixExecutable;
    /* 0x0050 */ FString SymlinkTarget;
    /* 0x0060 */ bool bIsReadOnly;
    /* 0x0061 */ bool bIsCompressed;
};

// Size: 0x14
struct FSHAHashData {
    /* 0x0000 */ uint8_t Hash[20];
};

// Size: 0x300
class ACableActor : public AActor {
    /* 0x02f8 */ UCableComponent* CableComponent;
};

// Size: 0x5a0
class UCableComponent : public UMeshComponent {
    /* 0x0500 */ bool bAttachStart;
    /* 0x0501 */ bool bAttachEnd;
    /* 0x0508 */ FComponentReference AttachEndTo;
    /* 0x0538 */ FName AttachEndToSocketName;
    /* 0x0544 */ FVector EndLocation;
    /* 0x0550 */ float CableLength;
    /* 0x0554 */ int32_t NumSegments;
    /* 0x0558 */ float SubstepTime;
    /* 0x055c */ int32_t SolverIterations;
    /* 0x0560 */ bool bEnableStiffness;
    /* 0x0561 */ bool bUseSubstepping;
    /* 0x0562 */ bool bSkipCableUpdateWhenNotVisible;
    /* 0x0563 */ bool bSkipCableUpdateWhenNotOwnerRecentlyRendered;
    /* 0x0564 */ bool bEnableCollision;
    /* 0x0568 */ float CollisionFriction;
    /* 0x056c */ FVector CableForce;
    /* 0x0578 */ float CableGravityScale;
    /* 0x057c */ float CableWidth;
    /* 0x0580 */ int32_t NumSides;
    /* 0x0584 */ float TileMaterial;

    AActor* GetAttachedActor() const;
    USceneComponent* GetAttachedComponent() const;
    void GetCableParticleLocations(TArray<FVector>& Locations) const;
    void SetAttachEndTo(AActor* Actor, FName ComponentProperty, FName SocketName);
    void SetAttachEndToComponent(USceneComponent* Component, FName SocketName);
};

// Size: 0x2a10
class APreviewPlayerCameraManager : public APlayerCameraManager {
};

// Size: 0x68
struct FChaosSolverConfiguration {
    /* 0x0000 */ int32_t Iterations;
    /* 0x0004 */ int32_t CollisionPairIterations;
    /* 0x0008 */ int32_t PushOutIterations;
    /* 0x000c */ int32_t CollisionPushOutPairIterations;
    /* 0x0010 */ float CollisionMarginFraction;
    /* 0x0014 */ float CollisionMarginMax;
    /* 0x0018 */ float CollisionCullDistance;
    /* 0x001c */ int32_t JointPairIterations;
    /* 0x0020 */ int32_t JointPushOutPairIterations;
    /* 0x0024 */ float ClusterConnectionFactor;
    /* 0x0028 */ EClusterUnionMethod ClusterUnionConnectionType;
    /* 0x0029 */ bool bGenerateCollisionData;
    /* 0x002c */ FSolverCollisionFilterSettings CollisionFilterSettings;
    /* 0x003c */ bool bGenerateBreakData;
    /* 0x0040 */ FSolverBreakingFilterSettings BreakingFilterSettings;
    /* 0x0050 */ bool bGenerateTrailingData;
    /* 0x0054 */ FSolverTrailingFilterSettings TrailingFilterSettings;
    /* 0x0064 */ bool bGenerateContactGraph;
};

enum class EChaosBufferMode {
    Double = 0,
    Triple = 1,
    Num = 2,
    Invalid = 3,
    EChaosBufferMode_MAX = 4,
};

enum class EChaosSolverTickMode {
    Fixed = 0,
    Variable = 1,
    VariableCapped = 2,
    VariableCappedWithTarget = 3,
    EChaosSolverTickMode_MAX = 4,
};

enum class EChaosThreadingMode {
    DedicatedThread = 0,
    TaskGraph = 1,
    SingleThread = 2,
    Num = 3,
    Invalid = 4,
    EChaosThreadingMode_MAX = 5,
};

enum class EClusterUnionMethod {
    PointImplicit = 0,
    DelaunayTriangulation = 1,
    MinimalSpanningSubsetDelaunayTriangulation = 2,
    PointImplicitAugmentedWithMinimalDelaunay = 3,
    None = 4,
    EClusterUnionMethod_MAX = 5,
};

enum class ECollisionTypeEnum {
    Chaos_Volumetric = 0,
    Chaos_Surface_Volumetric = 1,
    Chaos_Max = 2,
    Chaos_Max = 3,
};

enum class EEmissionPatternTypeEnum {
    Chaos_Emission_Pattern_First_Frame = 0,
    Chaos_Emission_Pattern_On_Demand = 1,
    Chaos_Max = 2,
    Chaos_Max = 3,
};

enum class EFieldCullingOperationType {
    Field_Culling_Inside = 0,
    Field_Culling_Outside = 1,
    Field_Culling_Operation_Max = 2,
    Field_Culling_MAX = 3,
};

enum class EFieldFalloffType {
    Field_FallOff_None = 0,
    Field_Falloff_Linear = 1,
    Field_Falloff_Inverse = 2,
    Field_Falloff_Squared = 3,
    Field_Falloff_Logarithmic = 4,
    Field_Falloff_Max = 5,
};

enum class EFieldFilterType {
    Field_Filter_Dynamic = 0,
    Field_Filter_Kinematic = 1,
    Field_Filter_Static = 2,
    Field_Filter_All = 3,
    Field_Filter_Max = 4,
    Field_Filter_Max = 5,
};

enum class EFieldIntegerType {
    Integer_DynamicState = 0,
    Integer_ActivateDisabled = 1,
    Integer_CollisionGroup = 2,
    Integer_PositionAnimated = 3,
    Integer_PositionStatic = 4,
    Integer_TargetMax = 5,
    Integer_MAX = 6,
};

enum class EFieldOperationType {
    Field_Multiply = 0,
    Field_Divide = 1,
    Field_Add = 2,
    Field_Substract = 3,
    Field_Operation_Max = 4,
};

enum class EFieldOutputType {
    Field_Output_Vector = 0,
    Field_Output_Scalar = 1,
    Field_Output_Integer = 2,
    Field_Output_Max = 3,
    Field_Output_Max = 4,
};

enum class EFieldPhysicsDefaultFields {
    Field_RadialIntMask = 0,
    Field_RadialFalloff = 1,
    Field_UniformVector = 2,
    Field_RadialVector = 3,
    Field_RadialVectorFalloff = 4,
    Field_EFieldPhysicsDefaultFields_Max = 5,
    Field_MAX = 6,
};

enum class EFieldPhysicsType {
    Field_None = 0,
    Field_DynamicState = 1,
    Field_LinearForce = 2,
    Field_ExternalClusterStrain = 3,
    Field_Kill = 4,
    Field_LinearVelocity = 5,
    Field_AngularVelociy = 6,
    Field_AngularTorque = 7,
    Field_InternalClusterStrain = 8,
    Field_DisableThreshold = 9,
    Field_SleepingThreshold = 10,
    Field_PositionStatic = 11,
    Field_PositionAnimated = 12,
    Field_PositionTarget = 13,
    Field_DynamicConstraint = 14,
    Field_CollisionGroup = 15,
    Field_ActivateDisabled = 16,
    Field_PhysicsType_Max = 17,
};

enum class EFieldResolutionType {
    Field_Resolution_Minimal = 0,
    Field_Resolution_DisabledParents = 1,
    Field_Resolution_Maximum = 2,
    Field_Resolution_Max = 3,
    Field_Resolution_Max = 4,
};

enum class EFieldScalarType {
    Scalar_ExternalClusterStrain = 0,
    Scalar_Kill = 1,
    Scalar_DisableThreshold = 2,
    Scalar_SleepingThreshold = 3,
    Scalar_InternalClusterStrain = 4,
    Scalar_DynamicConstraint = 5,
    Scalar_TargetMax = 6,
    Scalar_MAX = 7,
};

enum class EFieldVectorType {
    Vector_LinearForce = 0,
    Vector_LinearVelocity = 1,
    Vector_AngularVelocity = 2,
    Vector_AngularTorque = 3,
    Vector_PositionTarget = 4,
    Vector_TargetMax = 5,
    Vector_MAX = 6,
};

enum class EGeometryCollectionCacheType {
    None = 0,
    Record = 1,
    Play = 2,
    RecordAndPlay = 3,
    EGeometryCollectionCacheType_MAX = 4,
};

enum class EGeometryCollectionPhysicsTypeEnum {
    Chaos_AngularVelocity = 0,
    Chaos_DynamicState = 1,
    Chaos_LinearVelocity = 2,
    Chaos_InitialAngularVelocity = 3,
    Chaos_InitialLinearVelocity = 4,
    Chaos_CollisionGroup = 5,
    Chaos_LinearForce = 6,
    Chaos_AngularTorque = 7,
    Chaos_Max = 8,
    Chaos_Max = 9,
};

enum class EImplicitTypeEnum {
    Chaos_Implicit_Box = 0,
    Chaos_Implicit_Sphere = 1,
    Chaos_Implicit_Capsule = 2,
    Chaos_Implicit_LevelSet = 3,
    Chaos_Implicit_None = 4,
    Chaos_Max = 5,
    Chaos_Max = 6,
};

enum class EInitialVelocityTypeEnum {
    Chaos_Initial_Velocity_User_Defined = 0,
    Chaos_Initial_Velocity_None = 1,
    Chaos_Max = 2,
    Chaos_Max = 3,
};

enum class EObjectStateTypeEnum {
    Chaos_NONE = 0,
    Chaos_Object_Sleeping = 1,
    Chaos_Object_Kinematic = 2,
    Chaos_Object_Static = 3,
    Chaos_Object_Dynamic = 4,
    Chaos_Object_UserDefined = 100,
    Chaos_Max = 101,
    Chaos_Max = 102,
};

enum class ESetMaskConditionType {
    Field_Set_Always = 0,
    Field_Set_IFF_NOT_Interior = 1,
    Field_Set_IFF_NOT_Exterior = 2,
    Field_MaskCondition_Max = 3,
};

enum class EWaveFunctionType {
    Field_Wave_Cosine = 0,
    Field_Wave_Gaussian = 1,
    Field_Wave_Falloff = 2,
    Field_Wave_Decay = 3,
    Field_Wave_Max = 4,
    Field_Wave_Max = 5,
};

// Size: 0xb8
struct FRecordedFrame {
    /* 0x0000 */ TArray<FTransform> Transforms;
    /* 0x0010 */ TArray<int32_t> TransformIndices;
    /* 0x0020 */ TArray<int32_t> PreviousTransformIndices;
    /* 0x0030 */ TArray<bool> DisabledFlags;
    /* 0x0040 */ TArray<FSolverCollisionData> Collisions;
    /* 0x0050 */ TArray<FSolverBreakingData> Breakings;
    /* 0x0060 */ TSet<FSolverTrailingData> Trailings;
    /* 0x00b0 */ float Timestamp;
};

// Size: 0x10
struct FRecordedTransformTrack {
    /* 0x0000 */ TArray<FRecordedFrame> Records;
};

// Size: 0x30
struct FSolverBreakingData {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FVector Velocity;
    /* 0x0018 */ FVector AngularVelocity;
    /* 0x0024 */ float Mass;
    /* 0x0028 */ int32_t ParticleIndex;
    /* 0x002c */ int32_t ParticleIndexMesh;
};

// Size: 0x10
struct FSolverBreakingFilterSettings {
    /* 0x0000 */ bool FilterEnabled;
    /* 0x0004 */ float MinMass;
    /* 0x0008 */ float MinSpeed;
    /* 0x000c */ float MinVolume;
};

// Size: 0x6c
struct FSolverCollisionData {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FVector AccumulatedImpulse;
    /* 0x0018 */ FVector Normal;
    /* 0x0024 */ FVector Velocity1;
    /* 0x0030 */ FVector Velocity2;
    /* 0x003c */ FVector AngularVelocity1;
    /* 0x0048 */ FVector AngularVelocity2;
    /* 0x0054 */ float Mass1;
    /* 0x0058 */ float Mass2;
    /* 0x005c */ int32_t ParticleIndex;
    /* 0x0060 */ int32_t LevelsetIndex;
    /* 0x0064 */ int32_t ParticleIndexMesh;
    /* 0x0068 */ int32_t LevelsetIndexMesh;
};

// Size: 0x10
struct FSolverCollisionFilterSettings {
    /* 0x0000 */ bool FilterEnabled;
    /* 0x0004 */ float MinMass;
    /* 0x0008 */ float MinSpeed;
    /* 0x000c */ float MinImpulse;
};

// Size: 0x30
struct FSolverTrailingData {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FVector Velocity;
    /* 0x0018 */ FVector AngularVelocity;
    /* 0x0024 */ float Mass;
    /* 0x0028 */ int32_t ParticleIndex;
    /* 0x002c */ int32_t ParticleIndexMesh;
};

// Size: 0x10
struct FSolverTrailingFilterSettings {
    /* 0x0000 */ bool FilterEnabled;
    /* 0x0004 */ float MinMass;
    /* 0x0008 */ float MinSpeed;
    /* 0x000c */ float MinVolume;
};

// Size: 0xd8
class UChaosClothConfig : public UClothConfigCommon {
    /* 0x0030 */ EClothMassMode MassMode;
    /* 0x0034 */ float UniformMass;
    /* 0x0038 */ float TotalMass;
    /* 0x003c */ float Density;
    /* 0x0040 */ float MinPerParticleMass;
    /* 0x0044 */ float EdgeStiffness;
    /* 0x0048 */ float BendingStiffness;
    /* 0x004c */ bool bUseBendingElements;
    /* 0x0050 */ float AreaStiffness;
    /* 0x0054 */ float VolumeStiffness;
    /* 0x0058 */ FChaosClothWeightedValue TetherStiffness;
    /* 0x0060 */ float LimitScale;
    /* 0x0064 */ bool bUseGeodesicDistance;
    /* 0x0068 */ float ShapeTargetStiffness;
    /* 0x006c */ float CollisionThickness;
    /* 0x0070 */ float FrictionCoefficient;
    /* 0x0074 */ bool bUseCCD;
    /* 0x0075 */ bool bUseSelfCollisions;
    /* 0x0078 */ float SelfCollisionThickness;
    /* 0x007c */ bool bUseLegacyBackstop;
    /* 0x0080 */ float DampingCoefficient;
    /* 0x0084 */ bool bUsePointBasedWindModel;
    /* 0x0088 */ float DragCoefficient;
    /* 0x008c */ float LiftCoefficient;
    /* 0x0090 */ bool bUseGravityOverride;
    /* 0x0094 */ float GravityScale;
    /* 0x0098 */ FVector Gravity;
    /* 0x00a4 */ FChaosClothWeightedValue AnimDriveStiffness;
    /* 0x00ac */ FChaosClothWeightedValue AnimDriveDamping;
    /* 0x00b4 */ FVector LinearVelocityScale;
    /* 0x00c0 */ float AngularVelocityScale;
    /* 0x00c4 */ float FictitiousAngularScale;
    /* 0x00c8 */ bool bUseTetrahedralConstraints;
    /* 0x00c9 */ bool bUseThinShellVolumeConstraints;
    /* 0x00ca */ bool bUseContinuousCollisionDetection;
    /* 0x00cb */ EChaosClothTetherMode TetherMode;
    /* 0x00cc */ float AnimDriveSpringStiffness;
    /* 0x00d0 */ float StrainLimitingStiffness;
};

// Size: 0x60
class UChaosClothSharedSimConfig : public UClothSharedConfigCommon {
    /* 0x0030 */ int32_t IterationCount;
    /* 0x0034 */ int32_t SubdivisionCount;
    /* 0x0038 */ float SelfCollisionThickness;
    /* 0x003c */ float CollisionThickness;
    /* 0x0040 */ bool bUseDampingOverride;
    /* 0x0044 */ float Damping;
    /* 0x0048 */ bool bUseGravityOverride;
    /* 0x004c */ float GravityScale;
    /* 0x0050 */ FVector Gravity;
    /* 0x005c */ bool bUseLocalSpaceSimulation;
    /* 0x005d */ bool bUseXPBDConstraints;
};

// Size: 0x8
struct FChaosClothWeightedValue {
    /* 0x0000 */ float Low;
    /* 0x0004 */ float High;
};

// Size: 0x48
class UChaosClothingInteractor : public UClothingInteractor {

    void ResetAndTeleport(bool bReset, bool bTeleport);
    void SetAerodynamics(float DragCoefficient, float LiftCoefficient, FVector WindVelocity);
    void SetAnimDrive(FVector2D AnimDriveStiffness, FVector2D AnimDriveDamping);
    void SetAnimDriveLinear(float AnimDriveStiffness);
    void SetCollision(float CollisionThickness, float FrictionCoefficient, bool bUseCCD, float SelfCollisionThickness);
    void SetDamping(float DampingCoefficient);
    void SetGravity(float GravityScale, bool bIsGravityOverridden, FVector GravityOverride);
    void SetLongRangeAttachment(FVector2D TetherStiffness);
    void SetLongRangeAttachmentLinear(float TetherStiffness);
    void SetMaterialLinear(float EdgeStiffness, float BendingStiffness, float AreaStiffness);
    void SetVelocityScale(FVector LinearVelocityScale, float AngularVelocityScale, float FictitiousAngularScale);
};

// Size: 0x30
class UChaosClothingSimulationFactory : public UClothingSimulationFactory {
};

// Size: 0xa8
class UChaosClothingSimulationInteractor : public UClothingSimulationInteractor {
};

enum class EChaosClothTetherMode {
    FastTetherFastLength = 0,
    AccurateTetherFastLength = 1,
    AccurateTetherAccurateLength = 2,
    MaxChaosClothTetherMode = 3,
    EChaosClothTetherMode_MAX = 4,
};

enum class EChaosWeightMapTarget {
    None = 0,
    MaxDistance = 1,
    BackstopDistance = 2,
    BackstopRadius = 3,
    AnimDriveStiffness = 4,
    AnimDriveDamping = 5,
    TetherStiffness = 6,
    EChaosWeightMapTarget_MAX = 7,
};

// Size: 0x44
struct FChaosDestructionEvent {
    /* 0x0000 */ FVector Position;
    /* 0x000c */ FVector Normal;
    /* 0x0018 */ FVector Velocity;
    /* 0x0024 */ FVector AngularVelocity;
    /* 0x0030 */ float ExtentMin;
    /* 0x0034 */ float ExtentMax;
    /* 0x0038 */ int32_t ParticleID;
    /* 0x003c */ float Time;
    /* 0x0040 */ int32_t Type;
};

enum class EDataSortTypeEnum {
    ChaosNiagara_DataSortType_NoSorting = 0,
    ChaosNiagara_DataSortType_RandomShuffle = 1,
    ChaosNiagara_DataSortType_SortByMassMaxToMin = 2,
    ChaosNiagara_DataSortType_SortByMassMinToMax = 3,
    ChaosNiagara_Max = 4,
    ChaosNiagara_Max = 5,
};

enum class EDataSourceTypeEnum {
    ChaosNiagara_DataSourceType_Collision = 0,
    ChaosNiagara_DataSourceType_Breaking = 1,
    ChaosNiagara_DataSourceType_Trailing = 2,
    ChaosNiagara_Max = 3,
    ChaosNiagara_Max = 4,
};

enum class EDebugTypeEnum {
    ChaosNiagara_DebugType_NoDebug = 0,
    ChaosNiagara_DebugType_ColorBySolver = 1,
    ChaosNiagara_DebugType_ColorByParticleIndex = 2,
    ChaosNiagara_Max = 3,
    ChaosNiagara_Max = 4,
};

enum class ELocationFilteringModeEnum {
    ChaosNiagara_LocationFilteringMode_Inclusive = 0,
    ChaosNiagara_LocationFilteringMode_Exclusive = 1,
    ChaosNiagara_Max = 2,
    ChaosNiagara_Max = 3,
};

enum class ELocationXToSpawnEnum {
    ChaosNiagara_LocationXToSpawn_None = 0,
    ChaosNiagara_LocationXToSpawn_Min = 1,
    ChaosNiagara_LocationXToSpawn_Max = 2,
    ChaosNiagara_LocationXToSpawn_MinMax = 3,
    ChaosNiagara_Max = 4,
    ChaosNiagara_Max = 5,
};

enum class ELocationYToSpawnEnum {
    ChaosNiagara_LocationYToSpawn_None = 0,
    ChaosNiagara_LocationYToSpawn_Min = 1,
    ChaosNiagara_LocationYToSpawn_Max = 2,
    ChaosNiagara_LocationYToSpawn_MinMax = 3,
    ChaosNiagara_Max = 4,
    ChaosNiagara_Max = 5,
};

enum class ELocationZToSpawnEnum {
    ChaosNiagara_LocationZToSpawn_None = 0,
    ChaosNiagara_LocationZToSpawn_Min = 1,
    ChaosNiagara_LocationZToSpawn_Max = 2,
    ChaosNiagara_LocationZToSpawn_MinMax = 3,
    ChaosNiagara_Max = 4,
    ChaosNiagara_Max = 5,
};

enum class ERandomVelocityGenerationTypeEnum {
    ChaosNiagara_RandomVelocityGenerationType_RandomDistribution = 0,
    ChaosNiagara_RandomVelocityGenerationType_RandomDistributionWithStreamers = 1,
    ChaosNiagara_RandomVelocityGenerationType_CollisionNormalBased = 2,
    ChaosNiagara_Max = 3,
    ChaosNiagara_Max = 4,
};

// Size: 0x280
class UNiagaraDataInterfaceChaosDestruction : public UNiagaraDataInterface {
    /* 0x0080 */ TSet<AChaosSolverActor*> ChaosSolverActorSet;
    /* 0x00d0 */ EDataSourceTypeEnum DataSourceType;
    /* 0x00d4 */ int32_t DataProcessFrequency;
    /* 0x00d8 */ int32_t MaxNumberOfDataEntriesToSpawn;
    /* 0x00dc */ bool DoSpawn;
    /* 0x00e0 */ FVector2D SpawnMultiplierMinMax;
    /* 0x00e8 */ float SpawnChance;
    /* 0x00ec */ FVector2D ImpulseToSpawnMinMax;
    /* 0x00f4 */ FVector2D SpeedToSpawnMinMax;
    /* 0x00fc */ FVector2D MassToSpawnMinMax;
    /* 0x0104 */ FVector2D ExtentMinToSpawnMinMax;
    /* 0x010c */ FVector2D ExtentMaxToSpawnMinMax;
    /* 0x0114 */ FVector2D VolumeToSpawnMinMax;
    /* 0x011c */ FVector2D SolverTimeToSpawnMinMax;
    /* 0x0124 */ int32_t SurfaceTypeToSpawn;
    /* 0x0128 */ ELocationFilteringModeEnum LocationFilteringMode;
    /* 0x0129 */ ELocationXToSpawnEnum LocationXToSpawn;
    /* 0x012c */ FVector2D LocationXToSpawnMinMax;
    /* 0x0134 */ ELocationYToSpawnEnum LocationYToSpawn;
    /* 0x0138 */ FVector2D LocationYToSpawnMinMax;
    /* 0x0140 */ ELocationZToSpawnEnum LocationZToSpawn;
    /* 0x0144 */ FVector2D LocationZToSpawnMinMax;
    /* 0x014c */ EDataSortTypeEnum DataSortingType;
    /* 0x014d */ bool bGetExternalCollisionData;
    /* 0x014e */ bool DoSpatialHash;
    /* 0x0150 */ FVector SpatialHashVolumeMin;
    /* 0x015c */ FVector SpatialHashVolumeMax;
    /* 0x0168 */ FVector SpatialHashVolumeCellSize;
    /* 0x0174 */ int32_t MaxDataPerCell;
    /* 0x0178 */ bool bApplyMaterialsFilter;
    /* 0x0180 */ TSet<UPhysicalMaterial*> ChaosBreakingMaterialSet;
    /* 0x01d0 */ bool bGetExternalBreakingData;
    /* 0x01d1 */ bool bGetExternalTrailingData;
    /* 0x01d4 */ FVector2D RandomPositionMagnitudeMinMax;
    /* 0x01dc */ float InheritedVelocityMultiplier;
    /* 0x01e0 */ ERandomVelocityGenerationTypeEnum RandomVelocityGenerationType;
    /* 0x01e4 */ FVector2D RandomVelocityMagnitudeMinMax;
    /* 0x01ec */ float SpreadAngleMax;
    /* 0x01f0 */ FVector VelocityOffsetMin;
    /* 0x01fc */ FVector VelocityOffsetMax;
    /* 0x0208 */ FVector2D FinalVelocityMagnitudeMinMax;
    /* 0x0210 */ float MaxLatency;
    /* 0x0214 */ EDebugTypeEnum DebugType;
    /* 0x0218 */ int32_t LastSpawnedPointID;
    /* 0x021c */ float LastSpawnTime;
    /* 0x0230 */ float SolverTime;
    /* 0x0234 */ float TimeStampOfLastProcessedData;
};

// Size: 0x80
class UNiagaraDataInterfacePhysicsField : public UNiagaraDataInterface {
};

// Size: 0x78
class UActorFactoryChaosSolver : public UActorFactory {
};

// Size: 0x88
class UChaosSolverFactory : public UFactory {
};

// Size: 0x50
struct FBreakEventCallbackWrapper {
};

// Size: 0x30
struct FChaosBreakEvent {
    /* 0x0000 */ UPrimitiveComponent* Component;
    /* 0x0008 */ FVector Location;
    /* 0x0014 */ FVector Velocity;
    /* 0x0020 */ FVector AngularVelocity;
    /* 0x002c */ float Mass;
};

// Size: 0xd8
class UChaosDebugDrawComponent : public UActorComponent {
};

// Size: 0x18
struct FChaosDebugSubstepControl {
    /* 0x0000 */ bool bPause;
    /* 0x0001 */ bool bSubstep;
    /* 0x0002 */ bool bStep;
};

// Size: 0xc8
class UChaosEventListenerComponent : public UActorComponent {
};

// Size: 0x280
class UChaosGameplayEventDispatcher : public UChaosEventListenerComponent {
    /* 0x01d8 */ TMap<UPrimitiveComponent*, FChaosHandlerSet> CollisionEventRegistrations;
    /* 0x0228 */ TMap<UPrimitiveComponent*, FBreakEventCallbackWrapper> BreakEventRegistrations;
};

// Size: 0x58
struct FChaosHandlerSet {
    /* 0x0008 */ TSet<UObject*> ChaosHandlers;
};

// Size: 0x30
class IChaosNotifyHandlerInterface : public UInterface {
};

// Size: 0x70
struct FChaosPhysicsCollisionInfo {
    /* 0x0000 */ UPrimitiveComponent* Component;
    /* 0x0008 */ UPrimitiveComponent* OtherComponent;
    /* 0x0010 */ FVector Location;
    /* 0x001c */ FVector Normal;
    /* 0x0028 */ FVector AccumulatedImpulse;
    /* 0x0034 */ FVector Velocity;
    /* 0x0040 */ FVector OtherVelocity;
    /* 0x004c */ FVector AngularVelocity;
    /* 0x0058 */ FVector OtherAngularVelocity;
    /* 0x0064 */ float Mass;
    /* 0x0068 */ float OtherMass;
};

// Size: 0x30
class UChaosSolver : public UObject {
};

// Size: 0x408
class AChaosSolverActor : public AActor {
    /* 0x02f8 */ FChaosSolverConfiguration Properties;
    /* 0x0360 */ float TimeStepMultiplier;
    /* 0x0364 */ int32_t CollisionIterations;
    /* 0x0368 */ int32_t PushOutIterations;
    /* 0x036c */ int32_t PushOutPairIterations;
    /* 0x0370 */ float ClusterConnectionFactor;
    /* 0x0374 */ EClusterConnectionTypeEnum ClusterUnionConnectionType;
    /* 0x0375 */ bool DoGenerateCollisionData;
    /* 0x0378 */ FSolverCollisionFilterSettings CollisionFilterSettings;
    /* 0x0388 */ bool DoGenerateBreakingData;
    /* 0x038c */ FSolverBreakingFilterSettings BreakingFilterSettings;
    /* 0x039c */ bool DoGenerateTrailingData;
    /* 0x03a0 */ FSolverTrailingFilterSettings TrailingFilterSettings;
    /* 0x03b0 */ float MassScale;
    /* 0x03b4 */ bool bGenerateContactGraph;
    /* 0x03b5 */ bool bHasFloor;
    /* 0x03b8 */ float FloorHeight;
    /* 0x03c0 */ FChaosDebugSubstepControl ChaosDebugSubstepControl;
    /* 0x03d8 */ UBillboardComponent* SpriteComponent;
    /* 0x03f8 */ UChaosGameplayEventDispatcher* GameplayEventDispatcherComponent;

    void SetAsCurrentWorldSolver();
    void SetSolverActive(bool bActive);
};

// Size: 0x30
class UChaosSolverEngineBlueprintLibrary : public UBlueprintFunctionLibrary {

    static FHitResult ConvertPhysicsCollisionToHitResult(const FChaosPhysicsCollisionInfo& PhysicsCollision);
};

// Size: 0x88
class UChaosSolverSettings : public UDeveloperSettings {
    /* 0x0068 */ FSoftClassPath DefaultChaosSolverActorClass;
};

enum class EClusterConnectionTypeEnum {
    Chaos_PointImplicit = 0,
    Chaos_DelaunayTriangulation = 1,
    Chaos_MinimalSpanningSubsetDelaunayTriangulation = 2,
    Chaos_PointImplicitAugmentedWithMinimalDelaunay = 3,
    Chaos_None = 4,
    Chaos_EClsuterCreationParameters_Max = 5,
    Chaos_MAX = 6,
};

// Size: 0xc
struct FCameraFilmbackSettings {
    /* 0x0000 */ float SensorWidth;
    /* 0x0004 */ float SensorHeight;
    /* 0x0008 */ float SensorAspectRatio;
};

// Size: 0x60
struct FCameraFocusSettings {
    /* 0x0000 */ ECameraFocusMethod FocusMethod;
    /* 0x0004 */ float ManualFocusDistance;
    /* 0x0008 */ FCameraTrackingFocusSettings TrackingFocusSettings;
    /* 0x0048 */ bool bDrawDebugFocusPlane;
    /* 0x004c */ FColor DebugFocusPlaneColor;
    /* 0x0050 */ bool bSmoothFocusChanges;
    /* 0x0054 */ float FocusSmoothingInterpSpeed;
    /* 0x0058 */ float FocusOffset;
};

// Size: 0x18
struct FCameraLensSettings {
    /* 0x0000 */ float MinFocalLength;
    /* 0x0004 */ float MaxFocalLength;
    /* 0x0008 */ float MinFStop;
    /* 0x000c */ float MaxFStop;
    /* 0x0010 */ float MinimumFocusDistance;
    /* 0x0014 */ int32_t DiaphragmBladeCount;
};

// Size: 0x58
struct FCameraLookatTrackingSettings {
    /* 0x0000 */ bool bEnableLookAtTracking;
    /* 0x0000 */ bool bDrawDebugLookAtTrackingPosition;
    /* 0x0004 */ float LookAtTrackingInterpSpeed;
    /* 0x0018 */ TSoftObjectPtr<AActor> ActorToTrack;
    /* 0x0048 */ FVector RelativeOffset;
    /* 0x0054 */ bool bAllowRoll;
};

// Size: 0x348
class ACameraRig_Crane : public AActor {
    /* 0x02f8 */ float CranePitch;
    /* 0x02fc */ float CraneYaw;
    /* 0x0300 */ float CraneArmLength;
    /* 0x0304 */ bool bLockMountPitch;
    /* 0x0305 */ bool bLockMountYaw;
    /* 0x0308 */ USceneComponent* TransformComponent;
    /* 0x0310 */ USceneComponent* CraneYawControl;
    /* 0x0318 */ USceneComponent* CranePitchControl;
    /* 0x0320 */ USceneComponent* CraneCameraMount;
    /* 0x0328 */ UStaticMeshComponent* PreviewMesh_CraneArm;
    /* 0x0330 */ UStaticMeshComponent* PreviewMesh_CraneBase;
    /* 0x0338 */ UStaticMeshComponent* PreviewMesh_CraneMount;
    /* 0x0340 */ UStaticMeshComponent* PreviewMesh_CraneCounterWeight;
};

// Size: 0x348
class ACameraRig_Rail : public AActor {
    /* 0x02f8 */ float CurrentPositionOnRail;
    /* 0x02fc */ bool bLockOrientationToRail;
    /* 0x02fd */ bool bShowRailVisualization;
    /* 0x0300 */ float PreviewMeshScale;
    /* 0x0308 */ USceneComponent* TransformComponent;
    /* 0x0310 */ USplineComponent* RailSplineComponent;
    /* 0x0318 */ USceneComponent* RailCameraMount;
    /* 0x0320 */ USplineMeshComponent* PreviewMesh_Rail;
    /* 0x0328 */ TArray<USplineMeshComponent*> PreviewRailMeshSegments;
    /* 0x0338 */ UStaticMesh* PreviewRailStaticMesh;
    /* 0x0340 */ UStaticMeshComponent* PreviewMesh_Mount;

    USplineComponent* GetRailSplineComponent();
};

// Size: 0x40
struct FCameraTrackingFocusSettings {
    /* 0x0000 */ TSoftObjectPtr<AActor> ActorToTrack;
    /* 0x0030 */ FVector RelativeOffset;
    /* 0x003c */ bool bDrawDebugTrackingFocusPoint;
};

// Size: 0x930
class ACineCameraActor : public ACameraActor {
    /* 0x08c0 */ FCameraLookatTrackingSettings LookatTrackingSettings;

    UCineCameraComponent* GetCineCameraComponent() const;
};

// Size: 0x980
class UCineCameraComponent : public UCameraComponent {
    /* 0x0858 */ FCameraFilmbackSettings FilmbackSettings;
    /* 0x0864 */ FCameraFilmbackSettings Filmback;
    /* 0x0870 */ FCameraLensSettings LensSettings;
    /* 0x0888 */ FCameraFocusSettings FocusSettings;
    /* 0x08e8 */ float CurrentFocalLength;
    /* 0x08ec */ float CurrentAperture;
    /* 0x08f0 */ float CurrentFocusDistance;
    /* 0x08f4 */ float CurrentHorizontalFOV;
    /* 0x0900 */ UStaticMesh* FocusPlaneVisualizationMesh;
    /* 0x0908 */ UMaterial* FocusPlaneVisualizationMaterial;
    /* 0x0910 */ UStaticMeshComponent* DebugFocusPlaneComponent;
    /* 0x0918 */ UMaterialInstanceDynamic* DebugFocusPlaneMID;
    /* 0x0920 */ TArray<FNamedFilmbackPreset> FilmbackPresets;
    /* 0x0930 */ TArray<FNamedLensPreset> LensPresets;
    /* 0x0940 */ FString DefaultFilmbackPresetName;
    /* 0x0950 */ FString DefaultFilmbackPreset;
    /* 0x0960 */ FString DefaultLensPresetName;
    /* 0x0970 */ float DefaultLensFocalLength;
    /* 0x0974 */ float DefaultLensFStop;

    FString GetDefaultFilmbackPresetName() const;
    FString GetFilmbackPresetName() const;
    static TArray<FNamedFilmbackPreset> GetFilmbackPresetsCopy();
    float GetHorizontalFieldOfView() const;
    FString GetLensPresetName() const;
    static TArray<FNamedLensPreset> GetLensPresetsCopy();
    float GetVerticalFieldOfView() const;
    void SetCurrentFocalLength(float InFocalLength);
    void SetFilmbackPresetByName(FString InPresetName);
    void SetLensPresetByName(FString InPresetName);
};

enum class ECameraFocusMethod {
    DoNotOverride = 0,
    Manual = 1,
    Tracking = 2,
    Disable = 3,
    MAX = 4,
};

// Size: 0x20
struct FNamedFilmbackPreset {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FCameraFilmbackSettings FilmbackSettings;
};

// Size: 0x28
struct FNamedLensPreset {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FCameraLensSettings LensSettings;
};

// Size: 0x50
class UClassViewerProjectSettings : public UObject {
    /* 0x0030 */ TArray<FDirectoryPath> InternalOnlyPaths;
    /* 0x0040 */ TArray<FSoftClassPath> InternalOnlyClasses;
};

// Size: 0x38
class UClothPaintTool_BrushSettings : public UObject {
    /* 0x0030 */ float PaintValue;
};

// Size: 0x38
class UClothPaintTool_FillSettings : public UObject {
    /* 0x0030 */ float Threshold;
    /* 0x0034 */ float FillValue;
};

// Size: 0x40
class UClothPaintTool_GradientSettings : public UObject {
    /* 0x0030 */ float GradientStartValue;
    /* 0x0034 */ float GradientEndValue;
    /* 0x0038 */ bool bUseRegularBrush;
};

// Size: 0x38
class UClothPaintTool_SmoothSettings : public UObject {
    /* 0x0030 */ float Strength;
};

// Size: 0x80
class UClothPainterSettings : public UMeshPaintSettings {
    /* 0x0050 */ float ViewMin;
    /* 0x0054 */ float ViewMax;
    /* 0x0058 */ bool bAutoViewRange;
    /* 0x005c */ float AutoCalculatedViewMin;
    /* 0x0060 */ float AutoCalculatedViewMax;
    /* 0x0068 */ TArray<UClothingAssetCommon*> ClothingAssets;
    /* 0x0078 */ bool bFlipNormal;
    /* 0x0079 */ bool bCullBackface;
    /* 0x007c */ float Opacity;
};

// Size: 0x8
struct FCopyVertexColorToClothParams {
    /* 0x0000 */ ESourceColorChannel ColorChannel;
    /* 0x0004 */ float ScalingFactor;
};

enum class EPaintableClothProperty {
    MaxDistances = 0,
    BackstopDistances = 1,
    BackstopRadius = 2,
    EPaintableClothProperty_MAX = 3,
};

enum class ESourceColorChannel {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
    ESourceColorChannel_MAX = 4,
};

// Size: 0x30
class UClothingAssetFactory : public UClothingAssetFactoryBase {
};

// Size: 0x30
class UClothingAssetFactoryBase : public UObject {
};

// Size: 0x30
class UClothConfigCommon : public UClothConfigBase {
};

// Size: 0xd4
struct FClothConfig_Legacy {
    /* 0x0000 */ EClothingWindMethod_Legacy WindMethod;
    /* 0x0004 */ FClothConstraintSetup_Legacy VerticalConstraintConfig;
    /* 0x0014 */ FClothConstraintSetup_Legacy HorizontalConstraintConfig;
    /* 0x0024 */ FClothConstraintSetup_Legacy BendConstraintConfig;
    /* 0x0034 */ FClothConstraintSetup_Legacy ShearConstraintConfig;
    /* 0x0044 */ float SelfCollisionRadius;
    /* 0x0048 */ float SelfCollisionStiffness;
    /* 0x004c */ float SelfCollisionCullScale;
    /* 0x0050 */ FVector Damping;
    /* 0x005c */ float Friction;
    /* 0x0060 */ float WindDragCoefficient;
    /* 0x0064 */ float WindLiftCoefficient;
    /* 0x0068 */ FVector LinearDrag;
    /* 0x0074 */ FVector AngularDrag;
    /* 0x0080 */ FVector LinearInertiaScale;
    /* 0x008c */ FVector AngularInertiaScale;
    /* 0x0098 */ FVector CentrifugalInertiaScale;
    /* 0x00a4 */ float SolverFrequency;
    /* 0x00a8 */ float StiffnessFrequency;
    /* 0x00ac */ float GravityScale;
    /* 0x00b0 */ FVector GravityOverride;
    /* 0x00bc */ bool bUseGravityOverride;
    /* 0x00c0 */ float TetherStiffness;
    /* 0x00c4 */ float TetherLimit;
    /* 0x00c8 */ float CollisionThickness;
    /* 0x00cc */ float AnimDriveSpringStiffness;
    /* 0x00d0 */ float AnimDriveDamperStiffness;
};

// Size: 0x10
struct FClothConstraintSetup_Legacy {
    /* 0x0000 */ float Stiffness;
    /* 0x0004 */ float StiffnessMultiplier;
    /* 0x0008 */ float StretchLimit;
    /* 0x000c */ float CompressionLimit;
};

// Size: 0x190
struct FClothLODDataCommon {
    /* 0x0000 */ FClothPhysicalMeshData PhysicalMeshData;
    /* 0x0108 */ FClothCollisionData CollisionData;
    /* 0x0148 */ bool bUseMultipleInfluences;
    /* 0x014c */ float SkinningKernelRadius;
    /* 0x0150 */ TArray<FClothParameterMask_Legacy> ParameterMasks;
    /* 0x0160 */ TArray<FPointWeightMap> PointWeightMaps;
};

// Size: 0x1b0
class UClothLODDataCommon_Legacy : public UObject {
    /* 0x0030 */ UClothPhysicalMeshDataBase_Legacy* PhysicalMeshData;
    /* 0x0038 */ FClothPhysicalMeshData ClothPhysicalMeshData;
    /* 0x0140 */ FClothCollisionData CollisionData;
    /* 0x0180 */ TArray<FPointWeightMap> ParameterMasks;
};

// Size: 0x30
struct FClothParameterMask_Legacy {
    /* 0x0000 */ FName MaskName;
    /* 0x000c */ EWeightMapTargetCommon CurrentTarget;
    /* 0x0010 */ float MaxValue;
    /* 0x0014 */ float MinValue;
    /* 0x0018 */ TArray<float> Values;
    /* 0x0028 */ bool bEnabled;
};

// Size: 0x108
struct FClothPhysicalMeshData {
    /* 0x0000 */ TArray<FVector> Vertices;
    /* 0x0010 */ TArray<FVector> Normals;
    /* 0x0020 */ TArray<FColor> VertexColors;
    /* 0x0030 */ TArray<uint32_t> Indices;
    /* 0x0040 */ TMap<uint32_t, FPointWeightMap> WeightMaps;
    /* 0x0090 */ TArray<float> InverseMasses;
    /* 0x00a0 */ TArray<FClothVertBoneData> BoneData;
    /* 0x00b0 */ int32_t MaxBoneWeights;
    /* 0x00b4 */ int32_t NumFixedVerts;
    /* 0x00b8 */ TArray<uint32_t> SelfCollisionIndices;
    /* 0x00c8 */ TArray<float> MaxDistances;
    /* 0x00d8 */ TArray<float> BackstopDistances;
    /* 0x00e8 */ TArray<float> BackstopRadiuses;
    /* 0x00f8 */ TArray<float> AnimDriveMultipliers;
};

// Size: 0x30
class UClothSharedConfigCommon : public UClothConfigCommon {
};

// Size: 0x1f8
class UClothingAssetCommon : public UClothingAssetBase {
    /* 0x0050 */ UPhysicsAsset* PhysicsAsset;
    /* 0x0058 */ TMap<FName, UClothConfigBase*> ClothConfigs;
    /* 0x00a8 */ UClothConfigBase* ClothSharedSimConfig;
    /* 0x00b0 */ UClothConfigBase* ClothSimConfig;
    /* 0x00b8 */ UClothConfigBase* ChaosClothSimConfig;
    /* 0x00c0 */ TArray<UClothLODDataCommon_Legacy*> ClothLODData;
    /* 0x00d0 */ TArray<FClothLODDataCommon> LODData;
    /* 0x00e0 */ TArray<int32_t> LodMap;
    /* 0x00f0 */ TArray<FName> UsedBoneNames;
    /* 0x0100 */ TArray<int32_t> UsedBoneIndices;
    /* 0x0110 */ int32_t ReferenceBoneIndex;
    /* 0x0118 */ UClothingAssetCustomData* CustomData;
    /* 0x0120 */ FClothConfig_Legacy ClothConfig;
};

// Size: 0x30
class UClothingAssetCustomData : public UObject {
};

enum class EClothMassMode {
    UniformMass = 0,
    TotalMass = 1,
    Density = 2,
    MaxClothMassMode = 3,
    EClothMassMode_MAX = 4,
};

enum class EClothingWindMethod_Legacy {
    Legacy = 0,
    Accurate = 1,
    EClothingWindMethod_MAX = 2,
};

enum class EWeightMapTargetCommon {
    None = 0,
    MaxDistance = 1,
    BackstopDistance = 2,
    BackstopRadius = 3,
    AnimDriveStiffness = 4,
    AnimDriveDamping = 5,
    EWeightMapTargetCommon_MAX = 6,
};

// Size: 0x20
struct FPointWeightMap {
    /* 0x0000 */ TArray<float> Values;
    /* 0x0010 */ FName Name;
    /* 0x001c */ uint8_t CurrentTarget;
    /* 0x001d */ bool bEnabled;
};

// Size: 0x40
struct FClothCollisionData {
    /* 0x0000 */ TArray<FClothCollisionPrim_Sphere> Spheres;
    /* 0x0010 */ TArray<FClothCollisionPrim_SphereConnection> SphereConnections;
    /* 0x0020 */ TArray<FClothCollisionPrim_Convex> Convexes;
    /* 0x0030 */ TArray<FClothCollisionPrim_Box> Boxes;
};

// Size: 0x30
struct FClothCollisionPrim_Box {
    /* 0x0000 */ FVector LocalPosition;
    /* 0x0010 */ FQuat LocalRotation;
    /* 0x0020 */ FVector HalfExtents;
    /* 0x002c */ int32_t BoneIndex;
};

// Size: 0x38
struct FClothCollisionPrim_Convex {
    /* 0x0000 */ TArray<FPlane> planes;
    /* 0x0010 */ TArray<FClothCollisionPrim_ConvexFace> Faces;
    /* 0x0020 */ TArray<FVector> SurfacePoints;
    /* 0x0030 */ int32_t BoneIndex;
};

// Size: 0x20
struct FClothCollisionPrim_ConvexFace {
    /* 0x0000 */ FPlane Plane;
    /* 0x0010 */ TArray<int32_t> Indices;
};

// Size: 0x14
struct FClothCollisionPrim_Sphere {
    /* 0x0000 */ int32_t BoneIndex;
    /* 0x0004 */ float Radius;
    /* 0x0008 */ FVector LocalPosition;
};

// Size: 0x8
struct FClothCollisionPrim_SphereConnection {
    /* 0x0000 */ int32_t SphereIndices[2];
};

// Size: 0x30
class UClothConfigBase : public UObject {
};

// Size: 0xf8
class UClothPhysicalMeshDataBase_Legacy : public UObject {
    /* 0x0030 */ TArray<FVector> Vertices;
    /* 0x0040 */ TArray<FVector> Normals;
    /* 0x0050 */ TArray<FColor> VertexColors;
    /* 0x0060 */ TArray<uint32_t> Indices;
    /* 0x0070 */ TArray<float> InverseMasses;
    /* 0x0080 */ TArray<FClothVertBoneData> BoneData;
    /* 0x0090 */ int32_t NumFixedVerts;
    /* 0x0094 */ int32_t MaxBoneWeights;
    /* 0x0098 */ TArray<uint32_t> SelfCollisionIndices;
};

// Size: 0x30
class UClothSharedSimConfigBase : public UObject {
};

// Size: 0x4c
struct FClothVertBoneData {
    /* 0x0000 */ int32_t NumInfluences;
    /* 0x0004 */ uint16_t BoneIndices[12];
    /* 0x001c */ float BoneWeights[12];
};

// Size: 0x50
class UClothingAssetBase : public UObject {
    /* 0x0030 */ FString ImportedFilePath;
    /* 0x0040 */ FGuid AssetGuid;
};

// Size: 0x38
class UClothingInteractor : public UObject {
};

// Size: 0x30
class UClothingSimulationFactory : public UObject {
};

// Size: 0x98
class UClothingSimulationInteractor : public UObject {
    /* 0x0030 */ TMap<FName, UClothingInteractor*> ClothingInteractors;

    void ClothConfigUpdated();
    void DisableGravityOverride();
    void EnableGravityOverride(const FVector& InVector);
    UClothingInteractor* GetClothingInteractor(FString ClothingAssetName) const;
    int32_t GetNumCloths() const;
    int32_t GetNumDynamicParticles() const;
    int32_t GetNumIterations() const;
    int32_t GetNumKinematicParticles() const;
    int32_t GetNumSubsteps() const;
    float GetSimulationTime() const;
    void PhysicsAssetUpdated();
    void SetAnimDriveSpringStiffness(float InStiffness);
    void SetNumIterations(int32_t NumIterations);
    void SetNumSubsteps(int32_t NumSubsteps);
};

// Size: 0x148
class UClothConfigNv : public UClothConfigCommon {
    /* 0x0030 */ EClothingWindMethodNv ClothingWindMethod;
    /* 0x0034 */ FClothConstraintSetupNv VerticalConstraint;
    /* 0x0044 */ FClothConstraintSetupNv HorizontalConstraint;
    /* 0x0054 */ FClothConstraintSetupNv BendConstraint;
    /* 0x0064 */ FClothConstraintSetupNv ShearConstraint;
    /* 0x0074 */ float SelfCollisionRadius;
    /* 0x0078 */ float SelfCollisionStiffness;
    /* 0x007c */ float SelfCollisionCullScale;
    /* 0x0080 */ FVector Damping;
    /* 0x008c */ float Friction;
    /* 0x0090 */ float WindDragCoefficient;
    /* 0x0094 */ float WindLiftCoefficient;
    /* 0x0098 */ FVector LinearDrag;
    /* 0x00a4 */ FVector AngularDrag;
    /* 0x00b0 */ FVector LinearInertiaScale;
    /* 0x00bc */ FVector AngularInertiaScale;
    /* 0x00c8 */ FVector CentrifugalInertiaScale;
    /* 0x00d4 */ float SolverFrequency;
    /* 0x00d8 */ float StiffnessFrequency;
    /* 0x00dc */ float GravityScale;
    /* 0x00e0 */ FVector GravityOverride;
    /* 0x00ec */ bool bUseGravityOverride;
    /* 0x00f0 */ float TetherStiffness;
    /* 0x00f4 */ float TetherLimit;
    /* 0x00f8 */ float CollisionThickness;
    /* 0x00fc */ float AnimDriveSpringStiffness;
    /* 0x0100 */ float AnimDriveDamperStiffness;
    /* 0x0104 */ EClothingWindMethod_Legacy WindMethod;
    /* 0x0108 */ FClothConstraintSetup_Legacy VerticalConstraintConfig;
    /* 0x0118 */ FClothConstraintSetup_Legacy HorizontalConstraintConfig;
    /* 0x0128 */ FClothConstraintSetup_Legacy BendConstraintConfig;
    /* 0x0138 */ FClothConstraintSetup_Legacy ShearConstraintConfig;
};

// Size: 0x10
struct FClothConstraintSetupNv {
    /* 0x0000 */ float Stiffness;
    /* 0x0004 */ float StiffnessMultiplier;
    /* 0x0008 */ float StretchLimit;
    /* 0x000c */ float CompressionLimit;
};

// Size: 0x138
class UClothPhysicalMeshDataNv_Legacy : public UClothPhysicalMeshDataBase_Legacy {
    /* 0x00f8 */ TArray<float> MaxDistances;
    /* 0x0108 */ TArray<float> BackstopDistances;
    /* 0x0118 */ TArray<float> BackstopRadiuses;
    /* 0x0128 */ TArray<float> AnimDriveMultipliers;
};

// Size: 0x30
class UClothingSimulationFactoryNv : public UClothingSimulationFactory {
};

// Size: 0xa8
class UClothingSimulationInteractorNv : public UClothingSimulationInteractor {

    void SetAnimDriveDamperStiffness(float InStiffness);
};

enum class EClothingWindMethodNv {
    Legacy = 0,
    Accurate = 1,
    EClothingWindMethodNv_MAX = 2,
};

// Size: 0xd0
class UArcSplineGenerator : public USplineGeneratorBase {
    /* 0x00c0 */ int32_t NumberOfPoints;
    /* 0x00c4 */ float Radius;
    /* 0x00c8 */ float Degrees;
    /* 0x00cc */ bool bReverseDir;
    /* 0x00cd */ bool bKeepFirstKeyTangent;
    /* 0x00ce */ bool bBranchRight;
};

// Size: 0xd0
class UCircleSplineGenerator : public USplineGeneratorBase {
    /* 0x00c0 */ int32_t NumberOfPoints;
    /* 0x00c4 */ float Radius;
    /* 0x00c8 */ bool bReverseDir;
    /* 0x00c9 */ bool bKeepFirstKeyTangent;
    /* 0x00ca */ bool bBranchRight;
};

enum class ESelectedTangentHandle {
    None = 0,
    Leave = 1,
    Arrive = 2,
    ESelectedTangentHandle_MAX = 3,
};

enum class EShapeAddMode {
    AppendAfter = 1,
    AppendBefore = 2,
    InsertAfter = 4,
    InsertBefore = 8,
    EShapeAddMode_MAX = 9,
};

// Size: 0xd0
class UEllipseSplineGenerator : public USplineGeneratorBase {
    /* 0x00c0 */ int32_t NumberOfPoints;
    /* 0x00c4 */ float Length;
    /* 0x00c8 */ float Width;
    /* 0x00cc */ bool bReverseDir;
    /* 0x00cd */ bool bKeepFirstKeyTangent;
    /* 0x00ce */ bool bBranchRight;
};

// Size: 0xd0
class ULineSplineGenerator : public USplineGeneratorBase {
    /* 0x00c0 */ int32_t NumberOfPoints;
    /* 0x00c4 */ float Length;
    /* 0x00c8 */ bool bEnableUpToNextPoint;
    /* 0x00c9 */ bool bUpToNextPoint;
};

// Size: 0x310
class AManipulator : public AActor {
    /* 0x0300 */ USceneComponent* AssociatedComponent;
    /* 0x0308 */ UStaticMeshComponent* StaticMeshComponent;
};

// Size: 0xd0
class URectangleSplineGenerator : public USplineGeneratorBase {
    /* 0x00c0 */ float Length;
    /* 0x00c4 */ float Width;
    /* 0x00c8 */ bool bBranchRight;
};

// Size: 0xd0
class USplineComponentVisualizerSelectionState : public UObject {
    /* 0x0030 */ FComponentPropertyPath SplinePropertyPath;
    /* 0x0050 */ TSet<int32_t> SelectedKeys;
    /* 0x00a0 */ int32_t LastKeyIndexSelected;
    /* 0x00a4 */ int32_t SelectedSegmentIndex;
    /* 0x00a8 */ int32_t SelectedTangentHandle;
    /* 0x00ac */ ESelectedTangentHandle SelectedTangentHandleType;
    /* 0x00b0 */ FVector SelectedSplinePosition;
    /* 0x00c0 */ FQuat CachedRotation;
};

// Size: 0xc0
class USplineGeneratorBase : public UObject {
    /* 0x0030 */ EShapeAddMode ShapeAddMode;
};

// Size: 0xc8
class USquareSplineGenerator : public USplineGeneratorBase {
    /* 0x00c0 */ float Length;
    /* 0x00c4 */ bool bBranchRight;
};

// Size: 0x70
class UConfigHierarchyPropertyView : public UObject {
    /* 0x0030 */ FFieldPath EditProperty;
    /* 0x0060 */ TArray<UPropertyConfigFileDisplayRow*> ConfigFilePropertyObjects;
};

enum class EConfigFileSourceControlStatus {
    CFSCS_Unknown = 0,
    CFSCS_Writable = 1,
    CFSCS_Locked = 2,
    CFSCS_MAX = 3,
};

// Size: 0x78
class UPropertyConfigFileDisplayRow : public UObject {
    /* 0x0030 */ FString ConfigFileName;
    /* 0x0040 */ FFieldPath ExternalProperty;
    /* 0x0070 */ bool bIsFileWritable;
};

// Size: 0x70
class UContentBrowserAssetContextMenuContext : public UObject {
    /* 0x0050 */ TArray<TWeakObjectPtr<UObject>> SelectedObjects;
    /* 0x0060 */ UClass* CommonClass;
    /* 0x0068 */ bool bCanBeModified;

    TArray<UObject*> GetSelectedObjects() const;
};

// Size: 0x40
class UContentBrowserAssetViewContextMenuContext : public UObject {
};

// Size: 0x60
class UContentBrowserFolderContext : public UContentBrowserMenuContext {
    /* 0x0040 */ bool bCanBeModified;
    /* 0x0041 */ bool bNoFolderOnDisk;
    /* 0x0044 */ int32_t NumAssetPaths;
    /* 0x0048 */ int32_t NumClassPaths;
};

// Size: 0x30
class UContentBrowserFrontEndFilterExtension : public UObject {
};

// Size: 0x40
class UContentBrowserMenuContext : public UObject {
};

// Size: 0x10
struct FContentBrowserPluginSettings {
    /* 0x0000 */ FName PluginName;
    /* 0x000c */ float RootFolderSortPriority;
};

// Size: 0x170
class UContentBrowserAssetDataSource : public UContentBrowserDataSource {
};

// Size: 0x6f0
struct FContentBrowserCompiledAssetDataFilter {
};

// Size: 0x98
class UContentBrowserClassDataSource : public UContentBrowserDataSource {
};

// Size: 0xa0
struct FContentBrowserCompiledClassDataFilter {
    /* 0x0000 */ TSet<UClass*> ValidClasses;
    /* 0x0050 */ TSet<FName> ValidFolders;
};

// Size: 0x10
struct FContentBrowserCompiledSubsystemFilter {
};

// Size: 0x50
struct FContentBrowserCompiledVirtualFolderFilter {
};

// Size: 0x38
struct FContentBrowserDataClassFilter {
    /* 0x0000 */ TArray<FName> ClassNamesToInclude;
    /* 0x0010 */ TArray<FName> ClassNamesToExclude;
    /* 0x0020 */ bool bRecursiveClassNamesToInclude;
    /* 0x0021 */ bool bRecursiveClassNamesToExclude;
};

// Size: 0x18
struct FContentBrowserDataCollectionFilter {
    /* 0x0010 */ bool bIncludeChildCollections;
};

// Size: 0x18
struct FContentBrowserDataFilter {
    /* 0x0000 */ bool bRecursivePaths;
    /* 0x0001 */ EContentBrowserItemTypeFilter ItemTypeFilter;
    /* 0x0002 */ EContentBrowserItemCategoryFilter ItemCategoryFilter;
    /* 0x0003 */ EContentBrowserItemAttributeFilter ItemAttributeFilter;
};

// Size: 0x10
struct FContentBrowserDataLegacyFilter {
};

// Size: 0x58
class UContentBrowserDataMenuContext_AddNewMenu : public UObject {
    /* 0x0030 */ TArray<FName> SelectedPaths;
    /* 0x0040 */ EContentBrowserDataMenuContext_AddNewMenuDomain OwnerDomain;
};

// Size: 0xb8
class UContentBrowserDataMenuContext_DragDropMenu : public UObject {
    /* 0x0030 */ FContentBrowserItem DropTargetItem;
    /* 0x0090 */ TArray<FContentBrowserItem> DraggedItems;
    /* 0x00a0 */ bool bCanMove;
    /* 0x00a1 */ bool bCanCopy;
};

// Size: 0x88
class UContentBrowserDataMenuContext_FileMenu : public UObject {
    /* 0x0030 */ TArray<FContentBrowserItem> SelectedItems;
    /* 0x0050 */ bool bCanBeModified;
};

// Size: 0x58
class UContentBrowserDataMenuContext_FolderMenu : public UObject {
    /* 0x0030 */ TArray<FContentBrowserItem> SelectedItems;
    /* 0x0040 */ bool bCanBeModified;
};

// Size: 0xc8
struct FContentBrowserDataObjectFilter {
    /* 0x0000 */ TArray<FName> ObjectNamesToInclude;
    /* 0x0010 */ TArray<FName> ObjectNamesToExclude;
    /* 0x0020 */ bool bOnDiskObjectsOnly;
};

// Size: 0x58
struct FContentBrowserDataPackageFilter {
    /* 0x0000 */ TArray<FName> PackageNamesToInclude;
    /* 0x0010 */ TArray<FName> PackageNamesToExclude;
    /* 0x0020 */ TArray<FName> PackagePathsToInclude;
    /* 0x0030 */ TArray<FName> PackagePathsToExclude;
    /* 0x0040 */ bool bRecursivePackagePathsToInclude;
    /* 0x0041 */ bool bRecursivePackagePathsToExclude;
};

// Size: 0x70
class UContentBrowserDataSource : public UObject {
};

// Size: 0x128
class UContentBrowserDataSubsystem : public UEditorSubsystem {
    /* 0x00b8 */ TArray<FName> EnabledDataSources;

    void ActivateAllDataSources();
    bool ActivateDataSource(const FName Name);
    void DeactivateAllDataSources();
    bool DeactivateDataSource(const FName Name);
    TArray<FName> GetActiveDataSources() const;
    TArray<FName> GetAvailableDataSources() const;
    FContentBrowserItem GetItemAtPath(const FName InPath, const EContentBrowserItemTypeFilter InItemTypeFilter) const;
    TArray<FContentBrowserItem> GetItemsAtPath(const FName InPath, const EContentBrowserItemTypeFilter InItemTypeFilter) const;
    TArray<FContentBrowserItem> GetItemsUnderPath(const FName InPath, const FContentBrowserDataFilter& InFilter) const;
};

// Size: 0x60
struct FContentBrowserItem {
};

// Size: 0x30
class UContentBrowserItemLibrary : public UBlueprintFunctionLibrary {

    static FText GetDisplayName(const FContentBrowserItem& Item);
    static FName GetVirtualPath(const FContentBrowserItem& Item);
    static bool IsFile(const FContentBrowserItem& Item);
    static bool IsFolder(const FContentBrowserItem& Item);
};

enum class EContentBrowserDataMenuContext_AddNewMenuDomain {
    Toolbar = 0,
    AssetView = 1,
    PathView = 2,
    EContentBrowserDataMenuContext_MAX = 3,
};

enum class EContentBrowserItemAttributeFilter {
    IncludeNone = 0,
    IncludeProject = 1,
    IncludeEngine = 2,
    IncludePlugins = 4,
    IncludeDeveloper = 8,
    IncludeLocalized = 16,
    IncludeAll = 31,
    EContentBrowserItemAttributeFilter_MAX = 32,
};

enum class EContentBrowserItemCategoryFilter {
    IncludeNone = 0,
    IncludeAssets = 1,
    IncludeClasses = 2,
    IncludeCollections = 4,
    IncludeMisc = 8,
    IncludeAll = 15,
    EContentBrowserItemCategoryFilter_MAX = 16,
};

enum class EContentBrowserItemTypeFilter {
    IncludeNone = 0,
    IncludeFolders = 1,
    IncludeFiles = 2,
    IncludeAll = 3,
    EContentBrowserItemTypeFilter_MAX = 4,
};

// Size: 0x20
struct FContentBrowserCompiledFileDataFilter {
};

// Size: 0x1e0
class UContentBrowserFileDataSource : public UContentBrowserDataSource {
};

// Size: 0xf0
struct FARFilter {
    /* 0x0000 */ TArray<FName> PackageNames;
    /* 0x0010 */ TArray<FName> PackagePaths;
    /* 0x0020 */ TArray<FName> ObjectPaths;
    /* 0x0030 */ TArray<FName> ClassNames;
    /* 0x0090 */ TSet<FName> RecursiveClassesExclusionSet;
    /* 0x00e0 */ bool bRecursivePaths;
    /* 0x00e1 */ bool bRecursiveClasses;
    /* 0x00e2 */ bool bIncludeOnlyOnDiskAssets;
};

// Size: 0x90
class UArrayProperty : public UProperty {
};

// Size: 0x10
struct FAssetBundleData {
    /* 0x0000 */ TArray<FAssetBundleEntry> Bundles;
};

// Size: 0x20
struct FAssetBundleEntry {
    /* 0x0000 */ FName BundleName;
    /* 0x0010 */ TArray<FSoftObjectPath> BundleAssets;
};

// Size: 0x78
struct FAssetData {
    /* 0x0000 */ FName ObjectPath;
    /* 0x000c */ FName PackageName;
    /* 0x0018 */ FName PackagePath;
    /* 0x0024 */ FName AssetName;
    /* 0x0030 */ FName AssetClass;
};

// Size: 0x38
struct FAutomationEvent {
    /* 0x0000 */ EAutomationEventType Type;
    /* 0x0008 */ FString Message;
    /* 0x0018 */ FString Context;
    /* 0x0028 */ FGuid Artifact;
};

// Size: 0x58
struct FAutomationExecutionEntry {
    /* 0x0000 */ FAutomationEvent Event;
    /* 0x0038 */ FString Filename;
    /* 0x0048 */ int32_t LineNumber;
    /* 0x0050 */ FDateTime Timestamp;
};

// Size: 0x90
class UBoolProperty : public UProperty {
};

// Size: 0x1c
struct FBox {
    /* 0x0000 */ FVector Min;
    /* 0x000c */ FVector Max;
    /* 0x0018 */ uint8_t IsValid;
};

// Size: 0x14
struct FBox2D {
    /* 0x0000 */ FVector2D Min;
    /* 0x0008 */ FVector2D Max;
    /* 0x0010 */ uint8_t bIsValid;
};

// Size: 0x1c
struct FBoxSphereBounds {
    /* 0x0000 */ FVector Origin;
    /* 0x000c */ FVector BoxExtent;
    /* 0x0018 */ float SphereRadius;
};

// Size: 0x90
class UByteProperty : public UNumericProperty {
};

// Size: 0x278
class UClass : public Ustruct {
};

// Size: 0x98
class UClassProperty : public UObjectProperty {
};

// Size: 0x4
struct FColor {
    /* 0x0000 */ uint8_t B;
    /* 0x0001 */ uint8_t G;
    /* 0x0002 */ uint8_t R;
    /* 0x0003 */ uint8_t A;
};

// Size: 0x8
struct FDateTime {
};

// Size: 0xf0
class UDelegateFunction : public UFunction {
};

// Size: 0x90
class UDelegateProperty : public UProperty {
};

// Size: 0x88
class UDoubleProperty : public UNumericProperty {
};

// Size: 0x2f8
class UDynamicClass : public UClass {
};

enum class EAppMsgType {
    Ok = 0,
    YesNo = 1,
    OkCancel = 2,
    YesNoCancel = 3,
    CancelRetryContinue = 4,
    YesNoYesAllNoAll = 5,
    YesNoYesAllNoAllCancel = 6,
    YesNoYesAll = 7,
    EAppMsgType_MAX = 8,
};

enum class EAppReturnType {
    No = 0,
    Yes = 1,
    YesAll = 2,
    NoAll = 3,
    Cancel = 4,
    Ok = 5,
    Retry = 6,
    Continue = 7,
    EAppReturnType_MAX = 8,
};

enum class EAutomationEventType {
    Info = 0,
    Warning = 1,
    Error = 2,
    EAutomationEventType_MAX = 3,
};

enum class EAxis {
    None = 0,
    X = 1,
    Y = 2,
    Z = 3,
    EAxis_MAX = 4,
};

enum class EDataValidationResult {
    Invalid = 0,
    Valid = 1,
    NotValidated = 2,
    EDataValidationResult_MAX = 3,
};

enum class EInterpCurveMode {
    CIM_Linear = 0,
    CIM_CurveAuto = 1,
    CIM_Constant = 2,
    CIM_CurveUser = 3,
    CIM_CurveBreak = 4,
    CIM_CurveAutoClamped = 5,
    CIM_MAX = 6,
};

enum class ELifetimeCondition {
    COND_None = 0,
    COND_InitialOnly = 1,
    COND_OwnerOnly = 2,
    COND_SkipOwner = 3,
    COND_SimulatedOnly = 4,
    COND_AutonomousOnly = 5,
    COND_SimulatedOrPhysics = 6,
    COND_InitialOrOwner = 7,
    COND_Custom = 8,
    COND_ReplayOrOwner = 9,
    COND_ReplayOnly = 10,
    COND_SimulatedOnlyNoReplay = 11,
    COND_SimulatedOrPhysicsNoReplay = 12,
    COND_SkipReplay = 13,
    COND_Never = 15,
    COND_Max = 16,
    COND_Max = 17,
};

enum class ELocalizedTextSourceCategory {
    Game = 0,
    Engine = 1,
    Editor = 2,
    ELocalizedTextSourceCategory_MAX = 3,
};

enum class ELogTimes {
    None = 0,
    UTC = 1,
    SinceGStartTime = 2,
    Local = 3,
    ELogTimes_MAX = 4,
};

enum class EMouseCursor {
    None = 0,
    Default = 1,
    TextEditBeam = 2,
    ResizeLeftRight = 3,
    ResizeUpDown = 4,
    ResizeSouthEast = 5,
    ResizeSouthWest = 6,
    CardinalCross = 7,
    Crosshairs = 8,
    Hand = 9,
    GrabHand = 10,
    GrabHandClosed = 11,
    SlashedCircle = 12,
    EyeDropper = 13,
    EMouseCursor_MAX = 14,
};

enum class EPixelFormat {
    PF_Unknown = 0,
    PF_A32B32G32R32F = 1,
    PF_B8G8R8A8 = 2,
    PF_G8 = 3,
    PF_G16 = 4,
    PF_DXT1 = 5,
    PF_DXT3 = 6,
    PF_DXT5 = 7,
    PF_UYVY = 8,
    PF_FloatRGB = 9,
    PF_FloatRGBA = 10,
    PF_DepthStencil = 11,
    PF_ShadowDepth = 12,
    PF_R32_FLOAT = 13,
    PF_G16R16 = 14,
    PF_G16R16F = 15,
    PF_G16R16F_FILTER = 16,
    PF_G32R32F = 17,
    PF_A2B10G10R10 = 18,
    PF_A16B16G16R16 = 19,
    PF_D24 = 20,
    PF_R16F = 21,
    PF_R16F_FILTER = 22,
    PF_BC5 = 23,
    PF_V8U8 = 24,
    PF_A1 = 25,
    PF_FloatR11G11B10 = 26,
    PF_A8 = 27,
    PF_R32_UINT = 28,
    PF_R32_SINT = 29,
    PF_PVRTC2 = 30,
    PF_PVRTC4 = 31,
    PF_R16_UINT = 32,
    PF_R16_SINT = 33,
    PF_R16G16B16A16_UINT = 34,
    PF_R16G16B16A16_SINT = 35,
    PF_R5G6B5_UNORM = 36,
    PF_R8G8B8A8 = 37,
    PF_A8R8G8B8 = 38,
    PF_BC4 = 39,
    PF_R8G8 = 40,
    PF_ATC_RGB = 41,
    PF_ATC_RGBA_E = 42,
    PF_ATC_RGBA_I = 43,
    PF_X24_G8 = 44,
    PF_ETC1 = 45,
    PF_ETC2_RGB = 46,
    PF_ETC2_RGBA = 47,
    PF_R32G32B32A32_UINT = 48,
    PF_R16G16_UINT = 49,
    PF_ASTC_4x4 = 50,
    PF_ASTC_6x6 = 51,
    PF_ASTC_8x8 = 52,
    PF_ASTC_10x10 = 53,
    PF_ASTC_12x12 = 54,
    PF_BC6H = 55,
    PF_BC7 = 56,
    PF_R8_UINT = 57,
    PF_L8 = 58,
    PF_XGXR8 = 59,
    PF_R8G8B8A8_UINT = 60,
    PF_R8G8B8A8_SNORM = 61,
    PF_R16G16B16A16_UNORM = 62,
    PF_R16G16B16A16_SNORM = 63,
    PF_PLATFORM_HDR_0 = 64,
    PF_PLATFORM_HDR_1 = 65,
    PF_PLATFORM_HDR_2 = 66,
    PF_NV12 = 67,
    PF_R32G32_UINT = 68,
    PF_ETC2_R11_EAC = 69,
    PF_ETC2_RG11_EAC = 70,
    PF_MAX = 72,
};

enum class EPropertyAccessChangeNotifyMode {
    Default = 0,
    Never = 1,
    Always = 2,
    EPropertyAccessChangeNotifyMode_MAX = 3,
};

enum class ERangeBoundTypes {
    Exclusive = 0,
    Inclusive = 1,
    Open = 2,
    ERangeBoundTypes_MAX = 3,
};

enum class ESearchCase {
    CaseSensitive = 0,
    IgnoreCase = 1,
    ESearchCase_MAX = 2,
};

enum class ESearchDir {
    FromStart = 0,
    FromEnd = 1,
    ESearchDir_MAX = 2,
};

enum class EUnit {
    Micrometers = 0,
    Millimeters = 1,
    Centimeters = 2,
    Meters = 3,
    Kilometers = 4,
    Inches = 5,
    Feet = 6,
    Yards = 7,
    Miles = 8,
    Lightyears = 9,
    Degrees = 10,
    Radians = 11,
    MetersPerSecond = 12,
    KilometersPerHour = 13,
    MilesPerHour = 14,
    Celsius = 15,
    Farenheit = 16,
    Kelvin = 17,
    Micrograms = 18,
    Milligrams = 19,
    Grams = 20,
    Kilograms = 21,
    MetricTons = 22,
    Ounces = 23,
    Pounds = 24,
    Stones = 25,
    Newtons = 26,
    PoundsForce = 27,
    KilogramsForce = 28,
    Hertz = 29,
    Kilohertz = 30,
    Megahertz = 31,
    Gigahertz = 32,
    RevolutionsPerMinute = 33,
    Bytes = 34,
    Kilobytes = 35,
    Megabytes = 36,
    Gigabytes = 37,
    Terabytes = 38,
    Lumens = 39,
    Milliseconds = 43,
    Seconds = 44,
    Minutes = 45,
    Hours = 46,
    Days = 47,
    Months = 48,
    Years = 49,
    Multiplier = 52,
    Percentage = 51,
    Unspecified = 53,
    EUnit_MAX = 54,
};

// Size: 0x68
class UEnum : public UField {
};

// Size: 0x98
class UEnumProperty : public UProperty {
};

// Size: 0x1
struct FFallbackStruct {
};

// Size: 0x38
class UField : public UObject {
};

// Size: 0x8
struct FFloatInterval {
    /* 0x0000 */ float Min;
    /* 0x0004 */ float Max;
};

// Size: 0x88
class UFloatProperty : public UNumericProperty {
};

// Size: 0x10
struct FFloatRange {
    /* 0x0000 */ FFloatRangeBound LowerBound;
    /* 0x0008 */ FFloatRangeBound UpperBound;
};

// Size: 0x8
struct FFloatRangeBound {
    /* 0x0000 */ uint8_t Type;
    /* 0x0004 */ float Value;
};

// Size: 0x4
struct FFrameNumber {
    /* 0x0000 */ int32_t Value;
};

// Size: 0x10
struct FFrameNumberRange {
    /* 0x0000 */ FFrameNumberRangeBound LowerBound;
    /* 0x0008 */ FFrameNumberRangeBound UpperBound;
};

// Size: 0x8
struct FFrameNumberRangeBound {
    /* 0x0000 */ uint8_t Type;
    /* 0x0004 */ FFrameNumber Value;
};

// Size: 0x8
struct FFrameRate {
    /* 0x0000 */ int32_t Numerator;
    /* 0x0004 */ int32_t Denominator;
};

// Size: 0x8
struct FFrameTime {
    /* 0x0000 */ FFrameNumber FrameNumber;
    /* 0x0004 */ float SubFrame;
};

// Size: 0xf0
class UFunction : public Ustruct {
};

// Size: 0x78
class UGCObjectReferencer : public UObject {
};

// Size: 0x10
struct FGuid {
    /* 0x0000 */ int32_t A;
    /* 0x0004 */ int32_t B;
    /* 0x0008 */ int32_t C;
    /* 0x000c */ int32_t D;
};

// Size: 0x88
class UInt16Property : public UNumericProperty {
};

// Size: 0x8
struct FInt32Interval {
    /* 0x0000 */ int32_t Min;
    /* 0x0004 */ int32_t Max;
};

// Size: 0x10
struct FInt32Range {
    /* 0x0000 */ FInt32RangeBound LowerBound;
    /* 0x0008 */ FInt32RangeBound UpperBound;
};

// Size: 0x8
struct FInt32RangeBound {
    /* 0x0000 */ uint8_t Type;
    /* 0x0004 */ int32_t Value;
};

// Size: 0x88
class UInt64Property : public UNumericProperty {
};

// Size: 0x88
class UInt8Property : public UNumericProperty {
};

// Size: 0x8
struct FIntPoint {
    /* 0x0000 */ int32_t X;
    /* 0x0004 */ int32_t Y;
};

// Size: 0x88
class UIntProperty : public UNumericProperty {
};

// Size: 0xc
struct FIntVector {
    /* 0x0000 */ int32_t X;
    /* 0x0004 */ int32_t Y;
    /* 0x0008 */ int32_t Z;
};

// Size: 0x30
class UInterface : public UObject {
};

// Size: 0x90
class UInterfaceProperty : public UProperty {
};

// Size: 0x18
struct FInterpCurveFloat {
    /* 0x0000 */ TArray<FInterpCurvePointFloat> Points;
    /* 0x0010 */ bool bIsLooped;
    /* 0x0014 */ float LoopKeyOffset;
};

// Size: 0x18
struct FInterpCurveLinearColor {
    /* 0x0000 */ TArray<FInterpCurvePointLinearColor> Points;
    /* 0x0010 */ bool bIsLooped;
    /* 0x0014 */ float LoopKeyOffset;
};

// Size: 0x14
struct FInterpCurvePointFloat {
    /* 0x0000 */ float InVal;
    /* 0x0004 */ float OutVal;
    /* 0x0008 */ float ArriveTangent;
    /* 0x000c */ float LeaveTangent;
    /* 0x0010 */ uint8_t InterpMode;
};

// Size: 0x38
struct FInterpCurvePointLinearColor {
    /* 0x0000 */ float InVal;
    /* 0x0004 */ FLinearColor OutVal;
    /* 0x0014 */ FLinearColor ArriveTangent;
    /* 0x0024 */ FLinearColor LeaveTangent;
    /* 0x0034 */ uint8_t InterpMode;
};

// Size: 0x50
struct FInterpCurvePointQuat {
    /* 0x0000 */ float InVal;
    /* 0x0010 */ FQuat OutVal;
    /* 0x0020 */ FQuat ArriveTangent;
    /* 0x0030 */ FQuat LeaveTangent;
    /* 0x0040 */ uint8_t InterpMode;
};

// Size: 0x50
struct FInterpCurvePointTwoVectors {
    /* 0x0000 */ float InVal;
    /* 0x0004 */ FTwoVectors OutVal;
    /* 0x001c */ FTwoVectors ArriveTangent;
    /* 0x0034 */ FTwoVectors LeaveTangent;
    /* 0x004c */ uint8_t InterpMode;
};

// Size: 0x2c
struct FInterpCurvePointVector {
    /* 0x0000 */ float InVal;
    /* 0x0004 */ FVector OutVal;
    /* 0x0010 */ FVector ArriveTangent;
    /* 0x001c */ FVector LeaveTangent;
    /* 0x0028 */ uint8_t InterpMode;
};

// Size: 0x20
struct FInterpCurvePointVector2D {
    /* 0x0000 */ float InVal;
    /* 0x0004 */ FVector2D OutVal;
    /* 0x000c */ FVector2D ArriveTangent;
    /* 0x0014 */ FVector2D LeaveTangent;
    /* 0x001c */ uint8_t InterpMode;
};

// Size: 0x18
struct FInterpCurveQuat {
    /* 0x0000 */ TArray<FInterpCurvePointQuat> Points;
    /* 0x0010 */ bool bIsLooped;
    /* 0x0014 */ float LoopKeyOffset;
};

// Size: 0x18
struct FInterpCurveTwoVectors {
    /* 0x0000 */ TArray<FInterpCurvePointTwoVectors> Points;
    /* 0x0010 */ bool bIsLooped;
    /* 0x0014 */ float LoopKeyOffset;
};

// Size: 0x18
struct FInterpCurveVector {
    /* 0x0000 */ TArray<FInterpCurvePointVector> Points;
    /* 0x0010 */ bool bIsLooped;
    /* 0x0014 */ float LoopKeyOffset;
};

// Size: 0x18
struct FInterpCurveVector2D {
    /* 0x0000 */ TArray<FInterpCurvePointVector2D> Points;
    /* 0x0010 */ bool bIsLooped;
    /* 0x0014 */ float LoopKeyOffset;
};

// Size: 0x18
struct FJoinabilitySettings {
    /* 0x0000 */ FName SessionName;
    /* 0x000c */ bool bPublicSearchable;
    /* 0x000d */ bool bAllowInvites;
    /* 0x000e */ bool bJoinViaPresence;
    /* 0x000f */ bool bJoinViaPresenceFriendsOnly;
    /* 0x0010 */ int32_t MaxPlayers;
    /* 0x0014 */ int32_t MaxPartySize;
};

// Size: 0x90
class ULazyObjectProperty : public UObjectPropertyBase {
};

// Size: 0x10
struct FLinearColor {
    /* 0x0000 */ float R;
    /* 0x0004 */ float G;
    /* 0x0008 */ float B;
    /* 0x000c */ float A;
};

// Size: 0x430
class ULinkerPlaceholderClass : public UClass {
};

// Size: 0xf8
class ULinkerPlaceholderExportObject : public UObject {
};

// Size: 0x2a8
class ULinkerPlaceholderFunction : public UFunction {
};

// Size: 0xb0
class UMapProperty : public UProperty {
};

// Size: 0x40
struct FMatrix {
    /* 0x0000 */ FPlane XPlane;
    /* 0x0010 */ FPlane YPlane;
    /* 0x0020 */ FPlane ZPlane;
    /* 0x0030 */ FPlane WPlane;
};

// Size: 0xd0
class UMetaData : public UObject {
};

// Size: 0x90
class UMulticastDelegateProperty : public UProperty {
};

// Size: 0x38
class UMulticastDelegatePropertyWrapper : public UPropertyWrapper {
};

// Size: 0x90
class UMulticastInlineDelegateProperty : public UMulticastDelegateProperty {
};

// Size: 0x38
class UMulticastInlineDelegatePropertyWrapper : public UMulticastDelegatePropertyWrapper {
};

// Size: 0x90
class UMulticastSparseDelegateProperty : public UMulticastDelegateProperty {
};

// Size: 0x88
class UNameProperty : public UProperty {
};

// Size: 0x88
class UNumericProperty : public UProperty {
};

// Size: 0x30
class UObject {

    void ExecuteUbergraph(int32_t EntryPoint);
};

// Size: 0x90
class UObjectProperty : public UObjectPropertyBase {
};

// Size: 0x90
class UObjectPropertyBase : public UProperty {
};

// Size: 0x38
class UObjectRedirector : public UObject {
};

// Size: 0x3c
struct FOrientedBox {
    /* 0x0000 */ FVector Center;
    /* 0x000c */ FVector AxisX;
    /* 0x0018 */ FVector AxisY;
    /* 0x0024 */ FVector AxisZ;
    /* 0x0030 */ float ExtentX;
    /* 0x0034 */ float ExtentY;
    /* 0x0038 */ float ExtentZ;
};

// Size: 0xd8
class UPackage : public UObject {
};

// Size: 0xe8
class UPackageMap : public UObject {
};

// Size: 0x4
struct FPackedNormal {
    /* 0x0000 */ uint8_t X;
    /* 0x0001 */ uint8_t Y;
    /* 0x0002 */ uint8_t Z;
    /* 0x0003 */ uint8_t W;
};

// Size: 0x4
struct FPackedRGB10A2N {
    /* 0x0000 */ int32_t Packed;
};

// Size: 0x8
struct FPackedRGBA16N {
    /* 0x0000 */ int32_t XY;
    /* 0x0004 */ int32_t ZW;
};

// Size: 0x10
struct FPlane : public FVector {
    /* 0x000c */ float W;
};

// Size: 0xb8
struct FPolyglotTextData {
    /* 0x0000 */ ELocalizedTextSourceCategory Category;
    /* 0x0008 */ FString NativeCulture;
    /* 0x0018 */ FString Namespace;
    /* 0x0028 */ FString Key;
    /* 0x0038 */ FString NativeString;
    /* 0x0048 */ TMap<FString, FString> LocalizedStrings;
    /* 0x0098 */ bool bIsMinimalPatch;
    /* 0x00a0 */ FText CachedText;
};

// Size: 0x18
struct FPrimaryAssetId {
    /* 0x0000 */ FPrimaryAssetType PrimaryAssetType;
    /* 0x000c */ FName PrimaryAssetName;
};

// Size: 0xc
struct FPrimaryAssetType {
    /* 0x0000 */ FName Name;
};

// Size: 0x88
class UProperty : public UField {
};

// Size: 0x38
class UPropertyWrapper : public UObject {
};

// Size: 0x10
struct FQualifiedFrameTime {
    /* 0x0000 */ FFrameTime Time;
    /* 0x0008 */ FFrameRate Rate;
};

// Size: 0x10
struct FQuat {
    /* 0x0000 */ float X;
    /* 0x0004 */ float Y;
    /* 0x0008 */ float Z;
    /* 0x000c */ float W;
};

// Size: 0x8
struct FRandomStream {
    /* 0x0000 */ int32_t InitialSeed;
    /* 0x0004 */ int32_t Seed;
};

// Size: 0xc
struct FRotator {
    /* 0x0000 */ float Pitch;
    /* 0x0004 */ float Yaw;
    /* 0x0008 */ float Roll;
};

// Size: 0xd0
class UScriptStruct : public Ustruct {
};

// Size: 0xa8
class USetProperty : public UProperty {
};

// Size: 0x20
struct FSoftClassPath : public FSoftObjectPath {
};

// Size: 0x98
class USoftClassProperty : public USoftObjectProperty {
};

// Size: 0x20
struct FSoftObjectPath {
    /* 0x0000 */ FName AssetPathName;
    /* 0x0010 */ FString SubPathString;
};

// Size: 0x90
class USoftObjectProperty : public UObjectPropertyBase {
};

// Size: 0x108
class USparseDelegateFunction : public UDelegateFunction {
};

// Size: 0x88
class UStrProperty : public UProperty {
};

// Size: 0x90
class UStructProperty : public UProperty {
};

// Size: 0x18
struct FTestUninitializedScriptStructMembersTest {
    /* 0x0000 */ UObject* UninitializedObjectReference;
    /* 0x0008 */ UObject* InitializedObjectReference;
    /* 0x0010 */ float UnusedValue;
};

// Size: 0x58
class UTextBuffer : public UObject {
};

// Size: 0x88
class UTextProperty : public UProperty {
};

// Size: 0x14
struct FTimecode {
    /* 0x0000 */ int32_t Hours;
    /* 0x0004 */ int32_t Minutes;
    /* 0x0008 */ int32_t Seconds;
    /* 0x000c */ int32_t Frames;
    /* 0x0010 */ bool bDropFrameFormat;
};

// Size: 0x8
struct FTimespan {
};

// Size: 0x30
struct FTransform {
    /* 0x0000 */ FQuat Rotation;
    /* 0x0010 */ FVector Translation;
    /* 0x0020 */ FVector Scale3D;
};

// Size: 0x18
struct FTwoVectors {
    /* 0x0000 */ FVector v1;
    /* 0x000c */ FVector v2;
};

// Size: 0x88
class UUInt16Property : public UNumericProperty {
};

// Size: 0x88
class UUInt32Property : public UNumericProperty {
};

// Size: 0x88
class UUInt64Property : public UNumericProperty {
};

// Size: 0x1
struct FUniqueNetIdWrapper {
};

// Size: 0xc
struct FVector {
    /* 0x0000 */ float X;
    /* 0x0004 */ float Y;
    /* 0x0008 */ float Z;
};

// Size: 0x8
struct FVector2D {
    /* 0x0000 */ float X;
    /* 0x0004 */ float Y;
};

// Size: 0x10
struct FVector4 {
    /* 0x0000 */ float X;
    /* 0x0004 */ float Y;
    /* 0x0008 */ float Z;
    /* 0x000c */ float W;
};

// Size: 0x90
class UWeakObjectProperty : public UObjectPropertyBase {
};

// Size: 0xc0
class Ustruct : public UField {
};

// Size: 0x30
struct FCryptoEncryptionKey {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ FString Name;
    /* 0x0020 */ FString Key;
};

// Size: 0x88
class UCryptoKeysCommandlet : public UCommandlet {
};

// Size: 0x90
class UCryptoKeysSettings : public UObject {
    /* 0x0030 */ FString EncryptionKey;
    /* 0x0040 */ TArray<FCryptoEncryptionKey> SecondaryEncryptionKeys;
    /* 0x0050 */ bool bEncryptPakIniFiles;
    /* 0x0051 */ bool bEncryptPakIndex;
    /* 0x0052 */ bool bEncryptUAssetFiles;
    /* 0x0053 */ bool bEncryptAllAssetFiles;
    /* 0x0058 */ FString SigningPublicExponent;
    /* 0x0068 */ FString SigningModulus;
    /* 0x0078 */ FString SigningPrivateExponent;
    /* 0x0088 */ bool bEnablePakSigning;
};

// Size: 0x40
class UCurveEditorBakeFilter : public UCurveEditorFilterBase {
    /* 0x0030 */ bool bUseFrameBake;
    /* 0x0034 */ FFrameNumber BakeIntervalInFrames;
    /* 0x0038 */ float BakeIntervalInSeconds;
};

// Size: 0x50
class UCurveEditorCopyBuffer : public UObject {
    /* 0x0030 */ TArray<UCurveEditorCopyableCurveKeys*> Curves;
    /* 0x0040 */ double TimeOffset;
    /* 0x0048 */ bool bAbsolutePosition;
};

// Size: 0x80
class UCurveEditorCopyableCurveKeys : public UObject {
    /* 0x0030 */ TArray<FKeyPosition> KeyPositions;
    /* 0x0040 */ TArray<FKeyAttributes> KeyAttributes;
    /* 0x0050 */ FString ShortDisplayName;
    /* 0x0060 */ FString LongDisplayName;
    /* 0x0070 */ FString IntentionName;
};

// Size: 0x30
class UCurveEditorEulerFilter : public UCurveEditorFilterBase {
};

// Size: 0x30
class UCurveEditorFilterBase : public UObject {
};

// Size: 0x30
class ICurveEditorKeyProxy : public UInterface {
};

// Size: 0x38
class UCurveEditorReduceFilter : public UCurveEditorFilterBase {
    /* 0x0030 */ float Tolerance;
};

// Size: 0x38
class UCurveEditorSettings : public UObject {
    /* 0x0030 */ bool bAutoFrameCurveEditor;
    /* 0x0031 */ bool bShowCurveEditorCurveToolTips;
    /* 0x0032 */ ECurveEditorTangentVisibility TangentVisibility;
    /* 0x0033 */ ECurveEditorZoomPosition ZoomPosition;
};

enum class ECurveEditorTangentVisibility {
    AllTangents = 0,
    SelectedKeys = 1,
    NoTangents = 2,
    ECurveEditorTangentVisibility_MAX = 3,
};

enum class ECurveEditorZoomPosition {
    CurrentTime = 0,
    MousePosition = 1,
    ECurveEditorZoomPosition_MAX = 2,
};

// Size: 0x18
struct FKeyAttributes {
    /* 0x0000 */ bool bHasArriveTangent;
    /* 0x0000 */ bool bHasLeaveTangent;
    /* 0x0000 */ bool bHasInterpMode;
    /* 0x0000 */ bool bHasTangentMode;
    /* 0x0000 */ bool bHasTangentWeightMode;
    /* 0x0000 */ bool bHasArriveTangentWeight;
    /* 0x0000 */ bool bHasLeaveTangentWeight;
    /* 0x0004 */ float ArriveTangent;
    /* 0x0008 */ float LeaveTangent;
    /* 0x000c */ uint8_t InterpMode;
    /* 0x000d */ uint8_t TangentMode;
    /* 0x000e */ uint8_t TangentWeightMode;
    /* 0x0010 */ float ArriveTangentWeight;
    /* 0x0014 */ float LeaveTangentWeight;
};

// Size: 0x10
struct FKeyPosition {
    /* 0x0000 */ double InputValue;
    /* 0x0008 */ double OutputValue;
};

// Size: 0x68
class URichCurveKeyProxy : public UObject {
    /* 0x0038 */ FRichCurveKey Value;
};

// Size: 0x40
class UCurveEditorFFTFilter : public UCurveEditorFilterBase {
    /* 0x0030 */ float CutoffFrequency;
    /* 0x0034 */ ECurveEditorFFTFilterType Type;
    /* 0x0035 */ ECurveEditorFFTFilterClass Response;
    /* 0x0038 */ int32_t Order;
};

// Size: 0x10
struct FCurveEditorRetimeAnchor {
    /* 0x0000 */ double ValueInSeconds;
    /* 0x0008 */ bool bIsSelected;
};

// Size: 0x40
class UCurveEditorRetimeToolData : public UObject {
    /* 0x0030 */ TArray<FCurveEditorRetimeAnchor> RetimingAnchors;
};

enum class ECurveEditorFFTFilterClass {
    Butterworth = 0,
    Chebyshev = 1,
    ECurveEditorFFTFilterClass_MAX = 2,
};

enum class ECurveEditorFFTFilterType {
    Lowpass = 0,
    Highpass = 1,
    ECurveEditorFFTFilterType_MAX = 2,
};

enum class EMultiScalePivotType {
    Average = 0,
    BoundCenter = 1,
    FirstKey = 2,
    LastKey = 3,
    EMultiScalePivotType_MAX = 4,
};

enum class EToolTransformInterpType {
    Linear = 0,
    Sinusoidal = 1,
    Cubic = 2,
    CircularIn = 3,
    CircularOut = 4,
    ExpIn = 5,
    ExpOut = 6,
    EToolTransformInterpType_MAX = 7,
};

// Size: 0xc
struct FMultiScaleToolOptions {
    /* 0x0000 */ float XScale;
    /* 0x0004 */ float YScale;
    /* 0x0008 */ EMultiScalePivotType PivotType;
};

// Size: 0x1c
struct FTransformToolOptions {
    /* 0x0000 */ float UpperBound;
    /* 0x0004 */ float LowerBound;
    /* 0x0008 */ float LeftBound;
    /* 0x000c */ float RightBound;
    /* 0x0010 */ float ScaleCenterX;
    /* 0x0014 */ float ScaleCenterY;
    /* 0x0018 */ EToolTransformInterpType FalloffInterpType;
};

// Size: 0x510
class UCustomMeshComponent : public UMeshComponent {

    void AddCustomMeshTriangles(const TArray<FCustomMeshTriangle>& Triangles);
    void ClearCustomMeshTriangles();
    bool SetCustomMeshTriangles(const TArray<FCustomMeshTriangle>& Triangles);
};

// Size: 0x24
struct FCustomMeshTriangle {
    /* 0x0000 */ FVector Vertex0;
    /* 0x000c */ FVector Vertex1;
    /* 0x0018 */ FVector Vertex2;
};

// Size: 0x88
class UDataValidationCommandlet : public UCommandlet {
};

// Size: 0x78
class UDataValidationManager : public UObject {
    /* 0x0030 */ TArray<FDirectoryPath> ExcludedDirectories;
    /* 0x0040 */ bool bValidateOnSave;
    /* 0x0058 */ FSoftClassPath DataValidationManagerClassName;
};

// Size: 0x38
class UDataValidationSettings : public UObject {
    /* 0x0030 */ bool bValidateOnSave;
};

// Size: 0x50
class UEditorValidatorBase : public UObject {
    /* 0x0030 */ bool bIsEnabled;

    void AssetFails(UObject* InAsset, const FText& InMessage, TArray<FText>& ValidationErrors);
    void AssetPasses(UObject* InAsset);
    void AssetWarning(UObject* InAsset, const FText& InMessage);
    bool CanValidateAsset(UObject* InAsset) const;
    EDataValidationResult GetValidationResult() const;
    EDataValidationResult ValidateLoadedAsset(UObject* InAsset, TArray<FText>& ValidationErrors);
};

// Size: 0xb8
class UEditorValidatorSubsystem : public UEditorSubsystem {
    /* 0x0038 */ TArray<FDirectoryPath> ExcludedDirectories;
    /* 0x0048 */ bool bValidateOnSave;
    /* 0x0060 */ TMap<UClass*, UEditorValidatorBase*> Validators;
    /* 0x00b0 */ bool bValidateAssetsWhileSavingForCook;
    /* 0x00b1 */ bool bAllowBlueprintValidators;

    void AddValidator(UEditorValidatorBase* InValidator);
    EDataValidationResult IsAssetValid(FAssetData& AssetData, TArray<FText>& ValidationErrors, TArray<FText>& ValidationWarnings) const;
    EDataValidationResult IsObjectValid(UObject* InObject, TArray<FText>& ValidationErrors, TArray<FText>& ValidationWarnings) const;
    int32_t ValidateAssets(TArray<FAssetData> AssetDataList, bool bSkipExcludedDirectories, bool bShowIfNoFailures) const;
};

// Size: 0xa0
class UEditorValidator_Localization : public UEditorValidatorBase {
};

// Size: 0xd8
class UDatasmithActorTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ TSet<FName> Layers;
    /* 0x0088 */ TSet<FName> Tags;
};

// Size: 0x30
class UDatasmithAdditionalData : public UObject {
};

// Size: 0x350
class ADatasmithAreaLightActor : public AActor {
    /* 0x02f8 */ uint8_t Mobility;
    /* 0x02f9 */ EDatasmithAreaLightActorType LightType;
    /* 0x02fa */ EDatasmithAreaLightActorShape LightShape;
    /* 0x02fc */ FVector2D Dimensions;
    /* 0x0304 */ float Intensity;
    /* 0x0308 */ ELightUnits IntensityUnits;
    /* 0x030c */ FLinearColor Color;
    /* 0x031c */ float Temperature;
    /* 0x0320 */ UTextureLightProfile* IESTexture;
    /* 0x0328 */ bool bUseIESBrightness;
    /* 0x032c */ float IESBrightnessScale;
    /* 0x0330 */ FRotator Rotation;
    /* 0x033c */ float SourceRadius;
    /* 0x0340 */ float SourceLength;
    /* 0x0344 */ float AttenuationRadius;
    /* 0x0348 */ float SpotlightInnerAngle;
    /* 0x034c */ float SpotlightOuterAngle;
};

// Size: 0xb0
class UDatasmithAreaLightActorTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ EDatasmithAreaLightActorType LightType;
    /* 0x0039 */ EDatasmithAreaLightActorShape LightShape;
    /* 0x003c */ FVector2D Dimensions;
    /* 0x0044 */ FLinearColor Color;
    /* 0x0054 */ float Intensity;
    /* 0x0058 */ ELightUnits IntensityUnits;
    /* 0x005c */ float Temperature;
    /* 0x0060 */ TSoftObjectPtr<UTextureLightProfile> IESTexture;
    /* 0x0090 */ bool bUseIESBrightness;
    /* 0x0094 */ float IESBrightnessScale;
    /* 0x0098 */ FRotator Rotation;
    /* 0x00a4 */ float SourceRadius;
    /* 0x00a8 */ float SourceLength;
    /* 0x00ac */ float AttenuationRadius;
};

// Size: 0x80
class UDatasmithAssetImportData : public UAssetImportData {
    /* 0x0060 */ FDatasmithAssetImportOptions AssetImportOptions;
    /* 0x0070 */ TArray<UDatasmithAdditionalData*> AdditionalData;
};

// Size: 0xc
struct FDatasmithAssetImportOptions {
    /* 0x0000 */ FName PackagePath;
};

// Size: 0xd0
class UDatasmithAssetUserData : public UAssetUserData {
    /* 0x0030 */ TMap<FName, FString> MetaData;
    /* 0x0080 */ TMap<UClass*, UDatasmithObjectTemplate*> ObjectTemplates;
};

// Size: 0x88
class UDatasmithCADImportSceneData : public UDatasmithSceneImportData {
    /* 0x0078 */ FDatasmithTessellationOptions TessellationOptions;
};

// Size: 0x8
struct FDatasmithCameraFilmbackSettingsTemplate {
    /* 0x0000 */ float SensorWidth;
    /* 0x0004 */ float SensorHeight;
};

// Size: 0x8
struct FDatasmithCameraFocusSettingsTemplate {
    /* 0x0000 */ ECameraFocusMethod FocusMethod;
    /* 0x0004 */ float ManualFocusDistance;
};

// Size: 0x4
struct FDatasmithCameraLensSettingsTemplate {
    /* 0x0000 */ float MaxFStop;
};

// Size: 0x38
struct FDatasmithCameraLookatTrackingSettingsTemplate {
    /* 0x0000 */ bool bEnableLookAtTracking;
    /* 0x0000 */ bool bAllowRoll;
    /* 0x0008 */ TSoftObjectPtr<AActor> ActorToTrack;
};

// Size: 0x70
class UDatasmithCineCameraActorTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ FDatasmithCameraLookatTrackingSettingsTemplate LookatTrackingSettings;
};

// Size: 0xa0
class UDatasmithCineCameraComponentTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ FDatasmithCameraFilmbackSettingsTemplate FilmbackSettings;
    /* 0x0040 */ FDatasmithCameraLensSettingsTemplate LensSettings;
    /* 0x0044 */ FDatasmithCameraFocusSettingsTemplate FocusSettings;
    /* 0x004c */ float CurrentFocalLength;
    /* 0x0050 */ float CurrentAperture;
    /* 0x0060 */ FDatasmithPostProcessSettingsTemplate PostProcessSettings;
};

// Size: 0x40
class UDatasmithCommonTessellationOptions : public UDatasmithOptionsBase {
    /* 0x0030 */ FDatasmithTessellationOptions Options;
};

// Size: 0x30
class UDatasmithContentBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void GetAllDatasmithUserData(UClass* ObjectClass, TArray<UDatasmithAssetUserData*>& OutUserData);
    static void GetAllObjectsAndValuesForKey(FName Key, UClass* ObjectClass, TArray<UObject*>& OutObjects, TArray<FString>& OutValues);
    static UDatasmithAssetUserData* GetDatasmithUserData(UObject* Object);
    static void GetDatasmithUserDataKeysAndValuesForValue(UObject* Object, FString StringToMatch, TArray<FName>& OutKeys, TArray<FString>& OutValues);
    static FString GetDatasmithUserDataValueForKey(UObject* Object, FName Key);
};

// Size: 0x38
class UDatasmithCustomActionBase : public UObject {
};

// Size: 0x50
class UDatasmithDecalComponentTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ int32_t SortOrder;
    /* 0x003c */ FVector DecalSize;
    /* 0x0048 */ UMaterialInterface* Material;
};

// Size: 0x80
class UDatasmithDeltaGenAssetImportData : public UDatasmithAssetImportData {
};

// Size: 0xe0
class UDatasmithDeltaGenSceneImportData : public UDatasmithFBXSceneImportData {
    /* 0x0098 */ bool bMergeNodes;
    /* 0x0099 */ bool bOptimizeDuplicatedNodes;
    /* 0x009a */ bool bRemoveInvisibleNodes;
    /* 0x009b */ bool bSimplifyNodeHierarchy;
    /* 0x009c */ bool bImportVar;
    /* 0x00a0 */ FString VarPath;
    /* 0x00b0 */ bool bImportPos;
    /* 0x00b8 */ FString PosPath;
    /* 0x00c8 */ bool bImportTml;
    /* 0x00d0 */ FString TmlPath;
};

// Size: 0x98
class UDatasmithFBXSceneImportData : public UDatasmithSceneImportData {
    /* 0x0078 */ bool bGenerateLightmapUVs;
    /* 0x0080 */ FString TexturesDir;
    /* 0x0090 */ uint8_t IntermediateSerialization;
    /* 0x0091 */ bool bColorizeMaterials;
};

// Size: 0xc0
class UDatasmithGLTFSceneImportData : public UDatasmithSceneImportData {
    /* 0x0078 */ FString Generator;
    /* 0x0088 */ float Version;
    /* 0x0090 */ FString Author;
    /* 0x00a0 */ FString License;
    /* 0x00b0 */ FString Source;
};

// Size: 0x78
class UDatasmithIFCSceneImportData : public UDatasmithSceneImportData {
};

// Size: 0x18
struct FDatasmithImportBaseOptions {
    /* 0x0000 */ EDatasmithImportScene SceneHandling;
    /* 0x0001 */ bool bIncludeGeometry;
    /* 0x0002 */ bool bIncludeMaterial;
    /* 0x0003 */ bool bIncludeLight;
    /* 0x0004 */ bool bIncludeCamera;
    /* 0x0005 */ bool bIncludeAnimation;
    /* 0x0008 */ FDatasmithAssetImportOptions AssetOptions;
    /* 0x0014 */ FDatasmithStaticMeshImportOptions StaticMeshOptions;
};

// Size: 0x80
class UDatasmithImportOptions : public UDatasmithOptionsBase {
    /* 0x0030 */ EDatasmithImportSearchPackagePolicy SearchPackagePolicy;
    /* 0x0031 */ EDatasmithImportAssetConflictPolicy MaterialConflictPolicy;
    /* 0x0032 */ EDatasmithImportAssetConflictPolicy TextureConflictPolicy;
    /* 0x0033 */ EDatasmithImportActorPolicy StaticMeshActorImportPolicy;
    /* 0x0034 */ EDatasmithImportActorPolicy LightImportPolicy;
    /* 0x0035 */ EDatasmithImportActorPolicy CameraImportPolicy;
    /* 0x0036 */ EDatasmithImportActorPolicy OtherActorImportPolicy;
    /* 0x0037 */ EDatasmithImportMaterialQuality MaterialQuality;
    /* 0x0038 */ FDatasmithImportBaseOptions BaseOptions;
    /* 0x0050 */ FDatasmithReimportOptions ReimportOptions;
    /* 0x0058 */ FString Filename;
    /* 0x0068 */ FString FilePath;
};

// Size: 0x308
class ADatasmithImportedSequencesActor : public AActor {
    /* 0x02f8 */ TArray<ULevelSequence*> ImportedSequences;

    void PlayLevelSequence(ULevelSequence* SequenceToPlay);
};

// Size: 0x48
class UDatasmithLandscapeTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ UMaterialInterface* LandscapeMaterial;
    /* 0x0040 */ int32_t StaticLightingLOD;
};

// Size: 0x70
class UDatasmithLightComponentTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ bool bVisible;
    /* 0x003c */ bool CastShadows;
    /* 0x003c */ bool bUseTemperature;
    /* 0x003c */ bool bUseIESBrightness;
    /* 0x0040 */ float Intensity;
    /* 0x0044 */ float Temperature;
    /* 0x0048 */ float IESBrightnessScale;
    /* 0x004c */ FLinearColor LightColor;
    /* 0x0060 */ UMaterialInterface* LightFunctionMaterial;
    /* 0x0068 */ UTextureLightProfile* IESTexture;
};

// Size: 0x78
class UDatasmithMDLSceneImportData : public UDatasmithSceneImportData {
};

// Size: 0x1a8
class UDatasmithMaterialInstanceTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ TSoftObjectPtr<UMaterialInterface> ParentMaterial;
    /* 0x0068 */ TMap<FName, float> ScalarParameterValues;
    /* 0x00b8 */ TMap<FName, FLinearColor> VectorParameterValues;
    /* 0x0108 */ TMap<FName, TSoftObjectPtr<UTexture>> TextureParameterValues;
    /* 0x0158 */ FDatasmithStaticParameterSetTemplate StaticParameters;
};

// Size: 0x10
struct FDatasmithMeshBuildSettingsTemplate {
    /* 0x0000 */ bool bUseMikkTSpace;
    /* 0x0000 */ bool bRecomputeNormals;
    /* 0x0000 */ bool bRecomputeTangents;
    /* 0x0000 */ bool bRemoveDegenerates;
    /* 0x0000 */ bool bBuildAdjacencyBuffer;
    /* 0x0000 */ bool bUseHighPrecisionTangentBasis;
    /* 0x0000 */ bool bUseFullPrecisionUVs;
    /* 0x0000 */ bool bGenerateLightmapUVs;
    /* 0x0004 */ int32_t MinLightmapResolution;
    /* 0x0008 */ int32_t SrcLightmapIndex;
    /* 0x000c */ int32_t DstLightmapIndex;
};

// Size: 0x50
struct FDatasmithMeshSectionInfoMapTemplate {
    /* 0x0000 */ TMap<uint32_t, FDatasmithMeshSectionInfoTemplate> Map;
};

// Size: 0x4
struct FDatasmithMeshSectionInfoTemplate {
    /* 0x0000 */ int32_t MaterialIndex;
};

// Size: 0x38
class UDatasmithObjectTemplate : public UObject {
};

// Size: 0x30
class UDatasmithOptionsBase : public UObject {
};

// Size: 0x48
class UDatasmithPointLightComponentTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ ELightUnits IntensityUnits;
    /* 0x003c */ float SourceRadius;
    /* 0x0040 */ float SourceLength;
    /* 0x0044 */ float AttenuationRadius;
};

// Size: 0x40
struct FDatasmithPostProcessSettingsTemplate {
    /* 0x0000 */ bool bOverride_WhiteTemp;
    /* 0x0000 */ bool bOverride_ColorSaturation;
    /* 0x0000 */ bool bOverride_VignetteIntensity;
    /* 0x0000 */ bool bOverride_FilmWhitePoint;
    /* 0x0000 */ bool bOverride_AutoExposureMethod;
    /* 0x0000 */ bool bOverride_CameraISO;
    /* 0x0000 */ bool bOverride_CameraShutterSpeed;
    /* 0x0004 */ bool bOverride_DepthOfFieldFstop;
    /* 0x0008 */ float WhiteTemp;
    /* 0x000c */ float VignetteIntensity;
    /* 0x0010 */ FLinearColor FilmWhitePoint;
    /* 0x0020 */ FVector4 ColorSaturation;
    /* 0x0030 */ uint8_t AutoExposureMethod;
    /* 0x0034 */ float CameraISO;
    /* 0x0038 */ float CameraShutterSpeed;
    /* 0x003c */ float DepthOfFieldFstop;
};

// Size: 0x90
class UDatasmithPostProcessVolumeTemplate : public UDatasmithObjectTemplate {
    /* 0x0040 */ FDatasmithPostProcessSettingsTemplate Settings;
    /* 0x0080 */ bool bEnabled;
    /* 0x0080 */ bool bUnbound;
};

// Size: 0x2
struct FDatasmithReimportOptions {
    /* 0x0000 */ bool bUpdateActors;
    /* 0x0001 */ bool bRespawnDeletedActors;
};

// Size: 0x14
struct FDatasmithRetessellationOptions : public FDatasmithTessellationOptions {
    /* 0x0010 */ EDatasmithCADRetessellationRule RetessellationRule;
};

// Size: 0x2d8
class UDatasmithScene : public UObject {
    /* 0x0038 */ UDatasmithSceneImportData* AssetImportData;
    /* 0x0040 */ int32_t BulkDataVersion;
    /* 0x00e0 */ TMap<FName, TSoftObjectPtr<UStaticMesh>> StaticMeshes;
    /* 0x0130 */ TMap<FName, TSoftObjectPtr<UTexture>> Textures;
    /* 0x0180 */ TMap<FName, TSoftObjectPtr<UMaterialFunction>> MaterialFunctions;
    /* 0x01d0 */ TMap<FName, TSoftObjectPtr<UMaterialInterface>> Materials;
    /* 0x0220 */ TMap<FName, TSoftObjectPtr<ULevelSequence>> LevelSequences;
    /* 0x0270 */ TMap<FName, TSoftObjectPtr<ULevelVariantSets>> LevelVariantSets;
    /* 0x02c0 */ TArray<UAssetUserData*> AssetUserData;
};

// Size: 0x358
class ADatasmithSceneActor : public AActor {
    /* 0x02f8 */ UDatasmithScene* Scene;
    /* 0x0300 */ TMap<FName, TSoftObjectPtr<AActor>> RelatedActors;
};

// Size: 0x100
class UDatasmithSceneComponentTemplate : public UDatasmithObjectTemplate {
    /* 0x0040 */ FTransform RelativeTransform;
    /* 0x0070 */ uint8_t Mobility;
    /* 0x0078 */ TSoftObjectPtr<USceneComponent> AttachParent;
    /* 0x00a8 */ bool bVisible;
    /* 0x00b0 */ TSet<FName> Tags;
};

// Size: 0x78
class UDatasmithSceneImportData : public UAssetImportData {
    /* 0x0060 */ FDatasmithImportBaseOptions BaseOptions;
};

// Size: 0x48
class UDatasmithSkyLightComponentTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ uint8_t SourceType;
    /* 0x003c */ int32_t CubemapResolution;
    /* 0x0040 */ UTextureCube* Cubemap;
};

// Size: 0x40
class UDatasmithSpotLightComponentTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ float InnerConeAngle;
    /* 0x003c */ float OuterConeAngle;
};

// Size: 0x18
struct FDatasmithStaticMaterialTemplate {
    /* 0x0000 */ FName MaterialSlotName;
    /* 0x0010 */ UMaterialInterface* MaterialInterface;
};

// Size: 0xd8
class UDatasmithStaticMeshCADImportData : public UDatasmithStaticMeshImportData {
    /* 0x0088 */ FDatasmithTessellationOptions TessellationOptions;
    /* 0x0098 */ double ModelUnit;
    /* 0x00a0 */ double ModelTolerance;
    /* 0x00a8 */ FString ResourcePath;
    /* 0x00b8 */ FString ResourceFilename;
    /* 0x00c8 */ TArray<FString> AuxiliaryFilenames;
};

// Size: 0x50
class UDatasmithStaticMeshComponentTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ UStaticMesh* StaticMesh;
    /* 0x0040 */ TArray<UMaterialInterface*> OverrideMaterials;
};

// Size: 0x98
class UDatasmithStaticMeshGLTFImportData : public UDatasmithStaticMeshImportData {
    /* 0x0088 */ FString SourceMeshName;
};

// Size: 0x98
class UDatasmithStaticMeshIFCImportData : public UDatasmithStaticMeshImportData {
    /* 0x0088 */ FString SourceGlobalId;
};

// Size: 0x88
class UDatasmithStaticMeshImportData : public UDatasmithAssetImportData {
    /* 0x0080 */ FDatasmithStaticMeshImportOptions ImportOptions;
};

// Size: 0x4
struct FDatasmithStaticMeshImportOptions {
    /* 0x0000 */ EDatasmithImportLightmapMin MinLightmapResolution;
    /* 0x0001 */ EDatasmithImportLightmapMax MaxLightmapResolution;
    /* 0x0002 */ bool bGenerateLightmapUVs;
    /* 0x0003 */ bool bRemoveDegenerates;
};

// Size: 0xb0
class UDatasmithStaticMeshTemplate : public UDatasmithObjectTemplate {
    /* 0x0038 */ FDatasmithMeshSectionInfoMapTemplate SectionInfoMap;
    /* 0x0088 */ int32_t LightMapCoordinateIndex;
    /* 0x008c */ int32_t LightMapResolution;
    /* 0x0090 */ TArray<FDatasmithMeshBuildSettingsTemplate> BuildSettings;
    /* 0x00a0 */ TArray<FDatasmithStaticMaterialTemplate> StaticMaterials;
};

// Size: 0x50
struct FDatasmithStaticParameterSetTemplate {
    /* 0x0000 */ TMap<FName, bool> StaticSwitchParameters;
};

// Size: 0x10
struct FDatasmithTessellationOptions {
    /* 0x0000 */ float ChordTolerance;
    /* 0x0004 */ float MaxEdgeLength;
    /* 0x0008 */ float NormalTolerance;
    /* 0x000c */ EDatasmithCADStitchingTechnique StitchingTechnique;
};

// Size: 0x88
class UDatasmithTranslatedSceneImportData : public UDatasmithSceneImportData {
    /* 0x0078 */ TArray<UDatasmithOptionsBase*> AdditionalOptions;
};

// Size: 0x80
class UDatasmithVREDAssetImportData : public UDatasmithAssetImportData {
};

// Size: 0xf8
class UDatasmithVREDSceneImportData : public UDatasmithFBXSceneImportData {
    /* 0x0098 */ bool bMergeNodes;
    /* 0x0099 */ bool bOptimizeDuplicatedNodes;
    /* 0x009a */ bool bImportMats;
    /* 0x00a0 */ FString MatsPath;
    /* 0x00b0 */ bool bImportVar;
    /* 0x00b1 */ bool bCleanVar;
    /* 0x00b8 */ FString VarPath;
    /* 0x00c8 */ bool bImportLightInfo;
    /* 0x00d0 */ FString LightInfoPath;
    /* 0x00e0 */ bool bImportClipInfo;
    /* 0x00e8 */ FString ClipInfoPath;
};

enum class EDatasmithAreaLightActorShape {
    Rectangle = 0,
    Disc = 1,
    Sphere = 2,
    Cylinder = 3,
    None = 4,
    EDatasmithAreaLightActorShape_MAX = 5,
};

enum class EDatasmithAreaLightActorType {
    Point = 0,
    Spot = 1,
    Rect = 2,
    EDatasmithAreaLightActorType_MAX = 3,
};

enum class EDatasmithCADRetessellationRule {
    All = 0,
    SkipDeletedSurfaces = 1,
    EDatasmithCADRetessellationRule_MAX = 2,
};

enum class EDatasmithCADStitchingTechnique {
    StitchingNone = 0,
    StitchingHeal = 1,
    StitchingSew = 2,
    EDatasmithCADStitchingTechnique_MAX = 3,
};

enum class EDatasmithImportActorPolicy {
    Update = 0,
    Full = 1,
    Ignore = 2,
    EDatasmithImportActorPolicy_MAX = 3,
};

enum class EDatasmithImportAssetConflictPolicy {
    Replace = 0,
    Update = 1,
    Use = 2,
    Ignore = 3,
    EDatasmithImportAssetConflictPolicy_MAX = 4,
};

enum class EDatasmithImportLightmapMax {
    LIGHTMAP_64 = 0,
    LIGHTMAP_128 = 1,
    LIGHTMAP_256 = 2,
    LIGHTMAP_512 = 3,
    LIGHTMAP_1024 = 4,
    LIGHTMAP_2048 = 5,
    LIGHTMAP_4096 = 6,
    LIGHTMAP_MAX = 7,
};

enum class EDatasmithImportLightmapMin {
    LIGHTMAP_16 = 0,
    LIGHTMAP_32 = 1,
    LIGHTMAP_64 = 2,
    LIGHTMAP_128 = 3,
    LIGHTMAP_256 = 4,
    LIGHTMAP_512 = 5,
    LIGHTMAP_MAX = 6,
};

enum class EDatasmithImportMaterialQuality {
    UseNoFresnelCurves = 0,
    UseSimplifierFresnelCurves = 1,
    UseRealFresnelCurves = 2,
    EDatasmithImportMaterialQuality_MAX = 3,
};

enum class EDatasmithImportScene {
    NewLevel = 0,
    CurrentLevel = 1,
    AssetsOnly = 2,
    EDatasmithImportScene_MAX = 3,
};

enum class EDatasmithImportSearchPackagePolicy {
    Current = 0,
    All = 1,
    EDatasmithImportSearchPackagePolicy_MAX = 2,
};

enum class EMaterialImportMethod {
    CreateNewMaterials = 0,
    CreateNewInstancedMaterials = 1,
    DoNotCreateMaterialString = 2,
    EMaterialImportMethod_MAX = 3,
};

// Size: 0x30
class USplineMetadataDetailsFactoryBase : public UObject {
};

// Size: 0x60
class UDeveloperSettings : public UObject {
};

// Size: 0x18
struct FAdaptorPolygon {
    /* 0x0000 */ FPolygonGroupID PolygonGroupID;
    /* 0x0008 */ TArray<FAdaptorTriangleID> TriangulatedPolygonTriangleIndices;
};

// Size: 0x48
struct FAdaptorPolygon2Group {
    /* 0x0000 */ uint32_t RenderingSectionIndex;
    /* 0x0004 */ int32_t MaterialIndex;
    /* 0x0008 */ int32_t MaxTriangles;
};

// Size: 0x4
struct FAdaptorTriangleID : public FElementID {
};

// Size: 0x18
struct FAttributesForEdge {
    /* 0x0000 */ FEdgeID EdgeID;
    /* 0x0008 */ FMeshElementAttributeList EdgeAttributes;
};

// Size: 0x18
struct FAttributesForVertex {
    /* 0x0000 */ FVertexID VertexID;
    /* 0x0008 */ FMeshElementAttributeList VertexAttributes;
};

// Size: 0x18
struct FAttributesForVertexInstance {
    /* 0x0000 */ FVertexInstanceID VertexInstanceID;
    /* 0x0008 */ FMeshElementAttributeList VertexInstanceAttributes;
};

// Size: 0x28
struct FChangeVertexInstancesForPolygon {
    /* 0x0000 */ FPolygonID PolygonID;
    /* 0x0008 */ TArray<FVertexIndexAndInstanceID> PerimeterVertexIndicesAndInstanceIDs;
    /* 0x0018 */ TArray<FVertexInstancesForPolygonHole> VertexIndicesAndInstanceIDsForEachHole;
};

enum class EInsetPolygonsMode {
    All = 0,
    CenterPolygonOnly = 1,
    SidePolygonsOnly = 2,
    EInsetPolygonsMode_MAX = 3,
};

enum class EMeshElementAttributeType {
    None = 0,
    FVector4 = 1,
    FVector = 2,
    FVector2D = 3,
    Float = 4,
    Int = 5,
    Bool = 6,
    FName = 7,
    EMeshElementAttributeType_MAX = 8,
};

enum class EMeshModificationType {
    FirstInterim = 0,
    Interim = 1,
    Final = 2,
    EMeshModificationType_MAX = 3,
};

enum class EMeshTopologyChange {
    NoTopologyChange = 0,
    TopologyChange = 1,
    EMeshTopologyChange_MAX = 2,
};

enum class EPolygonEdgeHardness {
    NewEdgesSoft = 0,
    NewEdgesHard = 1,
    AllEdgesSoft = 2,
    AllEdgesHard = 3,
    EPolygonEdgeHardness_MAX = 4,
};

enum class ETriangleTessellationMode {
    ThreeTriangles = 0,
    FourTriangles = 1,
    ETriangleTessellationMode_MAX = 2,
};

// Size: 0x20
struct FEdgeToCreate {
    /* 0x0000 */ FVertexID VertexID0;
    /* 0x0004 */ FVertexID VertexID1;
    /* 0x0008 */ FMeshElementAttributeList EdgeAttributes;
    /* 0x0018 */ FEdgeID OriginalEdgeID;
};

// Size: 0xe0
class UEditableGeometryCollectionAdapter : public UEditableMeshAdapter {
    /* 0x0030 */ UGeometryCollection* GeometryCollection;
    /* 0x0038 */ UGeometryCollection* OriginalGeometryCollection;
    /* 0x0040 */ int32_t GeometryCollectionLODIndex;
};

// Size: 0x710
class UEditableMesh : public UObject {
    /* 0x03c0 */ TArray<UEditableMeshAdapter*> Adapters;
    /* 0x03d8 */ int32_t TextureCoordinateCount;
    /* 0x0524 */ int32_t PendingCompactCounter;
    /* 0x0528 */ int32_t SubdivisionCount;

    bool AnyChangesToUndo() const;
    void AssignPolygonsToPolygonGroups(const TArray<FPolygonGroupForPolygon>& PolygonGroupForPolygons, const bool bDeleteOrphanedPolygonGroups);
    void BevelPolygons(const TArray<FPolygonID>& PolygonIDs, const float BevelFixedDistance, const float BevelProgressTowardCenter, TArray<FPolygonID>& OutNewCenterPolygonIDs, TArray<FPolygonID>& OutNewSidePolygonIDs);
    void ChangePolygonsVertexInstances(const TArray<FChangeVertexInstancesForPolygon>& VertexInstancesForPolygons);
    void Commit();
    UEditableMesh* CommitInstance(UPrimitiveComponent* ComponentToInstanceTo);
    FBox ComputeBoundingBox() const;
    FBoxSphereBounds ComputeBoundingBoxAndSphere() const;
    FVector ComputePolygonCenter(const FPolygonID PolygonID) const;
    FVector ComputePolygonNormal(const FPolygonID PolygonID) const;
    FPlane ComputePolygonPlane(const FPolygonID PolygonID) const;
    void ComputePolygonsSharedEdges(const TArray<FPolygonID>& PolygonIDs, TArray<FEdgeID>& OutSharedEdgeIDs) const;
    void CreateEdges(const TArray<FEdgeToCreate>& EdgesToCreate, TArray<FEdgeID>& OutNewEdgeIDs);
    void CreateEmptyVertexRange(const int32_t NumVerticesToCreate, TArray<FVertexID>& OutNewVertexIDs);
    void CreateMissingPolygonPerimeterEdges(const FPolygonID PolygonID, TArray<FEdgeID>& OutNewEdgeIDs);
    void CreatePolygonGroups(const TArray<FPolygonGroupToCreate>& PolygonGroupsToCreate, TArray<FPolygonGroupID>& OutNewPolygonGroupIDs);
    void CreatePolygons(const TArray<FPolygonToCreate>& PolygonsToCreate, TArray<FPolygonID>& OutNewPolygonIDs, TArray<FEdgeID>& OutNewEdgeIDs);
    void CreateVertexInstances(const TArray<FVertexInstanceToCreate>& VertexInstancesToCreate, TArray<FVertexInstanceID>& OutNewVertexInstanceIDs);
    void CreateVertices(const TArray<FVertexToCreate>& VerticesToCreate, TArray<FVertexID>& OutNewVertexIDs);
    void DeleteEdgeAndConnectedPolygons(const FEdgeID EdgeID, const bool bDeleteOrphanedEdges, const bool bDeleteOrphanedVertices, const bool bDeleteOrphanedVertexInstances, const bool bDeleteEmptyPolygonGroups);
    void DeleteEdges(const TArray<FEdgeID>& EdgeIDsToDelete, const bool bDeleteOrphanedVertices);
    void DeleteOrphanVertices(const TArray<FVertexID>& VertexIDsToDelete);
    void DeletePolygonGroups(const TArray<FPolygonGroupID>& PolygonGroupIDs);
    void DeletePolygons(const TArray<FPolygonID>& PolygonIDsToDelete, const bool bDeleteOrphanedEdges, const bool bDeleteOrphanedVertices, const bool bDeleteOrphanedVertexInstances, const bool bDeleteEmptyPolygonGroups);
    void DeleteVertexAndConnectedEdgesAndPolygons(const FVertexID VertexID, const bool bDeleteOrphanedEdges, const bool bDeleteOrphanedVertices, const bool bDeleteOrphanedVertexInstances, const bool bDeleteEmptyPolygonGroups);
    void DeleteVertexInstances(const TArray<FVertexInstanceID>& VertexInstanceIDsToDelete, const bool bDeleteOrphanedVertices);
    void EndModification(const bool bFromUndo);
    void ExtendEdges(const TArray<FEdgeID>& EdgeIDs, const bool bWeldNeighbors, TArray<FEdgeID>& OutNewExtendedEdgeIDs);
    void ExtendVertices(const TArray<FVertexID>& VertexIDs, const bool bOnlyExtendClosestEdge, const FVector ReferencePosition, TArray<FVertexID>& OutNewExtendedVertexIDs);
    void ExtrudePolygons(const TArray<FPolygonID>& Polygons, const float ExtrudeDistance, const bool bKeepNeighborsTogether, TArray<FPolygonID>& OutNewExtrudedFrontPolygons);
    void FindPolygonLoop(const FEdgeID EdgeID, TArray<FEdgeID>& OutEdgeLoopEdgeIDs, TArray<FEdgeID>& OutFlippedEdgeIDs, TArray<FEdgeID>& OutReversedEdgeIDPathToTake, TArray<FPolygonID>& OutPolygonIDsToSplit) const;
    int32_t FindPolygonPerimeterEdgeNumberForVertices(const FPolygonID PolygonID, const FVertexID EdgeVertexID0, const FVertexID EdgeVertexID1) const;
    int32_t FindPolygonPerimeterVertexNumberForVertex(const FPolygonID PolygonID, const FVertexID VertexID) const;
    void FlipPolygons(const TArray<FPolygonID>& PolygonIDs);
    void GeneratePolygonTangentsAndNormals(const TArray<FPolygonID>& PolygonIDs);
    FPolygonID GetEdgeConnectedPolygon(const FEdgeID EdgeID, const int32_t ConnectedPolygonNumber) const;
    int32_t GetEdgeConnectedPolygonCount(const FEdgeID EdgeID) const;
    void GetEdgeConnectedPolygons(const FEdgeID EdgeID, TArray<FPolygonID>& OutConnectedPolygonIDs) const;
    int32_t GetEdgeCount() const;
    void GetEdgeLoopElements(const FEdgeID EdgeID, TArray<FEdgeID>& EdgeLoopIDs) const;
    FEdgeID GetEdgeThatConnectsVertices(const FVertexID VertexID0, const FVertexID VertexID1) const;
    FVertexID GetEdgeVertex(const FEdgeID EdgeID, const int32_t EdgeVertexNumber) const;
    void GetEdgeVertices(const FEdgeID EdgeID, FVertexID& OutEdgeVertexID0, FVertexID& OutEdgeVertexID1) const;
    FPolygonGroupID GetFirstValidPolygonGroup() const;
    FPolygonGroupID GetGroupForPolygon(const FPolygonID PolygonID) const;
    void GetPolygonAdjacentPolygons(const FPolygonID PolygonID, TArray<FPolygonID>& OutAdjacentPolygons) const;
    int32_t GetPolygonCount() const;
    int32_t GetPolygonCountInGroup(const FPolygonGroupID PolygonGroupID) const;
    int32_t GetPolygonGroupCount() const;
    FPolygonID GetPolygonInGroup(const FPolygonGroupID PolygonGroupID, const int32_t PolygonNumber) const;
    FEdgeID GetPolygonPerimeterEdge(const FPolygonID PolygonID, const int32_t PerimeterEdgeNumber, bool& bOutEdgeWindingIsReversedForPolygon) const;
    int32_t GetPolygonPerimeterEdgeCount(const FPolygonID PolygonID) const;
    void GetPolygonPerimeterEdges(const FPolygonID PolygonID, TArray<FEdgeID>& OutPolygonPerimeterEdgeIDs) const;
    FVertexID GetPolygonPerimeterVertex(const FPolygonID PolygonID, const int32_t PolygonVertexNumber) const;
    int32_t GetPolygonPerimeterVertexCount(const FPolygonID PolygonID) const;
    FVertexInstanceID GetPolygonPerimeterVertexInstance(const FPolygonID PolygonID, const int32_t PolygonVertexNumber) const;
    void GetPolygonPerimeterVertexInstances(const FPolygonID PolygonID, TArray<FVertexInstanceID>& OutPolygonPerimeterVertexInstanceIDs) const;
    void GetPolygonPerimeterVertices(const FPolygonID PolygonID, TArray<FVertexID>& OutPolygonPerimeterVertexIDs) const;
    FTriangleID GetPolygonTriangulatedTriangle(const FPolygonID PolygonID, int32_t PolygonTriangleNumber) const;
    int32_t GetPolygonTriangulatedTriangleCount(const FPolygonID PolygonID) const;
    int32_t GetSubdivisionCount() const;
    FSubdivisionLimitData GetSubdivisionLimitData() const;
    int32_t GetTextureCoordinateCount() const;
    void GetVertexAdjacentVertices(const FVertexID VertexID, TArray<FVertexID>& OutAdjacentVertexIDs) const;
    FEdgeID GetVertexConnectedEdge(const FVertexID VertexID, const int32_t ConnectedEdgeNumber) const;
    int32_t GetVertexConnectedEdgeCount(const FVertexID VertexID) const;
    void GetVertexConnectedEdges(const FVertexID VertexID, TArray<FEdgeID>& OutConnectedEdgeIDs) const;
    void GetVertexConnectedPolygons(const FVertexID VertexID, TArray<FPolygonID>& OutConnectedPolygonIDs) const;
    int32_t GetVertexCount() const;
    FPolygonID GetVertexInstanceConnectedPolygon(const FVertexInstanceID VertexInstanceID, const int32_t ConnectedPolygonNumber) const;
    int32_t GetVertexInstanceConnectedPolygonCount(const FVertexInstanceID VertexInstanceID) const;
    void GetVertexInstanceConnectedPolygons(const FVertexInstanceID VertexInstanceID, TArray<FPolygonID>& OutConnectedPolygonIDs) const;
    int32_t GetVertexInstanceCount() const;
    FVertexID GetVertexInstanceVertex(const FVertexInstanceID VertexInstanceID) const;
    FEdgeID GetVertexPairEdge(const FVertexID VertexID, const FVertexID NextVertexID, bool& bOutEdgeWindingIsReversed) const;
    void InitializeAdapters();
    void InsertEdgeLoop(const FEdgeID EdgeID, const TArray<float>& Splits, TArray<FEdgeID>& OutNewEdgeIDs);
    void InsetPolygons(const TArray<FPolygonID>& PolygonIDs, const float InsetFixedDistance, const float InsetProgressTowardCenter, const EInsetPolygonsMode Mode, TArray<FPolygonID>& OutNewCenterPolygonIDs, TArray<FPolygonID>& OutNewSidePolygonIDs);
    static FEdgeID InvalidEdgeID();
    static FPolygonGroupID InvalidPolygonGroupID();
    static FPolygonID InvalidPolygonID();
    static FVertexID InvalidVertexID();
    bool IsBeingModified() const;
    bool IsCommitted() const;
    bool IsCommittedAsInstance() const;
    bool IsCompactAllowed() const;
    bool IsOrphanedVertex(const FVertexID VertexID) const;
    bool IsPreviewingSubdivisions() const;
    bool IsSpatialDatabaseAllowed() const;
    bool IsUndoAllowed() const;
    bool IsValidEdge(const FEdgeID EdgeID) const;
    bool IsValidPolygon(const FPolygonID PolygonID) const;
    bool IsValidPolygonGroup(const FPolygonGroupID PolygonGroupID) const;
    bool IsValidVertex(const FVertexID VertexID) const;
    static FEdgeID MakeEdgeID(const int32_t EdgeIndex);
    static FPolygonGroupID MakePolygonGroupID(const int32_t PolygonGroupIndex);
    static FPolygonID MakePolygonID(const int32_t PolygonIndex);
    static FVertexID MakeVertexID(const int32_t VertexIndex);
    void MoveVertices(const TArray<FVertexToMove>& VerticesToMove);
    void PropagateInstanceChanges();
    void QuadrangulateMesh(TArray<FPolygonID>& OutNewPolygonIDs);
    void RebuildRenderMesh();
    void Revert();
    UEditableMesh* RevertInstance();
    void SearchSpatialDatabaseForPolygonsInVolume(const TArray<FPlane>& planes, TArray<FPolygonID>& OutPolygons) const;
    void SearchSpatialDatabaseForPolygonsPotentiallyIntersectingLineSegment(const FVector LineSegmentStart, const FVector LineSegmentEnd, TArray<FPolygonID>& OutPolygons) const;
    void SearchSpatialDatabaseForPolygonsPotentiallyIntersectingPlane(const FPlane& InPlane, TArray<FPolygonID>& OutPolygons) const;
    void SetAllowCompact(const bool bInAllowCompact);
    void SetAllowSpatialDatabase(const bool bInAllowSpatialDatabase);
    void SetAllowUndo(const bool bInAllowUndo);
    void SetEdgesAttributes(const TArray<FAttributesForEdge>& AttributesForEdges);
    void SetEdgesCreaseSharpness(const TArray<FEdgeID>& EdgeIDs, const TArray<float>& EdgesNewCreaseSharpness);
    void SetEdgesHardness(const TArray<FEdgeID>& EdgeIDs, const TArray<bool>& EdgesNewIsHard);
    void SetEdgesHardnessAutomatically(const TArray<FEdgeID>& EdgeIDs, const float MaxDotProductForSoftEdge);
    void SetPolygonsVertexAttributes(const TArray<FVertexAttributesForPolygon>& VertexAttributesForPolygons);
    void SetSubdivisionCount(const int32_t NewSubdivisionCount);
    void SetTextureCoordinateCount(const int32_t NumTexCoords);
    void SetVertexInstancesAttributes(const TArray<FAttributesForVertexInstance>& AttributesForVertexInstances);
    void SetVerticesAttributes(const TArray<FAttributesForVertex>& AttributesForVertices);
    void SetVerticesCornerSharpness(const TArray<FVertexID>& VertexIDs, const TArray<float>& VerticesNewCornerSharpness);
    void SplitEdge(const FEdgeID EdgeID, const TArray<float>& Splits, TArray<FVertexID>& OutNewVertexIDs);
    void SplitPolygonalMesh(const FPlane& InPlane, TArray<FPolygonID>& PolygonIDs1, TArray<FPolygonID>& PolygonIDs2, TArray<FEdgeID>& BoundaryIDs);
    void SplitPolygons(const TArray<FPolygonToSplit>& PolygonsToSplit, TArray<FEdgeID>& OutNewEdgeIDs);
    void StartModification(const EMeshModificationType MeshModificationType, const EMeshTopologyChange MeshTopologyChange);
    void TessellatePolygons(const TArray<FPolygonID>& PolygonIDs, const ETriangleTessellationMode TriangleTessellationMode, TArray<FPolygonID>& OutNewPolygonIDs);
    void TriangulatePolygons(const TArray<FPolygonID>& PolygonIDs, TArray<FPolygonID>& OutNewTrianglePolygons);
    void TryToRemovePolygonEdge(const FEdgeID EdgeID, bool& bOutWasEdgeRemoved, FPolygonID& OutNewPolygonID);
    void TryToRemoveVertex(const FVertexID VertexID, bool& bOutWasVertexRemoved, FEdgeID& OutNewEdgeID);
    void WeldVertices(const TArray<FVertexID>& VertexIDs, FVertexID& OutNewVertexID);
};

// Size: 0x30
class UEditableMeshAdapter : public UObject {
};

// Size: 0x30
class UEditableMeshFactory : public UObject {

    static UEditableMesh* MakeEditableMesh(UPrimitiveComponent* PrimitiveComponent, const int32_t LODIndex);
};

// Size: 0xe8
class UEditableStaticMeshAdapter : public UEditableMeshAdapter {
    /* 0x0030 */ UStaticMesh* StaticMesh;
    /* 0x0038 */ UStaticMesh* OriginalStaticMesh;
    /* 0x0040 */ int32_t StaticMeshLODIndex;
};

// Size: 0x60
struct FMeshElementAttributeData {
    /* 0x0000 */ FName AttributeName;
    /* 0x000c */ int32_t AttributeIndex;
    /* 0x0010 */ FMeshElementAttributeValue AttributeValue;
};

// Size: 0x10
struct FMeshElementAttributeList {
    /* 0x0000 */ TArray<FMeshElementAttributeData> Attributes;
};

// Size: 0x50
struct FMeshElementAttributeValue {
};

// Size: 0x8
struct FPolygonGroupForPolygon {
    /* 0x0000 */ FPolygonID PolygonID;
    /* 0x0004 */ FPolygonGroupID PolygonGroupID;
};

// Size: 0x18
struct FPolygonGroupToCreate {
    /* 0x0000 */ FMeshElementAttributeList PolygonGroupAttributes;
    /* 0x0010 */ FPolygonGroupID OriginalPolygonGroupID;
};

// Size: 0x20
struct FPolygonToCreate {
    /* 0x0000 */ FPolygonGroupID PolygonGroupID;
    /* 0x0008 */ TArray<FVertexAndAttributes> PerimeterVertices;
    /* 0x0018 */ FPolygonID OriginalPolygonID;
    /* 0x001c */ EPolygonEdgeHardness PolygonEdgeHardness;
};

// Size: 0x18
struct FPolygonToSplit {
    /* 0x0000 */ FPolygonID PolygonID;
    /* 0x0008 */ TArray<FVertexPair> VertexPairsToSplitAt;
};

// Size: 0x18
struct FRenderingPolygon {
    /* 0x0000 */ FPolygonGroupID PolygonGroupID;
    /* 0x0008 */ TArray<FTriangleID> TriangulatedPolygonTriangleIndices;
};

// Size: 0x48
struct FRenderingPolygonGroup {
    /* 0x0000 */ uint32_t RenderingSectionIndex;
    /* 0x0004 */ int32_t MaterialIndex;
    /* 0x0008 */ int32_t MaxTriangles;
};

// Size: 0xd0
struct FSubdividedQuad {
    /* 0x0000 */ FSubdividedQuadVertex QuadVertex0;
    /* 0x0034 */ FSubdividedQuadVertex QuadVertex1;
    /* 0x0068 */ FSubdividedQuadVertex QuadVertex2;
    /* 0x009c */ FSubdividedQuadVertex QuadVertex3;
};

// Size: 0x34
struct FSubdividedQuadVertex {
    /* 0x0000 */ int32_t VertexPositionIndex;
    /* 0x0004 */ FVector2D TextureCoordinate0;
    /* 0x000c */ FVector2D TextureCoordinate1;
    /* 0x0014 */ FColor VertexColor;
    /* 0x0018 */ FVector VertexNormal;
    /* 0x0024 */ FVector VertexTangent;
    /* 0x0030 */ float VertexBinormalSign;
};

// Size: 0xc
struct FSubdividedWireEdge {
    /* 0x0000 */ int32_t EdgeVertex0PositionIndex;
    /* 0x0004 */ int32_t EdgeVertex1PositionIndex;
};

// Size: 0x30
struct FSubdivisionLimitData {
    /* 0x0000 */ TArray<FVector> VertexPositions;
    /* 0x0010 */ TArray<FSubdivisionLimitSection> Sections;
    /* 0x0020 */ TArray<FSubdividedWireEdge> SubdividedWireEdges;
};

// Size: 0x10
struct FSubdivisionLimitSection {
    /* 0x0000 */ TArray<FSubdividedQuad> SubdividedQuads;
};

// Size: 0x18
struct FVertexAndAttributes {
    /* 0x0000 */ FVertexInstanceID VertexInstanceID;
    /* 0x0004 */ FVertexID VertexID;
    /* 0x0008 */ FMeshElementAttributeList PolygonVertexAttributes;
};

// Size: 0x28
struct FVertexAttributesForPolygon {
    /* 0x0000 */ FPolygonID PolygonID;
    /* 0x0008 */ TArray<FMeshElementAttributeList> PerimeterVertexAttributeLists;
    /* 0x0018 */ TArray<FVertexAttributesForPolygonHole> VertexAttributeListsForEachHole;
};

// Size: 0x10
struct FVertexAttributesForPolygonHole {
    /* 0x0000 */ TArray<FMeshElementAttributeList> VertexAttributeList;
};

// Size: 0x8
struct FVertexIndexAndInstanceID {
    /* 0x0000 */ int32_t ContourIndex;
    /* 0x0004 */ FVertexInstanceID VertexInstanceID;
};

// Size: 0x20
struct FVertexInstanceToCreate {
    /* 0x0000 */ FVertexID VertexID;
    /* 0x0008 */ FMeshElementAttributeList VertexInstanceAttributes;
    /* 0x0018 */ FVertexInstanceID OriginalVertexInstanceID;
};

// Size: 0x10
struct FVertexInstancesForPolygonHole {
    /* 0x0000 */ TArray<FVertexIndexAndInstanceID> VertexIndicesAndInstanceIDs;
};

// Size: 0x8
struct FVertexPair {
    /* 0x0000 */ FVertexID VertexID0;
    /* 0x0004 */ FVertexID VertexID1;
};

// Size: 0x18
struct FVertexToCreate {
    /* 0x0000 */ FMeshElementAttributeList VertexAttributes;
    /* 0x0010 */ FVertexID OriginalVertexID;
};

// Size: 0x10
struct FVertexToMove {
    /* 0x0000 */ FVertexID VertexID;
    /* 0x0004 */ FVector NewVertexPosition;
};

// Size: 0x248
class UEdModeInteractiveToolsContext : public UInteractiveToolsContext {
    /* 0x00a8 */ UMaterialInterface* StandardVertexColorMaterial;
};

enum class EAssetEditorOpenLocation {
    Default = 0,
    NewWindow = 1,
    MainWindow = 2,
    ContentBrowser = 3,
    LastDockedWindowOrNewWindow = 4,
    LastDockedWindowOrMainWindow = 5,
    LastDockedWindowOrContentBrowser = 6,
    EAssetEditorOpenLocation_MAX = 7,
};

// Size: 0x340
class UEditorStyleSettings : public UObject {
    /* 0x0030 */ bool bEnableHighDPIAwareness;
    /* 0x0031 */ bool bEnableUserEditorLayoutManagement;
    /* 0x0032 */ EColorVisionDeficiency ColorVisionDeficiencyPreviewType;
    /* 0x0034 */ int32_t ColorVisionDeficiencySeverity;
    /* 0x0038 */ bool bColorVisionDeficiencyCorrection;
    /* 0x0039 */ bool bColorVisionDeficiencyCorrectionPreviewWithDeficiency;
    /* 0x003c */ FLinearColor SelectionColor;
    /* 0x004c */ FLinearColor PressedSelectionColor;
    /* 0x005c */ FLinearColor InactiveSelectionColor;
    /* 0x006c */ FLinearColor KeyboardFocusColor;
    /* 0x007c */ FLinearColor EditorWindowBackgroundColor;
    /* 0x0090 */ FSlateBrush EditorMainWindowBackgroundOverride;
    /* 0x0130 */ FSlateBrush EditorChildWindowBackgroundOverride;
    /* 0x01d0 */ bool bResetEditorWindowBackgroundSettings;
    /* 0x01d4 */ bool bUseSmallToolBarIcons;
    /* 0x01d4 */ bool bUseGrid;
    /* 0x01d8 */ FLinearColor RegularColor;
    /* 0x01e8 */ FLinearColor RuleColor;
    /* 0x01f8 */ FLinearColor CenterColor;
    /* 0x0208 */ uint32_t GridSnapSize;
    /* 0x0210 */ FSlateBrush GraphBackgroundBrush;
    /* 0x02b0 */ bool bEnableWindowAnimations;
    /* 0x02b0 */ bool bShowFriendlyNames;
    /* 0x02b0 */ bool bShowNativeComponentNames;
    /* 0x02b0 */ bool bExpandConfigurationMenus;
    /* 0x02b0 */ bool bShowProjectMenus;
    /* 0x02b0 */ bool bShowLaunchMenus;
    /* 0x02b4 */ FLinearColor LogBackgroundColor;
    /* 0x02c4 */ FLinearColor LogSelectionBackgroundColor;
    /* 0x02d4 */ FLinearColor LogNormalColor;
    /* 0x02e4 */ FLinearColor LogCommandColor;
    /* 0x02f4 */ FLinearColor LogWarningColor;
    /* 0x0304 */ FLinearColor LogErrorColor;
    /* 0x0314 */ bool bShowAllAdvancedDetails;
    /* 0x0314 */ bool bShowHiddenPropertiesWhilePlaying;
    /* 0x0318 */ int32_t LogFontSize;
    /* 0x031c */ uint8_t LogTimestampMode;
    /* 0x031d */ bool bPromoteOutputLogWarningsDuringPIE;
    /* 0x031e */ EAssetEditorOpenLocation AssetEditorOpenLocation;
    /* 0x0320 */ bool bEnableColorizedEditorTabs;
    /* 0x0320 */ bool bEnableLegacyEditorModeUI;
};

// Size: 0x38
class UEditorSubsystem : public UDynamicSubsystem {
};

// Size: 0x28
struct FA2CSPose : public FA2Pose {
    /* 0x0018 */ TArray<uint8_t> ComponentSpaceFlags;
};

// Size: 0x10
struct FA2Pose {
    /* 0x0000 */ TArray<FTransform> Bones;
};

// Size: 0x70
class UAISystemBase : public UObject {
    /* 0x0030 */ FSoftClassPath AISystemClassName;
    /* 0x0050 */ FName AISystemModuleName;
    /* 0x0068 */ bool bInstantiateAISystemOnClient;
};

// Size: 0x18
struct FActiveCameraShakeInfo {
    /* 0x0000 */ UCameraShakeBase* ShakeInstance;
    /* 0x0008 */ TWeakObjectPtr<UCameraShakeSourceComponent> ShakeSource;
    /* 0x0010 */ bool bIsCustomInitialized;
};

// Size: 0x20
struct FActiveForceFeedbackEffect {
    /* 0x0000 */ UForceFeedbackEffect* ForceFeedbackEffect;
};

// Size: 0x18
struct FActiveHapticFeedbackEffect {
    /* 0x0000 */ UHapticFeedbackEffect_Base* HapticEffect;
};

// Size: 0x2f8
class AActor : public UObject {
    /* 0x0038 */ FActorTickFunction PrimaryActorTick;
    /* 0x0068 */ bool bNetTemporary;
    /* 0x0068 */ bool bNetStartup;
    /* 0x0068 */ bool bOnlyRelevantToOwner;
    /* 0x0068 */ bool bAlwaysRelevant;
    /* 0x0068 */ bool bReplicateMovement;
    /* 0x0068 */ bool bHidden;
    /* 0x0068 */ bool bTearOff;
    /* 0x0068 */ bool bForceNetAddressable;
    /* 0x0069 */ bool bExchangedRoles;
    /* 0x0069 */ bool bNetLoadOnClient;
    /* 0x0069 */ bool bNetUseOwnerRelevancy;
    /* 0x0069 */ bool bRelevantForNetworkReplays;
    /* 0x0069 */ bool bRelevantForLevelBounds;
    /* 0x0069 */ bool bReplayRewindable;
    /* 0x0069 */ bool bAllowTickBeforeBeginPlay;
    /* 0x0069 */ bool bAutoDestroyWhenFinished;
    /* 0x006a */ bool bCanBeDamaged;
    /* 0x006a */ bool bBlockInput;
    /* 0x006a */ bool bCollideWhenPlacing;
    /* 0x006a */ bool bFindCameraComponentWhenViewTarget;
    /* 0x006a */ bool bGenerateOverlapEventsDuringLevelStreaming;
    /* 0x006a */ bool bIgnoresOriginShifting;
    /* 0x006a */ bool bEnableAutoLODGeneration;
    /* 0x006a */ bool bIsEditorOnlyActor;
    /* 0x006b */ bool bActorSeamlessTraveled;
    /* 0x006b */ bool bReplicates;
    /* 0x006b */ bool bCanBeInCluster;
    /* 0x006b */ bool bAllowReceiveTickEventOnDedicatedServer;
    /* 0x006c */ bool bActorEnableCollision;
    /* 0x006c */ bool bActorIsBeingDestroyed;
    /* 0x006d */ EActorUpdateOverlapsMethod UpdateOverlapsMethodDuringLevelStreaming;
    /* 0x006e */ EActorUpdateOverlapsMethod DefaultUpdateOverlapsMethodDuringLevelStreaming;
    /* 0x006f */ uint8_t RemoteRole;
    /* 0x0070 */ FRepMovement ReplicatedMovement;
    /* 0x00a4 */ float InitialLifeSpan;
    /* 0x00a8 */ float CustomTimeDilation;
    /* 0x00b0 */ FRepAttachment AttachmentReplication;
    /* 0x00f0 */ AActor* Owner;
    /* 0x0100 */ FName NetDriverName;
    /* 0x010c */ uint8_t Role;
    /* 0x010d */ uint8_t NetDormancy;
    /* 0x010e */ ESpawnActorCollisionHandlingMethod SpawnCollisionHandlingMethod;
    /* 0x010f */ uint8_t AutoReceiveInput;
    /* 0x0110 */ int32_t InputPriority;
    /* 0x0118 */ UInputComponent* InputComponent;
    /* 0x0120 */ float NetCullDistanceSquared;
    /* 0x0124 */ int32_t NetTag;
    /* 0x0128 */ float NetUpdateFrequency;
    /* 0x012c */ float MinNetUpdateFrequency;
    /* 0x0130 */ float NetPriority;
    /* 0x0138 */ APawn* Instigator;
    /* 0x0140 */ TArray<AActor*> Children;
    /* 0x0150 */ USceneComponent* RootComponent;
    /* 0x0158 */ FVector PivotOffset;
    /* 0x0168 */ TArray<AMatineeActor*> ControllingMatineeActors;
    /* 0x0180 */ TArray<FName> Layers;
    /* 0x0190 */ TWeakObjectPtr<AActor> ParentComponentActor;
    /* 0x0198 */ TWeakObjectPtr<UChildActorComponent> ParentComponent;
    /* 0x01a0 */ FGuid ActorGuid;
    /* 0x01b0 */ AActor* GroupActor;
    /* 0x01b8 */ float SpriteScale;
    /* 0x01c0 */ uint64_t HiddenEditorViews;
    /* 0x01c8 */ FString ActorLabel;
    /* 0x01d8 */ FName FolderPath;
    /* 0x01e4 */ bool bHiddenEd;
    /* 0x01e4 */ bool bIsEditorPreviewActor;
    /* 0x01e4 */ bool bHiddenEdLayer;
    /* 0x01e4 */ bool bHiddenEdLevel;
    /* 0x01e4 */ bool bLockLocation;
    /* 0x01e4 */ bool bActorLabelEditable;
    /* 0x01e4 */ bool bEditable;
    /* 0x01e5 */ bool bListedInSceneOutliner;
    /* 0x01e5 */ bool bOptimizeBPComponentData;
    /* 0x01e5 */ bool bHiddenEdTemporary;
    /* 0x01e8 */ TArray<FName> Tags;
    /* 0x01f8 */ FMulticastSparseDelegate OnTakeAnyDamage;
    /* 0x01f9 */ FMulticastSparseDelegate OnTakePointDamage;
    /* 0x01fa */ FMulticastSparseDelegate OnTakeRadialDamage;
    /* 0x01fb */ FMulticastSparseDelegate OnActorBeginOverlap;
    /* 0x01fc */ FMulticastSparseDelegate OnActorEndOverlap;
    /* 0x01fd */ FMulticastSparseDelegate OnBeginCursorOver;
    /* 0x01fe */ FMulticastSparseDelegate OnEndCursorOver;
    /* 0x01ff */ FMulticastSparseDelegate OnClicked;
    /* 0x0200 */ FMulticastSparseDelegate OnReleased;
    /* 0x0201 */ FMulticastSparseDelegate OnInputTouchBegin;
    /* 0x0202 */ FMulticastSparseDelegate OnInputTouchEnd;
    /* 0x0203 */ FMulticastSparseDelegate OnInputTouchEnter;
    /* 0x0204 */ FMulticastSparseDelegate OnInputTouchLeave;
    /* 0x0205 */ FMulticastSparseDelegate OnActorHit;
    /* 0x0206 */ FMulticastSparseDelegate OnDestroyed;
    /* 0x0207 */ FMulticastSparseDelegate OnEndPlay;
    /* 0x02c8 */ TArray<UActorComponent*> InstanceComponents;
    /* 0x02d8 */ TArray<UActorComponent*> BlueprintCreatedComponents;

    bool ActorHasTag(FName Tag) const;
    UActorComponent* AddComponent(FName TemplateName, bool bManualAttachment, const FTransform& RelativeTransform, const UObject* ComponentTemplateContext, bool bDeferredFinish);
    UActorComponent* AddComponentByClass(UClass* Class, bool bManualAttachment, const FTransform& RelativeTransform, bool bDeferredFinish);
    void AddTickPrerequisiteActor(AActor* PrerequisiteActor);
    void AddTickPrerequisiteComponent(UActorComponent* PrerequisiteComponent);
    void DetachRootComponentFromParent(bool bMaintainWorldPosition);
    void DisableInput(APlayerController* PlayerController);
    void EnableInput(APlayerController* PlayerController);
    void FinishAddComponent(UActorComponent* Component, bool bManualAttachment, const FTransform& RelativeTransform);
    void FlushNetDormancy();
    void ForceNetUpdate();
    void GetActorBounds(bool bOnlyCollidingComponents, FVector& Origin, FVector& BoxExtent, bool bIncludeFromChildActors) const;
    bool GetActorEnableCollision() const;
    void GetActorEyesViewPoint(FVector& OutLocation, FRotator& OutRotation) const;
    FVector GetActorForwardVector() const;
    FString GetActorLabel() const;
    FVector GetActorRelativeScale3D() const;
    FVector GetActorRightVector() const;
    FVector GetActorScale3D() const;
    float GetActorTickInterval() const;
    float GetActorTimeDilation() const;
    FVector GetActorUpVector() const;
    void GetAllChildActors(TArray<AActor*>& ChildActors, bool bIncludeDescendants) const;
    AActor* GetAttachParentActor() const;
    FName GetAttachParentSocketName() const;
    void GetAttachedActors(TArray<AActor*>& OutActors, bool bResetArray) const;
    UActorComponent* GetComponentByClass(UClass* ComponentClass) const;
    TArray<UActorComponent*> GetComponentsByInterface(UClass* Interface) const;
    TArray<UActorComponent*> GetComponentsByTag(UClass* ComponentClass, FName Tag) const;
    float GetDistanceTo(const AActor* OtherActor) const;
    float GetDotProductTo(const AActor* OtherActor) const;
    FName GetFolderPath() const;
    float GetGameTimeSinceCreation() const;
    float GetHorizontalDistanceTo(const AActor* OtherActor) const;
    float GetHorizontalDotProductTo(const AActor* OtherActor) const;
    float GetInputAxisKeyValue(const FKey InputAxisKey) const;
    float GetInputAxisValue(const FName InputAxisName) const;
    FVector GetInputVectorAxisValue(const FKey InputAxisKey) const;
    APawn* GetInstigator() const;
    AController* GetInstigatorController() const;
    float GetLifeSpan() const;
    uint8_t GetLocalRole() const;
    void GetOverlappingActors(TArray<AActor*>& OverlappingActors, UClass* ClassFilter) const;
    void GetOverlappingComponents(TArray<UPrimitiveComponent*>& OverlappingComponents) const;
    AActor* GetOwner() const;
    AActor* GetParentActor() const;
    UChildActorComponent* GetParentComponent() const;
    uint8_t GetRemoteRole() const;
    float GetSquaredDistanceTo(const AActor* OtherActor) const;
    float GetSquaredHorizontalDistanceTo(const AActor* OtherActor) const;
    bool GetTickableWhenPaused();
    FTransform GetTransform() const;
    FVector GetVelocity() const;
    float GetVerticalDistanceTo(const AActor* OtherActor) const;
    bool HasAuthority() const;
    bool IsActorBeingDestroyed() const;
    bool IsActorTickEnabled() const;
    bool IsChildActor() const;
    bool IsEditable() const;
    bool IsHiddenEd() const;
    bool IsHiddenEdAtStartup() const;
    bool IsOverlappingActor(const AActor* Other) const;
    bool IsSelectable() const;
    bool IsTemporarilyHiddenInEditor(bool bIncludeParent) const;
    void K2_AddActorLocalOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorLocalRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorLocalTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldTransformKeepScale(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AttachRootComponentTo(USceneComponent* InParent, FName InSocketName, uint8_t AttachLocationType, bool bWeldSimulatedBodies);
    void K2_AttachRootComponentToActor(AActor* InParentActor, FName InSocketName, uint8_t AttachLocationType, bool bWeldSimulatedBodies);
    void K2_AttachToActor(AActor* ParentActor, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    void K2_AttachToComponent(USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    void K2_DestroyActor();
    void K2_DestroyComponent(UActorComponent* Component);
    void K2_DetachFromActor(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule);
    FVector K2_GetActorLocation() const;
    FRotator K2_GetActorRotation() const;
    TArray<UActorComponent*> K2_GetComponentsByClass(UClass* ComponentClass) const;
    USceneComponent* K2_GetRootComponent() const;
    void K2_OnBecomeViewTarget(APlayerController* PC);
    void K2_OnEndViewTarget(APlayerController* PC);
    void K2_OnReset();
    bool K2_SetActorLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_SetActorLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetActorRelativeLocation(FVector NewRelativeLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetActorRelativeRotation(FRotator NewRelativeRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetActorRelativeTransform(const FTransform& NewRelativeTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_SetActorRotation(FRotator NewRotation, bool bTeleportPhysics);
    bool K2_SetActorTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_TeleportTo(FVector DestLocation, FRotator DestRotation);
    UMaterialInstanceDynamic* MakeMIDForMaterial(UMaterialInterface* Parent);
    void MakeNoise(float Loudness, APawn* NoiseInstigator, FVector NoiseLocation, float MaxRange, FName Tag);
    void OnRep_AttachmentReplication();
    void OnRep_Instigator();
    void OnRep_Owner();
    void OnRep_ReplicateMovement();
    void OnRep_ReplicatedMovement();
    void PrestreamTextures(float Seconds, bool bEnableStreaming, int32_t CinematicTextureGroups);
    void ReceiveActorBeginCursorOver();
    void ReceiveActorBeginOverlap(AActor* OtherActor);
    void ReceiveActorEndCursorOver();
    void ReceiveActorEndOverlap(AActor* OtherActor);
    void ReceiveActorOnClicked(FKey ButtonPressed);
    void ReceiveActorOnInputTouchBegin(const uint8_t FingerIndex);
    void ReceiveActorOnInputTouchEnd(const uint8_t FingerIndex);
    void ReceiveActorOnInputTouchEnter(const uint8_t FingerIndex);
    void ReceiveActorOnInputTouchLeave(const uint8_t FingerIndex);
    void ReceiveActorOnReleased(FKey ButtonReleased);
    void ReceiveAnyDamage(float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser);
    void ReceiveBeginPlay();
    void ReceiveDestroyed();
    void ReceiveEndPlay(uint8_t EndPlayReason);
    void ReceiveHit(UPrimitiveComponent* MyComp, AActor* Other, UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit);
    void ReceivePointDamage(float Damage, const UDamageType* DamageType, FVector HitLocation, FVector HitNormal, UPrimitiveComponent* HitComponent, FName BoneName, FVector ShotFromDirection, AController* InstigatedBy, AActor* DamageCauser, const FHitResult& HitInfo);
    void ReceiveRadialDamage(float DamageReceived, const UDamageType* DamageType, FVector Origin, const FHitResult& HitInfo, AController* InstigatedBy, AActor* DamageCauser);
    void ReceiveTick(float DeltaSeconds);
    void RemoveTickPrerequisiteActor(AActor* PrerequisiteActor);
    void RemoveTickPrerequisiteComponent(UActorComponent* PrerequisiteComponent);
    void SetActorEnableCollision(bool bNewActorEnableCollision);
    void SetActorHiddenInGame(bool bNewHidden);
    void SetActorLabel(FString NewActorLabel, bool bMarkDirty);
    void SetActorRelativeScale3D(FVector NewRelativeScale);
    void SetActorScale3D(FVector NewScale3D);
    void SetActorTickEnabled(bool bEnabled);
    void SetActorTickInterval(float TickInterval);
    void SetAutoDestroyWhenFinished(bool bVal);
    void SetFolderPath(const FName& NewFolderPath);
    void SetIsTemporarilyHiddenInEditor(bool bIsHidden);
    void SetLifeSpan(float InLifespan);
    void SetNetDormancy(uint8_t NewDormancy);
    void SetOwner(AActor* NewOwner);
    void SetReplicateMovement(bool bInReplicateMovement);
    void SetReplicates(bool bInReplicates);
    void SetTickGroup(uint8_t NewTickGroup);
    void SetTickableWhenPaused(bool bTickableWhenPaused);
    void SnapRootComponentTo(AActor* InParentActor, FName InSocketName);
    void TearOff();
    void UserConstructionScript();
    bool WasRecentlyRendered(float Tolerance) const;
};

// Size: 0x2a0
class UActorChannel : public UChannel {
    /* 0x0078 */ AActor* Actor;
    /* 0x0168 */ TArray<UObject*> CreateSubObjects;
};

// Size: 0xc0
class UActorComponent : public UObject {
    /* 0x0040 */ FActorComponentTickFunction PrimaryComponentTick;
    /* 0x0070 */ TArray<FName> ComponentTags;
    /* 0x0080 */ TArray<UAssetUserData*> AssetUserData;
    /* 0x0094 */ int32_t UCSSerializationIndex;
    /* 0x0098 */ bool bNetAddressable;
    /* 0x0098 */ bool bReplicates;
    /* 0x0099 */ bool bCreatedByConstructionScript;
    /* 0x009a */ bool bInstanceComponent;
    /* 0x009a */ bool bAutoActivate;
    /* 0x009a */ bool bIsActive;
    /* 0x009a */ bool bEditableWhenInherited;
    /* 0x009a */ bool bCanEverAffectNavigation;
    /* 0x009a */ bool bIsEditorOnly;
    /* 0x009b */ bool bIsVisualizationComponent;
    /* 0x009b */ bool bNeedsUCSSerializationIndexEvaluted;
    /* 0x009d */ EComponentCreationMethod CreationMethod;
    /* 0x009e */ FMulticastSparseDelegate OnComponentActivated;
    /* 0x009f */ FMulticastSparseDelegate OnComponentDeactivated;
    /* 0x00a0 */ TArray<FSimpleMemberReference> UCSModifiedProperties;

    void Activate(bool bReset);
    void AddTickPrerequisiteActor(AActor* PrerequisiteActor);
    void AddTickPrerequisiteComponent(UActorComponent* PrerequisiteComponent);
    bool ComponentHasTag(FName Tag) const;
    void Deactivate();
    float GetComponentTickInterval() const;
    AActor* GetOwner() const;
    bool IsActive() const;
    bool IsBeingDestroyed() const;
    bool IsComponentTickEnabled() const;
    void K2_DestroyComponent(UObject* Object);
    void OnRep_IsActive();
    void ReceiveBeginPlay();
    void ReceiveEndPlay(uint8_t EndPlayReason);
    void ReceiveTick(float DeltaSeconds);
    void RemoveTickPrerequisiteActor(AActor* PrerequisiteActor);
    void RemoveTickPrerequisiteComponent(UActorComponent* PrerequisiteComponent);
    void SetActive(bool bNewActive, bool bReset);
    void SetAutoActivate(bool bNewAutoActivate);
    void SetComponentTickEnabled(bool bEnabled);
    void SetComponentTickInterval(float TickInterval);
    void SetComponentTickIntervalAndCooldown(float TickInterval);
    void SetIsReplicated(bool ShouldReplicate);
    void SetTickGroup(uint8_t NewTickGroup);
    void SetTickableWhenPaused(bool bTickableWhenPaused);
    void ToggleActive();
};

// Size: 0x10
struct FActorComponentDuplicatedObjectData {
};

// Size: 0x68
struct FActorComponentInstanceData {
    /* 0x0008 */ UObject* SourceComponentTemplate;
    /* 0x0010 */ EComponentCreationMethod SourceComponentCreationMethod;
    /* 0x0014 */ int32_t SourceComponentTypeSerializedIndex;
    /* 0x0018 */ TArray<uint8_t> SavedProperties;
    /* 0x0028 */ FActorComponentDuplicatedObjectData UniqueTransientPackage;
    /* 0x0038 */ TArray<FActorComponentDuplicatedObjectData> DuplicatedObjects;
    /* 0x0048 */ TArray<UObject*> ReferencedObjects;
    /* 0x0058 */ TArray<FName> ReferencedNames;
};

// Size: 0x30
class UActorComponentInstanceDataTransientOuter : public UObject {
};

// Size: 0x30
struct FActorComponentTickFunction : public FTickFunction {
};

// Size: 0x30
struct FActorTickFunction : public FTickFunction {
};

// Size: 0x1f0
class UAimOffsetBlendSpace : public UBlendSpace {
};

// Size: 0x1f0
class UAimOffsetBlendSpace1D : public UBlendSpace1D {
};

// Size: 0x30
struct FAlphaBlend {
    /* 0x0000 */ UCurveFloat* CustomCurve;
    /* 0x0008 */ float BlendTime;
    /* 0x0024 */ EAlphaBlendOption BlendOption;
};

// Size: 0x300
class AAmbientSound : public AActor {
    /* 0x02f8 */ UAudioComponent* AudioComponent;

    void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel);
    void FadeIn(float FadeInDuration, float FadeVolumeLevel);
    void FadeOut(float FadeOutDuration, float FadeVolumeLevel);
    void Play(float StartTime);
    void Stop();
};

// Size: 0x4c
struct FAngularDriveConstraint {
    /* 0x0000 */ FConstraintDrive TwistDrive;
    /* 0x0010 */ FConstraintDrive SwingDrive;
    /* 0x0020 */ FConstraintDrive SlerpDrive;
    /* 0x0030 */ FRotator OrientationTarget;
    /* 0x003c */ FVector AngularVelocityTarget;
    /* 0x0048 */ uint8_t AngularDriveMode;
};

// Size: 0x5a8
class UAnimBlueprint : public UBlueprint {
    /* 0x04e0 */ USkeleton* TargetSkeleton;
    /* 0x04e8 */ TArray<FAnimGroupInfo> Groups;
    /* 0x04f8 */ bool bUseMultiThreadedAnimationUpdate;
    /* 0x04f9 */ bool bWarnAboutBlueprintUsage;
    /* 0x0518 */ TArray<FAnimParentNodeAssetOverride> ParentAssetOverrides;
    /* 0x0528 */ TArray<UPoseWatch*> PoseWatches;
    /* 0x0538 */ TSoftObjectPtr<USkeletalMesh> PreviewSkeletalMesh;
    /* 0x0568 */ TSoftObjectPtr<UAnimBlueprint> PreviewAnimationBlueprint;
    /* 0x0598 */ EPreviewAnimationBlueprintApplicationMethod PreviewAnimationBlueprintApplicationMethod;
    /* 0x059c */ FName PreviewAnimationBlueprintTag;
};

// Size: 0x2a0
struct FAnimBlueprintDebugData {
};

// Size: 0x70
struct FAnimBlueprintFunction {
    /* 0x0000 */ FName Name;
    /* 0x000c */ FName Group;
    /* 0x0018 */ int32_t OutputPoseNodeIndex;
    /* 0x0020 */ TArray<FName> InputPoseNames;
    /* 0x0030 */ TArray<int32_t> InputPoseNodeIndices;
    /* 0x0068 */ bool bImplemented;
};

// Size: 0x50
struct FAnimBlueprintFunctionData {
    /* 0x0000 */ FFieldPath OutputPoseNodeProperty;
    /* 0x0030 */ TArray<FFieldPath> InputPoseNodeProperties;
    /* 0x0040 */ TArray<FFieldPath> InputProperties;
};

// Size: 0xb10
class UAnimBlueprintGeneratedClass : public UBlueprintGeneratedClass {
    /* 0x05f0 */ TArray<FBakedAnimationStateMachine> BakedStateMachines;
    /* 0x0600 */ USkeleton* TargetSkeleton;
    /* 0x0608 */ TArray<FAnimNotifyEvent> AnimNotifies;
    /* 0x0618 */ TMap<FName, FCachedPoseIndices> OrderedSavedPoseIndicesMap;
    /* 0x06e8 */ TArray<FName> SyncGroupNames;
    /* 0x06f8 */ TArray<FExposedValueHandler> EvaluateGraphExposedInputs;
    /* 0x0708 */ TMap<FName, FGraphAssetPlayerInformation> GraphAssetPlayerInformation;
    /* 0x0758 */ TMap<FName, FAnimGraphBlendOptions> GraphBlendOptions;
    /* 0x07a8 */ FPropertyAccessLibrary PropertyAccessLibrary;
};

// Size: 0x40
class UAnimBoneCompressionCodec : public UObject {
    /* 0x0030 */ FString Description;
};

// Size: 0x48
class UAnimBoneCompressionSettings : public UObject {
    /* 0x0030 */ TArray<UAnimBoneCompressionCodec*> Codecs;
    /* 0x0040 */ float ErrorThreshold;
    /* 0x0044 */ bool bForceBelowThreshold;
};

// Size: 0x338
class UAnimClassData : public UObject {
    /* 0x0038 */ TArray<FBakedAnimationStateMachine> BakedStateMachines;
    /* 0x0048 */ USkeleton* TargetSkeleton;
    /* 0x0050 */ TArray<FAnimNotifyEvent> AnimNotifies;
    /* 0x0060 */ TMap<FName, FCachedPoseIndices> OrderedSavedPoseIndicesMap;
    /* 0x00b0 */ TArray<FAnimBlueprintFunction> AnimBlueprintFunctions;
    /* 0x00c0 */ TArray<FAnimBlueprintFunctionData> AnimBlueprintFunctionData;
    /* 0x00d0 */ TArray<FFieldPath> AnimNodeProperties;
    /* 0x00f0 */ TArray<FFieldPath> LinkedAnimGraphNodeProperties;
    /* 0x0110 */ TArray<FFieldPath> LinkedAnimLayerNodeProperties;
    /* 0x0130 */ TArray<FFieldPath> PreUpdateNodeProperties;
    /* 0x0150 */ TArray<FFieldPath> DynamicResetNodeProperties;
    /* 0x0170 */ TArray<FFieldPath> StateMachineNodeProperties;
    /* 0x0190 */ TArray<FFieldPath> InitializationNodeProperties;
    /* 0x01b0 */ TMap<FName, FGraphAssetPlayerInformation> GraphNameAssetPlayers;
    /* 0x0200 */ TArray<FName> SyncGroupNames;
    /* 0x0210 */ TArray<FExposedValueHandler> EvaluateGraphExposedInputs;
    /* 0x0220 */ TMap<FName, FAnimGraphBlendOptions> GraphBlendOptions;
    /* 0x0270 */ FPropertyAccessLibrary PropertyAccessLibrary;
};

// Size: 0x30
class IAnimClassInterface : public UInterface {
};

// Size: 0x1a0
class UAnimComposite : public UAnimCompositeBase {
    /* 0x0188 */ FAnimTrack AnimationTrack;
    /* 0x0198 */ UAnimSequence* PreviewBasePose;
};

// Size: 0x188
class UAnimCompositeBase : public UAnimSequenceBase {
};

// Size: 0x48
class UAnimCompress : public UAnimBoneCompressionCodec {
    /* 0x0040 */ bool bNeedsSkeleton;
    /* 0x0044 */ uint8_t TranslationCompressionFormat;
    /* 0x0045 */ uint8_t RotationCompressionFormat;
    /* 0x0046 */ uint8_t ScaleCompressionFormat;
};

// Size: 0x48
class UAnimCompress_BitwiseCompressOnly : public UAnimCompress {
};

// Size: 0x48
class UAnimCompress_LeastDestructive : public UAnimCompress_BitwiseCompressOnly {
};

// Size: 0xe0
class UAnimCompress_PerTrackCompression : public UAnimCompress_RemoveLinearKeys {
    /* 0x0068 */ float MaxZeroingThreshold;
    /* 0x006c */ float MaxPosDiffBitwise;
    /* 0x0070 */ float MaxAngleDiffBitwise;
    /* 0x0074 */ float MaxScaleDiffBitwise;
    /* 0x0078 */ TArray<uint8_t> AllowedRotationFormats;
    /* 0x0088 */ TArray<uint8_t> AllowedTranslationFormats;
    /* 0x0098 */ TArray<uint8_t> AllowedScaleFormats;
    /* 0x00a8 */ bool bResampleAnimation;
    /* 0x00ac */ float ResampledFramerate;
    /* 0x00b0 */ int32_t MinKeysForResampling;
    /* 0x00b4 */ bool bUseAdaptiveError;
    /* 0x00b4 */ bool bUseOverrideForEndEffectors;
    /* 0x00b8 */ int32_t TrackHeightBias;
    /* 0x00bc */ float ParentingDivisor;
    /* 0x00c0 */ float ParentingDivisorExponent;
    /* 0x00c4 */ bool bUseAdaptiveError2;
    /* 0x00c8 */ float RotationErrorSourceRatio;
    /* 0x00cc */ float TranslationErrorSourceRatio;
    /* 0x00d0 */ float ScaleErrorSourceRatio;
    /* 0x00d4 */ float MaxErrorPerTrackRatio;
    /* 0x00d8 */ float PerturbationProbeSize;
};

// Size: 0x50
class UAnimCompress_RemoveEverySecondKey : public UAnimCompress {
    /* 0x0048 */ int32_t MinKeys;
    /* 0x004c */ bool bStartAtSecondKey;
};

// Size: 0x68
class UAnimCompress_RemoveLinearKeys : public UAnimCompress {
    /* 0x0048 */ float MaxPosDiff;
    /* 0x004c */ float MaxAngleDiff;
    /* 0x0050 */ float MaxScaleDiff;
    /* 0x0054 */ float MaxEffectorDiff;
    /* 0x0058 */ float MinEffectorDiff;
    /* 0x005c */ float EffectorDiffSocket;
    /* 0x0060 */ float ParentKeyScale;
    /* 0x0064 */ bool bRetarget;
    /* 0x0064 */ bool bActuallyFilterLinearKeys;
};

// Size: 0x58
class UAnimCompress_RemoveTrivialKeys : public UAnimCompress {
    /* 0x0048 */ float MaxPosDiff;
    /* 0x004c */ float MaxAngleDiff;
    /* 0x0050 */ float MaxScaleDiff;
};

// Size: 0x20
struct FAnimControlTrackKey {
    /* 0x0000 */ float StartTime;
    /* 0x0008 */ UAnimSequence* AnimSeq;
    /* 0x0010 */ float AnimStartOffset;
    /* 0x0014 */ float AnimEndOffset;
    /* 0x0018 */ float AnimPlayRate;
    /* 0x001c */ bool bLooping;
    /* 0x001c */ bool bReverse;
};

// Size: 0x30
struct FAnimCurveBase {
    /* 0x0000 */ FName LastObservedName;
    /* 0x000c */ FSmartName Name;
    /* 0x001c */ FLinearColor Color;
    /* 0x002c */ int32_t CurveTypeFlags;
};

// Size: 0x40
class UAnimCurveCompressionCodec : public UObject {
};

// Size: 0x50
class UAnimCurveCompressionCodec_CompressedRichCurve : public UAnimCurveCompressionCodec {
    /* 0x0040 */ float MaxCurveError;
    /* 0x0044 */ bool UseAnimSequenceSampleRate;
    /* 0x0048 */ float ErrorSampleRate;
};

// Size: 0x40
class UAnimCurveCompressionCodec_UniformIndexable : public UAnimCurveCompressionCodec {
};

// Size: 0x48
class UAnimCurveCompressionCodec_UniformlySampled : public UAnimCurveCompressionCodec {
    /* 0x0040 */ bool UseAnimSequenceSampleRate;
    /* 0x0044 */ float SampleRate;
};

// Size: 0x38
class UAnimCurveCompressionSettings : public UObject {
    /* 0x0030 */ UAnimCurveCompressionCodec* Codec;
};

// Size: 0x10
struct FAnimCurveParam {
    /* 0x0000 */ FName Name;
};

// Size: 0x2
struct FAnimCurveType {
};

// Size: 0x8
struct FAnimGraphBlendOptions {
    /* 0x0000 */ float BlendInTime;
    /* 0x0004 */ float BlendOutTime;
};

// Size: 0x1c
struct FAnimGroupInfo {
    /* 0x0000 */ FName Name;
    /* 0x000c */ FLinearColor Color;
};

// Size: 0x80
struct FAnimGroupInstance {
};

// Size: 0x300
class UAnimInstance : public UObject {
    /* 0x0030 */ USkeleton* CurrentSkeleton;
    /* 0x0038 */ uint8_t RootMotionMode;
    /* 0x003c */ float DeltaTime;
    /* 0x0040 */ bool bRunUpdatesInWorkerThreads;
    /* 0x0040 */ bool bCanUseParallelUpdateAnimation;
    /* 0x0040 */ bool bWarnAboutBlueprintUsage;
    /* 0x0040 */ bool bUseMultiThreadedAnimationUpdate;
    /* 0x0040 */ bool bUsingCopyPoseFromMesh;
    /* 0x0040 */ bool bReceiveNotifiesFromLinkedInstances;
    /* 0x0041 */ bool bPropagateNotifiesToLinkedInstances;
    /* 0x0041 */ bool bQueueMontageEvents;
    /* 0x0048 */ FMulticastInlineDelegate OnMontageBlendingOut;
    /* 0x0058 */ FMulticastInlineDelegate OnMontageStarted;
    /* 0x0068 */ FMulticastInlineDelegate OnMontageEnded;
    /* 0x0078 */ FMulticastInlineDelegate OnAllMontageInstancesEnded;
    /* 0x0108 */ FSoftClassPath PostCompileValidationClassName;
    /* 0x0130 */ FAnimNotifyQueue NotifyQueue;
    /* 0x01a0 */ TArray<FAnimNotifyEvent> ActiveAnimNotifyState;

    void BlueprintBeginPlay();
    void BlueprintInitializeAnimation();
    void BlueprintLinkedAnimationLayersInitialized();
    void BlueprintPostEvaluateAnimation();
    void BlueprintUpdateAnimation(float DeltaTimeX);
    float CalculateDirection(const FVector& Velocity, const FRotator& BaseRotation) const;
    void ClearMorphTargets();
    void GetActiveCurveNames(EAnimCurveType CurveType, TArray<FName>& OutNames) const;
    void GetAllCurveNames(TArray<FName>& OutNames) const;
    UAnimMontage* GetCurrentActiveMontage() const;
    FName GetCurrentStateName(int32_t MachineIndex);
    float GetCurveValue(FName CurveName) const;
    float GetInstanceAssetPlayerLength(int32_t AssetPlayerIndex);
    float GetInstanceAssetPlayerTime(int32_t AssetPlayerIndex);
    float GetInstanceAssetPlayerTimeFraction(int32_t AssetPlayerIndex);
    float GetInstanceAssetPlayerTimeFromEnd(int32_t AssetPlayerIndex);
    float GetInstanceAssetPlayerTimeFromEndFraction(int32_t AssetPlayerIndex);
    float GetInstanceCurrentStateElapsedTime(int32_t MachineIndex);
    float GetInstanceMachineWeight(int32_t MachineIndex);
    float GetInstanceStateWeight(int32_t MachineIndex, int32_t StateIndex);
    float GetInstanceTransitionCrossfadeDuration(int32_t MachineIndex, int32_t TransitionIndex);
    float GetInstanceTransitionTimeElapsed(int32_t MachineIndex, int32_t TransitionIndex);
    float GetInstanceTransitionTimeElapsedFraction(int32_t MachineIndex, int32_t TransitionIndex);
    UAnimInstance* GetLinkedAnimGraphInstanceByTag(FName InTag) const;
    void GetLinkedAnimGraphInstancesByTag(FName InTag, TArray<UAnimInstance*>& OutLinkedInstances) const;
    UAnimInstance* GetLinkedAnimLayerInstanceByClass(UClass* InClass) const;
    UAnimInstance* GetLinkedAnimLayerInstanceByGroup(FName InGroup) const;
    UAnimInstance* GetLinkedAnimLayerInstanceByGroupAndClass(FName InGroup, UClass* InClass) const;
    void GetLinkedAnimLayerInstancesByGroup(FName InGroup, TArray<UAnimInstance*>& OutLinkedInstances) const;
    AActor* GetOwningActor() const;
    USkeletalMeshComponent* GetOwningComponent() const;
    bool GetPropagateNotifiesToLinkedInstances() const;
    bool GetReceiveNotifiesFromLinkedInstances() const;
    float GetRelevantAnimLength(int32_t MachineIndex, int32_t StateIndex);
    float GetRelevantAnimTime(int32_t MachineIndex, int32_t StateIndex);
    float GetRelevantAnimTimeFraction(int32_t MachineIndex, int32_t StateIndex);
    float GetRelevantAnimTimeRemaining(int32_t MachineIndex, int32_t StateIndex);
    float GetRelevantAnimTimeRemainingFraction(int32_t MachineIndex, int32_t StateIndex);
    FMarkerSyncAnimPosition GetSyncGroupPosition(FName InSyncGroupName) const;
    bool GetTimeToClosestMarker(FName SyncGroup, FName MarkerName, float& OutMarkerTime) const;
    bool HasMarkerBeenHitThisFrame(FName SyncGroup, FName MarkerName) const;
    bool IsAnyMontagePlaying() const;
    bool IsPlayingSlotAnimation(const UAnimSequenceBase* Asset, FName SlotNodeName) const;
    bool IsSyncGroupBetweenMarkers(FName InSyncGroupName, FName PreviousMarker, FName NextMarker, bool bRespectMarkerOrder) const;
    void LinkAnimClassLayers(UClass* InClass);
    void LinkAnimGraphByTag(FName InTag, UClass* InClass);
    void LockAIResources(bool bLockMovement, bool LockAILogic);
    float Montage_GetBlendTime(const UAnimMontage* Montage) const;
    FName Montage_GetCurrentSection(const UAnimMontage* Montage) const;
    bool Montage_GetIsStopped(const UAnimMontage* Montage) const;
    float Montage_GetPlayRate(const UAnimMontage* Montage) const;
    float Montage_GetPosition(const UAnimMontage* Montage) const;
    bool Montage_IsActive(const UAnimMontage* Montage) const;
    bool Montage_IsPlaying(const UAnimMontage* Montage) const;
    void Montage_JumpToSection(FName SectionName, const UAnimMontage* Montage);
    void Montage_JumpToSectionsEnd(FName SectionName, const UAnimMontage* Montage);
    void Montage_Pause(const UAnimMontage* Montage);
    float Montage_Play(UAnimMontage* MontageToPlay, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages);
    void Montage_Resume(const UAnimMontage* Montage);
    void Montage_SetNextSection(FName SectionNameToChange, FName NextSection, const UAnimMontage* Montage);
    void Montage_SetPlayRate(const UAnimMontage* Montage, float NewPlayRate);
    void Montage_SetPosition(const UAnimMontage* Montage, float NewPosition);
    void Montage_Stop(float InBlendOutTime, const UAnimMontage* Montage);
    void Montage_StopGroupByName(float InBlendOutTime, FName GroupName);
    float PlaySlotAnimation(UAnimSequenceBase* Asset, FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32_t LoopCount);
    UAnimMontage* PlaySlotAnimationAsDynamicMontage(UAnimSequenceBase* Asset, FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32_t LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
    void ResetDynamics(ETeleportType InTeleportType);
    void SavePoseSnapshot(FName SnapshotName);
    void SetMorphTarget(FName MorphTargetName, float Value);
    void SetPropagateNotifiesToLinkedInstances(bool bSet);
    void SetReceiveNotifiesFromLinkedInstances(bool bSet);
    void SetRootMotionMode(uint8_t Value);
    void SnapshotPose(FPoseSnapshot& Snapshot);
    void StopSlotAnimation(float InBlendOutTime, FName SlotNodeName);
    APawn* TryGetPawnOwner() const;
    void UnlinkAnimClassLayers(UClass* InClass);
    void UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic);
};

// Size: 0x810
struct FAnimInstanceProxy {
};

// Size: 0x1
struct FAnimInstanceSubsystemData {
};

// Size: 0x30
class IAnimLayerInterface : public UInterface {
};

// Size: 0x30
struct FAnimLinkableElement {
    /* 0x0008 */ UAnimMontage* LinkedMontage;
    /* 0x0010 */ int32_t SlotIndex;
    /* 0x0014 */ int32_t SegmentIndex;
    /* 0x0018 */ uint8_t LinkMethod;
    /* 0x0019 */ uint8_t CachedLinkMethod;
    /* 0x001c */ float SegmentBeginTime;
    /* 0x0020 */ float SegmentLength;
    /* 0x0024 */ float LinkValue;
    /* 0x0028 */ UAnimSequenceBase* LinkedSequence;
};

// Size: 0x30
class UAnimMetaData : public UObject {
};

// Size: 0x2d8
class UAnimMontage : public UAnimCompositeBase {
    /* 0x0188 */ FAlphaBlend BlendIn;
    /* 0x01b8 */ float BlendInTime;
    /* 0x01c0 */ FAlphaBlend BlendOut;
    /* 0x01f0 */ float BlendOutTime;
    /* 0x01f4 */ float BlendOutTriggerTime;
    /* 0x01f8 */ FName SyncGroup;
    /* 0x0204 */ int32_t SyncSlotIndex;
    /* 0x0208 */ FMarkerSyncData MarkerData;
    /* 0x0228 */ TArray<FCompositeSection> CompositeSections;
    /* 0x0238 */ TArray<FSlotAnimationTrack> SlotAnimTracks;
    /* 0x0248 */ TArray<FBranchingPoint> BranchingPoints;
    /* 0x0258 */ bool bEnableRootMotionTranslation;
    /* 0x0259 */ bool bEnableRootMotionRotation;
    /* 0x025a */ bool bEnableAutoBlendOut;
    /* 0x025b */ uint8_t RootMotionRootLock;
    /* 0x0260 */ UAnimSequence* PreviewBasePose;
    /* 0x0280 */ TArray<FBranchingPointMarker> BranchingPointMarkers;
    /* 0x0290 */ TArray<int32_t> BranchingPointStateNotifyIndices;
    /* 0x02a0 */ FTimeStretchCurve TimeStretchCurve;
    /* 0x02c8 */ FName TimeStretchCurveName;

    float GetDefaultBlendOutTime() const;
};

// Size: 0x1b8
struct FAnimMontageInstance {
    /* 0x0000 */ UAnimMontage* Montage;
    /* 0x0028 */ bool bPlaying;
    /* 0x002c */ float DefaultBlendTimeMultiplier;
    /* 0x00e8 */ TArray<int32_t> NextSections;
    /* 0x00f8 */ TArray<int32_t> PrevSections;
    /* 0x0118 */ TArray<FAnimNotifyEvent> ActiveStateBranchingPoints;
    /* 0x0128 */ float Position;
    /* 0x012c */ float PlayRate;
    /* 0x0130 */ FAlphaBlend Blend;
    /* 0x0190 */ int32_t DisableRootMotionCount;
};

// Size: 0xe8
struct FAnimNode_ApplyMeshSpaceAdditive : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink Base;
    /* 0x0028 */ FPoseLink Additive;
    /* 0x0040 */ EAnimAlphaInputType AlphaInputType;
    /* 0x0044 */ float Alpha;
    /* 0x0048 */ bool bAlphaBoolEnabled;
    /* 0x0050 */ FInputAlphaBoolBlend AlphaBoolBlend;
    /* 0x0098 */ FName AlphaCurveName;
    /* 0x00a4 */ FInputScaleBias AlphaScaleBias;
    /* 0x00ac */ FInputScaleBiasClamp AlphaScaleBiasClamp;
    /* 0x00dc */ int32_t LODThreshold;
};

// Size: 0x40
struct FAnimNode_AssetPlayerBase : public FAnimNode_Base {
    /* 0x0010 */ FName GroupName;
    /* 0x001c */ int32_t GroupIndex;
    /* 0x0020 */ uint8_t GroupRole;
    /* 0x0021 */ EAnimSyncGroupScope GroupScope;
    /* 0x0022 */ bool bIgnoreForRelevancyTest;
    /* 0x0024 */ float BlendWeight;
    /* 0x0028 */ float InternalTimeAccumulator;
};

// Size: 0x10
struct FAnimNode_Base {
};

// Size: 0x28
struct FAnimNode_ConvertComponentToLocalSpace : public FAnimNode_Base {
    /* 0x0010 */ FComponentSpacePoseLink ComponentPose;
};

// Size: 0x28
struct FAnimNode_ConvertLocalToComponentSpace : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink LocalPose;
};

// Size: 0x60
struct FAnimNode_CustomProperty : public FAnimNode_Base {
    /* 0x0010 */ TArray<FName> SourcePropertyNames;
    /* 0x0020 */ TArray<FName> DestPropertyNames;
    /* 0x0030 */ UObject* TargetInstance;
};

// Size: 0x78
struct FAnimNode_Inertialization : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink Source;
};

// Size: 0xb0
struct FAnimNode_LinkedAnimGraph : public FAnimNode_CustomProperty {
    /* 0x0060 */ TArray<FPoseLink> InputPoses;
    /* 0x0070 */ TArray<FName> InputPoseNames;
    /* 0x0080 */ UClass* InstanceClass;
    /* 0x0088 */ FName Tag;
    /* 0x00ac */ bool bReceiveNotifiesFromLinkedInstances;
    /* 0x00ac */ bool bPropagateNotifiesToLinkedInstances;
};

// Size: 0xe0
struct FAnimNode_LinkedAnimLayer : public FAnimNode_LinkedAnimGraph {
    /* 0x00b0 */ UClass* Interface;
    /* 0x00b8 */ FName Layer;
};

// Size: 0x128
struct FAnimNode_LinkedInputPose : public FAnimNode_Base {
    /* 0x0010 */ FName Name;
    /* 0x001c */ FName Graph;
    /* 0x0028 */ FPoseLink InputPose;
};

// Size: 0x40
struct FAnimNode_Root : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink Result;
    /* 0x0028 */ FName Name;
    /* 0x0034 */ FName Group;
};

// Size: 0x160
struct FAnimNode_SaveCachedPose : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink Pose;
    /* 0x0028 */ FName CachePoseName;
};

// Size: 0x88
struct FAnimNode_SequencePlayer : public FAnimNode_AssetPlayerBase {
    /* 0x0040 */ UAnimSequenceBase* Sequence;
    /* 0x0048 */ float PlayRateBasis;
    /* 0x004c */ float PlayRate;
    /* 0x0050 */ FInputScaleBiasClamp PlayRateScaleBiasClamp;
    /* 0x0080 */ float StartPosition;
    /* 0x0084 */ bool bLoopAnimation;
};

// Size: 0x40
struct FAnimNode_SingleNode : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink SourcePose;
};

// Size: 0xb0
struct FAnimNode_StateMachine : public FAnimNode_Base {
    /* 0x0010 */ int32_t StateMachineIndexInClass;
    /* 0x0014 */ int32_t MaxTransitionsPerFrame;
    /* 0x0018 */ bool bSkipFirstUpdateTransition;
    /* 0x0019 */ bool bReinitializeOnBecomingRelevant;
};

// Size: 0xf8
struct FAnimNode_TransitionPoseEvaluator : public FAnimNode_Base {
    /* 0x00e8 */ int32_t FramesToCachePose;
    /* 0x00f0 */ uint8_t DataSource;
    /* 0x00f1 */ uint8_t EvaluatorMode;
};

// Size: 0x28
struct FAnimNode_TransitionResult : public FAnimNode_Base {
    /* 0x0010 */ bool bCanEnterTransition;
};

// Size: 0x38
struct FAnimNode_UseCachedPose : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink LinkToCachingNode;
    /* 0x0028 */ FName CachePoseName;
};

// Size: 0x40
class UAnimNotify : public UObject {
    /* 0x0030 */ FColor NotifyColor;

    FString GetNotifyName() const;
    bool Received_Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation) const;
};

// Size: 0x10
struct FAnimNotifyArray {
    /* 0x0000 */ TArray<FAnimNotifyEventReference> Notifies;
};

// Size: 0xe0
struct FAnimNotifyEvent : public FAnimLinkableElement {
    /* 0x0030 */ float DisplayTime;
    /* 0x0034 */ float TriggerTimeOffset;
    /* 0x0038 */ float EndTriggerTimeOffset;
    /* 0x003c */ float TriggerWeightThreshold;
    /* 0x0040 */ FName NotifyName;
    /* 0x0050 */ UAnimNotify* Notify;
    /* 0x0058 */ UAnimNotifyState* NotifyStateClass;
    /* 0x0060 */ float Duration;
    /* 0x0068 */ FAnimLinkableElement EndLink;
    /* 0x0098 */ bool bConvertedFromBranchingPoint;
    /* 0x0099 */ uint8_t MontageTickType;
    /* 0x009c */ float NotifyTriggerChance;
    /* 0x00a0 */ uint8_t NotifyFilterType;
    /* 0x00a4 */ int32_t NotifyFilterLOD;
    /* 0x00a8 */ bool bTriggerOnDedicatedServer;
    /* 0x00a9 */ bool bTriggerOnFollower;
    /* 0x00ac */ FColor NotifyColor;
    /* 0x00b0 */ FGuid Guid;
    /* 0x00c0 */ int32_t TrackIndex;
};

// Size: 0x10
struct FAnimNotifyEventReference {
    /* 0x0008 */ UObject* NotifySource;
};

// Size: 0x70
struct FAnimNotifyQueue {
    /* 0x0010 */ TArray<FAnimNotifyEventReference> AnimNotifies;
    /* 0x0020 */ TMap<FName, FAnimNotifyArray> UnfilteredMontageAnimNotifies;
};

// Size: 0x38
class UAnimNotifyState : public UObject {
    /* 0x0030 */ FColor NotifyColor;

    FString GetNotifyName() const;
    bool Received_NotifyBegin(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration) const;
    bool Received_NotifyEnd(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation) const;
    bool Received_NotifyTick(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float FrameDeltaTime) const;
};

// Size: 0x38
class UAnimNotifyState_DisableRootMotion : public UAnimNotifyState {
};

// Size: 0x88
class UAnimNotifyState_TimedParticleEffect : public UAnimNotifyState {
    /* 0x0038 */ UParticleSystem* PSTemplate;
    /* 0x0040 */ FName SocketName;
    /* 0x004c */ FVector LocationOffset;
    /* 0x0058 */ FRotator RotationOffset;
    /* 0x0064 */ bool bDestroyAtEnd;
    /* 0x0068 */ TArray<UParticleSystem*> PreviousPSTemplates;
    /* 0x0078 */ TArray<FName> PreviousSocketNames;
};

// Size: 0x70
class UAnimNotifyState_Trail : public UAnimNotifyState {
    /* 0x0038 */ UParticleSystem* PSTemplate;
    /* 0x0040 */ FName FirstSocketName;
    /* 0x004c */ FName SecondSocketName;
    /* 0x0058 */ uint8_t WidthScaleMode;
    /* 0x005c */ FName WidthScaleCurve;
    /* 0x0068 */ bool bRecycleSpawnedSystems;
    /* 0x0068 */ bool bRenderGeometry;
    /* 0x0068 */ bool bRenderSpawnPoints;
    /* 0x0068 */ bool bRenderTangents;
    /* 0x0068 */ bool bRenderTessellation;

    UParticleSystem* OverridePSTemplate(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation) const;
};

// Size: 0x40
struct FAnimNotifyTrack {
    /* 0x0000 */ FName TrackName;
    /* 0x000c */ FLinearColor TrackColor;
};

// Size: 0x40
class UAnimNotify_PauseClothingSimulation : public UAnimNotify {
};

// Size: 0x90
class UAnimNotify_PlayParticleEffect : public UAnimNotify {
    /* 0x0040 */ UParticleSystem* PSTemplate;
    /* 0x0048 */ FVector LocationOffset;
    /* 0x0054 */ FRotator RotationOffset;
    /* 0x0060 */ FVector Scale;
    /* 0x0080 */ bool Attached;
    /* 0x0084 */ FName SocketName;
};

// Size: 0x60
class UAnimNotify_PlaySound : public UAnimNotify {
    /* 0x0040 */ USoundBase* Sound;
    /* 0x0048 */ float VolumeMultiplier;
    /* 0x004c */ float PitchMultiplier;
    /* 0x0050 */ bool bFollow;
    /* 0x0050 */ bool bPreviewIgnoreAttenuation;
    /* 0x0054 */ FName AttachName;
};

// Size: 0x40
class UAnimNotify_ResetClothingSimulation : public UAnimNotify {
};

// Size: 0x40
class UAnimNotify_ResetDynamics : public UAnimNotify {
};

// Size: 0x40
class UAnimNotify_ResumeClothingSimulation : public UAnimNotify {
};

// Size: 0x18
struct FAnimParentNodeAssetOverride {
    /* 0x0000 */ UAnimationAsset* NewAsset;
    /* 0x0008 */ FGuid ParentNodeGuid;
};

enum class AnimPhysCollisionType {
    CoM = 0,
    CustomSphere = 1,
    InnerSphere = 2,
    OuterSphere = 3,
    AnimPhysCollisionType_MAX = 4,
};

enum class AnimPhysTwistAxis {
    AxisX = 0,
    AxisY = 1,
    AxisZ = 2,
    AnimPhysTwistAxis_MAX = 3,
};

// Size: 0x20
struct FAnimSegment {
    /* 0x0000 */ UAnimSequenceBase* AnimReference;
    /* 0x0008 */ float StartPos;
    /* 0x000c */ float AnimStartTime;
    /* 0x0010 */ float AnimEndTime;
    /* 0x0014 */ float AnimPlayRate;
    /* 0x0018 */ int32_t LoopingCount;
};

// Size: 0x400
class UAnimSequence : public UAnimSequenceBase {
    /* 0x0188 */ float ImportFileFramerate;
    /* 0x018c */ int32_t ImportResampleFramerate;
    /* 0x0190 */ int32_t NumFrames;
    /* 0x0198 */ TArray<FTrackToSkeletonMap> TrackToSkeletonMapTable;
    /* 0x01b8 */ FGuid RawDataGuid;
    /* 0x01c8 */ TArray<FName> AnimationTrackNames;
    /* 0x01e8 */ bool bAllowFrameStripping;
    /* 0x01ec */ float CompressionErrorThresholdScale;
    /* 0x01f0 */ UAnimBoneCompressionSettings* BoneCompressionSettings;
    /* 0x01f8 */ UAnimCurveCompressionSettings* CurveCompressionSettings;
    /* 0x02f8 */ uint8_t AdditiveAnimType;
    /* 0x02f9 */ uint8_t RefPoseType;
    /* 0x0300 */ UAnimSequence* RefPoseSeq;
    /* 0x0308 */ int32_t RefFrameIndex;
    /* 0x030c */ FName RetargetSource;
    /* 0x0318 */ TSoftObjectPtr<USkeletalMesh> RetargetSourceAsset;
    /* 0x0348 */ TArray<FTransform> RetargetSourceAssetReferencePose;
    /* 0x0358 */ EAnimInterpolationType Interpolation;
    /* 0x0359 */ bool bEnableRootMotion;
    /* 0x035a */ uint8_t RootMotionRootLock;
    /* 0x035b */ bool bForceRootLock;
    /* 0x035c */ bool bUseNormalizedRootMotionScale;
    /* 0x035d */ bool bRootMotionSettingsCopiedFromMontage;
    /* 0x0360 */ int32_t CompressCommandletVersion;
    /* 0x0364 */ bool bDoNotOverrideCompression;
    /* 0x0368 */ UAssetImportData* AssetImportData;
    /* 0x0370 */ FString SourceFilePath;
    /* 0x0380 */ FString SourceFileTimestamp;
    /* 0x0390 */ bool bNeedsRebake;
    /* 0x0398 */ TArray<FAnimSyncMarker> AuthoredSyncMarkers;
    /* 0x03c0 */ TArray<FCustomAttributePerBoneData> PerBoneCustomAttributeData;
    /* 0x03d0 */ FGuid CustomAttributesGuid;
    /* 0x03e0 */ FGuid BakedCustomAttributesGuid;
    /* 0x03f0 */ TArray<FBakedCustomAttributePerBoneData> BakedPerBoneCustomAttributeData;

    void AddBoneFloatCustomAttribute(const FName& BoneName, const FName& AttributeName, const TArray<float>& TimeKeys, const TArray<float>& ValueKeys);
    void AddBoneIntegerCustomAttribute(const FName& BoneName, const FName& AttributeName, const TArray<float>& TimeKeys, const TArray<int32_t>& ValueKeys);
    void AddBoneStringCustomAttribute(const FName& BoneName, const FName& AttributeName, const TArray<float>& TimeKeys, const TArray<FString>& ValueKeys);
    void RemoveAllCustomAttributes();
    void RemoveAllCustomAttributesForBone(const FName& BoneName);
    void RemoveCustomAttribute(const FName& BoneName, const FName& AttributeName);
};

// Size: 0x188
class UAnimSequenceBase : public UAnimationAsset {
    /* 0x00e8 */ TArray<FAnimNotifyEvent> Notifies;
    /* 0x00f8 */ float SequenceLength;
    /* 0x00fc */ float RateScale;
    /* 0x0100 */ FRawCurveTracks RawCurveData;
    /* 0x0130 */ TArray<FAnimNotifyTrack> AnimNotifyTracks;

    float GetPlayLength();
};

// Size: 0x20
struct FAnimSequenceTrackContainer {
    /* 0x0000 */ TArray<FRawAnimSequenceTrack> AnimationTracks;
    /* 0x0010 */ TArray<FName> TrackNames;
};

// Size: 0x110
class UAnimSet : public UObject {
    /* 0x0030 */ bool bAnimRotationOnly;
    /* 0x0038 */ TArray<FName> TrackBoneNames;
    /* 0x0048 */ TArray<UAnimSequence*> Sequences;
    /* 0x0058 */ TArray<FAnimSetMeshLinkup> LinkupCache;
    /* 0x0068 */ TArray<uint8_t> BoneUseAnimTranslation;
    /* 0x0078 */ TArray<uint8_t> ForceUseMeshTranslation;
    /* 0x0088 */ TArray<FName> UseTranslationBoneNames;
    /* 0x0098 */ TArray<FName> ForceMeshTranslationBoneNames;
    /* 0x00a8 */ FName PreviewSkelMeshName;
    /* 0x00b4 */ FName BestRatioSkelMeshName;
};

// Size: 0x10
struct FAnimSetMeshLinkup {
    /* 0x0000 */ TArray<int32_t> BoneToTrackTable;
};

// Size: 0x320
class UAnimSingleNodeInstance : public UAnimInstance {
    /* 0x02f8 */ UAnimationAsset* CurrentAsset;
    /* 0x0300 */ FDelegate PostEvaluateAnimEvent;

    UAnimationAsset* GetAnimationAsset() const;
    float GetLength();
    void PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition);
    void SetAnimationAsset(UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate);
    void SetBlendSpaceInput(const FVector& InBlendInput);
    void SetLooping(bool bIsLooping);
    void SetPlayRate(float InPlayRate);
    void SetPlaying(bool bIsPlaying);
    void SetPosition(float InPosition, bool bFireNotifies);
    void SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies);
    void SetPreviewCurveOverride(const FName& PoseName, float Value, bool bRemoveIfZero);
    void SetReverse(bool bInReverse);
    void StopAnim();
};

// Size: 0x980
struct FAnimSingleNodeInstanceProxy : public FAnimInstanceProxy {
};

// Size: 0x10
struct FAnimSlotDesc {
    /* 0x0000 */ FName SlotName;
    /* 0x000c */ int32_t NumChannels;
};

// Size: 0x20
struct FAnimSlotGroup {
    /* 0x0000 */ FName GroupName;
    /* 0x0010 */ TArray<FName> SlotNames;
};

// Size: 0x20
struct FAnimSlotInfo {
    /* 0x0000 */ FName SlotName;
    /* 0x0010 */ TArray<float> ChannelWeights;
};

// Size: 0x30
class UAnimStateMachineTypes : public UObject {
};

// Size: 0x258
class UAnimStreamable : public UAnimSequenceBase {
    /* 0x0188 */ int32_t NumFrames;
    /* 0x018c */ EAnimInterpolationType Interpolation;
    /* 0x0190 */ FName RetargetSource;
    /* 0x01a0 */ UAnimSequence* SourceSequence;
    /* 0x01a8 */ FGuid RawDataGuid;
    /* 0x01b8 */ TArray<FRawAnimSequenceTrack> RawAnimationData;
    /* 0x01c8 */ TArray<FTrackToSkeletonMap> TrackToSkeletonMapTable;
    /* 0x01d8 */ TArray<FName> AnimationTrackNames;
    /* 0x0240 */ UAnimBoneCompressionSettings* BoneCompressionSettings;
    /* 0x0248 */ UAnimCurveCompressionSettings* CurveCompressionSettings;
    /* 0x0250 */ bool bEnableRootMotion;
    /* 0x0251 */ uint8_t RootMotionRootLock;
    /* 0x0252 */ bool bForceRootLock;
    /* 0x0253 */ bool bUseNormalizedRootMotionScale;
};

// Size: 0x24
struct FAnimSyncMarker {
    /* 0x0000 */ FName MarkerName;
    /* 0x000c */ float Time;
    /* 0x0010 */ int32_t TrackIndex;
    /* 0x0014 */ FGuid Guid;
};

// Size: 0x48
struct FAnimTickRecord {
    /* 0x0000 */ UAnimationAsset* SourceAsset;
};

// Size: 0x10
struct FAnimTrack {
    /* 0x0000 */ TArray<FAnimSegment> AnimSegments;
};

// Size: 0x88
struct FAnimUpdateRateParameters {
    /* 0x0001 */ EUpdateRateShiftBucket ShiftBucket;
    /* 0x0002 */ bool bInterpolateSkippedFrames;
    /* 0x0002 */ bool bShouldUseLodMap;
    /* 0x0002 */ bool bShouldUseMinLod;
    /* 0x0002 */ bool bSkipUpdate;
    /* 0x0002 */ bool bSkipEvaluation;
    /* 0x0004 */ int32_t UpdateRate;
    /* 0x0008 */ int32_t EvaluationRate;
    /* 0x000c */ float TickedPoseOffestTime;
    /* 0x0010 */ float AdditionalTime;
    /* 0x0018 */ int32_t BaseNonRenderedUpdateRate;
    /* 0x001c */ int32_t MaxEvalRateForInterpolation;
    /* 0x0020 */ TArray<float> BaseVisibleDistanceFactorThesholds;
    /* 0x0030 */ TMap<int32_t, int32_t> LODToFrameSkipMap;
    /* 0x0080 */ int32_t SkippedUpdateFrames;
    /* 0x0084 */ int32_t SkippedEvalFrames;
};

// Size: 0xd0
struct FAnimationActiveTransitionEntry {
    /* 0x00c0 */ UBlendProfile* BlendProfile;
};

// Size: 0xe8
class UAnimationAsset : public UObject {
    /* 0x0040 */ USkeleton* Skeleton;
    /* 0x0068 */ TArray<UAnimMetaData*> MetaData;
    /* 0x0078 */ UAnimationAsset* ParentAsset;
    /* 0x0080 */ TArray<UAnimationAsset*> ChildrenAssets;
    /* 0x0090 */ UAssetMappingTable* AssetMappingTable;
    /* 0x0098 */ TArray<UAssetUserData*> AssetUserData;
    /* 0x00a8 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x00b0 */ UPoseAsset* PreviewPoseAsset;
    /* 0x00b8 */ TSoftObjectPtr<USkeletalMesh> PreviewSkeletalMesh;
};

enum class AnimationCompressionFormat {
    ACF_None = 0,
    ACF_Float96NoW = 1,
    ACF_Fixed48NoW = 2,
    ACF_IntervalFixed32NoW = 3,
    ACF_Fixed32NoW = 4,
    ACF_Float32NoW = 5,
    ACF_Identity = 6,
    ACF_MAX = 7,
};

// Size: 0x10
struct FAnimationErrorStats {
};

// Size: 0x18
struct FAnimationFrameSnapshot {
};

// Size: 0x10
struct FAnimationGroupReference {
    /* 0x0000 */ FName GroupName;
    /* 0x000c */ uint8_t GroupRole;
    /* 0x000d */ EAnimSyncGroupScope GroupScope;
};

enum class AnimationKeyFormat {
    AKF_ConstantKeyLerp = 0,
    AKF_VariableKeyLerp = 1,
    AKF_PerTrackCompression = 2,
    AKF_MAX = 3,
};

// Size: 0x30
struct FAnimationPotentialTransition {
};

// Size: 0x14
struct FAnimationRecordingSettings {
    /* 0x0000 */ bool bRecordInWorldSpace;
    /* 0x0001 */ bool bRemoveRootAnimation;
    /* 0x0002 */ bool bAutoSaveAsset;
    /* 0x0004 */ float SampleRate;
    /* 0x0008 */ float Length;
    /* 0x000c */ uint8_t InterpMode;
    /* 0x000d */ uint8_t TangentMode;
    /* 0x000f */ bool bRecordTransforms;
    /* 0x0010 */ bool bRecordCurves;
};

// Size: 0xf8
class UAnimationSettings : public UDeveloperSettings {
    /* 0x0060 */ int32_t CompressCommandletVersion;
    /* 0x0068 */ TArray<FString> KeyEndEffectorsMatchNameArray;
    /* 0x0078 */ bool ForceRecompression;
    /* 0x0079 */ bool bForceBelowThreshold;
    /* 0x007a */ bool bFirstRecompressUsingCurrentOrDefault;
    /* 0x007b */ bool bRaiseMaxErrorToExisting;
    /* 0x007c */ bool bEnablePerformanceLog;
    /* 0x007d */ bool bStripAnimationDataOnDedicatedServer;
    /* 0x007e */ bool bTickAnimationOnSkeletalMeshInit;
    /* 0x0080 */ TArray<FCustomAttributeSetting> BoneCustomAttributesNames;
    /* 0x0090 */ TArray<FString> BoneNamesWithCustomAttributes;
    /* 0x00a0 */ TMap<FName, ECustomAttributeBlendType> AttributeBlendModes;
    /* 0x00f0 */ ECustomAttributeBlendType DefaultAttributeBlendMode;
};

// Size: 0x30
struct FAnimationState : public FAnimationStateBase {
    /* 0x0010 */ TArray<FAnimationTransitionRule> Transitions;
    /* 0x0020 */ int32_t StateRootNodeIndex;
    /* 0x0024 */ int32_t StartNotify;
    /* 0x0028 */ int32_t EndNotify;
    /* 0x002c */ int32_t FullyBlendedNotify;
};

// Size: 0xc
struct FAnimationStateBase {
    /* 0x0000 */ FName StateName;
};

// Size: 0x40
struct FAnimationTransitionBetweenStates : public FAnimationStateBase {
    /* 0x000c */ int32_t PreviousState;
    /* 0x0010 */ int32_t NextState;
    /* 0x0014 */ float CrossfadeDuration;
    /* 0x0018 */ int32_t StartNotify;
    /* 0x001c */ int32_t EndNotify;
    /* 0x0020 */ int32_t InterruptNotify;
    /* 0x0024 */ EAlphaBlendOption BlendMode;
    /* 0x0028 */ UCurveFloat* CustomCurve;
    /* 0x0030 */ UBlendProfile* BlendProfile;
    /* 0x0038 */ uint8_t LogicType;
};

// Size: 0x14
struct FAnimationTransitionRule {
    /* 0x0000 */ FName RuleToExecute;
    /* 0x000c */ bool TransitionReturnVal;
    /* 0x0010 */ int32_t TransitionIndex;
};

// Size: 0x150
class UApplicationLifecycleComponent : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate ApplicationWillDeactivateDelegate;
    /* 0x00d0 */ FMulticastInlineDelegate ApplicationHasReactivatedDelegate;
    /* 0x00e0 */ FMulticastInlineDelegate ApplicationWillEnterBackgroundDelegate;
    /* 0x00f0 */ FMulticastInlineDelegate ApplicationHasEnteredForegroundDelegate;
    /* 0x0100 */ FMulticastInlineDelegate ApplicationWillTerminateDelegate;
    /* 0x0110 */ FMulticastInlineDelegate ApplicationShouldUnloadResourcesDelegate;
    /* 0x0120 */ FMulticastInlineDelegate ApplicationReceivedStartupArgumentsDelegate;
    /* 0x0130 */ FMulticastInlineDelegate OnTemperatureChangeDelegate;
    /* 0x0140 */ FMulticastInlineDelegate OnLowPowerModeDelegate;

    void ApplicationLifetimeDelegate__DelegateSignature();
    void ApplicationStartupArgumentsDelegate__DelegateSignature(const TArray<FString>& StartupArguments);
    void OnLowPowerModeDelegate__DelegateSignature(bool bInLowPowerMode);
    void OnTemperatureChangeDelegate__DelegateSignature(ETemperatureSeverityType Severity);
};

// Size: 0x540
class UArrowComponent : public UPrimitiveComponent {
    /* 0x04d8 */ FColor ArrowColor;
    /* 0x04dc */ float ArrowSize;
    /* 0x04e0 */ float ArrowLength;
    /* 0x04e4 */ float ScreenSize;
    /* 0x04e8 */ bool bIsScreenSizeScaled;
    /* 0x04e8 */ bool bTreatAsASprite;
    /* 0x04ec */ FName SpriteCategoryName;
    /* 0x04f8 */ FSpriteCategoryInfo SpriteInfo;
    /* 0x0538 */ bool bLightAttachment;
    /* 0x053c */ bool bUseInEditorScaling;

    void SetArrowColor(FLinearColor NewColor);
};

// Size: 0x28
struct FAssetEditorOrbitCameraPosition {
    /* 0x0000 */ bool bIsSet;
    /* 0x0004 */ FVector CamOrbitPoint;
    /* 0x0010 */ FVector CamOrbitZoom;
    /* 0x001c */ FRotator CamOrbitRotation;
};

// Size: 0x80
class UAssetExportTask : public UObject {
    /* 0x0030 */ UObject* Object;
    /* 0x0038 */ UExporter* Exporter;
    /* 0x0040 */ FString Filename;
    /* 0x0050 */ bool bSelected;
    /* 0x0051 */ bool bReplaceIdentical;
    /* 0x0052 */ bool bPrompt;
    /* 0x0053 */ bool bAutomated;
    /* 0x0054 */ bool bUseFileArchive;
    /* 0x0055 */ bool bWriteEmptyFiles;
    /* 0x0058 */ TArray<UObject*> IgnoreObjectList;
    /* 0x0068 */ UObject* Options;
    /* 0x0070 */ TArray<FString> Errors;
};

// Size: 0x60
class UAssetImportData : public UObject {
    /* 0x0030 */ FString SourceFilePath;
    /* 0x0040 */ FString SourceFileTimestamp;
    /* 0x0050 */ FAssetImportInfo SourceData;

    TArray<FString> K2_ExtractFilenames() const;
    FString K2_GetFirstFilename() const;
    void ScriptedAddFilename(FString InPath, int32_t index, FString SourceFileLabel);
};

// Size: 0x10
struct FAssetImportInfo {
};

// Size: 0x520
class UAssetManager : public UObject {
    /* 0x0388 */ TArray<UObject*> ObjectReferenceList;
    /* 0x0398 */ bool bIsGlobalAsyncScanEnvironment;
    /* 0x0399 */ bool bShouldGuessTypeAndName;
    /* 0x039a */ bool bShouldUseSynchronousLoad;
    /* 0x039b */ bool bIsLoadingFromPakFiles;
    /* 0x039c */ bool bShouldAcquireMissingChunksOnLoad;
    /* 0x039d */ bool bOnlyCookProductionAssets;
    /* 0x039e */ bool bIsBulkScanning;
    /* 0x039f */ bool bIsPrimaryAssetDirectoryCurrent;
    /* 0x03a0 */ bool bIsManagementDatabaseCurrent;
    /* 0x03a1 */ bool bUpdateManagementDatabaseAfterScan;
    /* 0x03a2 */ bool bIncludeOnlyOnDiskAssets;
    /* 0x03a3 */ bool bHasCompletedInitialScan;
    /* 0x03a4 */ int32_t NumberOfSpawnedNotifications;
};

// Size: 0x20
struct FAssetManagerRedirect {
    /* 0x0000 */ FString Old;
    /* 0x0010 */ FString New;
};

// Size: 0x50
struct FAssetManagerSearchRules {
    /* 0x0000 */ TArray<FString> AssetScanPaths;
    /* 0x0010 */ TArray<FString> IncludePatterns;
    /* 0x0020 */ TArray<FString> ExcludePatterns;
    /* 0x0030 */ UClass* AssetBaseClass;
    /* 0x0038 */ bool bHasBlueprintClasses;
    /* 0x0039 */ bool bForceSynchronousScan;
    /* 0x003a */ bool bSkipVirtualPathExpansion;
    /* 0x003b */ bool bSkipManagerIncludeCheck;
};

// Size: 0x128
class UAssetManagerSettings : public UDeveloperSettings {
    /* 0x0060 */ TArray<FPrimaryAssetTypeInfo> PrimaryAssetTypesToScan;
    /* 0x0070 */ TArray<FDirectoryPath> DirectoriesToExclude;
    /* 0x0080 */ TArray<FPrimaryAssetRulesOverride> PrimaryAssetRules;
    /* 0x0090 */ TArray<FPrimaryAssetRulesCustomOverride> CustomPrimaryAssetRules;
    /* 0x00a0 */ bool bOnlyCookProductionAssets;
    /* 0x00a1 */ bool bShouldManagerDetermineTypeAndName;
    /* 0x00a2 */ bool bShouldGuessTypeAndNameInEditor;
    /* 0x00a3 */ bool bShouldAcquireMissingChunksOnLoad;
    /* 0x00a8 */ TArray<FAssetManagerRedirect> PrimaryAssetIdRedirects;
    /* 0x00b8 */ TArray<FAssetManagerRedirect> PrimaryAssetTypeRedirects;
    /* 0x00c8 */ TArray<FAssetManagerRedirect> AssetPathRedirects;
    /* 0x00d8 */ TSet<FName> MetaDataTagsForAssetRegistry;
};

// Size: 0x10
struct FAssetMapping {
    /* 0x0000 */ UAnimationAsset* SourceAsset;
    /* 0x0008 */ UAnimationAsset* TargetAsset;
};

// Size: 0x40
class UAssetMappingTable : public UObject {
    /* 0x0030 */ TArray<FAssetMapping> MappedAssets;
};

// Size: 0x30
class UAssetUserData : public UObject {
};

// Size: 0x90
class UAsyncActionChangePrimaryAssetBundles : public UAsyncActionLoadPrimaryAssetBase {
    /* 0x0080 */ FMulticastInlineDelegate Completed;

    static UAsyncActionChangePrimaryAssetBundles* AsyncChangeBundleStateForMatchingPrimaryAssets(UObject* WorldContextObject, const TArray<FName>& NewBundles, const TArray<FName>& OldBundles);
    static UAsyncActionChangePrimaryAssetBundles* AsyncChangeBundleStateForPrimaryAssetList(UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& AddBundles, const TArray<FName>& RemoveBundles);
};

// Size: 0x70
class UAsyncActionHandleSaveGame : public UBlueprintAsyncActionBase {
    /* 0x0038 */ FMulticastInlineDelegate Completed;
    /* 0x0068 */ USaveGame* SaveGameObject;

    static UAsyncActionHandleSaveGame* AsyncLoadGameFromSlot(UObject* WorldContextObject, FString SlotName, const int32_t UserIndex);
    static UAsyncActionHandleSaveGame* AsyncSaveGameToSlot(UObject* WorldContextObject, USaveGame* SaveGameObject, FString SlotName, const int32_t UserIndex);
};

// Size: 0x90
class UAsyncActionLoadPrimaryAsset : public UAsyncActionLoadPrimaryAssetBase {
    /* 0x0080 */ FMulticastInlineDelegate Completed;

    static UAsyncActionLoadPrimaryAsset* AsyncLoadPrimaryAsset(UObject* WorldContextObject, FPrimaryAssetId PrimaryAsset, const TArray<FName>& LoadBundles);
};

// Size: 0x80
class UAsyncActionLoadPrimaryAssetBase : public UBlueprintAsyncActionBase {
};

// Size: 0x90
class UAsyncActionLoadPrimaryAssetClass : public UAsyncActionLoadPrimaryAssetBase {
    /* 0x0080 */ FMulticastInlineDelegate Completed;

    static UAsyncActionLoadPrimaryAssetClass* AsyncLoadPrimaryAssetClass(UObject* WorldContextObject, FPrimaryAssetId PrimaryAsset, const TArray<FName>& LoadBundles);
};

// Size: 0x90
class UAsyncActionLoadPrimaryAssetClassList : public UAsyncActionLoadPrimaryAssetBase {
    /* 0x0080 */ FMulticastInlineDelegate Completed;

    static UAsyncActionLoadPrimaryAssetClassList* AsyncLoadPrimaryAssetClassList(UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& LoadBundles);
};

// Size: 0x90
class UAsyncActionLoadPrimaryAssetList : public UAsyncActionLoadPrimaryAssetBase {
    /* 0x0080 */ FMulticastInlineDelegate Completed;

    static UAsyncActionLoadPrimaryAssetList* AsyncLoadPrimaryAssetList(UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& LoadBundles);
};

// Size: 0x2b0
struct FAtmospherePrecomputeInstanceData : public FSceneComponentInstanceData {
};

// Size: 0x2c
struct FAtmospherePrecomputeParameters {
    /* 0x0000 */ float DensityHeight;
    /* 0x0004 */ float DecayHeight;
    /* 0x0008 */ int32_t MaxScatteringOrder;
    /* 0x000c */ int32_t TransmittanceTexWidth;
    /* 0x0010 */ int32_t TransmittanceTexHeight;
    /* 0x0014 */ int32_t IrradianceTexWidth;
    /* 0x0018 */ int32_t IrradianceTexHeight;
    /* 0x001c */ int32_t InscatterAltitudeSampleNum;
    /* 0x0020 */ int32_t InscatterMuNum;
    /* 0x0024 */ int32_t InscatterMuSNum;
    /* 0x0028 */ int32_t InscatterNuNum;
};

// Size: 0x310
class AAtmosphericFog : public AInfo {
    /* 0x0300 */ UAtmosphericFogComponent* AtmosphericFogComponent;
    /* 0x0308 */ UArrowComponent* ArrowComponent;
};

// Size: 0x490
class UAtmosphericFogComponent : public USceneComponent {
    /* 0x0228 */ float SunMultiplier;
    /* 0x022c */ float FogMultiplier;
    /* 0x0230 */ float DensityMultiplier;
    /* 0x0234 */ float DensityOffset;
    /* 0x0238 */ float DistanceScale;
    /* 0x023c */ float AltitudeScale;
    /* 0x0240 */ float DistanceOffset;
    /* 0x0244 */ float GroundOffset;
    /* 0x0248 */ float StartDistance;
    /* 0x024c */ float SunDiscScale;
    /* 0x0250 */ float DefaultBrightness;
    /* 0x0254 */ FColor DefaultLightColor;
    /* 0x0258 */ bool bDisableSunDisk;
    /* 0x0258 */ bool bAtmosphereAffectsSunIlluminance;
    /* 0x0258 */ bool bDisableGroundScattering;
    /* 0x025c */ FAtmospherePrecomputeParameters PrecomputeParams;
    /* 0x0288 */ UTexture2D* TransmittanceTexture;
    /* 0x0290 */ UTexture2D* IrradianceTexture;

    void DisableGroundScattering(bool NewGroundScattering);
    void DisableSunDisk(bool NewSunDisk);
    void SetAltitudeScale(float NewAltitudeScale);
    void SetDefaultBrightness(float NewBrightness);
    void SetDefaultLightColor(FLinearColor NewLightColor);
    void SetDensityMultiplier(float NewDensityMultiplier);
    void SetDensityOffset(float NewDensityOffset);
    void SetDistanceOffset(float NewDistanceOffset);
    void SetDistanceScale(float NewDistanceScale);
    void SetFogMultiplier(float NewFogMultiplier);
    void SetPrecomputeParams(float DensityHeight, int32_t MaxScatteringOrder, int32_t InscatterAltitudeSampleNum);
    void SetStartDistance(float NewStartDistance);
    void SetSunMultiplier(float NewSunMultiplier);
    void StartPrecompute();
};

// Size: 0xa8
struct FAttenuationSubmixSendSettings {
    /* 0x0000 */ USoundSubmixBase* Submix;
    /* 0x0008 */ ESubmixSendMethod SubmixSendMethod;
    /* 0x000c */ float SubmixSendLevelMin;
    /* 0x0010 */ float SubmixSendLevelMax;
    /* 0x0014 */ float SubmixSendDistanceMin;
    /* 0x0018 */ float SubmixSendDistanceMax;
    /* 0x001c */ float ManualSubmixSendLevel;
    /* 0x0020 */ FRuntimeFloatCurve CustomSubmixSendCurve;
};

// Size: 0x38
class UAudioBus : public UObject {
    /* 0x0030 */ EAudioBusChannels AudioBusChannels;
};

// Size: 0x8d0
class UAudioComponent : public USceneComponent {
    /* 0x0228 */ USoundBase* Sound;
    /* 0x0230 */ TArray<FAudioComponentParam> InstanceParameters;
    /* 0x0240 */ USoundClass* SoundClassOverride;
    /* 0x0248 */ bool bAutoDestroy;
    /* 0x0248 */ bool bStopWhenOwnerDestroyed;
    /* 0x0248 */ bool bShouldRemainActiveIfDropped;
    /* 0x0248 */ bool bAllowSpatialization;
    /* 0x0248 */ bool bOverrideAttenuation;
    /* 0x0248 */ bool bOverrideSubtitlePriority;
    /* 0x0248 */ bool bIsUISound;
    /* 0x0248 */ bool bEnableLowPassFilter;
    /* 0x0249 */ bool bOverridePriority;
    /* 0x0249 */ bool bSuppressSubtitles;
    /* 0x024a */ bool bAutoManageAttachment;
    /* 0x0250 */ FName AudioComponentUserID;
    /* 0x025c */ float PitchModulationMin;
    /* 0x0260 */ float PitchModulationMax;
    /* 0x0264 */ float VolumeModulationMin;
    /* 0x0268 */ float VolumeModulationMax;
    /* 0x026c */ float VolumeMultiplier;
    /* 0x0270 */ int32_t EnvelopeFollowerAttackTime;
    /* 0x0274 */ int32_t EnvelopeFollowerReleaseTime;
    /* 0x0278 */ float Priority;
    /* 0x027c */ float SubtitlePriority;
    /* 0x0280 */ USoundEffectSourcePresetChain* SourceEffectChain;
    /* 0x0288 */ float VolumeWeightedPriorityScale;
    /* 0x028c */ float HighFrequencyGainMultiplier;
    /* 0x0290 */ float PitchMultiplier;
    /* 0x0294 */ float LowPassFilterFrequency;
    /* 0x02a0 */ USoundAttenuation* AttenuationSettings;
    /* 0x02a8 */ FSoundAttenuationSettings AttenuationOverrides;
    /* 0x0670 */ USoundConcurrency* ConcurrencySettings;
    /* 0x0678 */ TSet<USoundConcurrency*> ConcurrencySet;
    /* 0x06d4 */ EAttachmentRule AutoAttachLocationRule;
    /* 0x06d5 */ EAttachmentRule AutoAttachRotationRule;
    /* 0x06d6 */ EAttachmentRule AutoAttachScaleRule;
    /* 0x06d8 */ FSoundModulationDefaultRoutingSettings ModulationRouting;
    /* 0x0720 */ FMulticastInlineDelegate OnAudioPlayStateChanged;
    /* 0x0748 */ FMulticastInlineDelegate OnAudioVirtualizationChanged;
    /* 0x0770 */ FMulticastInlineDelegate OnAudioFinished;
    /* 0x0798 */ FMulticastInlineDelegate OnAudioPlaybackPercent;
    /* 0x07c0 */ FMulticastInlineDelegate OnAudioSingleEnvelopeValue;
    /* 0x07e8 */ FMulticastInlineDelegate OnAudioMultiEnvelopeValue;
    /* 0x0810 */ FDelegate OnQueueSubtitles;
    /* 0x0824 */ TWeakObjectPtr<USceneComponent> AutoAttachParent;
    /* 0x082c */ FName AutoAttachSocketName;

    void AdjustAttenuation(const FSoundAttenuationSettings& InAttenuationSettings);
    void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel, const EAudioFaderCurve FadeCurve);
    bool BP_GetAttenuationSettingsToApply(FSoundAttenuationSettings& OutAttenuationSettings);
    void FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime, const EAudioFaderCurve FadeCurve);
    void FadeOut(float FadeOutDuration, float FadeVolumeLevel, const EAudioFaderCurve FadeCurve);
    bool GetCookedEnvelopeData(float& OutEnvelopeData);
    bool GetCookedEnvelopeDataForAllPlayingSounds(TArray<FSoundWaveEnvelopeDataPerSound>& OutEnvelopeData);
    bool GetCookedFFTData(const TArray<float>& FrequenciesToGet, TArray<FSoundWaveSpectralData>& OutSoundWaveSpectralData);
    bool GetCookedFFTDataForAllPlayingSounds(TArray<FSoundWaveSpectralDataPerSound>& OutSoundWaveSpectralData);
    EAudioComponentPlayState GetPlayState() const;
    bool HasCookedAmplitudeEnvelopeData() const;
    bool HasCookedFFTData() const;
    bool IsPlaying() const;
    bool IsVirtualized() const;
    void Play(float StartTime);
    void PlayQuantized(const UObject* WorldContextObject, UQuartzClockHandle*& InClockHandle, FQuartzQuantizationBoundary& InQuantizationBoundary, const FDelegate& InDelegate, float InStartTime, float InFadeInDuration, float InFadeVolumeLevel, EAudioFaderCurve InFadeCurve);
    void SetAudioBusSendPostEffect(UAudioBus* AudioBus, float AudioBusSendLevel);
    void SetAudioBusSendPreEffect(UAudioBus* AudioBus, float AudioBusSendLevel);
    void SetBoolParameter(FName InName, bool InBool);
    void SetFloatParameter(FName InName, float InFloat);
    void SetIntParameter(FName InName, int32_t inInt);
    void SetLowPassFilterEnabled(bool InLowPassFilterEnabled);
    void SetLowPassFilterFrequency(float InLowPassFilterFrequency);
    void SetOutputToBusOnly(bool bInOutputToBusOnly);
    void SetPaused(bool bPause);
    void SetPitchMultiplier(float NewPitchMultiplier);
    void SetSound(USoundBase* NewSound);
    void SetSourceBusSendPostEffect(USoundSourceBus* SoundSourceBus, float SourceBusSendLevel);
    void SetSourceBusSendPreEffect(USoundSourceBus* SoundSourceBus, float SourceBusSendLevel);
    void SetSubmixSend(USoundSubmixBase* Submix, float SendLevel);
    void SetUISound(bool bInUISound);
    void SetVolumeMultiplier(float NewVolumeMultiplier);
    void SetWaveParameter(FName InName, USoundWave* InWave);
    void Stop();
    void StopDelayed(float DelayTime);
};

// Size: 0x20
struct FAudioComponentParam {
    /* 0x0000 */ FName ParamName;
    /* 0x000c */ float FloatParam;
    /* 0x0010 */ bool BoolParam;
    /* 0x0014 */ int32_t IntParam;
    /* 0x0018 */ USoundWave* SoundWaveParam;
};

// Size: 0x40
struct FAudioEQEffect : public FAudioEffectParameters {
    /* 0x0010 */ float FrequencyCenter0;
    /* 0x0014 */ float Gain0;
    /* 0x0018 */ float Bandwidth0;
    /* 0x001c */ float FrequencyCenter1;
    /* 0x0020 */ float Gain1;
    /* 0x0024 */ float Bandwidth1;
    /* 0x0028 */ float FrequencyCenter2;
    /* 0x002c */ float Gain2;
    /* 0x0030 */ float Bandwidth2;
    /* 0x0034 */ float FrequencyCenter3;
    /* 0x0038 */ float Gain3;
    /* 0x003c */ float Bandwidth3;
};

// Size: 0x8
struct FAudioEffectParameters {
};

// Size: 0x20
struct FAudioQualitySettings {
    /* 0x0000 */ FText DisplayName;
    /* 0x0018 */ int32_t MaxChannels;
};

// Size: 0x48
struct FAudioReverbEffect : public FAudioEffectParameters {
};

// Size: 0x290
class UAudioSettings : public UDeveloperSettings {
    /* 0x0060 */ FSoftObjectPath DefaultSoundClassName;
    /* 0x0080 */ FSoftObjectPath DefaultMediaSoundClassName;
    /* 0x00a0 */ FSoftObjectPath DefaultSoundConcurrencyName;
    /* 0x00c0 */ FSoftObjectPath DefaultBaseSoundMix;
    /* 0x00e0 */ FSoftObjectPath VoiPSoundClass;
    /* 0x0100 */ FSoftObjectPath MasterSubmix;
    /* 0x0120 */ FSoftObjectPath BaseDefaultSubmix;
    /* 0x0140 */ FSoftObjectPath ReverbSubmix;
    /* 0x0160 */ FSoftObjectPath EQSubmix;
    /* 0x0180 */ EVoiceSampleRate VoiPSampleRate;
    /* 0x0184 */ float DefaultReverbSendLevel;
    /* 0x0188 */ int32_t MaximumConcurrentStreams;
    /* 0x018c */ float GlobalMinPitchScale;
    /* 0x0190 */ float GlobalMaxPitchScale;
    /* 0x0198 */ TArray<FAudioQualitySettings> QualityLevels;
    /* 0x01a8 */ bool bAllowPlayWhenSilent;
    /* 0x01a8 */ bool bDisableMasterEQ;
    /* 0x01a8 */ bool bAllowCenterChannel3DPanning;
    /* 0x01ac */ uint32_t NumStoppingSources;
    /* 0x01b0 */ EPanningMethod PanningMethod;
    /* 0x01b1 */ EMonoChannelUpmixMethod MonoChannelUpmixMethod;
    /* 0x01b8 */ FString DialogueFilenameFormat;
    /* 0x01c8 */ TArray<FSoundDebugEntry> DebugSounds;
    /* 0x01d8 */ TArray<FDefaultAudioBusSettings> DefaultAudioBuses;
    /* 0x0200 */ USoundClass* DefaultSoundClass;
    /* 0x0208 */ USoundClass* DefaultMediaSoundClass;
    /* 0x0210 */ USoundConcurrency* DefaultSoundConcurrency;
};

// Size: 0x3a8
class AAudioVolume : public AVolume {
    /* 0x0338 */ float Priority;
    /* 0x033c */ bool bEnabled;
    /* 0x0340 */ FReverbSettings Settings;
    /* 0x0360 */ FInteriorSettings AmbientZoneSettings;
    /* 0x0388 */ TArray<FAudioVolumeSubmixSendSettings> SubmixSendSettings;
    /* 0x0398 */ TArray<FAudioVolumeSubmixOverrideSettings> SubmixOverrideSettings;

    void OnRep_bEnabled();
    void SetEnabled(bool bNewEnabled);
    void SetInteriorSettings(const FInteriorSettings& NewInteriorSettings);
    void SetPriority(float NewPriority);
    void SetReverbSettings(const FReverbSettings& NewReverbSettings);
    void SetSubmixOverrideSettings(const TArray<FAudioVolumeSubmixOverrideSettings>& NewSubmixOverrideSettings);
    void SetSubmixSendSettings(const TArray<FAudioVolumeSubmixSendSettings>& NewSubmixSendSettings);
};

// Size: 0x20
struct FAudioVolumeSubmixOverrideSettings {
    /* 0x0000 */ USoundSubmix* Submix;
    /* 0x0008 */ TArray<USoundEffectSubmixPreset*> SubmixEffectChain;
    /* 0x0018 */ float CrossfadeTime;
};

// Size: 0x18
struct FAudioVolumeSubmixSendSettings {
    /* 0x0000 */ EAudioVolumeLocationState ListenerLocationState;
    /* 0x0001 */ EAudioVolumeLocationState SourceLocationState;
    /* 0x0008 */ TArray<FSoundSubmixSendInfo> SubmixSends;
};

// Size: 0x28
struct FAutoCompleteNode {
    /* 0x0000 */ int32_t IndexChar;
    /* 0x0008 */ TArray<int32_t> AutoCompleteListIndices;
};

// Size: 0x58
class UAutoDestroySubsystem : public UTickableWorldSubsystem {
    /* 0x0048 */ TArray<AActor*> ActorsToPoll;

    void OnActorEndPlay(AActor* Actor, uint8_t EndPlayReason);
};

// Size: 0x350
class UAutomationTestSettings : public UObject {
    /* 0x0030 */ TArray<FString> EngineTestModules;
    /* 0x0040 */ TArray<FString> EditorTestModules;
    /* 0x0050 */ FSoftObjectPath AutomationTestmap;
    /* 0x0070 */ TArray<FEditorMapPerformanceTestDefinition> EditorPerformanceTestMaps;
    /* 0x0080 */ TArray<FSoftObjectPath> AssetsToOpen;
    /* 0x0090 */ TArray<FString> MapsToPIETest;
    /* 0x00a0 */ FBuildPromotionTestSettings BuildPromotionTest;
    /* 0x0290 */ FMaterialEditorPromotionSettings MaterialEditorPromotionTest;
    /* 0x02c0 */ FParticleEditorPromotionSettings ParticleEditorPromotionTest;
    /* 0x02d0 */ FBlueprintEditorPromotionSettings BlueprintEditorPromotionTest;
    /* 0x0300 */ TArray<FString> TestLevelFolders;
    /* 0x0310 */ TArray<FExternalToolDefinition> ExternalTools;
    /* 0x0320 */ TArray<FEditorImportExportTestDefinition> ImportExportTestDefinitions;
    /* 0x0330 */ TArray<FLaunchOnTestSettings> LaunchOnSettings;
    /* 0x0340 */ FIntPoint DefaultScreenshotResolution;
    /* 0x0348 */ float PIETestDuration;
};

// Size: 0x100
class UAvoidanceManager : public UObject {
    /* 0x0038 */ float DefaultTimeToLive;
    /* 0x003c */ float LockTimeAfterAvoid;
    /* 0x0040 */ float LockTimeAfterClean;
    /* 0x0044 */ float DeltaTimeToPredict;
    /* 0x0048 */ float ArtificialRadiusExpansion;
    /* 0x004c */ float TestHeightDifference;
    /* 0x0050 */ float HeightCheckMargin;

    FVector GetAvoidanceVelocityForComponent(UMovementComponent* MovementComp);
    int32_t GetNewAvoidanceUID();
    int32_t GetObjectCount();
    bool RegisterMovementComponent(UMovementComponent* MovementComp, float AvoidanceWeight);
};

// Size: 0x18
struct FBPComponentClassOverride {
    /* 0x0000 */ FName ComponentName;
    /* 0x0010 */ UClass* ComponentClass;
};

// Size: 0x38
struct FBPEditorBookmarkNode {
    /* 0x0000 */ FGuid NodeGuid;
    /* 0x0010 */ FGuid ParentGuid;
    /* 0x0020 */ FText DisplayName;
};

// Size: 0x18
struct FBPInterfaceDescription {
    /* 0x0000 */ UClass* Interface;
    /* 0x0008 */ TArray<UEdGraph*> Graphs;
};

// Size: 0xf0
struct FBPVariableDescription {
    /* 0x0000 */ FName VarName;
    /* 0x000c */ FGuid VarGuid;
    /* 0x0020 */ FEdGraphPinType VarType;
    /* 0x0090 */ FString FriendlyName;
    /* 0x00a0 */ FText Category;
    /* 0x00b8 */ uint64_t PropertyFlags;
    /* 0x00c0 */ FName RepNotifyFunc;
    /* 0x00cc */ uint8_t ReplicationCondition;
    /* 0x00d0 */ TArray<FBPVariableMetaDataEntry> MetaDataArray;
    /* 0x00e0 */ FString DefaultValue;
};

// Size: 0x20
struct FBPVariableMetaDataEntry {
    /* 0x0000 */ FName DataKey;
    /* 0x0010 */ FString DataValue;
};

// Size: 0x60
struct FBakedAnimationState {
    /* 0x0000 */ FName StateName;
    /* 0x0010 */ TArray<FBakedStateExitTransition> Transitions;
    /* 0x0020 */ int32_t StateRootNodeIndex;
    /* 0x0024 */ int32_t StartNotify;
    /* 0x0028 */ int32_t EndNotify;
    /* 0x002c */ int32_t FullyBlendedNotify;
    /* 0x0030 */ bool bIsAConduit;
    /* 0x0034 */ int32_t EntryRuleNodeIndex;
    /* 0x0038 */ TArray<int32_t> PlayerNodeIndices;
    /* 0x0048 */ TArray<int32_t> LayerNodeIndices;
    /* 0x0058 */ bool bAlwaysResetOnEntry;
};

// Size: 0x38
struct FBakedAnimationStateMachine {
    /* 0x0000 */ FName MachineName;
    /* 0x000c */ int32_t InitialState;
    /* 0x0010 */ TArray<FBakedAnimationState> States;
    /* 0x0020 */ TArray<FAnimationTransitionBetweenStates> Transitions;
};

// Size: 0x38
struct FBakedCustomAttributePerBoneData {
    /* 0x0000 */ int32_t BoneTreeIndex;
    /* 0x0008 */ TArray<FBakedStringCustomAttribute> StringAttributes;
    /* 0x0018 */ TArray<FBakedIntegerCustomAttribute> IntAttributes;
    /* 0x0028 */ TArray<FBakedFloatCustomAttribute> FloatAttributes;
};

// Size: 0x98
struct FBakedFloatCustomAttribute {
    /* 0x0000 */ FName AttributeName;
    /* 0x0010 */ FSimpleCurve FloatCurve;
};

// Size: 0x90
struct FBakedIntegerCustomAttribute {
    /* 0x0000 */ FName AttributeName;
    /* 0x0010 */ FIntegralCurve IntCurve;
};

// Size: 0x20
struct FBakedStateExitTransition {
    /* 0x0000 */ int32_t CanTakeDelegateIndex;
    /* 0x0004 */ int32_t CustomResultNodeIndex;
    /* 0x0008 */ int32_t TransitionIndex;
    /* 0x000c */ bool bDesiredTransitionReturnValue;
    /* 0x000d */ bool bAutomaticRemainingTimeRule;
    /* 0x0010 */ TArray<int32_t> PoseEvaluatorLinks;
};

// Size: 0x98
struct FBakedStringCustomAttribute {
    /* 0x0000 */ FName AttributeName;
    /* 0x0010 */ FStringCurve StringCurve;
};

// Size: 0x318
class ABandwidthTestActor : public AActor {
    /* 0x02f8 */ FBandwidthTestGenerator BandwidthGenerator;
};

// Size: 0x20
struct FBandwidthTestGenerator {
    /* 0x0000 */ TArray<FBandwidthTestItem> ReplicatedBuffers;
};

// Size: 0x10
struct FBandwidthTestItem {
    /* 0x0000 */ TArray<uint8_t> Kilobyte;
};

// Size: 0xb0
struct FBaseAttenuationSettings {
    /* 0x0008 */ EAttenuationDistanceModel DistanceAlgorithm;
    /* 0x0009 */ uint8_t AttenuationShape;
    /* 0x000c */ float dBAttenuationAtMax;
    /* 0x0010 */ ENaturalSoundFalloffMode FalloffMode;
    /* 0x0014 */ FVector AttenuationShapeExtents;
    /* 0x0020 */ float ConeOffset;
    /* 0x0024 */ float FalloffDistance;
    /* 0x0028 */ FRuntimeFloatCurve CustomAttenuationCurve;
};

// Size: 0x30
struct FBasedMovementInfo {
    /* 0x0000 */ UPrimitiveComponent* MovementBase;
    /* 0x0008 */ FName BoneName;
    /* 0x0014 */ FVector_NetQuantize100 Location;
    /* 0x0020 */ FRotator Rotation;
    /* 0x002c */ bool bServerHasBaseComponent;
    /* 0x002d */ bool bRelativeRotation;
    /* 0x002e */ bool bServerHasVelocity;
};

// Size: 0x38
struct FBasedPosition {
    /* 0x0000 */ AActor* Base;
    /* 0x0008 */ FVector Position;
    /* 0x0014 */ FVector CachedBaseLocation;
    /* 0x0020 */ FRotator CachedBaseRotation;
    /* 0x002c */ FVector CachedTransPosition;
};

// Size: 0x34
struct FBatchedLine {
    /* 0x0000 */ FVector Start;
    /* 0x000c */ FVector End;
    /* 0x0018 */ FLinearColor Color;
    /* 0x0028 */ float Thickness;
    /* 0x002c */ float RemainingLifeTime;
    /* 0x0030 */ uint8_t DepthPriority;
};

// Size: 0x28
struct FBatchedPoint {
    /* 0x0000 */ FVector Position;
    /* 0x000c */ FLinearColor Color;
    /* 0x001c */ float PointSize;
    /* 0x0020 */ float RemainingLifeTime;
    /* 0x0024 */ uint8_t DepthPriority;
};

enum class Beam2SourceTargetMethod {
    PEB2STM_Default = 0,
    PEB2STM_UserSet = 1,
    PEB2STM_Emitter = 2,
    PEB2STM_Particle = 3,
    PEB2STM_Actor = 4,
    PEB2STM_MAX = 5,
};

enum class Beam2SourceTargetTangentMethod {
    PEB2STTM_Direct = 0,
    PEB2STTM_UserSet = 1,
    PEB2STTM_Distribution = 2,
    PEB2STTM_Emitter = 3,
    PEB2STTM_MAX = 4,
};

// Size: 0x4
struct FBeamModifierOptions {
    /* 0x0000 */ bool bModify;
    /* 0x0000 */ bool bScale;
    /* 0x0000 */ bool bLock;
};

enum class BeamModifierType {
    PEB2MT_Source = 0,
    PEB2MT_Target = 1,
    PEB2MT_MAX = 2,
};

// Size: 0x10
struct FBeamTargetData {
    /* 0x0000 */ FName TargetName;
    /* 0x000c */ float TargetPercentage;
};

// Size: 0x550
class UBillboardComponent : public UPrimitiveComponent {
    /* 0x04d8 */ UTexture2D* Sprite;
    /* 0x04e0 */ bool bIsScreenSizeScaled;
    /* 0x04e4 */ float ScreenSize;
    /* 0x04e8 */ float U;
    /* 0x04ec */ float UL;
    /* 0x04f0 */ float V;
    /* 0x04f4 */ float VL;
    /* 0x04f8 */ FName SpriteCategoryName;
    /* 0x0508 */ FSpriteCategoryInfo SpriteInfo;
    /* 0x0548 */ bool bUseInEditorScaling;

    void SetSprite(UTexture2D* NewSprite);
    void SetSpriteAndUV(UTexture2D* NewSprite, int32_t NewU, int32_t NewUL, int32_t NewV, int32_t NewVL);
    void SetUV(int32_t NewU, int32_t NewUL, int32_t NewV, int32_t NewVL);
};

// Size: 0x78
struct FBlendFilter {
};

// Size: 0x20
struct FBlendParameter {
    /* 0x0000 */ FString DisplayName;
    /* 0x0010 */ float Min;
    /* 0x0014 */ float Max;
    /* 0x0018 */ int32_t GridNum;
};

// Size: 0x50
class UBlendProfile : public UObject {
    /* 0x0038 */ USkeleton* OwningSkeleton;
    /* 0x0040 */ TArray<FBlendProfileBoneEntry> ProfileEntries;
};

// Size: 0x18
struct FBlendProfileBoneEntry {
    /* 0x0000 */ FBoneReference BoneReference;
    /* 0x0014 */ float BlendScale;
};

// Size: 0x20
struct FBlendSample {
    /* 0x0000 */ UAnimSequence* Animation;
    /* 0x0008 */ FVector SampleValue;
    /* 0x0014 */ float RateScale;
    /* 0x0018 */ bool bSnapToGrid;
    /* 0x0018 */ bool bIsValid;
};

// Size: 0x40
struct FBlendSampleData {
    /* 0x0000 */ int32_t SampleDataIndex;
    /* 0x0008 */ UAnimSequence* Animation;
    /* 0x0010 */ float TotalWeight;
    /* 0x0014 */ float Time;
    /* 0x0018 */ float PreviousTime;
    /* 0x001c */ float SamplePlayRate;
};

// Size: 0x1f0
class UBlendSpace : public UBlendSpaceBase {
    /* 0x01e8 */ uint8_t AxisToScaleAnimation;
};

// Size: 0x1f0
class UBlendSpace1D : public UBlendSpaceBase {
    /* 0x01e8 */ bool bDisplayEditorVertically;
    /* 0x01e9 */ bool bScaleAnimation;
};

// Size: 0x1e8
class UBlendSpaceBase : public UAnimationAsset {
    /* 0x00f0 */ bool bRotationBlendInMeshSpace;
    /* 0x00f8 */ UAnimSequence* PreviewBasePose;
    /* 0x0100 */ float AnimLength;
    /* 0x0104 */ FInterpolationParameter InterpolationParam[3];
    /* 0x011c */ float TargetWeightInterpolationSpeedPerSec;
    /* 0x0120 */ uint8_t NotifyTriggerMode;
    /* 0x0128 */ TArray<FPerBoneInterpolation> PerBoneBlend;
    /* 0x0138 */ int32_t SampleIndexWithMarkers;
    /* 0x0140 */ TArray<FBlendSample> SampleData;
    /* 0x0150 */ TArray<FEditorElement> GridSamples;
    /* 0x0160 */ FBlendParameter BlendParameters[3];
};

// Size: 0x30
class IBlendableInterface : public UInterface {
};

// Size: 0x338
class ABlockingVolume : public AVolume {
};

// Size: 0x4d8
class UBlueprint : public UBlueprintCore {
    /* 0x0058 */ UClass* ParentClass;
    /* 0x0060 */ uint8_t BlueprintType;
    /* 0x0061 */ bool bRecompileOnLoad;
    /* 0x0061 */ bool bHasBeenRegenerated;
    /* 0x0061 */ bool bIsRegeneratingOnLoad;
    /* 0x0061 */ bool bBeingCompiled;
    /* 0x0061 */ bool bIsNewlyCreated;
    /* 0x0061 */ bool bForceFullEditor;
    /* 0x0061 */ bool bQueuedForCompilation;
    /* 0x0061 */ bool bRunConstructionScriptOnDrag;
    /* 0x0062 */ bool bRunConstructionScriptInSequencer;
    /* 0x0062 */ bool bGenerateConstClass;
    /* 0x0062 */ bool bGenerateAbstractClass;
    /* 0x0062 */ bool bDisplayCompilePIEWarning;
    /* 0x0062 */ bool bDeprecate;
    /* 0x0062 */ bool bDuplicatingReadOnly;
    /* 0x0062 */ bool bNativize;
    /* 0x0063 */ EBlueprintNativizationFlag NativizationFlag;
    /* 0x0064 */ EBlueprintCompileMode CompileMode;
    /* 0x0065 */ uint8_t Status;
    /* 0x0068 */ FString BlueprintDisplayName;
    /* 0x0078 */ FString BlueprintDescription;
    /* 0x0088 */ FString BlueprintNamespace;
    /* 0x0098 */ FString BlueprintCategory;
    /* 0x00a8 */ TArray<FString> HideCategories;
    /* 0x00b8 */ int32_t BlueprintSystemVersion;
    /* 0x00c0 */ USimpleConstructionScript* SimpleConstructionScript;
    /* 0x00c8 */ TArray<UEdGraph*> UbergraphPages;
    /* 0x00d8 */ TArray<UEdGraph*> FunctionGraphs;
    /* 0x00e8 */ TArray<UEdGraph*> DelegateSignatureGraphs;
    /* 0x00f8 */ TArray<UEdGraph*> MacroGraphs;
    /* 0x0108 */ TArray<UEdGraph*> IntermediateGeneratedGraphs;
    /* 0x0118 */ TArray<UEdGraph*> EventGraphs;
    /* 0x0128 */ TMap<UEdGraph*, FBlueprintMacroCosmeticInfo> PRIVATE_CachedMacroInfo;
    /* 0x0178 */ TArray<UActorComponent*> ComponentTemplates;
    /* 0x0188 */ TArray<UTimelineTemplate*> Timelines;
    /* 0x0198 */ TArray<FBPComponentClassOverride> ComponentClassOverrides;
    /* 0x01a8 */ UInheritableComponentHandler* InheritableComponentHandler;
    /* 0x01b0 */ TArray<FBPVariableDescription> NewVariables;
    /* 0x01c0 */ TArray<FName> CategorySorting;
    /* 0x01d0 */ TArray<FBPInterfaceDescription> ImplementedInterfaces;
    /* 0x01e0 */ TArray<FEditedDocumentInfo> LastEditedDocuments;
    /* 0x01f0 */ TMap<FGuid, FEditedDocumentInfo> Bookmarks;
    /* 0x0240 */ TArray<FBPEditorBookmarkNode> BookmarkNodes;
    /* 0x0250 */ TArray<UBreakpoint*> Breakpoints;
    /* 0x0260 */ TArray<FEdGraphPinReference> WatchedPins;
    /* 0x0270 */ TArray<UEdGraphPin_Deprecated*> DeprecatedPinWatches;
    /* 0x0280 */ TMap<FName, int32_t> ComponentTemplateNameIndex;
    /* 0x02d0 */ TMap<FName, FName> OldToNewComponentTemplateNames;
    /* 0x0320 */ TArray<UBlueprintExtension*> Extensions;
    /* 0x0368 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x0370 */ uint32_t CrcLastCompiledCDO;
    /* 0x0374 */ uint32_t CrcLastCompiledSignature;
    /* 0x0478 */ UClass* OriginalClass;
};

// Size: 0x38
class UBlueprintAsyncActionBase : public UObject {

    void Activate();
};

// Size: 0x18
struct FBlueprintComponentChangedPropertyInfo {
    /* 0x0000 */ FName PropertyName;
    /* 0x000c */ int32_t ArrayIndex;
    /* 0x0010 */ Ustruct* PropertyScope;
};

// Size: 0x24
struct FBlueprintComponentDelegateBinding {
    /* 0x0000 */ FName ComponentPropertyName;
    /* 0x000c */ FName DelegatePropertyName;
    /* 0x0018 */ FName FunctionNameToBind;
};

// Size: 0x50
struct FBlueprintCookedComponentInstancingData {
    /* 0x0000 */ TArray<FBlueprintComponentChangedPropertyInfo> ChangedPropertyList;
    /* 0x0029 */ bool bHasValidCookedData;
};

// Size: 0x58
class UBlueprintCore : public UObject {
    /* 0x0030 */ UClass* SkeletonGeneratedClass;
    /* 0x0038 */ UClass* GeneratedClass;
    /* 0x0040 */ bool bLegacyNeedToPurgeSkelRefs;
    /* 0x0044 */ FGuid BlueprintGuid;
};

// Size: 0x1f0
struct FBlueprintDebugData {
};

// Size: 0x30
struct FBlueprintEditorPromotionSettings {
    /* 0x0000 */ FFilePath FirstMeshPath;
    /* 0x0010 */ FFilePath SecondMeshPath;
    /* 0x0020 */ FFilePath DefaultParticleAsset;
};

// Size: 0x30
class UBlueprintExtension : public UObject {
};

// Size: 0x30
class UBlueprintFunctionLibrary : public UObject {
};

// Size: 0x5e8
class UBlueprintGeneratedClass : public UClass {
    /* 0x0278 */ int32_t NumReplicatedProperties;
    /* 0x027c */ bool bHasNativizedParent;
    /* 0x027c */ bool bHasCookedComponentInstancingData;
    /* 0x0280 */ bool bIsSparseClassDataSerializable;
    /* 0x0288 */ TArray<UDynamicBlueprintBinding*> DynamicBindingObjects;
    /* 0x0298 */ TArray<UActorComponent*> ComponentTemplates;
    /* 0x02a8 */ TArray<UTimelineTemplate*> Timelines;
    /* 0x02b8 */ TArray<FBPComponentClassOverride> ComponentClassOverrides;
    /* 0x02c8 */ USimpleConstructionScript* SimpleConstructionScript;
    /* 0x02d0 */ UInheritableComponentHandler* InheritableComponentHandler;
    /* 0x02d8 */ UStructProperty* UberGraphFramePointerProperty;
    /* 0x02e8 */ UFunction* UberGraphFunction;
    /* 0x02f8 */ TArray<FEventGraphFastCallPair> FastCallPairs;
    /* 0x0308 */ UObject* OverridenArchetypeForCDO;
    /* 0x0310 */ TMap<FName, FGuid> PropertyGuids;
    /* 0x0360 */ TArray<UFunction*> CalledFunctions;
    /* 0x0370 */ TMap<FName, FBlueprintCookedComponentInstancingData> CookedComponentInstancingData;
};

// Size: 0x20
struct FBlueprintInputActionDelegateBinding : public FBlueprintInputDelegateBinding {
    /* 0x0004 */ FName InputActionName;
    /* 0x0010 */ uint8_t InputKeyEvent;
    /* 0x0014 */ FName FunctionNameToBind;
};

// Size: 0x1c
struct FBlueprintInputAxisDelegateBinding : public FBlueprintInputDelegateBinding {
    /* 0x0004 */ FName InputAxisName;
    /* 0x0010 */ FName FunctionNameToBind;
};

// Size: 0x38
struct FBlueprintInputAxisKeyDelegateBinding : public FBlueprintInputDelegateBinding {
    /* 0x0008 */ FKey AxisKey;
    /* 0x0028 */ FName FunctionNameToBind;
};

// Size: 0x4
struct FBlueprintInputDelegateBinding {
    /* 0x0000 */ bool bConsumeInput;
    /* 0x0000 */ bool bExecuteWhenPaused;
    /* 0x0000 */ bool bOverrideParentBinding;
};

// Size: 0x40
struct FBlueprintInputKeyDelegateBinding : public FBlueprintInputDelegateBinding {
    /* 0x0008 */ FInputChord InputChord;
    /* 0x0030 */ uint8_t InputKeyEvent;
    /* 0x0034 */ FName FunctionNameToBind;
};

// Size: 0x14
struct FBlueprintInputTouchDelegateBinding : public FBlueprintInputDelegateBinding {
    /* 0x0004 */ uint8_t InputKeyEvent;
    /* 0x0008 */ FName FunctionNameToBind;
};

// Size: 0x1
struct FBlueprintMacroCosmeticInfo {
};

// Size: 0x30
class UBlueprintMapLibrary : public UBlueprintFunctionLibrary {

    static void Map_Add(const TMap<int32_t, int32_t>& TargetMap, const int32_t& Key, const int32_t& Value);
    static void Map_Clear(const TMap<int32_t, int32_t>& TargetMap);
    static bool Map_Contains(const TMap<int32_t, int32_t>& TargetMap, const int32_t& Key);
    static bool Map_Find(const TMap<int32_t, int32_t>& TargetMap, const int32_t& Key, int32_t& Value);
    static void Map_Keys(const TMap<int32_t, int32_t>& TargetMap, TArray<int32_t>& Keys);
    static int32_t Map_Length(const TMap<int32_t, int32_t>& TargetMap);
    static bool Map_Remove(const TMap<int32_t, int32_t>& TargetMap, const int32_t& Key);
    static void Map_Values(const TMap<int32_t, int32_t>& TargetMap, TArray<int32_t>& Values);
    static void SetMapPropertyByName(UObject* Object, FName PropertyName, const TMap<int32_t, int32_t>& Value);
};

// Size: 0x30
class UBlueprintPathsLibrary : public UBlueprintFunctionLibrary {

    static FString AutomationDir();
    static FString AutomationLogDir();
    static FString AutomationTransientDir();
    static FString BugItDir();
    static FString ChangeExtension(FString InPath, FString InNewExtension);
    static FString CloudDir();
    static bool CollapseRelativeDirectories(FString InPath, FString& OutPath);
    static FString Combine(const TArray<FString>& InPaths);
    static FString ConvertFromSandboxPath(FString InPath, FString InSandboxName);
    static FString ConvertRelativePathToFull(FString InPath, FString InBasePath);
    static FString ConvertToSandboxPath(FString InPath, FString InSandboxName);
    static FString CreateTempFilename(FString Path, FString Prefix, FString Extension);
    static FString DiffDir();
    static bool DirectoryExists(FString InPath);
    static FString EngineConfigDir();
    static FString EngineContentDir();
    static FString EngineDir();
    static FString EngineIntermediateDir();
    static FString EnginePluginsDir();
    static FString EngineSavedDir();
    static FString EngineSourceDir();
    static FString EngineUserDir();
    static FString EngineVersionAgnosticUserDir();
    static FString EnterpriseDir();
    static FString EnterpriseFeaturePackDir();
    static FString EnterprisePluginsDir();
    static FString FeaturePackDir();
    static bool FileExists(FString InPath);
    static FString GameAgnosticSavedDir();
    static FString GameDevelopersDir();
    static FString GameSourceDir();
    static FString GameUserDeveloperDir();
    static FString GeneratedConfigDir();
    static FString GetBaseFilename(FString InPath, bool bRemovePath);
    static FString GetCleanFilename(FString InPath);
    static TArray<FString> GetEditorLocalizationPaths();
    static TArray<FString> GetEngineLocalizationPaths();
    static FString GetExtension(FString InPath, bool bIncludeDot);
    static TArray<FString> GetGameLocalizationPaths();
    static FString GetInvalidFileSystemChars();
    static FString GetPath(FString InPath);
    static FString GetProjectFilePath();
    static TArray<FString> GetPropertyNameLocalizationPaths();
    static FString GetRelativePathToRoot();
    static TArray<FString> GetRestrictedFolderNames();
    static TArray<FString> GetToolTipLocalizationPaths();
    static bool HasProjectPersistentDownloadDir();
    static bool IsDrive(FString InPath);
    static bool IsProjectFilePathSet();
    static bool IsRelative(FString InPath);
    static bool IsRestrictedPath(FString InPath);
    static bool IsSamePath(FString PathA, FString PathB);
    static FString LaunchDir();
    static bool MakePathRelativeTo(FString InPath, FString InRelativeTo, FString& OutPath);
    static void MakePlatformFilename(FString InPath, FString& OutPath);
    static void MakeStandardFilename(FString InPath, FString& OutPath);
    static FString MakeValidFileName(FString inString, FString InReplacementChar);
    static void NormalizeDirectoryName(FString InPath, FString& OutPath);
    static void NormalizeFilename(FString InPath, FString& OutPath);
    static FString ProfilingDir();
    static FString ProjectConfigDir();
    static FString ProjectContentDir();
    static FString ProjectDir();
    static FString ProjectIntermediateDir();
    static FString ProjectLogDir();
    static FString ProjectModsDir();
    static FString ProjectPersistentDownloadDir();
    static FString ProjectPluginsDir();
    static FString ProjectSavedDir();
    static FString ProjectUserDir();
    static void RemoveDuplicateSlashes(FString InPath, FString& OutPath);
    static FString RootDir();
    static FString SandboxesDir();
    static FString ScreenShotDir();
    static FString SetExtension(FString InPath, FString InNewExtension);
    static void SetProjectFilePath(FString NewGameProjectFilePath);
    static FString ShaderWorkingDir();
    static bool ShouldSaveToUserDir();
    static FString SourceConfigDir();
    static void Split(FString InPath, FString& PathPart, FString& FilenamePart, FString& ExtensionPart);
    static void ValidatePath(FString InPath, bool& bDidSucceed, FText& OutReason);
    static FString VideoCaptureDir();
};

// Size: 0x30
class UBlueprintPlatformLibrary : public UBlueprintFunctionLibrary {

    static void CancelLocalNotification(FString ActivationEvent);
    static void CancelLocalNotificationById(int32_t NotificationId);
    static void ClearAllLocalNotifications();
    static uint8_t GetDeviceOrientation();
    static void GetLaunchNotification(bool& NotificationLaunchedApp, FString& ActivationEvent, int32_t& FireDate);
    static int32_t ScheduleLocalNotificationAtTime(const FDateTime& FireDateTime, bool LocalTime, const FText& Title, const FText& Body, const FText& Action, FString ActivationEvent);
    static int32_t ScheduleLocalNotificationBadgeAtTime(const FDateTime& FireDateTime, bool LocalTime, FString ActivationEvent);
    static void ScheduleLocalNotificationBadgeFromNow(int32_t inSecondsFromNow, FString ActivationEvent);
    static int32_t ScheduleLocalNotificationFromNow(int32_t inSecondsFromNow, const FText& Title, const FText& Body, const FText& Action, FString ActivationEvent);
};

// Size: 0x30
class UBlueprintSetLibrary : public UBlueprintFunctionLibrary {

    static void SetSetPropertyByName(UObject* Object, FName PropertyName, const TSet<int32_t>& Value);
    static void Set_Add(const TSet<int32_t>& TargetSet, const int32_t& NewItem);
    static void Set_AddItems(const TSet<int32_t>& TargetSet, const TArray<int32_t>& NewItems);
    static void Set_Clear(const TSet<int32_t>& TargetSet);
    static bool Set_Contains(const TSet<int32_t>& TargetSet, const int32_t& ItemToFind);
    static void Set_Difference(const TSet<int32_t>& A, const TSet<int32_t>& B, TSet<int32_t>& Result);
    static void Set_Intersection(const TSet<int32_t>& A, const TSet<int32_t>& B, TSet<int32_t>& Result);
    static int32_t Set_Length(const TSet<int32_t>& TargetSet);
    static bool Set_Remove(const TSet<int32_t>& TargetSet, const int32_t& Item);
    static void Set_RemoveItems(const TSet<int32_t>& TargetSet, const TArray<int32_t>& Items);
    static void Set_ToArray(const TSet<int32_t>& A, TArray<int32_t>& Result);
    static void Set_Union(const TSet<int32_t>& A, const TSet<int32_t>& B, TSet<int32_t>& Result);
};

// Size: 0x190
struct FBodyInstance : public FBodyInstanceCore {
    /* 0x001e */ uint8_t ObjectType;
    /* 0x0020 */ uint8_t CollisionEnabled;
    /* 0x0059 */ ESleepFamily SleepFamily;
    /* 0x005a */ uint8_t DOFMode;
    /* 0x005b */ bool bUseCCD;
    /* 0x005b */ bool bIgnoreAnalyticCollisions;
    /* 0x005b */ bool bNotifyRigidBodyCollision;
    /* 0x005b */ bool bLockTranslation;
    /* 0x005b */ bool bLockRotation;
    /* 0x005b */ bool bLockXTranslation;
    /* 0x005b */ bool bLockYTranslation;
    /* 0x005c */ bool bLockZTranslation;
    /* 0x005c */ bool bLockXRotation;
    /* 0x005c */ bool bLockYRotation;
    /* 0x005c */ bool bLockZRotation;
    /* 0x005c */ bool bOverrideMaxAngularVelocity;
    /* 0x005c */ bool bOverrideMaxDepenetrationVelocity;
    /* 0x005d */ bool bOverrideWalkableSlopeOnInstance;
    /* 0x005d */ bool bInterpolateWhenSubStepping;
    /* 0x006c */ FCollisionResponseContainer ResponseToChannels;
    /* 0x008c */ FName CollisionProfileName;
    /* 0x0098 */ uint8_t PositionSolverIterationCount;
    /* 0x0099 */ uint8_t VelocitySolverIterationCount;
    /* 0x00a0 */ FCollisionResponse CollisionResponses;
    /* 0x00d0 */ float MaxDepenetrationVelocity;
    /* 0x00d4 */ float MassInKgOverride;
    /* 0x00e0 */ float LinearDamping;
    /* 0x00e4 */ float AngularDamping;
    /* 0x00e8 */ FVector CustomDOFPlaneNormal;
    /* 0x00f4 */ FVector COMNudge;
    /* 0x0100 */ float MassScale;
    /* 0x0104 */ FVector InertiaTensorScale;
    /* 0x0120 */ FWalkableSlopeOverride WalkableSlopeOverride;
    /* 0x0130 */ UPhysicalMaterial* PhysMaterialOverride;
    /* 0x0138 */ float MaxAngularVelocity;
    /* 0x013c */ float CustomSleepThresholdMultiplier;
    /* 0x0140 */ float StabilizationThresholdMultiplier;
    /* 0x0144 */ float PhysicsBlendWeight;
};

// Size: 0x300
class UBodySetup : public UBodySetupCore {
    /* 0x0050 */ FKAggregateGeom AggGeom;
    /* 0x00a8 */ bool bAlwaysFullAnimWeight;
    /* 0x00a8 */ bool bConsiderForBounds;
    /* 0x00a8 */ bool bMeshCollideAll;
    /* 0x00a8 */ bool bDoubleSidedGeometry;
    /* 0x00a8 */ bool bGenerateNonMirroredCollision;
    /* 0x00a8 */ bool bSharedCookedData;
    /* 0x00a8 */ bool bGenerateMirroredCollision;
    /* 0x00a8 */ bool bSupportUVsAndFaceRemap;
    /* 0x00b0 */ UPhysicalMaterial* PhysMaterial;
    /* 0x00b8 */ FWalkableSlopeOverride WalkableSlopeOverride;
    /* 0x00c8 */ float BuildScale;
    /* 0x0150 */ FBodyInstance DefaultInstance;
    /* 0x02e8 */ FVector BuildScale3D;
};

// Size: 0x10
struct FBoneFilter {
    /* 0x0000 */ bool bExcludeSelf;
    /* 0x0004 */ FName BoneName;
};

// Size: 0x40
class UBoneMaskFilter : public UObject {
    /* 0x0030 */ TArray<FInputBlendPose> BlendPoses;
};

// Size: 0x1c
struct FBoneMirrorExport {
    /* 0x0000 */ FName BoneName;
    /* 0x000c */ FName SourceBoneName;
    /* 0x0018 */ uint8_t BoneFlipAxis;
};

// Size: 0x8
struct FBoneMirrorInfo {
    /* 0x0000 */ int32_t SourceIndex;
    /* 0x0004 */ uint8_t BoneFlipAxis;
};

// Size: 0x14
struct FBoneNode {
    /* 0x0000 */ FName Name;
    /* 0x000c */ int32_t ParentIndex;
    /* 0x0010 */ uint8_t TranslationRetargetingMode;
};

// Size: 0x10
struct FBoneReductionSetting {
    /* 0x0000 */ TArray<FName> BonesToRemove;
};

// Size: 0x14
struct FBoneReference {
    /* 0x0000 */ FName BoneName;
};

// Size: 0x30
class IBoneReferenceSkeletonProvider : public UInterface {
};

// Size: 0x58
class UBookMark : public UBookmarkBase {
    /* 0x0030 */ FVector Location;
    /* 0x003c */ FRotator Rotation;
    /* 0x0048 */ TArray<FString> HiddenLevels;
};

// Size: 0x40
class UBookMark2D : public UBookmarkBase {
    /* 0x0030 */ float Zoom2D;
    /* 0x0034 */ FIntPoint Location;
};

// Size: 0x1
struct FBookmark2DJumpToSettings {
};

// Size: 0x30
class UBookmarkBase : public UObject {
};

// Size: 0x1
struct FBookmarkBaseJumpToSettings {
};

// Size: 0x1
struct FBookmarkJumpToSettings : public FBookmarkBaseJumpToSettings {
};

// Size: 0x8
struct FBoolTrackKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ bool Value;
};

// Size: 0x140
class UBoundsCopyComponent : public UActorComponent {
    /* 0x00c0 */ TSoftObjectPtr<AActor> BoundsSourceActor;
    /* 0x00f0 */ bool bUseCollidingComponentsForSourceBounds;
    /* 0x00f1 */ bool bKeepOwnBoundsScale;
    /* 0x00f2 */ bool bUseCollidingComponentsForOwnBounds;
    /* 0x0100 */ FTransform PostTransform;
    /* 0x0130 */ bool bCopyXBounds;
    /* 0x0131 */ bool bCopyYBounds;
    /* 0x0132 */ bool bCopyZBounds;

    void SetRotation();
    void SetTransformToBounds();
};

// Size: 0x500
class UBoxComponent : public UShapeComponent {
    /* 0x04f0 */ FVector BoxExtent;
    /* 0x04fc */ float LineThickness;

    FVector GetScaledBoxExtent() const;
    FVector GetUnscaledBoxExtent() const;
    void SetBoxExtent(FVector InBoxExtent, bool bUpdateOverlaps);
};

// Size: 0x310
class ABoxReflectionCapture : public AReflectionCapture {
};

// Size: 0x2c0
class UBoxReflectionCaptureComponent : public UReflectionCaptureComponent {
    /* 0x02a0 */ float BoxTransitionDistance;
    /* 0x02a8 */ UBoxComponent* PreviewInfluenceBox;
    /* 0x02b0 */ UBoxComponent* PreviewCaptureBox;
};

// Size: 0x10
struct FBranchFilter {
    /* 0x0000 */ FName BoneName;
    /* 0x000c */ int32_t BlendDepth;
};

// Size: 0x48
struct FBranchingPoint : public FAnimLinkableElement {
    /* 0x0030 */ FName EventName;
    /* 0x003c */ float DisplayTime;
    /* 0x0040 */ float TriggerTimeOffset;
};

// Size: 0xc
struct FBranchingPointMarker {
    /* 0x0000 */ int32_t NotifyIndex;
    /* 0x0004 */ float TriggerTime;
    /* 0x0008 */ uint8_t NotifyEventType;
};

// Size: 0x20
struct FBranchingPointNotifyPayload {
};

// Size: 0x48
class UBreakpoint : public UObject {
    /* 0x0030 */ bool bEnabled;
    /* 0x0038 */ UEdGraphNode* Node;
    /* 0x0040 */ bool bStepOnce;
    /* 0x0040 */ bool bStepOnce_WasPreviouslyDisabled;
    /* 0x0040 */ bool bStepOnce_RemoveAfterHit;
};

// Size: 0x40
struct FBroadphaseSettings {
    /* 0x0000 */ bool bUseMBPOnClient;
    /* 0x0001 */ bool bUseMBPOnServer;
    /* 0x0002 */ bool bUseMBPOuterBounds;
    /* 0x0004 */ FBox MBPBounds;
    /* 0x0020 */ FBox MBPOuterBounds;
    /* 0x003c */ uint32_t MBPNumSubdivs;
};

// Size: 0x338
class ABrush : public AActor {
    /* 0x02f8 */ uint8_t BrushType;
    /* 0x02fc */ FColor BrushColor;
    /* 0x0300 */ int32_t PolyFlags;
    /* 0x0304 */ bool bColored;
    /* 0x0304 */ bool bSolidWhenSelected;
    /* 0x0304 */ bool bPlaceableFromClassBrowser;
    /* 0x0304 */ bool bNotForClientOrServer;
    /* 0x0308 */ UModel* Brush;
    /* 0x0310 */ UBrushComponent* BrushComponent;
    /* 0x0318 */ UBrushBuilder* BrushBuilder;
    /* 0x0320 */ bool bInManipulation;
    /* 0x0328 */ TArray<FGeomSelection> SavedSelections;
};

// Size: 0x88
class UBrushBuilder : public UObject {
    /* 0x0030 */ FString BitmapFilename;
    /* 0x0040 */ FString Tooltip;
    /* 0x0050 */ bool NotifyBadParams;
    /* 0x0058 */ TArray<FVector> Vertices;
    /* 0x0068 */ TArray<FBuilderPoly> Polys;
    /* 0x0078 */ FName Layer;
    /* 0x0084 */ bool MergeCoplanars;
};

// Size: 0x500
class UBrushComponent : public UPrimitiveComponent {
    /* 0x04d8 */ UModel* Brush;
    /* 0x04e0 */ UBodySetup* BrushBodySetup;
    /* 0x04e8 */ FVector PrePivot;
};

// Size: 0x338
class ABrushShape : public ABrush {
};

// Size: 0x150
struct FBuildPromotionImportWorkflowSettings {
    /* 0x0000 */ FEditorImportWorkflowDefinition Diffuse;
    /* 0x0020 */ FEditorImportWorkflowDefinition Normal;
    /* 0x0040 */ FEditorImportWorkflowDefinition StaticMesh;
    /* 0x0060 */ FEditorImportWorkflowDefinition ReimportStaticMesh;
    /* 0x0080 */ FEditorImportWorkflowDefinition BlendShapeMesh;
    /* 0x00a0 */ FEditorImportWorkflowDefinition MorphMesh;
    /* 0x00c0 */ FEditorImportWorkflowDefinition SkeletalMesh;
    /* 0x00e0 */ FEditorImportWorkflowDefinition Animation;
    /* 0x0100 */ FEditorImportWorkflowDefinition Sound;
    /* 0x0120 */ FEditorImportWorkflowDefinition SurroundSound;
    /* 0x0140 */ TArray<FEditorImportWorkflowDefinition> OtherAssetsToImport;
};

// Size: 0x20
struct FBuildPromotionNewProjectSettings {
    /* 0x0000 */ FDirectoryPath NewProjectFolderOverride;
    /* 0x0010 */ FString NewProjectNameOverride;
};

// Size: 0x60
struct FBuildPromotionOpenAssetSettings {
    /* 0x0000 */ FFilePath BlueprintAsset;
    /* 0x0010 */ FFilePath MaterialAsset;
    /* 0x0020 */ FFilePath ParticleSystemAsset;
    /* 0x0030 */ FFilePath SkeletalMeshAsset;
    /* 0x0040 */ FFilePath StaticMeshAsset;
    /* 0x0050 */ FFilePath TextureAsset;
};

// Size: 0x1f0
struct FBuildPromotionTestSettings {
    /* 0x0000 */ FFilePath DefaultStaticMeshAsset;
    /* 0x0010 */ FBuildPromotionImportWorkflowSettings ImportWorkflow;
    /* 0x0160 */ FBuildPromotionOpenAssetSettings OpenAssets;
    /* 0x01c0 */ FBuildPromotionNewProjectSettings NewProjectSettings;
    /* 0x01e0 */ FFilePath SourceControlMaterial;
};

// Size: 0x28
struct FBuilderPoly {
    /* 0x0000 */ TArray<int32_t> VertexIndices;
    /* 0x0010 */ int32_t Direction;
    /* 0x0014 */ FName ItemName;
    /* 0x0020 */ int32_t PolyFlags;
};

// Size: 0x330
class UButtonStyleAsset : public UObject {
    /* 0x0030 */ FButtonStyle ButtonStyle;
};

// Size: 0x20
struct FCachedAnimAssetPlayerData {
    /* 0x0000 */ FName StateMachineName;
    /* 0x000c */ FName StateName;
};

// Size: 0x24
struct FCachedAnimRelevancyData {
    /* 0x0000 */ FName StateMachineName;
    /* 0x000c */ FName StateName;
};

// Size: 0x18
struct FCachedAnimStateArray {
    /* 0x0000 */ TArray<FCachedAnimStateData> States;
};

// Size: 0x24
struct FCachedAnimStateData {
    /* 0x0000 */ FName StateMachineName;
    /* 0x000c */ FName StateName;
};

// Size: 0x30
struct FCachedAnimTransitionData {
    /* 0x0000 */ FName StateMachineName;
    /* 0x000c */ FName FromStateName;
    /* 0x0018 */ FName ToStateName;
};

// Size: 0x70
struct FCachedKeyToActionInfo {
    /* 0x0000 */ UPlayerInput* PlayerInput;
};

// Size: 0x10
struct FCachedPoseIndices {
    /* 0x0000 */ TArray<int32_t> OrderedSavedPoseNodeIndices;
};

// Size: 0x8c0
class ACameraActor : public AActor {
    /* 0x02f8 */ uint8_t AutoActivateForPlayer;
    /* 0x0300 */ UCameraComponent* CameraComponent;
    /* 0x0308 */ USceneComponent* SceneComponent;
    /* 0x0318 */ bool bConstrainAspectRatio;
    /* 0x031c */ float AspectRatio;
    /* 0x0320 */ float FOVAngle;
    /* 0x0324 */ float PostProcessBlendWeight;
    /* 0x0330 */ FPostProcessSettings PostProcessSettings;

    int32_t GetAutoActivatePlayerIndex() const;
};

// Size: 0x610
class UCameraAnim : public UObject {
    /* 0x0030 */ UInterpGroup* CameraInterpGroup;
    /* 0x0038 */ UInterpGroup* PreviewInterpGroup;
    /* 0x0040 */ float AnimLength;
    /* 0x0044 */ FBox BoundingBox;
    /* 0x0060 */ bool bRelativeToInitialTransform;
    /* 0x0060 */ bool bRelativeToInitialFOV;
    /* 0x0064 */ float BaseFOV;
    /* 0x0070 */ FPostProcessSettings BasePostProcessSettings;
    /* 0x0600 */ float BasePostProcessBlendWeight;
};

// Size: 0x120
class UCameraAnimInst : public UObject {
    /* 0x0030 */ UCameraAnim* CamAnim;
    /* 0x0038 */ UInterpGroupInst* InterpGroupInst;
    /* 0x0058 */ float PlayRate;
    /* 0x0070 */ UInterpTrackMove* MoveTrack;
    /* 0x0078 */ UInterpTrackInstMove* MoveInst;
    /* 0x0080 */ ECameraShakePlaySpace PlaySpace;

    void SetDuration(float NewDuration);
    void SetScale(float NewDuration);
    void Stop(bool bImmediate);
};

// Size: 0x338
class ACameraBlockingVolume : public AVolume {
};

// Size: 0x630
struct FCameraCacheEntry {
    /* 0x0000 */ float Timestamp;
    /* 0x0010 */ FMinimalViewInfo POV;
};

// Size: 0x860
class UCameraComponent : public USceneComponent {
    /* 0x0228 */ float FieldOfView;
    /* 0x022c */ float OrthoWidth;
    /* 0x0230 */ float OrthoNearClipPlane;
    /* 0x0234 */ float OrthoFarClipPlane;
    /* 0x0238 */ float AspectRatio;
    /* 0x023c */ bool bConstrainAspectRatio;
    /* 0x023c */ bool bUseFieldOfViewForLOD;
    /* 0x023c */ bool bCameraMeshHiddenInGame;
    /* 0x023c */ bool bLockToHmd;
    /* 0x023c */ bool bUsePawnControlRotation;
    /* 0x023d */ uint8_t ProjectionMode;
    /* 0x0248 */ UStaticMesh* CameraMesh;
    /* 0x0290 */ float PostProcessBlendWeight;
    /* 0x02c0 */ FPostProcessSettings PostProcessSettings;
    /* 0x0850 */ bool bUseControllerViewRotation;

    void AddOrUpdateBlendable(TScriptInterface<IBlendableInterface> InBlendableObject, float InWeight);
    void GetCameraView(float DeltaTime, FMinimalViewInfo& DesiredView);
    FText GetFilmbackText() const;
    void OnCameraMeshHiddenChanged();
    void RemoveBlendable(TScriptInterface<IBlendableInterface> InBlendableObject);
    void SetAspectRatio(float InAspectRatio);
    void SetConstraintAspectRatio(bool bInConstrainAspectRatio);
    void SetFieldOfView(float InFieldOfView);
    void SetOrthoFarClipPlane(float InOrthoFarClipPlane);
    void SetOrthoNearClipPlane(float InOrthoNearClipPlane);
    void SetOrthoWidth(float InOrthoWidth);
    void SetPostProcessBlendWeight(float InPostProcessBlendWeight);
    void SetProjectionMode(uint8_t InProjectionMode);
    void SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD);
};

// Size: 0x10
struct FCameraCutInfo {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ float Timestamp;
};

// Size: 0x40
struct FCameraExposureSettings {
    /* 0x0000 */ uint8_t Method;
    /* 0x0004 */ float LowPercent;
    /* 0x0008 */ float HighPercent;
    /* 0x000c */ float MinBrightness;
    /* 0x0010 */ float MaxBrightness;
    /* 0x0014 */ float SpeedUp;
    /* 0x0018 */ float SpeedDown;
    /* 0x001c */ float Bias;
    /* 0x0020 */ UCurveFloat* BiasCurve;
    /* 0x0028 */ UTexture* MeterMask;
    /* 0x0030 */ float HistogramLogMin;
    /* 0x0034 */ float HistogramLogMax;
    /* 0x0038 */ float CalibrationConstant;
    /* 0x003c */ bool ApplyPhysicalCameraExposure;
};

// Size: 0x50
class UCameraModifier : public UObject {
    /* 0x0030 */ bool bDebug;
    /* 0x0030 */ bool bExclusive;
    /* 0x0034 */ uint8_t Priority;
    /* 0x0038 */ APlayerCameraManager* CameraOwner;
    /* 0x0040 */ float AlphaInTime;
    /* 0x0044 */ float AlphaOutTime;
    /* 0x0048 */ float Alpha;

    void BlueprintModifyCamera(float DeltaTime, FVector ViewLocation, FRotator ViewRotation, float FOV, FVector& NewViewLocation, FRotator& NewViewRotation, float& NewFOV);
    void BlueprintModifyPostProcess(float DeltaTime, float& PostProcessBlendWeight, FPostProcessSettings& PostProcessSettings);
    void DisableModifier(bool bImmediate);
    void EnableModifier();
    AActor* GetViewTarget() const;
    bool IsDisabled() const;
};

// Size: 0xb8
class UCameraModifier_CameraShake : public UCameraModifier {
    /* 0x0050 */ TArray<FActiveCameraShakeInfo> ActiveShakes;
    /* 0x0060 */ TMap<UClass*, FPooledCameraShakes> ExpiredPooledShakesMap;
    /* 0x00b0 */ float SplitScreenShakeScale;
};

// Size: 0x30
struct FCameraPreviewInfo {
    /* 0x0000 */ UClass* PawnClass;
    /* 0x0008 */ UAnimSequence* AnimSeq;
    /* 0x0010 */ FVector Location;
    /* 0x001c */ FRotator Rotation;
    /* 0x0028 */ APawn* PawnInst;
};

// Size: 0xb0
class UCameraShakeBase : public UObject {
    /* 0x0030 */ bool bSingleInstance;
    /* 0x0034 */ float ShakeScale;
    /* 0x0038 */ UCameraShakePattern* RootShakePattern;
    /* 0x0040 */ APlayerCameraManager* CameraManager;

    UCameraShakePattern* GetRootShakePattern() const;
    void SetRootShakePattern(UCameraShakePattern* InPattern);
};

// Size: 0x8
struct FCameraShakeDuration {
    /* 0x0000 */ float Duration;
    /* 0x0004 */ ECameraShakeDurationType Type;
};

// Size: 0x10
struct FCameraShakeInfo {
    /* 0x0000 */ FCameraShakeDuration Duration;
    /* 0x0008 */ float BlendIn;
    /* 0x000c */ float BlendOut;
};

// Size: 0x30
class UCameraShakePattern : public UObject {
};

// Size: 0x630
struct FCameraShakeScrubParams {
    /* 0x0000 */ float AbsoluteTime;
    /* 0x0004 */ float ShakeScale;
    /* 0x0008 */ float DynamicScale;
    /* 0x000c */ float BlendingWeight;
    /* 0x0010 */ FMinimalViewInfo POV;
};

// Size: 0x300
class ACameraShakeSourceActor : public AActor {
    /* 0x02f8 */ UCameraShakeSourceComponent* CameraShakeSourceComponent;
};

// Size: 0x260
class UCameraShakeSourceComponent : public USceneComponent {
    /* 0x0230 */ ECameraShakeAttenuation Attenuation;
    /* 0x0234 */ float InnerAttenuationRadius;
    /* 0x0238 */ float OuterAttenuationRadius;
    /* 0x0240 */ UClass* CameraShake;
    /* 0x0248 */ bool bAutoStart;
    /* 0x0250 */ UTexture2D* EditorSpriteTexture;
    /* 0x0258 */ float EditorSpriteTextureScale;

    float GetAttenuationFactor(const FVector& Location) const;
    void Start();
    void StartCameraShake(UClass* InCameraShake, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void StopAllCameraShakes(bool bImmediately);
    void StopAllCameraShakesOfType(UClass* InCameraShake, bool bImmediately);
};

// Size: 0x1
struct FCameraShakeStartParams {
    /* 0x0000 */ bool bIsRestarting;
};

// Size: 0x1
struct FCameraShakeStopParams {
    /* 0x0000 */ bool bImmediately;
};

// Size: 0x630
struct FCameraShakeUpdateParams {
    /* 0x0000 */ float DeltaTime;
    /* 0x0004 */ float ShakeScale;
    /* 0x0008 */ float DynamicScale;
    /* 0x000c */ float BlendingWeight;
    /* 0x0010 */ FMinimalViewInfo POV;
};

// Size: 0x5c0
struct FCameraShakeUpdateResult {
};

// Size: 0x2e0
class UCanvas : public UObject {
    /* 0x0030 */ float OrgX;
    /* 0x0034 */ float OrgY;
    /* 0x0038 */ float ClipX;
    /* 0x003c */ float ClipY;
    /* 0x0040 */ FColor DrawColor;
    /* 0x0044 */ bool bCenterX;
    /* 0x0044 */ bool bCenterY;
    /* 0x0044 */ bool bNoSmooth;
    /* 0x0048 */ int32_t SizeX;
    /* 0x004c */ int32_t SizeY;
    /* 0x0050 */ FPlane ColorModulate;
    /* 0x0060 */ UTexture2D* DefaultTexture;
    /* 0x0068 */ UTexture2D* GradientTexture0;
    /* 0x0070 */ UReporterGraph* ReporterGraph;

    void K2_Deproject(FVector2D ScreenPosition, FVector& WorldOrigin, FVector& WorldDirection);
    void K2_DrawBorder(UTexture* BorderTexture, UTexture* BackgroundTexture, UTexture* LeftBorderTexture, UTexture* RightBorderTexture, UTexture* TopBorderTexture, UTexture* BottomBorderTexture, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, FLinearColor RenderColor, FVector2D BorderScale, FVector2D BackgroundScale, float Rotation, FVector2D PivotPoint, FVector2D CornerSize);
    void K2_DrawBox(FVector2D ScreenPosition, FVector2D ScreenSize, float Thickness, FLinearColor RenderColor);
    void K2_DrawLine(FVector2D ScreenPositionA, FVector2D ScreenPositionB, float Thickness, FLinearColor RenderColor);
    void K2_DrawMaterial(UMaterialInterface* RenderMaterial, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, float Rotation, FVector2D PivotPoint);
    void K2_DrawMaterialTriangle(UMaterialInterface* RenderMaterial, TArray<FCanvasUVTri> Triangles);
    void K2_DrawPolygon(UTexture* RenderTexture, FVector2D ScreenPosition, FVector2D Radius, int32_t NumberOfSides, FLinearColor RenderColor);
    void K2_DrawText(UFont* RenderFont, FString RenderText, FVector2D ScreenPosition, FVector2D Scale, FLinearColor RenderColor, float Kerning, FLinearColor ShadowColor, FVector2D ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, FLinearColor OutlineColor);
    void K2_DrawTexture(UTexture* RenderTexture, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, FLinearColor RenderColor, uint8_t BlendMode, float Rotation, FVector2D PivotPoint);
    void K2_DrawTriangle(UTexture* RenderTexture, TArray<FCanvasUVTri> Triangles);
    FVector K2_Project(FVector WorldLocation);
    FVector2D K2_StrLen(UFont* RenderFont, FString RenderText);
    FVector2D K2_TextSize(UFont* RenderFont, FString RenderText, FVector2D Scale);
};

// Size: 0x18
struct FCanvasIcon {
    /* 0x0000 */ UTexture* Texture;
    /* 0x0008 */ float U;
    /* 0x000c */ float V;
    /* 0x0010 */ float UL;
    /* 0x0014 */ float VL;
};

// Size: 0x3f0
class UCanvasRenderTarget2D : public UTextureRenderTarget2D {
    /* 0x03c8 */ FMulticastInlineDelegate OnCanvasRenderTargetUpdate;
    /* 0x03d8 */ TWeakObjectPtr<UWorld> World;
    /* 0x03e0 */ bool bShouldClearRenderTargetOnReceiveUpdate;

    static UCanvasRenderTarget2D* CreateCanvasRenderTarget2D(UObject* WorldContextObject, UClass* CanvasRenderTarget2DClass, int32_t Width, int32_t Height);
    void GetSize(int32_t& Width, int32_t& Height);
    void ReceiveUpdate(UCanvas* Canvas, int32_t Width, int32_t Height);
    void UpdateResource();
};

// Size: 0x60
struct FCanvasUVTri {
    /* 0x0000 */ FVector2D V0_Pos;
    /* 0x0008 */ FVector2D V0_UV;
    /* 0x0010 */ FLinearColor V0_Color;
    /* 0x0020 */ FVector2D V1_Pos;
    /* 0x0028 */ FVector2D V1_UV;
    /* 0x0030 */ FLinearColor V1_Color;
    /* 0x0040 */ FVector2D V2_Pos;
    /* 0x0048 */ FVector2D V2_UV;
    /* 0x0050 */ FLinearColor V2_Color;
};

// Size: 0x500
class UCapsuleComponent : public UShapeComponent {
    /* 0x04f0 */ float CapsuleHalfHeight;
    /* 0x04f4 */ float CapsuleRadius;
    /* 0x04f8 */ float CapsuleHeight;

    float GetScaledCapsuleHalfHeight() const;
    float GetScaledCapsuleHalfHeight_WithoutHemisphere() const;
    float GetScaledCapsuleRadius() const;
    void GetScaledCapsuleSize(float& OutRadius, float& OutHalfHeight) const;
    void GetScaledCapsuleSize_WithoutHemisphere(float& OutRadius, float& OutHalfHeightWithoutHemisphere) const;
    float GetShapeScale() const;
    float GetUnscaledCapsuleHalfHeight() const;
    float GetUnscaledCapsuleHalfHeight_WithoutHemisphere() const;
    float GetUnscaledCapsuleRadius() const;
    void GetUnscaledCapsuleSize(float& OutRadius, float& OutHalfHeight) const;
    void GetUnscaledCapsuleSize_WithoutHemisphere(float& OutRadius, float& OutHalfHeightWithoutHemisphere) const;
    void SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps);
    void SetCapsuleRadius(float Radius, bool bUpdateOverlaps);
    void SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps);
};

// Size: 0x78
class UChannel : public UObject {
    /* 0x0030 */ UNetConnection* Connection;
};

// Size: 0x30
struct FChannelDefinition {
    /* 0x0000 */ FName ChannelName;
    /* 0x000c */ FName ClassName;
    /* 0x0018 */ UClass* ChannelClass;
    /* 0x0020 */ int32_t StaticChannelIndex;
    /* 0x0024 */ bool bTickOnCreate;
    /* 0x0025 */ bool bServerOpen;
    /* 0x0026 */ bool bClientOpen;
    /* 0x0027 */ bool bInitialServer;
    /* 0x0028 */ bool bInitialClient;
};

// Size: 0x3
struct FChaosPhysicsSettings {
    /* 0x0000 */ EChaosThreadingMode DefaultThreadingModel;
    /* 0x0001 */ EChaosSolverTickMode DedicatedThreadTickMode;
    /* 0x0002 */ EChaosBufferMode DedicatedThreadBufferMode;
};

// Size: 0x5a0
class ACharacter : public APawn {
    /* 0x0358 */ USkeletalMeshComponent* Mesh;
    /* 0x0360 */ UCharacterMovementComponent* CharacterMovement;
    /* 0x0368 */ UCapsuleComponent* CapsuleComponent;
    /* 0x0370 */ UArrowComponent* ArrowComponent;
    /* 0x0378 */ FBasedMovementInfo BasedMovement;
    /* 0x03a8 */ FBasedMovementInfo ReplicatedBasedMovement;
    /* 0x03d8 */ float AnimRootMotionTranslationScale;
    /* 0x03dc */ FVector BaseTranslationOffset;
    /* 0x03f0 */ FQuat BaseRotationOffset;
    /* 0x0400 */ float ReplicatedServerLastTransformUpdateTimeStamp;
    /* 0x0404 */ float ReplayLastTransformUpdateTimeStamp;
    /* 0x0408 */ uint8_t ReplicatedMovementMode;
    /* 0x0409 */ bool bInBaseReplication;
    /* 0x040c */ float CrouchedEyeHeight;
    /* 0x0410 */ bool bIsCrouched;
    /* 0x0410 */ bool bProxyIsJumpForceApplied;
    /* 0x0410 */ bool bPressedJump;
    /* 0x0410 */ bool bClientUpdating;
    /* 0x0410 */ bool bClientWasFalling;
    /* 0x0410 */ bool bClientResimulateRootMotion;
    /* 0x0410 */ bool bClientResimulateRootMotionSources;
    /* 0x0410 */ bool bSimGravityDisabled;
    /* 0x0411 */ bool bClientCheckEncroachmentOnNetUpdate;
    /* 0x0411 */ bool bServerMoveIgnoreRootMotion;
    /* 0x0411 */ bool bWasJumping;
    /* 0x0414 */ float JumpKeyHoldTime;
    /* 0x0418 */ float JumpForceTimeRemaining;
    /* 0x041c */ float ProxyJumpForceStartedTime;
    /* 0x0420 */ float JumpMaxHoldTime;
    /* 0x0424 */ int32_t JumpMaxCount;
    /* 0x0428 */ int32_t JumpCurrentCount;
    /* 0x042c */ int32_t JumpCurrentCountPreJump;
    /* 0x0438 */ FMulticastInlineDelegate OnReachedJumpApex;
    /* 0x0458 */ FMulticastInlineDelegate MovementModeChangedDelegate;
    /* 0x0468 */ FMulticastInlineDelegate OnCharacterMovementUpdated;
    /* 0x0478 */ FRootMotionSourceGroup SavedRootMotion;
    /* 0x04b0 */ FRootMotionMovementParams ClientRootMotionParams;
    /* 0x04f0 */ TArray<FSimulatedRootMotionReplicatedMove> RootMotionRepMoves;
    /* 0x0500 */ FRepRootMotionMontage RepRootMotion;

    void CacheInitialMeshOffset(FVector MeshRelativeLocation, FRotator MeshRelativeRotation);
    bool CanCrouch() const;
    bool CanJump() const;
    bool CanJumpInternal() const;
    void ClientAckGoodMove(float Timestamp);
    void ClientAdjustPosition(float Timestamp, FVector NewLoc, FVector NewVel, UPrimitiveComponent* NewBase, FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8_t ServerMovementMode);
    void ClientAdjustRootMotionPosition(float Timestamp, float ServerMontageTrackPosition, FVector ServerLoc, FVector_NetQuantizeNormal ServerRotation, float ServerVelZ, UPrimitiveComponent* ServerBase, FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8_t ServerMovementMode);
    void ClientAdjustRootMotionSourcePosition(float Timestamp, FRootMotionSourceGroup ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, FVector ServerLoc, FVector_NetQuantizeNormal ServerRotation, float ServerVelZ, UPrimitiveComponent* ServerBase, FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8_t ServerMovementMode);
    void ClientCheatFly();
    void ClientCheatGhost();
    void ClientCheatWalk();
    void ClientMoveResponsePacked(const FCharacterMoveResponsePackedBits PackedBits);
    void ClientVeryShortAdjustPosition(float Timestamp, FVector NewLoc, UPrimitiveComponent* NewBase, FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8_t ServerMovementMode);
    void Crouch(bool bClientSimulation);
    float GetAnimRootMotionTranslationScale() const;
    FRotator GetBaseRotationOffsetRotator() const;
    FVector GetBaseTranslationOffset() const;
    UAnimMontage* GetCurrentMontage() const;
    bool HasAnyRootMotion() const;
    bool IsJumpProvidingForce() const;
    bool IsPlayingNetworkedRootMotionMontage() const;
    bool IsPlayingRootMotion() const;
    void Jump();
    void K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
    void K2_OnMovementModeChanged(uint8_t PrevMovementMode, uint8_t NewMovementMode, uint8_t PrevCustomMode, uint8_t NewCustomMode);
    void K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
    void K2_UpdateCustomMovement(float DeltaTime);
    void LaunchCharacter(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);
    void OnJumped();
    void OnLanded(const FHitResult& Hit);
    void OnLaunched(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);
    void OnRep_IsCrouched();
    void OnRep_ReplayLastTransformUpdateTimeStamp();
    void OnRep_ReplicatedBasedMovement();
    void OnRep_RootMotion();
    void OnWalkingOffLedge(const FVector& PreviousFloorImpactNormal, const FVector& PreviousFloorContactNormal, const FVector& PreviousLocation, float TimeDelta);
    float PlayAnimMontage(UAnimMontage* AnimMontage, float InPlayRate, FName StartSectionName);
    void RootMotionDebugClientPrintOnScreen(FString inString);
    void ServerMove(float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8_t CompressedMoveFlags, uint8_t ClientRoll, uint32_t View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8_t ClientMovementMode);
    void ServerMoveDual(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8_t PendingFlags, uint32_t View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8_t NewFlags, uint8_t ClientRoll, uint32_t View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8_t ClientMovementMode);
    void ServerMoveDualHybridRootMotion(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8_t PendingFlags, uint32_t View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8_t NewFlags, uint8_t ClientRoll, uint32_t View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8_t ClientMovementMode);
    void ServerMoveDualNoBase(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8_t PendingFlags, uint32_t View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8_t NewFlags, uint8_t ClientRoll, uint32_t View, uint8_t ClientMovementMode);
    void ServerMoveNoBase(float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8_t CompressedMoveFlags, uint8_t ClientRoll, uint32_t View, uint8_t ClientMovementMode);
    void ServerMoveOld(float OldTimeStamp, FVector_NetQuantize10 OldAccel, uint8_t OldMoveFlags);
    void ServerMovePacked(const FCharacterServerMovePackedBits PackedBits);
    void StopAnimMontage(UAnimMontage* AnimMontage);
    void StopJumping();
    void UnCrouch(bool bClientSimulation);
};

// Size: 0x98
struct FCharacterMoveResponsePackedBits : public FCharacterNetworkSerializationPackedBits {
};

// Size: 0xb00
class UCharacterMovementComponent : public UPawnMovementComponent {
    /* 0x0160 */ ACharacter* CharacterOwner;
    /* 0x0168 */ float GravityScale;
    /* 0x016c */ float MaxStepHeight;
    /* 0x0170 */ float JumpZVelocity;
    /* 0x0174 */ float JumpOffJumpZFactor;
    /* 0x0178 */ float WalkableFloorAngle;
    /* 0x017c */ float WalkableFloorZ;
    /* 0x0180 */ uint8_t MovementMode;
    /* 0x0181 */ uint8_t CustomMovementMode;
    /* 0x0182 */ ENetworkSmoothingMode NetworkSmoothingMode;
    /* 0x0184 */ float GroundFriction;
    /* 0x01ac */ float MaxWalkSpeed;
    /* 0x01b0 */ float MaxWalkSpeedCrouched;
    /* 0x01b4 */ float MaxSwimSpeed;
    /* 0x01b8 */ float MaxFlySpeed;
    /* 0x01bc */ float MaxCustomMovementSpeed;
    /* 0x01c0 */ float MaxAcceleration;
    /* 0x01c4 */ float MinAnalogWalkSpeed;
    /* 0x01c8 */ float BrakingFrictionFactor;
    /* 0x01cc */ float BrakingFriction;
    /* 0x01d0 */ float BrakingSubStepTime;
    /* 0x01d4 */ float BrakingDecelerationWalking;
    /* 0x01d8 */ float BrakingDecelerationFalling;
    /* 0x01dc */ float BrakingDecelerationSwimming;
    /* 0x01e0 */ float BrakingDecelerationFlying;
    /* 0x01e4 */ float AirControl;
    /* 0x01e8 */ float AirControlBoostMultiplier;
    /* 0x01ec */ float AirControlBoostVelocityThreshold;
    /* 0x01f0 */ float FallingLateralFriction;
    /* 0x01f4 */ float CrouchedHalfHeight;
    /* 0x01f8 */ float Buoyancy;
    /* 0x01fc */ float PerchRadiusThreshold;
    /* 0x0200 */ float PerchAdditionalHeight;
    /* 0x0204 */ FRotator RotationRate;
    /* 0x0210 */ bool bUseSeparateBrakingFriction;
    /* 0x0210 */ bool bApplyGravityWhileJumping;
    /* 0x0210 */ bool bUseControllerDesiredRotation;
    /* 0x0210 */ bool bOrientRotationToMovement;
    /* 0x0210 */ bool bSweepWhileNavWalking;
    /* 0x0210 */ bool bMovementInProgress;
    /* 0x0210 */ bool bEnableScopedMovementUpdates;
    /* 0x0211 */ bool bEnableServerDualMoveScopedMovementUpdates;
    /* 0x0211 */ bool bForceMaxAccel;
    /* 0x0211 */ bool bRunPhysicsWithNoController;
    /* 0x0211 */ bool bForceNextFloorCheck;
    /* 0x0211 */ bool bShrinkProxyCapsule;
    /* 0x0211 */ bool bCanWalkOffLedges;
    /* 0x0211 */ bool bCanWalkOffLedgesWhenCrouching;
    /* 0x0212 */ bool bNetworkSkipProxyPredictionOnNetUpdate;
    /* 0x0212 */ bool bNetworkAlwaysReplicateTransformUpdateTimestamp;
    /* 0x0212 */ bool bDeferUpdateMoveComponent;
    /* 0x0212 */ bool bEnablePhysicsInteraction;
    /* 0x0212 */ bool bTouchForceScaledToMass;
    /* 0x0212 */ bool bPushForceScaledToMass;
    /* 0x0212 */ bool bPushForceUsingZOffset;
    /* 0x0213 */ bool bScalePushForceToVelocity;
    /* 0x0218 */ USceneComponent* DeferredUpdatedMoveComponent;
    /* 0x0220 */ float MaxOutOfWaterStepHeight;
    /* 0x0224 */ float OutofWaterZ;
    /* 0x0228 */ float Mass;
    /* 0x022c */ float StandingDownwardForceScale;
    /* 0x0230 */ float InitialPushForceFactor;
    /* 0x0234 */ float PushForceFactor;
    /* 0x0238 */ float PushForcePointZOffsetFactor;
    /* 0x023c */ float TouchForceFactor;
    /* 0x0240 */ float MinTouchForce;
    /* 0x0244 */ float MaxTouchForce;
    /* 0x0248 */ float RepulsionForce;
    /* 0x024c */ bool bForceBraking;
    /* 0x0250 */ float CrouchedSpeedMultiplier;
    /* 0x0254 */ float UpperImpactNormalScale;
    /* 0x0258 */ FVector Acceleration;
    /* 0x0270 */ FQuat LastUpdateRotation;
    /* 0x0280 */ FVector LastUpdateLocation;
    /* 0x028c */ FVector LastUpdateVelocity;
    /* 0x0298 */ float ServerLastTransformUpdateTimeStamp;
    /* 0x029c */ float ServerLastClientGoodMoveAckTime;
    /* 0x02a0 */ float ServerLastClientAdjustmentTime;
    /* 0x02a4 */ FVector PendingImpulseToApply;
    /* 0x02b0 */ FVector PendingForceToApply;
    /* 0x02bc */ float AnalogInputModifier;
    /* 0x02cc */ float MaxSimulationTimeStep;
    /* 0x02d0 */ int32_t MaxSimulationIterations;
    /* 0x02d4 */ int32_t MaxJumpApexAttemptsPerSimulation;
    /* 0x02d8 */ float MaxDepenetrationWithGeometry;
    /* 0x02dc */ float MaxDepenetrationWithGeometryAsProxy;
    /* 0x02e0 */ float MaxDepenetrationWithPawn;
    /* 0x02e4 */ float MaxDepenetrationWithPawnAsProxy;
    /* 0x02e8 */ float NetworkSimulatedSmoothLocationTime;
    /* 0x02ec */ float NetworkSimulatedSmoothRotationTime;
    /* 0x02f0 */ float ListenServerNetworkSimulatedSmoothLocationTime;
    /* 0x02f4 */ float ListenServerNetworkSimulatedSmoothRotationTime;
    /* 0x02f8 */ float NetProxyShrinkRadius;
    /* 0x02fc */ float NetProxyShrinkHalfHeight;
    /* 0x0300 */ float NetworkMaxSmoothUpdateDistance;
    /* 0x0304 */ float NetworkNoSmoothUpdateDistance;
    /* 0x0308 */ float NetworkMinTimeBetweenClientAckGoodMoves;
    /* 0x030c */ float NetworkMinTimeBetweenClientAdjustments;
    /* 0x0310 */ float NetworkMinTimeBetweenClientAdjustmentsLargeCorrection;
    /* 0x0314 */ float NetworkLargeClientCorrectionDistance;
    /* 0x0318 */ float LedgeCheckThreshold;
    /* 0x031c */ float JumpOutOfWaterPitch;
    /* 0x0320 */ FFindFloorResult CurrentFloor;
    /* 0x03bc */ uint8_t DefaultLandMovementMode;
    /* 0x03bd */ uint8_t DefaultWaterMovementMode;
    /* 0x03be */ uint8_t GroundMovementMode;
    /* 0x03bf */ bool bMaintainHorizontalGroundVelocity;
    /* 0x03bf */ bool bImpartBaseVelocityX;
    /* 0x03bf */ bool bImpartBaseVelocityY;
    /* 0x03bf */ bool bImpartBaseVelocityZ;
    /* 0x03bf */ bool bImpartBaseAngularVelocity;
    /* 0x03bf */ bool bJustTeleported;
    /* 0x03bf */ bool bNetworkUpdateReceived;
    /* 0x03bf */ bool bNetworkMovementModeChanged;
    /* 0x03c0 */ bool bIgnoreClientMovementErrorChecksAndCorrection;
    /* 0x03c0 */ bool bServerAcceptClientAuthoritativePosition;
    /* 0x03c0 */ bool bNotifyApex;
    /* 0x03c0 */ bool bCheatFlying;
    /* 0x03c0 */ bool bWantsToCrouch;
    /* 0x03c0 */ bool bCrouchMaintainsBaseLocation;
    /* 0x03c0 */ bool bIgnoreBaseRotation;
    /* 0x03c0 */ bool bFastAttachedMove;
    /* 0x03c1 */ bool bAlwaysCheckFloor;
    /* 0x03c1 */ bool bUseFlatBaseForFloorChecks;
    /* 0x03c1 */ bool bPerformingJumpOff;
    /* 0x03c1 */ bool bWantsToLeaveNavWalking;
    /* 0x03c1 */ bool bUseRVOAvoidance;
    /* 0x03c1 */ bool bRequestedMoveUseAcceleration;
    /* 0x03c1 */ bool bWasSimulatingRootMotion;
    /* 0x03c2 */ bool bAllowPhysicsRotationDuringAnimRootMotion;
    /* 0x03c2 */ bool bHasRequestedVelocity;
    /* 0x03c2 */ bool bRequestedMoveWithMaxSpeed;
    /* 0x03c2 */ bool bWasAvoidanceUpdated;
    /* 0x03c2 */ bool bProjectNavMeshWalking;
    /* 0x03c2 */ bool bProjectNavMeshOnBothWorldChannels;
    /* 0x03d4 */ float AvoidanceConsiderationRadius;
    /* 0x03d8 */ FVector RequestedVelocity;
    /* 0x03e4 */ int32_t AvoidanceUID;
    /* 0x03e8 */ FNavAvoidanceMask AvoidanceGroup;
    /* 0x03ec */ FNavAvoidanceMask GroupsToAvoid;
    /* 0x03f0 */ FNavAvoidanceMask GroupsToIgnore;
    /* 0x03f4 */ float AvoidanceWeight;
    /* 0x03f8 */ FVector PendingLaunchVelocity;
    /* 0x04b0 */ float NavMeshProjectionInterval;
    /* 0x04b4 */ float NavMeshProjectionTimer;
    /* 0x04b8 */ float NavMeshProjectionInterpSpeed;
    /* 0x04bc */ float NavMeshProjectionHeightScaleUp;
    /* 0x04c0 */ float NavMeshProjectionHeightScaleDown;
    /* 0x04c4 */ float NavWalkingFloorDistTolerance;
    /* 0x04c8 */ FCharacterMovementComponentPostPhysicsTickFunction PostPhysicsTickFunction;
    /* 0x0510 */ float MinTimeBetweenTimeStampResets;
    /* 0x0990 */ FRootMotionSourceGroup CurrentRootMotion;
    /* 0x09c8 */ FRootMotionSourceGroup ServerCorrectionRootMotion;
    /* 0x0a90 */ FRootMotionMovementParams RootMotionParams;
    /* 0x0ad0 */ FVector AnimRootMotionVelocity;

    void AddForce(FVector Force);
    void AddImpulse(FVector Impulse, bool bVelocityChange);
    void CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration);
    void CapsuleTouched(UPrimitiveComponent* OverlappedComp, AActor* Other, UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    void ClearAccumulatedForces();
    void DisableMovement();
    float GetAnalogInputModifier() const;
    ACharacter* GetCharacterOwner() const;
    FVector GetCurrentAcceleration() const;
    FVector GetImpartedMovementBaseVelocity() const;
    FVector GetLastUpdateLocation() const;
    FRotator GetLastUpdateRotation() const;
    FVector GetLastUpdateVelocity() const;
    float GetMaxAcceleration() const;
    float GetMaxBrakingDeceleration() const;
    float GetMaxJumpHeight() const;
    float GetMaxJumpHeightWithJumpTime() const;
    float GetMinAnalogSpeed() const;
    UPrimitiveComponent* GetMovementBase() const;
    float GetPerchRadiusThreshold() const;
    float GetValidPerchRadius() const;
    bool IsWalkable(const FHitResult& Hit) const;
    bool IsWalking() const;
    void K2_ComputeFloorDist(FVector CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, FFindFloorResult& FloorResult) const;
    void K2_FindFloor(FVector CapsuleLocation, FFindFloorResult& FloorResult) const;
    float K2_GetModifiedMaxAcceleration() const;
    float K2_GetWalkableFloorAngle() const;
    float K2_GetWalkableFloorZ() const;
    void SetAvoidanceEnabled(bool bEnable);
    void SetAvoidanceGroup(int32_t GroupFlags);
    void SetAvoidanceGroupMask(const FNavAvoidanceMask& GroupMask);
    void SetGroupsToAvoid(int32_t GroupFlags);
    void SetGroupsToAvoidMask(const FNavAvoidanceMask& GroupMask);
    void SetGroupsToIgnore(int32_t GroupFlags);
    void SetGroupsToIgnoreMask(const FNavAvoidanceMask& GroupMask);
    void SetMovementMode(uint8_t NewMovementMode, uint8_t NewCustomMode);
    void SetWalkableFloorAngle(float InWalkableFloorAngle);
    void SetWalkableFloorZ(float InWalkableFloorZ);
};

// Size: 0x30
struct FCharacterMovementComponentPostPhysicsTickFunction : public FTickFunction {
};

// Size: 0x98
struct FCharacterNetworkSerializationPackedBits {
};

// Size: 0x98
struct FCharacterServerMovePackedBits : public FCharacterNetworkSerializationPackedBits {
};

// Size: 0x90
class UCheatManager : public UObject {
    /* 0x0030 */ ADebugCameraController* DebugCameraControllerRef;
    /* 0x0038 */ UClass* DebugCameraControllerClass;
    /* 0x0080 */ TArray<UCheatManagerExtension*> CheatManagerExtensions;

    void BugIt(FString ScreenShotDescription);
    void BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll);
    void BugItStringCreator(FVector ViewLocation, FRotator ViewRotation, FString& GoString, FString& LocString);
    void ChangeSize(float F);
    void CheatScript(FString ScriptName);
    void DamageTarget(float DamageAmount);
    void DebugCapsuleSweep();
    void DebugCapsuleSweepCapture();
    void DebugCapsuleSweepChannel(uint8_t Channel);
    void DebugCapsuleSweepClear();
    void DebugCapsuleSweepComplex(bool bTraceComplex);
    void DebugCapsuleSweepPawn();
    void DebugCapsuleSweepSize(float HalfHeight, float Radius);
    void DestroyAll(UClass* aClass);
    void DestroyAllPawnsExceptTarget();
    void DestroyPawns(UClass* aClass);
    void DestroyServerStatReplicator();
    void DestroyTarget();
    void DisableDebugCamera();
    void DumpChatState();
    void DumpOnlineSessionState();
    void DumpPartyState();
    void DumpVoiceMutingState();
    void EnableDebugCamera();
    void FlushLog();
    void Fly();
    void FreezeFrame(float Delay);
    void Ghost();
    void God();
    void InvertMouse();
    void LogLoc();
    void OnlyLoadLevel(FName PackageName);
    void PlayersOnly();
    void ReceiveEndPlay();
    void ReceiveInitCheatManager();
    void ServerToggleAILogging();
    void SetMouseSensitivityToDefault();
    void SetWorldOrigin();
    void Slomo(float NewTimeDilation);
    void SpawnServerStatReplicator();
    void StreamLevelIn(FName PackageName);
    void StreamLevelOut(FName PackageName);
    void Summon(FString ClassName);
    void Teleport();
    void TestCollisionDistance();
    void ToggleAILogging();
    void ToggleDebugCamera();
    void ToggleServerStatReplicatorClientOverwrite();
    void ToggleServerStatReplicatorUpdateStatNet();
    void UpdateSafeArea();
    void ViewActor(FName ActorName);
    void ViewClass(UClass* DesiredClass);
    void ViewPlayer(FString S);
    void ViewSelf();
    void Walk();
};

// Size: 0x30
class UCheatManagerExtension : public UObject {
};

// Size: 0x6c8
class UCheckBoxStyleAsset : public UObject {
    /* 0x0030 */ FCheckBoxStyle CheckBoxStyle;
};

// Size: 0x50
struct FChildActorAttachedActorInfo {
    /* 0x0000 */ TWeakObjectPtr<AActor> Actor;
    /* 0x0008 */ FName SocketName;
    /* 0x0020 */ FTransform RelativeTransform;
};

// Size: 0x270
class UChildActorComponent : public USceneComponent {
    /* 0x0228 */ UClass* ChildActorClass;
    /* 0x0230 */ AActor* ChildActor;
    /* 0x0238 */ AActor* ChildActorTemplate;
    /* 0x0260 */ EChildActorComponentTreeViewVisualizationMode EditorTreeViewVisualizationMode;

    void SetChildActorClass(UClass* InClass);
};

// Size: 0x100
struct FChildActorComponentInstanceData : public FSceneComponentInstanceData {
    /* 0x00b8 */ UClass* ChildActorClass;
    /* 0x00c0 */ FName ChildActorName;
    /* 0x00d0 */ TArray<FChildActorAttachedActorInfo> AttachedActors;
};

// Size: 0x1c40
class UChildConnection : public UNetConnection {
    /* 0x1c38 */ UNetConnection* Parent;
};

// Size: 0x58
struct FClassRedirect {
    /* 0x0000 */ FName ObjectName;
    /* 0x000c */ FName OldClassName;
    /* 0x0018 */ FName NewClassName;
    /* 0x0024 */ FName OldSubobjName;
    /* 0x0030 */ FName NewSubobjName;
    /* 0x003c */ FName NewClassClass;
    /* 0x0048 */ FName NewClassPackage;
    /* 0x0054 */ bool InstanceOnly;
};

// Size: 0x40
struct FClientReceiveData {
    /* 0x0000 */ APlayerController* LocalPC;
    /* 0x0008 */ FName MessageType;
    /* 0x0014 */ int32_t MessageIndex;
    /* 0x0018 */ FString MessageString;
    /* 0x0028 */ APlayerState* RelatedPlayerState_1;
    /* 0x0030 */ APlayerState* RelatedPlayerState_2;
    /* 0x0038 */ UObject* OptionalObject;
};

// Size: 0x50
struct FClothPhysicsProperties_Legacy {
    /* 0x0000 */ float VerticalResistance;
    /* 0x0004 */ float HorizontalResistance;
    /* 0x0008 */ float BendResistance;
    /* 0x000c */ float ShearResistance;
    /* 0x0010 */ float Friction;
    /* 0x0014 */ float Damping;
    /* 0x0018 */ float TetherStiffness;
    /* 0x001c */ float TetherLimit;
    /* 0x0020 */ float Drag;
    /* 0x0024 */ float StiffnessFrequency;
    /* 0x0028 */ float GravityScale;
    /* 0x002c */ float MassScale;
    /* 0x0030 */ float InertiaBlend;
    /* 0x0034 */ float SelfCollisionThickness;
    /* 0x0038 */ float SelfCollisionSquashScale;
    /* 0x003c */ float SelfCollisionStiffness;
    /* 0x0040 */ float SolverFrequency;
    /* 0x0044 */ float FiberCompression;
    /* 0x0048 */ float FiberExpansion;
    /* 0x004c */ float FiberResistance;
};

// Size: 0x80
struct FClothingAssetData_Legacy {
    /* 0x0000 */ FName AssetName;
    /* 0x0010 */ FString ApexFileName;
    /* 0x0020 */ bool bClothPropertiesChanged;
    /* 0x0024 */ FClothPhysicsProperties_Legacy PhysicsProperties;
};

// Size: 0x58
class UCloudStorageBase : public UPlatformInterfaceBase {
    /* 0x0040 */ TArray<FString> LocalCloudFiles;
    /* 0x0050 */ bool bSuppressDelegateCalls;
};

// Size: 0x40
struct FClusterNode {
    /* 0x0000 */ FVector BoundMin;
    /* 0x000c */ int32_t FirstChild;
    /* 0x0010 */ FVector BoundMax;
    /* 0x001c */ int32_t LastChild;
    /* 0x0020 */ int32_t FirstInstance;
    /* 0x0024 */ int32_t LastInstance;
    /* 0x0028 */ FVector MinInstanceScale;
    /* 0x0034 */ FVector MaxInstanceScale;
};

// Size: 0x28
struct FClusterNode_DEPRECATED {
    /* 0x0000 */ FVector BoundMin;
    /* 0x000c */ int32_t FirstChild;
    /* 0x0010 */ FVector BoundMax;
    /* 0x001c */ int32_t LastChild;
    /* 0x0020 */ int32_t FirstInstance;
    /* 0x0024 */ int32_t LastInstance;
};

// Size: 0x1c
struct FCollectionParameterBase {
    /* 0x0000 */ FName ParameterName;
    /* 0x000c */ FGuid ID;
};

// Size: 0xc
struct FCollectionReference {
    /* 0x0000 */ FName CollectionName;
};

// Size: 0x20
struct FCollectionScalarParameter : public FCollectionParameterBase {
    /* 0x001c */ float DefaultValue;
};

// Size: 0x2c
struct FCollectionVectorParameter : public FCollectionParameterBase {
    /* 0x001c */ FLinearColor DefaultValue;
};

// Size: 0x30
struct FCollisionImpactData {
    /* 0x0000 */ TArray<FRigidBodyContactInfo> ContactInfos;
    /* 0x0010 */ FVector TotalNormalImpulse;
    /* 0x001c */ FVector TotalFrictionImpulse;
    /* 0x0028 */ bool bIsVelocityDeltaUnderThreshold;
};

// Size: 0x198
class UCollisionProfile : public UDeveloperSettings {
    /* 0x0060 */ TArray<FCollisionResponseTemplate> Profiles;
    /* 0x0070 */ TArray<FCustomChannelSetup> DefaultChannelResponses;
    /* 0x0080 */ TArray<FCustomProfile> EditProfiles;
    /* 0x0090 */ TArray<FRedirector> ProfileRedirects;
    /* 0x00a0 */ TArray<FRedirector> CollisionChannelRedirects;
};

// Size: 0xc
struct FCollisionProfileName {
    /* 0x0000 */ FName Name;
};

// Size: 0x30
struct FCollisionResponse {
    /* 0x0000 */ FCollisionResponseContainer ResponseToChannels;
    /* 0x0020 */ TArray<FResponseChannel> ResponseArray;
};

// Size: 0x20
struct FCollisionResponseContainer {
    /* 0x0000 */ uint8_t WorldStatic;
    /* 0x0001 */ uint8_t WorldDynamic;
    /* 0x0002 */ uint8_t Pawn;
    /* 0x0003 */ uint8_t Visibility;
    /* 0x0004 */ uint8_t Camera;
    /* 0x0005 */ uint8_t PhysicsBody;
    /* 0x0006 */ uint8_t Vehicle;
    /* 0x0007 */ uint8_t Destructible;
    /* 0x0008 */ uint8_t EngineTraceChannel1;
    /* 0x0009 */ uint8_t EngineTraceChannel2;
    /* 0x000a */ uint8_t EngineTraceChannel3;
    /* 0x000b */ uint8_t EngineTraceChannel4;
    /* 0x000c */ uint8_t EngineTraceChannel5;
    /* 0x000d */ uint8_t EngineTraceChannel6;
    /* 0x000e */ uint8_t GameTraceChannel1;
    /* 0x000f */ uint8_t GameTraceChannel2;
    /* 0x0010 */ uint8_t GameTraceChannel3;
    /* 0x0011 */ uint8_t GameTraceChannel4;
    /* 0x0012 */ uint8_t GameTraceChannel5;
    /* 0x0013 */ uint8_t GameTraceChannel6;
    /* 0x0014 */ uint8_t GameTraceChannel7;
    /* 0x0015 */ uint8_t GameTraceChannel8;
    /* 0x0016 */ uint8_t GameTraceChannel9;
    /* 0x0017 */ uint8_t GameTraceChannel10;
    /* 0x0018 */ uint8_t GameTraceChannel11;
    /* 0x0019 */ uint8_t GameTraceChannel12;
    /* 0x001a */ uint8_t GameTraceChannel13;
    /* 0x001b */ uint8_t GameTraceChannel14;
    /* 0x001c */ uint8_t GameTraceChannel15;
    /* 0x001d */ uint8_t GameTraceChannel16;
    /* 0x001e */ uint8_t GameTraceChannel17;
    /* 0x001f */ uint8_t GameTraceChannel18;
};

// Size: 0x60
struct FCollisionResponseTemplate {
    /* 0x0000 */ FName Name;
    /* 0x000c */ uint8_t CollisionEnabled;
    /* 0x000e */ bool bCanModify;
    /* 0x0030 */ FName ObjectTypeName;
    /* 0x0040 */ TArray<FResponseChannel> CustomResponses;
    /* 0x0050 */ FString HelpMessage;
};

// Size: 0x50
struct FColorGradePerRangeSettings {
    /* 0x0000 */ FVector4 Saturation;
    /* 0x0010 */ FVector4 Contrast;
    /* 0x0020 */ FVector4 Gamma;
    /* 0x0030 */ FVector4 Gain;
    /* 0x0040 */ FVector4 Offset;
};

// Size: 0x150
struct FColorGradingSettings {
    /* 0x0000 */ FColorGradePerRangeSettings Global;
    /* 0x0050 */ FColorGradePerRangeSettings Shadows;
    /* 0x00a0 */ FColorGradePerRangeSettings Midtones;
    /* 0x00f0 */ FColorGradePerRangeSettings Highlights;
    /* 0x0140 */ float ShadowsMax;
    /* 0x0144 */ float HighlightsMin;
};

// Size: 0x40
struct FColorMaterialInput : public Fmaterialinput {
    /* 0x0038 */ bool UseConstant;
    /* 0x003c */ FColor Constant;
};

// Size: 0x88
class UCommandlet : public UObject {
    /* 0x0030 */ FString HelpDescription;
    /* 0x0040 */ FString HelpUsage;
    /* 0x0050 */ FString HelpWebLink;
    /* 0x0060 */ TArray<FString> HelpParamNames;
    /* 0x0070 */ TArray<FString> HelpParamDescriptions;
    /* 0x0080 */ bool IsServer;
    /* 0x0080 */ bool IsClient;
    /* 0x0080 */ bool IsEditor;
    /* 0x0080 */ bool LogToConsole;
    /* 0x0080 */ bool ShowErrorCount;
    /* 0x0080 */ bool ShowProgress;
};

// Size: 0x80
struct FCompilerNativizationOptions {
    /* 0x0000 */ FName PlatformName;
    /* 0x000c */ bool ServerOnlyPlatform;
    /* 0x000d */ bool ClientOnlyPlatform;
    /* 0x000e */ bool bExcludeMonolithicHeaders;
    /* 0x0010 */ TArray<FName> ExcludedModules;
    /* 0x0020 */ TSet<FSoftObjectPath> ExcludedAssets;
    /* 0x0070 */ TArray<FString> ExcludedFolderPaths;
};

// Size: 0x40
class UComponentDelegateBinding : public UDynamicBlueprintBinding {
    /* 0x0030 */ TArray<FBlueprintComponentDelegateBinding> ComponentDelegateBindings;
};

// Size: 0x28
struct FComponentKey {
    /* 0x0000 */ UClass* OwnerClass;
    /* 0x0008 */ FName SCSVariableName;
    /* 0x0014 */ FGuid AssociatedGuid;
};

// Size: 0x88
struct FComponentOverrideRecord {
    /* 0x0000 */ UClass* ComponentClass;
    /* 0x0008 */ UActorComponent* ComponentTemplate;
    /* 0x0010 */ FComponentKey ComponentKey;
    /* 0x0038 */ FBlueprintCookedComponentInstancingData CookedComponentInstancingData;
};

// Size: 0x30
struct FComponentReference {
    /* 0x0000 */ AActor* OtherActor;
    /* 0x0008 */ FName ComponentProperty;
    /* 0x0018 */ FString PathToComponent;
};

// Size: 0x20
struct FComponentSpacePose {
    /* 0x0000 */ TArray<FTransform> Transforms;
    /* 0x0010 */ TArray<FName> Names;
};

// Size: 0x18
struct FComponentSpacePoseLink : public FPoseLinkBase {
};

// Size: 0x10
struct FComponentSync {
    /* 0x0000 */ FName Name;
    /* 0x000c */ ESyncOption SyncOption;
};

// Size: 0xe8
class UCompositeCurveTable : public UCurveTable {
    /* 0x00c0 */ TArray<UCurveTable*> ParentTables;
    /* 0x00d0 */ TArray<UCurveTable*> OldParentTables;
};

// Size: 0x1b8
class UCompositeDataTable : public UDataTable {
    /* 0x0140 */ TArray<UDataTable*> ParentTables;
    /* 0x0150 */ TArray<UDataTable*> OldParentTables;
};

// Size: 0x60
struct FCompositeSection : public FAnimLinkableElement {
    /* 0x0030 */ FName SectionName;
    /* 0x003c */ float StartTime;
    /* 0x0040 */ FName NextSectionName;
    /* 0x0050 */ TArray<UAnimMetaData*> MetaData;
};

// Size: 0x18
struct FCompressedRichCurve {
};

// Size: 0x38
struct FCompressedTrack {
    /* 0x0000 */ TArray<uint8_t> ByteStream;
    /* 0x0010 */ TArray<float> Times;
    /* 0x0020 */ float Mins[3];
    /* 0x002c */ float Ranges[3];
};

// Size: 0x20
struct FConeConstraint : public FConstraintBaseParams {
    /* 0x0014 */ float Swing1LimitDegrees;
    /* 0x0018 */ float Swing2LimitDegrees;
    /* 0x001c */ uint8_t Swing1Motion;
    /* 0x001d */ uint8_t Swing2Motion;
};

// Size: 0x140
class UConsole : public UObject {
    /* 0x0040 */ ULocalPlayer* ConsoleTargetPlayer;
    /* 0x0048 */ UTexture2D* DefaultTexture_Black;
    /* 0x0050 */ UTexture2D* DefaultTexture_White;
    /* 0x0070 */ TArray<FString> HistoryBuffer;
};

// Size: 0xc
struct FConstrainComponentPropName {
    /* 0x0000 */ FName ComponentName;
};

// Size: 0x14
struct FConstraintBaseParams {
    /* 0x0000 */ float Stiffness;
    /* 0x0004 */ float Damping;
    /* 0x0008 */ float Restitution;
    /* 0x000c */ float ContactDistance;
    /* 0x0010 */ bool bSoftConstraint;
};

// Size: 0x10
struct FConstraintDrive {
    /* 0x0000 */ float Stiffness;
    /* 0x0004 */ float Damping;
    /* 0x0008 */ float MaxForce;
    /* 0x000c */ bool bEnablePositionDrive;
    /* 0x000c */ bool bEnableVelocityDrive;
};

// Size: 0x2a0
struct FConstraintInstance : public FConstraintInstanceBase {
    /* 0x0018 */ FName JointName;
    /* 0x0024 */ FName ConstraintBone1;
    /* 0x0030 */ FName ConstraintBone2;
    /* 0x003c */ FVector Pos1;
    /* 0x0048 */ FVector PriAxis1;
    /* 0x0054 */ FVector SecAxis1;
    /* 0x0060 */ FVector Pos2;
    /* 0x006c */ FVector PriAxis2;
    /* 0x0078 */ FVector SecAxis2;
    /* 0x0084 */ FRotator AngularRotationOffset;
    /* 0x0090 */ bool bScaleLinearLimits;
    /* 0x0098 */ FConstraintProfileProperties ProfileInstance;
    /* 0x01d8 */ bool bDisableCollision;
    /* 0x01d8 */ bool bEnableProjection;
    /* 0x01dc */ float ProjectionLinearTolerance;
    /* 0x01e0 */ float ProjectionAngularTolerance;
    /* 0x01e4 */ uint8_t LinearXMotion;
    /* 0x01e5 */ uint8_t LinearYMotion;
    /* 0x01e6 */ uint8_t LinearZMotion;
    /* 0x01e8 */ float LinearLimitSize;
    /* 0x01ec */ bool bLinearLimitSoft;
    /* 0x01f0 */ float LinearLimitStiffness;
    /* 0x01f4 */ float LinearLimitDamping;
    /* 0x01f8 */ bool bLinearBreakable;
    /* 0x01fc */ float LinearBreakThreshold;
    /* 0x0200 */ uint8_t AngularSwing1Motion;
    /* 0x0201 */ uint8_t AngularTwistMotion;
    /* 0x0202 */ uint8_t AngularSwing2Motion;
    /* 0x0204 */ bool bSwingLimitSoft;
    /* 0x0204 */ bool bTwistLimitSoft;
    /* 0x0208 */ float Swing1LimitAngle;
    /* 0x020c */ float TwistLimitAngle;
    /* 0x0210 */ float Swing2LimitAngle;
    /* 0x0214 */ float SwingLimitStiffness;
    /* 0x0218 */ float SwingLimitDamping;
    /* 0x021c */ float TwistLimitStiffness;
    /* 0x0220 */ float TwistLimitDamping;
    /* 0x0224 */ bool bAngularBreakable;
    /* 0x0228 */ float AngularBreakThreshold;
    /* 0x022c */ bool bLinearXPositionDrive;
    /* 0x022c */ bool bLinearXVelocityDrive;
    /* 0x022c */ bool bLinearYPositionDrive;
    /* 0x022c */ bool bLinearYVelocityDrive;
    /* 0x022c */ bool bLinearZPositionDrive;
    /* 0x022c */ bool bLinearZVelocityDrive;
    /* 0x022c */ bool bLinearPositionDrive;
    /* 0x022c */ bool bLinearVelocityDrive;
    /* 0x0230 */ FVector LinearPositionTarget;
    /* 0x023c */ FVector LinearVelocityTarget;
    /* 0x0248 */ float LinearDriveSpring;
    /* 0x024c */ float LinearDriveDamping;
    /* 0x0250 */ float LinearDriveForceLimit;
    /* 0x0254 */ bool bSwingPositionDrive;
    /* 0x0254 */ bool bSwingVelocityDrive;
    /* 0x0254 */ bool bTwistPositionDrive;
    /* 0x0254 */ bool bTwistVelocityDrive;
    /* 0x0254 */ bool bAngularSlerpDrive;
    /* 0x0254 */ bool bAngularOrientationDrive;
    /* 0x0254 */ bool bEnableSwingDrive;
    /* 0x0254 */ bool bEnableTwistDrive;
    /* 0x0255 */ bool bAngularVelocityDrive;
    /* 0x0260 */ FQuat AngularPositionTarget;
    /* 0x0270 */ uint8_t AngularDriveMode;
    /* 0x0274 */ FRotator AngularOrientationTarget;
    /* 0x0280 */ FVector AngularVelocityTarget;
    /* 0x028c */ float AngularDriveSpring;
    /* 0x0290 */ float AngularDriveDamping;
    /* 0x0294 */ float AngularDriveForceLimit;
};

// Size: 0x18
struct FConstraintInstanceBase {
};

// Size: 0x114
struct FConstraintProfileProperties {
    /* 0x0000 */ float ProjectionLinearTolerance;
    /* 0x0004 */ float ProjectionAngularTolerance;
    /* 0x0008 */ float ProjectionLinearAlpha;
    /* 0x000c */ float ProjectionAngularAlpha;
    /* 0x0010 */ float LinearBreakThreshold;
    /* 0x0014 */ float LinearPlasticityThreshold;
    /* 0x0018 */ float AngularBreakThreshold;
    /* 0x001c */ float AngularPlasticityThreshold;
    /* 0x0020 */ FLinearConstraint LinearLimit;
    /* 0x003c */ FConeConstraint ConeLimit;
    /* 0x005c */ FTwistConstraint TwistLimit;
    /* 0x0078 */ FLinearDriveConstraint LinearDrive;
    /* 0x00c4 */ FAngularDriveConstraint AngularDrive;
    /* 0x0110 */ bool bDisableCollision;
    /* 0x0110 */ bool bParentDominates;
    /* 0x0110 */ bool bEnableProjection;
    /* 0x0110 */ bool bEnableSoftProjection;
    /* 0x0110 */ bool bAngularBreakable;
    /* 0x0110 */ bool bAngularPlasticity;
    /* 0x0110 */ bool bLinearBreakable;
    /* 0x0110 */ bool bLinearPlasticity;
};

// Size: 0x90
class UControlChannel : public UChannel {
};

// Size: 0x378
class AController : public AActor {
    /* 0x0300 */ APlayerState* PlayerState;
    /* 0x0310 */ FMulticastInlineDelegate OnInstigatedAnyDamage;
    /* 0x0320 */ FName StateName;
    /* 0x0330 */ APawn* Pawn;
    /* 0x0340 */ ACharacter* Character;
    /* 0x0348 */ USceneComponent* TransformComponent;
    /* 0x0368 */ FRotator ControlRotation;
    /* 0x0374 */ bool bAttachToPawn;

    APlayerController* CastToPlayerController();
    void ClientSetLocation(FVector NewLocation, FRotator NewRotation);
    void ClientSetRotation(FRotator NewRotation, bool bResetCamera);
    FRotator GetControlRotation() const;
    FRotator GetDesiredRotation() const;
    AActor* GetViewTarget() const;
    bool IsLocalController() const;
    bool IsLocalPlayerController() const;
    bool IsLookInputIgnored() const;
    bool IsMoveInputIgnored() const;
    bool IsPlayerController() const;
    APawn* K2_GetPawn() const;
    bool LineOfSightTo(const AActor* Other, FVector ViewPoint, bool bAlternateChecks) const;
    void OnRep_Pawn();
    void OnRep_PlayerState();
    void Possess(APawn* InPawn);
    void ReceiveInstigatedAnyDamage(float Damage, const UDamageType* DamageType, AActor* DamagedActor, AActor* DamageCauser);
    void ReceivePossess(APawn* PossessedPawn);
    void ReceiveUnPossess(APawn* UnpossessedPawn);
    void ResetIgnoreInputFlags();
    void ResetIgnoreLookInput();
    void ResetIgnoreMoveInput();
    void SetControlRotation(const FRotator& NewRotation);
    void SetIgnoreLookInput(bool bNewLookInput);
    void SetIgnoreMoveInput(bool bNewMoveInput);
    void SetInitialLocationAndRotation(const FVector& NewLocation, const FRotator& NewRotation);
    void StopMovement();
    void UnPossess();
};

// Size: 0x28
struct FConvolutionBloomSettings {
    /* 0x0000 */ UTexture2D* Texture;
    /* 0x0008 */ float Size;
    /* 0x000c */ FVector2D CenterUV;
    /* 0x0014 */ float PreFilterMin;
    /* 0x0018 */ float PreFilterMax;
    /* 0x001c */ float PreFilterMult;
    /* 0x0020 */ float BufferScale;
};

// Size: 0x8
struct FCullDistanceSizePair {
    /* 0x0000 */ float Size;
    /* 0x0004 */ float CullDistance;
};

// Size: 0x350
class ACullDistanceVolume : public AVolume {
    /* 0x0338 */ TArray<FCullDistanceSizePair> CullDistances;
    /* 0x0348 */ bool bEnabled;
};

// Size: 0x24
struct FCurveAtlasColorAdjustments {
    /* 0x0000 */ bool bChromaKeyTexture;
    /* 0x0004 */ float AdjustBrightness;
    /* 0x0008 */ float AdjustBrightnessCurve;
    /* 0x000c */ float AdjustVibrance;
    /* 0x0010 */ float AdjustSaturation;
    /* 0x0014 */ float AdjustRGBCurve;
    /* 0x0018 */ float AdjustHue;
    /* 0x001c */ float AdjustMinAlpha;
    /* 0x0020 */ float AdjustMaxAlpha;
};

// Size: 0x68
class UCurveBase : public UObject {
    /* 0x0038 */ UAssetImportData* AssetImportData;
    /* 0x0040 */ FString ImportPath;

    void GetTimeRange(float& MinTime, float& MaxTime) const;
    void GetValueRange(float& MinValue, float& MaxValue) const;
};

// Size: 0x38
struct FCurveEdEntry {
    /* 0x0000 */ UObject* CurveObject;
    /* 0x0008 */ FColor CurveColor;
    /* 0x0010 */ FString CurveName;
    /* 0x0020 */ int32_t bHideCurve;
    /* 0x0024 */ int32_t bColorCurve;
    /* 0x0028 */ int32_t bFloatingPointColorCurve;
    /* 0x002c */ int32_t bClamp;
    /* 0x0030 */ float ClampLow;
    /* 0x0034 */ float ClampHigh;
};

// Size: 0x30
class UCurveEdPresetCurve : public UObject {
};

// Size: 0x30
struct FCurveEdTab {
    /* 0x0000 */ FString TabName;
    /* 0x0010 */ TArray<FCurveEdEntry> Curves;
    /* 0x0020 */ float ViewStartInput;
    /* 0x0024 */ float ViewEndInput;
    /* 0x0028 */ float ViewStartOutput;
    /* 0x002c */ float ViewEndOutput;
};

// Size: 0xf0
class UCurveFloat : public UCurveBase {
    /* 0x0068 */ FRichCurve FloatCurve;
    /* 0x00e8 */ bool bIsEventCurve;

    float GetFloatValue(float InTime) const;
};

// Size: 0x2a0
class UCurveLinearColor : public UCurveBase {
    /* 0x0068 */ FRichCurve FloatCurves[4];
    /* 0x0268 */ float AdjustHue;
    /* 0x026c */ float AdjustSaturation;
    /* 0x0270 */ float AdjustBrightness;
    /* 0x0274 */ float AdjustBrightnessCurve;
    /* 0x0278 */ float AdjustVibrance;
    /* 0x027c */ float AdjustMinAlpha;
    /* 0x0280 */ float AdjustMaxAlpha;

    FLinearColor GetClampedLinearColorValue(float InTime) const;
    FLinearColor GetLinearColorValue(float InTime) const;
    FLinearColor GetUnadjustedLinearColorValue(float InTime) const;
};

// Size: 0x480
class UCurveLinearColorAtlas : public UTexture2D {
    /* 0x0410 */ bool bIsDirty;
    /* 0x0428 */ uint32_t TextureSize;
    /* 0x042c */ bool bSquareResolution;
    /* 0x0430 */ uint32_t TextureHeight;
    /* 0x0438 */ TArray<UCurveLinearColor*> GradientCurves;
    /* 0x0448 */ bool bDisableAllAdjustments;
    /* 0x0448 */ bool bHasCachedColorAdjustments;
    /* 0x044c */ FCurveAtlasColorAdjustments CachedColorAdjustments;

    bool GetCurvePosition(UCurveLinearColor* InCurve, float& Position);
};

// Size: 0x18
struct FCurveMetaData {
};

// Size: 0x30
class ICurveSourceInterface : public UInterface {

    FName GetBindingName() const;
    float GetCurveValue(FName CurveName) const;
    void GetCurves(TArray<FNamedCurveValue>& OutValues) const;
};

// Size: 0xc0
class UCurveTable : public UObject {
    /* 0x0088 */ UAssetImportData* AssetImportData;
    /* 0x0090 */ FString ImportPath;
};

// Size: 0x18
struct FCurveTableRowHandle {
    /* 0x0000 */ UCurveTable* CurveTable;
    /* 0x0008 */ FName RowName;
};

// Size: 0x20
struct FCurveTrack {
    /* 0x0000 */ FName CurveName;
    /* 0x0010 */ TArray<float> CurveWeights;
};

// Size: 0x1e8
class UCurveVector : public UCurveBase {
    /* 0x0068 */ FRichCurve FloatCurves[3];

    FVector GetVectorValue(float InTime) const;
};

// Size: 0x30
struct FCustomAttribute {
    /* 0x0000 */ FName Name;
    /* 0x000c */ int32_t VariantType;
    /* 0x0010 */ TArray<float> Times;
};

// Size: 0x18
struct FCustomAttributePerBoneData {
    /* 0x0000 */ int32_t BoneTreeIndex;
    /* 0x0008 */ TArray<FCustomAttribute> Attributes;
};

// Size: 0x20
struct FCustomAttributeSetting {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FString Meaning;
};

// Size: 0x10
struct FCustomChannelSetup {
    /* 0x0000 */ uint8_t Channel;
    /* 0x0001 */ uint8_t DefaultResponse;
    /* 0x0002 */ bool bTraceType;
    /* 0x0003 */ bool bStaticObject;
    /* 0x0004 */ FName Name;
};

// Size: 0x20
struct FCustomDefine {
    /* 0x0000 */ FString DefineName;
    /* 0x0010 */ FString DefineValue;
};

// Size: 0x48
struct FCustomInput {
    /* 0x0000 */ FName InputName;
    /* 0x0010 */ FExpressionInput Input;
};

// Size: 0x10
struct FCustomOutput {
    /* 0x0000 */ FName OutputName;
    /* 0x000c */ uint8_t OutputType;
};

// Size: 0x10
struct FCustomPrimitiveData {
    /* 0x0000 */ TArray<float> Data;
};

// Size: 0x20
struct FCustomProfile {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ TArray<FResponseChannel> CustomResponses;
};

enum class CylinderHeightAxis {
    PMLPC_HEIGHTAXIS_X = 0,
    PMLPC_HEIGHTAXIS_Y = 1,
    PMLPC_HEIGHTAXIS_Z = 2,
    PMLPC_HEIGHTAXIS_MAX = 3,
};

// Size: 0x30
class UDPICustomScalingRule : public UObject {
};

// Size: 0x10
struct FDamageEvent {
    /* 0x0008 */ UClass* DamageTypeClass;
};

// Size: 0x48
class UDamageType : public UObject {
    /* 0x0030 */ bool bCausedByWorld;
    /* 0x0030 */ bool bScaleMomentumByMass;
    /* 0x0030 */ bool bRadialDamageVelChange;
    /* 0x0034 */ float DamageImpulse;
    /* 0x0038 */ float DestructibleImpulse;
    /* 0x003c */ float DestructibleDamageSpreadScale;
    /* 0x0040 */ float DamageFalloff;
};

// Size: 0x38
class UDataAsset : public UObject {
    /* 0x0030 */ UClass* NativeClass;
};

// Size: 0x48
class UDataDrivenCVarEngineSubsystem : public UEngineSubsystem {
    /* 0x0038 */ FMulticastInlineDelegate OnDataDrivenCVarDelegate;

    void OnDataDrivenCVarChanged__DelegateSignature(FString CVarName);
};

// Size: 0x50
struct FDataDrivenConsoleVariable {
    /* 0x0000 */ FDataDrivenCVarType Type;
    /* 0x0008 */ FString Name;
    /* 0x0018 */ FString Tooltip;
    /* 0x0028 */ float DefaultValueFloat;
    /* 0x002c */ int32_t DefaultValueInt;
    /* 0x0030 */ bool DefaultValueBool;
};

// Size: 0x98
class UDataDrivenConsoleVariableSettings : public UDeveloperSettings {
    /* 0x0078 */ TArray<FDataDrivenConsoleVariable> CVarsArray;
};

// Size: 0x140
class UDataTable : public UObject {
    /* 0x0030 */ UScriptStruct* RowStruct;
    /* 0x0088 */ bool bStripFromClientBuilds;
    /* 0x0088 */ bool bIgnoreExtraFields;
    /* 0x0088 */ bool bIgnoreMissingFields;
    /* 0x0090 */ FString ImportKeyField;
    /* 0x00a0 */ UAssetImportData* AssetImportData;
    /* 0x00a8 */ FString ImportPath;
    /* 0x00b8 */ FName RowStructName;
    /* 0x00c8 */ TArray<uint8_t> RowsSerializedWithTags;
    /* 0x00d8 */ TSet<UObject*> TemporarilyReferencedObjects;
};

// Size: 0x20
struct FDataTableCategoryHandle {
    /* 0x0000 */ UDataTable* DataTable;
    /* 0x0008 */ FName ColumnName;
    /* 0x0014 */ FName RowContents;
};

// Size: 0x30
class UDataTableFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool DoesDataTableRowExist(UDataTable* Table, FName RowName);
    static void EvaluateCurveTableRow(UCurveTable* CurveTable, FName RowName, float InXY, uint8_t& OutResult, float& OutXY, FString ContextString);
    static bool FillDataTableFromCSVFile(UDataTable* DataTable, FString CSVFilePath);
    static bool FillDataTableFromCSVString(UDataTable* DataTable, FString CSVString);
    static bool FillDataTableFromJSONFile(UDataTable* DataTable, FString JSONFilePath, UScriptStruct* ImportRowStruct);
    static bool FillDataTableFromJSONString(UDataTable* DataTable, FString JsonString);
    static TArray<FString> GetDataTableColumnAsString(const UDataTable* DataTable, FName PropertyName);
    static bool GetDataTableRowFromName(UDataTable* Table, FName RowName, FTableRowBase& OutRow);
    static void GetDataTableRowNames(UDataTable* Table, TArray<FName>& OutRowNames);
};

// Size: 0x18
struct FDataTableRowHandle {
    /* 0x0000 */ UDataTable* DataTable;
    /* 0x0008 */ FName RowName;
};

// Size: 0x768
class ADebugCameraController : public APlayerController {
    /* 0x0660 */ bool bShowSelectedInfo;
    /* 0x0660 */ bool bIsFrozenRendering;
    /* 0x0660 */ bool bIsOrbitingSelectedActor;
    /* 0x0660 */ bool bOrbitPivotUseCenter;
    /* 0x0660 */ bool bEnableBufferVisualization;
    /* 0x0660 */ bool bEnableBufferVisualizationFullMode;
    /* 0x0660 */ bool bIsBufferVisualizationInputSetup;
    /* 0x0660 */ bool bLastDisplayEnabled;
    /* 0x0668 */ UDrawFrustumComponent* DrawFrustum;
    /* 0x0670 */ AActor* SelectedActor;
    /* 0x0678 */ UPrimitiveComponent* SelectedComponent;
    /* 0x0680 */ FHitResult SelectedHitPoint;
    /* 0x0710 */ APlayerController* OriginalControllerRef;
    /* 0x0718 */ UPlayer* OriginalPlayer;
    /* 0x0720 */ float SpeedScale;
    /* 0x0724 */ float InitialMaxSpeed;
    /* 0x0728 */ float InitialAccel;
    /* 0x072c */ float InitialDecel;

    AActor* GetSelectedActor() const;
    void ReceiveOnActivate(APlayerController* OriginalPC);
    void ReceiveOnActorSelected(AActor* NewSelectedActor, const FVector& SelectHitLocation, const FVector& SelectHitNormal, const FHitResult& Hit);
    void ReceiveOnDeactivate(APlayerController* RestoredPC);
    void SetPawnMovementSpeedScale(float NewSpeedScale);
    void ShowDebugSelectedInfo();
    void ToggleDisplay();
};

// Size: 0x70
class UDebugCameraControllerSettings : public UDeveloperSettings {
    /* 0x0060 */ TArray<FDebugCameraControllerSettingsViewModeIndex> CycleViewModes;
};

// Size: 0x10
struct FDebugCameraControllerSettingsViewModeIndex {
    /* 0x0008 */ uint8_t ViewModeIndex;
};

// Size: 0x3e8
class ADebugCameraHUD : public AHUD {
};

// Size: 0x20
struct FDebugDisplayProperty {
    /* 0x0000 */ UObject* Obj;
    /* 0x0008 */ UClass* WithinClass;
};

// Size: 0x30
class UDebugDrawService : public UBlueprintFunctionLibrary {
};

// Size: 0x20
struct FDebugFloatHistory {
    /* 0x0000 */ TArray<float> Samples;
    /* 0x0010 */ float MaxSamples;
    /* 0x0014 */ float MinValue;
    /* 0x0018 */ float MaxValue;
    /* 0x001c */ bool bAutoAdjustMinMax;
};

// Size: 0x60
struct FDebugTextInfo {
    /* 0x0000 */ AActor* SrcActor;
    /* 0x0008 */ FVector SrcActorOffset;
    /* 0x0014 */ FVector SrcActorDesiredOffset;
    /* 0x0020 */ FString DebugText;
    /* 0x0030 */ float TimeRemaining;
    /* 0x0034 */ float Duration;
    /* 0x0038 */ FColor TextColor;
    /* 0x003c */ bool bAbsoluteLocation;
    /* 0x003c */ bool bKeepAttachedToActor;
    /* 0x003c */ bool bDrawShadow;
    /* 0x0040 */ FVector OrigActorLocation;
    /* 0x0050 */ UFont* Font;
    /* 0x0058 */ float FontScale;
};

// Size: 0x190
struct FDebuggingInfoForSingleFunction {
};

// Size: 0x318
class ADecalActor : public AActor {
    /* 0x02f8 */ UDecalComponent* Decal;
    /* 0x0300 */ UArrowComponent* ArrowComponent;
    /* 0x0308 */ UBillboardComponent* SpriteComponent;
    /* 0x0310 */ UBoxComponent* BoxComponent;

    UMaterialInstanceDynamic* CreateDynamicMaterialInstance();
    UMaterialInterface* GetDecalMaterial() const;
    void SetDecalMaterial(UMaterialInterface* NewDecalMaterial);
};

// Size: 0x270
class UDecalComponent : public USceneComponent {
    /* 0x0228 */ UMaterialInterface* DecalMaterial;
    /* 0x0230 */ int32_t SortOrder;
    /* 0x0234 */ float FadeScreenSize;
    /* 0x0238 */ float FadeStartDelay;
    /* 0x023c */ float FadeDuration;
    /* 0x0240 */ float FadeInDuration;
    /* 0x0244 */ float FadeInStartDelay;
    /* 0x0248 */ bool bDestroyOwnerAfterFade;
    /* 0x024c */ FVector DecalSize;

    UMaterialInstanceDynamic* CreateDynamicMaterialInstance();
    UMaterialInterface* GetDecalMaterial() const;
    float GetFadeDuration() const;
    float GetFadeInDuration() const;
    float GetFadeInStartDelay() const;
    float GetFadeStartDelay() const;
    void SetDecalMaterial(UMaterialInterface* NewDecalMaterial);
    void SetFadeIn(float StartDelay, float Duaration);
    void SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade);
    void SetFadeScreenSize(float NewFadeScreenSize);
    void SetSortOrder(int32_t Value);
};

// Size: 0x20
struct FDefaultAudioBusSettings {
    /* 0x0000 */ FSoftObjectPath AudioBus;
};

// Size: 0x380
class ADefaultPawn : public APawn {
    /* 0x0358 */ float BaseTurnRate;
    /* 0x035c */ float BaseLookUpRate;
    /* 0x0360 */ UPawnMovementComponent* MovementComponent;
    /* 0x0368 */ USphereComponent* CollisionComponent;
    /* 0x0370 */ UStaticMeshComponent* MeshComponent;
    /* 0x0378 */ bool bAddDefaultMovementBindings;

    void LookUpAtRate(float Rate);
    void MoveForward(float Val);
    void MoveRight(float Val);
    void MoveUp_World(float Val);
    void TurnAtRate(float Rate);
};

// Size: 0x348
class ADefaultPhysicsVolume : public APhysicsVolume {
};

// Size: 0x10
struct FDelegateArray {
    /* 0x0000 */ TArray<FDelegate> Delegates;
};

// Size: 0x1ca8
class UDemoNetConnection : public UNetConnection {
};

// Size: 0x1340
class UDemoNetDriver : public UNetDriver {
    /* 0x08c0 */ TMap<FString, FRollbackNetStartupActorInfo> RollbackNetStartupActors;
    /* 0x0a6c */ float CheckpointSaveMaxMSPerFrame;
    /* 0x0a90 */ TArray<FMulticastRecordOptions> MulticastRecordOptions;
    /* 0x0aa0 */ bool bIsLocalReplay;
    /* 0x0aa8 */ TArray<APlayerController*> SpectatorControllers;
};

// Size: 0xc8
class UDemoPendingNetGame : public UPendingNetGame {
};

// Size: 0x24
struct FDepthFieldGlowInfo {
    /* 0x0000 */ bool bEnableGlow;
    /* 0x0004 */ FLinearColor GlowColor;
    /* 0x0014 */ FVector2D GlowOuterRadius;
    /* 0x001c */ FVector2D GlowInnerRadius;
};

// Size: 0x30
class IDestructibleInterface : public UInterface {
};

// Size: 0x100
class UDeviceProfile : public UTextureLODSettings {
    /* 0x0040 */ FString DeviceType;
    /* 0x0050 */ FString BaseProfileName;
    /* 0x0060 */ UObject* Parent;
    /* 0x0090 */ TArray<FString> CVars;
};

// Size: 0x40
class UDeviceProfileFragment : public UObject {
};

// Size: 0xd0
class UDeviceProfileManager : public UObject {
    /* 0x0030 */ TArray<UObject*> Profiles;
};

// Size: 0x18
struct FDialogueContext {
    /* 0x0000 */ UDialogueVoice* Speaker;
    /* 0x0008 */ TArray<UDialogueVoice*> Targets;
};

// Size: 0x38
struct FDialogueContextMapping {
    /* 0x0000 */ FDialogueContext Context;
    /* 0x0018 */ USoundWave* SoundWave;
    /* 0x0020 */ FString LocalizationKeyFormat;
    /* 0x0030 */ UDialogueSoundWaveProxy* Proxy;
};

// Size: 0x1a0
class UDialogueSoundWaveProxy : public USoundBase {
};

// Size: 0x48
class UDialogueVoice : public UObject {
    /* 0x0030 */ uint8_t Gender;
    /* 0x0031 */ uint8_t Plurality;
    /* 0x0034 */ FGuid LocalizationGUID;
};

// Size: 0x88
class UDialogueWave : public UObject {
    /* 0x0030 */ bool bMature;
    /* 0x0030 */ bool bOverride_SubtitleOverride;
    /* 0x0038 */ FString SpokenText;
    /* 0x0048 */ FString SubtitleOverride;
    /* 0x0058 */ FString VoiceActorDirection;
    /* 0x0068 */ TArray<FDialogueContextMapping> ContextMappings;
    /* 0x0078 */ FGuid LocalizationGUID;
};

// Size: 0x20
struct FDialogueWaveParameter {
    /* 0x0000 */ UDialogueWave* DialogueWave;
    /* 0x0008 */ FDialogueContext Context;
};

// Size: 0x318
class ADirectionalLight : public ALight {
    /* 0x0308 */ UArrowComponent* ArrowComponent;
    /* 0x0310 */ UDirectionalLightComponent* DirectionalLightComponent;
};

// Size: 0x440
class UDirectionalLightComponent : public ULightComponent {
    /* 0x0378 */ float ShadowCascadeBiasDistribution;
    /* 0x037c */ bool bEnableLightShaftOcclusion;
    /* 0x0380 */ float OcclusionMaskDarkness;
    /* 0x0384 */ float OcclusionDepthRange;
    /* 0x0388 */ FVector LightShaftOverrideDirection;
    /* 0x0394 */ float WholeSceneDynamicShadowRadius;
    /* 0x0398 */ float DynamicShadowDistanceMovableLight;
    /* 0x039c */ float DynamicShadowDistanceStationaryLight;
    /* 0x03a0 */ int32_t DynamicShadowCascades;
    /* 0x03a4 */ float CascadeDistributionExponent;
    /* 0x03a8 */ float CascadeTransitionFraction;
    /* 0x03ac */ float ShadowDistanceFadeoutFraction;
    /* 0x03b0 */ bool bUseInsetShadowsForMovableObjects;
    /* 0x03b4 */ int32_t FarShadowCascadeCount;
    /* 0x03b8 */ float FarShadowDistance;
    /* 0x03bc */ float DistanceFieldShadowDistance;
    /* 0x03c0 */ float LightSourceAngle;
    /* 0x03c4 */ float LightSourceSoftAngle;
    /* 0x03c8 */ float ShadowSourceAngleFactor;
    /* 0x03cc */ float TraceDistance;
    /* 0x03d0 */ bool bUsedAsAtmosphereSunLight;
    /* 0x03d4 */ int32_t AtmosphereSunLightIndex;
    /* 0x03d8 */ FLinearColor AtmosphereSunDiskColorScale;
    /* 0x03e8 */ bool bPerPixelAtmosphereTransmittance;
    /* 0x03e8 */ bool bCastShadowsOnClouds;
    /* 0x03e8 */ bool bCastShadowsOnAtmosphere;
    /* 0x03e8 */ bool bCastCloudShadows;
    /* 0x03ec */ float CloudShadowStrength;
    /* 0x03f0 */ float CloudShadowOnAtmosphereStrength;
    /* 0x03f4 */ float CloudShadowOnSurfaceStrength;
    /* 0x03f8 */ float CloudShadowDepthBias;
    /* 0x03fc */ float CloudShadowExtent;
    /* 0x0400 */ float CloudShadowMapResolutionScale;
    /* 0x0404 */ float CloudShadowRaySampleCountScale;
    /* 0x0408 */ FLinearColor CloudScatteredLuminanceScale;
    /* 0x0418 */ FLightmassDirectionalLightSettings LightmassSettings;
    /* 0x0428 */ bool bCastModulatedShadows;
    /* 0x042c */ FColor ModulatedShadowColor;
    /* 0x0430 */ float ShadowAmount;

    void SetAtmosphereSunLight(bool bNewValue);
    void SetAtmosphereSunLightIndex(int32_t NewValue);
    void SetCascadeDistributionExponent(float NewValue);
    void SetCascadeTransitionFraction(float NewValue);
    void SetDynamicShadowCascades(int32_t NewValue);
    void SetDynamicShadowDistanceMovableLight(float NewValue);
    void SetDynamicShadowDistanceStationaryLight(float NewValue);
    void SetEnableLightShaftOcclusion(bool bNewValue);
    void SetLightShaftOverrideDirection(FVector NewValue);
    void SetOcclusionMaskDarkness(float NewValue);
    void SetShadowAmount(float NewValue);
    void SetShadowDistanceFadeoutFraction(float NewValue);
};

// Size: 0x18
struct FDirectorTrackCut {
    /* 0x0000 */ float Time;
    /* 0x0004 */ float TransitionTime;
    /* 0x0008 */ FName TargetCamGroup;
    /* 0x0014 */ int32_t ShotNumber;
};

// Size: 0x10
struct FDirectoryPath {
    /* 0x0000 */ FString Path;
};

// Size: 0x14
struct FDistanceDatum {
    /* 0x0000 */ float FadeInDistanceStart;
    /* 0x0004 */ float FadeInDistanceEnd;
    /* 0x0008 */ float FadeOutDistanceStart;
    /* 0x000c */ float FadeOutDistanceEnd;
    /* 0x0010 */ float Volume;
};

// Size: 0x38
class UDistribution : public UObject {
};

// Size: 0x40
class UDistributionFloat : public UDistribution {
    /* 0x0038 */ bool bCanBeBaked;
    /* 0x0038 */ bool bBakedDataSuccesfully;
};

// Size: 0x48
class UDistributionFloatConstant : public UDistributionFloat {
    /* 0x0040 */ float Constant;
};

// Size: 0x58
class UDistributionFloatConstantCurve : public UDistributionFloat {
    /* 0x0040 */ FInterpCurveFloat ConstantCurve;
};

// Size: 0x68
class UDistributionFloatParameterBase : public UDistributionFloatConstant {
    /* 0x0048 */ FName ParameterName;
    /* 0x0054 */ float MinInput;
    /* 0x0058 */ float MaxInput;
    /* 0x005c */ float MinOutput;
    /* 0x0060 */ float MaxOutput;
    /* 0x0064 */ uint8_t ParamMode;
};

// Size: 0x68
class UDistributionFloatParticleParameter : public UDistributionFloatParameterBase {
};

// Size: 0x48
class UDistributionFloatUniform : public UDistributionFloat {
    /* 0x0040 */ float Min;
    /* 0x0044 */ float Max;
};

// Size: 0x58
class UDistributionFloatUniformCurve : public UDistributionFloat {
    /* 0x0040 */ FInterpCurveVector2D ConstantCurve;
};

// Size: 0x20
struct FDistributionLookupTable {
    /* 0x0000 */ float TimeScale;
    /* 0x0004 */ float TimeBias;
    /* 0x0008 */ TArray<float> Values;
    /* 0x0018 */ uint8_t Op;
    /* 0x0019 */ uint8_t EntryCount;
    /* 0x001a */ uint8_t EntryStride;
    /* 0x001b */ uint8_t SubEntryStride;
    /* 0x001c */ uint8_t LockFlag;
};

enum class DistributionParamMode {
    DPM_Normal = 0,
    DPM_Abs = 1,
    DPM_Direct = 2,
    DPM_MAX = 3,
};

// Size: 0x40
class UDistributionVector : public UDistribution {
    /* 0x0038 */ bool bCanBeBaked;
    /* 0x0038 */ bool bIsDirty;
    /* 0x0038 */ bool bBakedDataSuccesfully;
};

// Size: 0x58
class UDistributionVectorConstant : public UDistributionVector {
    /* 0x0040 */ FVector Constant;
    /* 0x004c */ bool bLockAxes;
    /* 0x0050 */ uint8_t LockedAxes;
};

// Size: 0x60
class UDistributionVectorConstantCurve : public UDistributionVector {
    /* 0x0040 */ FInterpCurveVector ConstantCurve;
    /* 0x0058 */ bool bLockAxes;
    /* 0x005c */ uint8_t LockedAxes;
};

// Size: 0x98
class UDistributionVectorParameterBase : public UDistributionVectorConstant {
    /* 0x0058 */ FName ParameterName;
    /* 0x0064 */ FVector MinInput;
    /* 0x0070 */ FVector MaxInput;
    /* 0x007c */ FVector MinOutput;
    /* 0x0088 */ FVector MaxOutput;
    /* 0x0094 */ uint8_t ParamModes[3];
};

// Size: 0x98
class UDistributionVectorParticleParameter : public UDistributionVectorParameterBase {
};

// Size: 0x68
class UDistributionVectorUniform : public UDistributionVector {
    /* 0x0040 */ FVector Max;
    /* 0x004c */ FVector Min;
    /* 0x0058 */ bool bLockAxes;
    /* 0x005c */ uint8_t LockedAxes;
    /* 0x005d */ uint8_t MirrorFlags[3];
    /* 0x0060 */ bool bUseExtremes;
};

// Size: 0x68
class UDistributionVectorUniformCurve : public UDistributionVector {
    /* 0x0040 */ FInterpCurveTwoVectors ConstantCurve;
    /* 0x0058 */ bool bLockAxes1;
    /* 0x0058 */ bool bLockAxes2;
    /* 0x005c */ uint8_t LockedAxes[2];
    /* 0x005e */ uint8_t MirrorFlags[3];
    /* 0x0064 */ bool bUseExtremes;
};

// Size: 0x318
class ADocumentationActor : public AActor {
    /* 0x02f8 */ FString DocumentLink;
    /* 0x0308 */ UMaterialBillboardComponent* Billboard;
};

// Size: 0x500
class UDrawFrustumComponent : public UPrimitiveComponent {
    /* 0x04d8 */ FColor FrustumColor;
    /* 0x04dc */ float FrustumAngle;
    /* 0x04e0 */ float FrustumAspectRatio;
    /* 0x04e4 */ float FrustumStartDist;
    /* 0x04e8 */ float FrustumEndDist;
    /* 0x04f0 */ UTexture* Texture;
};

// Size: 0x500
class UDrawSphereComponent : public USphereComponent {
};

// Size: 0x10
struct FDrawToRenderTargetContext {
    /* 0x0000 */ UTextureRenderTarget2D* RenderTarget;
};

// Size: 0x28
struct FDropNoteInfo {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FRotator Rotation;
    /* 0x0018 */ FString Comment;
};

// Size: 0x1
struct FDummySpacerCameraTypes {
};

// Size: 0x30
class UDynamicBlueprintBinding : public UObject {
};

// Size: 0x38
class UDynamicSubsystem : public USubsystem {
};

// Size: 0x38
struct FDynamicTextureInstance : public FStreamableTextureInstance {
    /* 0x0028 */ UTexture2D* Texture;
    /* 0x0030 */ bool bAttached;
    /* 0x0034 */ float OriginalRadius;
};

enum class EActorUpdateOverlapsMethod {
    UseConfigDefault = 0,
    AlwaysUpdate = 1,
    OnlyUpdateMovable = 2,
    NeverUpdate = 3,
    EActorUpdateOverlapsMethod_MAX = 4,
};

enum class EAdManagerDelegate {
    AMD_ClickedBanner = 0,
    AMD_UserClosedAd = 1,
    AMD_MAX = 2,
};

enum class EAdditiveAnimationType {
    AAT_None = 0,
    AAT_LocalSpaceBase = 1,
    AAT_RotationOffsetMeshSpace = 2,
    AAT_MAX = 3,
};

enum class EAdditiveBasePoseType {
    ABPT_None = 0,
    ABPT_RefPose = 1,
    ABPT_AnimScaled = 2,
    ABPT_AnimFrame = 3,
    ABPT_MAX = 4,
};

enum class EAirAbsorptionMethod {
    Linear = 0,
    CustomCurve = 1,
    EAirAbsorptionMethod_MAX = 2,
};

enum class EAlphaBlendOption {
    Linear = 0,
    Cubic = 1,
    HermiteCubic = 2,
    Sinusoidal = 3,
    QuadraticInOut = 4,
    CubicInOut = 5,
    QuarticInOut = 6,
    QuinticInOut = 7,
    CircularIn = 8,
    CircularOut = 9,
    CircularInOut = 10,
    ExpIn = 11,
    ExpOut = 12,
    ExpInOut = 13,
    Custom = 14,
    EAlphaBlendOption_MAX = 15,
};

enum class EAlphaChannelMode {
    Disabled = 0,
    LinearColorSpaceOnly = 1,
    AllowThroughTonemapper = 2,
    EAlphaChannelMode_MAX = 3,
};

enum class EAngularDriveMode {
    SLERP = 0,
    TwistAndSwing = 1,
    EAngularDriveMode_MAX = 2,
};

enum class EAnimAlphaInputType {
    Float = 0,
    Bool = 1,
    Curve = 2,
    EAnimAlphaInputType_MAX = 3,
};

enum class EAnimAssetCurveFlags {
    AACF_NONE = 0,
    AACF_DriveMorphTarget_DEPRECATED = 1,
    AACF_DriveAttribute_DEPRECATED = 2,
    AACF_Editable = 4,
    AACF_DriveMaterial_DEPRECATED = 8,
    AACF_Metadata = 16,
    AACF_DriveTrack = 32,
    AACF_Disabled = 64,
    AACF_MAX = 65,
};

enum class EAnimCurveType {
    AttributeCurve = 0,
    MaterialCurve = 1,
    MorphTargetCurve = 2,
    MaxAnimCurveType = 3,
    EAnimCurveType_MAX = 4,
};

enum class EAnimGroupRole {
    CanBeLeader = 0,
    AlwaysFollower = 1,
    AlwaysLeader = 2,
    TransitionLeader = 3,
    TransitionFollower = 4,
    EAnimGroupRole_MAX = 5,
};

enum class EAnimInterpolationType {
    Linear = 0,
    Step = 1,
    EAnimInterpolationType_MAX = 2,
};

enum class EAnimLinkMethod {
    Absolute = 0,
    Relative = 1,
    Proportional = 2,
    EAnimLinkMethod_MAX = 3,
};

enum class EAnimNotifyEventType {
    Begin = 0,
    End = 1,
    EAnimNotifyEventType_MAX = 2,
};

enum class EAnimSyncGroupScope {
    Local = 0,
    Component = 1,
    EAnimSyncGroupScope_MAX = 2,
};

enum class EAnimationMode {
    AnimationBlueprint = 0,
    AnimationSingleNode = 1,
    AnimationCustomMode = 2,
    EAnimationMode_MAX = 3,
};

enum class EAntiAliasingMethod {
    AAM_None = 0,
    AAM_FXAA = 1,
    AAM_TemporalAA = 2,
    AAM_MSAA = 3,
    AAM_MAX = 4,
};

enum class EApplicationState {
    Unknown = 0,
    Inactive = 1,
    Background = 2,
    Active = 3,
    EApplicationState_MAX = 4,
};

enum class EAspectRatioAxisConstraint {
    AspectRatio_MaintainYFOV = 0,
    AspectRatio_MaintainXFOV = 1,
    AspectRatio_MajorAxisFOV = 2,
    AspectRatio_MAX = 3,
};

enum class EAttachLocation {
    KeepRelativeOffset = 0,
    KeepWorldPosition = 1,
    SnapToTarget = 2,
    SnapToTargetIncludingScale = 3,
    EAttachLocation_MAX = 4,
};

enum class EAttachmentRule {
    KeepRelative = 0,
    KeepWorld = 1,
    SnapToTarget = 2,
    EAttachmentRule_MAX = 3,
};

enum class EAttenuationDistanceModel {
    Linear = 0,
    Logarithmic = 1,
    Inverse = 2,
    LogReverse = 3,
    NaturalSound = 4,
    Custom = 5,
    EAttenuationDistanceModel_MAX = 6,
};

enum class EAttenuationShape {
    Sphere = 0,
    Capsule = 1,
    Box = 2,
    Cone = 3,
    EAttenuationShape_MAX = 4,
};

enum class EAttractorParticleSelectionMethod {
    EAPSM_Random = 0,
    EAPSM_Sequential = 1,
    EAPSM_MAX = 2,
};

enum class EAudioBusChannels {
    Mono = 0,
    Stereo = 1,
    EAudioBusChannels_MAX = 2,
};

enum class EAudioComponentPlayState {
    Playing = 0,
    Stopped = 1,
    Paused = 2,
    FadingIn = 3,
    FadingOut = 4,
    Count = 5,
    EAudioComponentPlayState_MAX = 6,
};

enum class EAudioFaderCurve {
    Linear = 0,
    Logarithmic = 1,
    SCurve = 2,
    Sin = 3,
    Count = 4,
    EAudioFaderCurve_MAX = 5,
};

enum class EAudioOutputTarget {
    Speaker = 0,
    Controller = 1,
    ControllerFallbackToSpeaker = 2,
    EAudioOutputTarget_MAX = 3,
};

enum class EAudioRecordingExportType {
    SoundWave = 0,
    WavFile = 1,
    EAudioRecordingExportType_MAX = 2,
};

enum class EAudioSpectrumBandPresetType {
    KickDrum = 0,
    SnareDrum = 1,
    Voice = 2,
    Cymbals = 3,
    EAudioSpectrumBandPresetType_MAX = 4,
};

enum class EAudioSpectrumType {
    MagnitudeSpectrum = 0,
    PowerSpectrum = 1,
    Decibel = 2,
    EAudioSpectrumType_MAX = 3,
};

enum class EAudioVolumeLocationState {
    InsideTheVolume = 0,
    OutsideTheVolume = 1,
    EAudioVolumeLocationState_MAX = 2,
};

enum class EAutoExposureMethod {
    AEM_Histogram = 0,
    AEM_Basic = 1,
    AEM_Manual = 2,
    AEM_MAX = 3,
};

enum class EAutoExposureMethodUI {
    AEM_Histogram = 0,
    AEM_Basic = 1,
    AEM_Manual = 2,
    AEM_MAX = 3,
};

enum class EAutoPossessAI {
    Disabled = 0,
    PlacedInWorld = 1,
    Spawned = 2,
    PlacedInWorldOrSpawned = 3,
    EAutoPossessAI_MAX = 4,
};

enum class EAutoReceiveInput {
    Disabled = 0,
    Player0 = 1,
    Player1 = 2,
    Player2 = 3,
    Player3 = 4,
    Player4 = 5,
    Player5 = 6,
    Player6 = 7,
    Player7 = 8,
    EAutoReceiveInput_MAX = 9,
};

enum class EAxisOption {
    X = 0,
    Y = 1,
    Z = 2,
    X_Neg = 3,
    Y_Neg = 4,
    Z_Neg = 5,
    Custom = 6,
    EAxisOption_MAX = 7,
};

enum class EBeam2Method {
    PEB2M_Distance = 0,
    PEB2M_Target = 1,
    PEB2M_Branch = 2,
    PEB2M_MAX = 3,
};

enum class EBeamTaperMethod {
    PEBTM_None = 0,
    PEBTM_Full = 1,
    PEBTM_Partial = 2,
    PEBTM_MAX = 3,
};

enum class EBlendMode {
    BLEND_Opaque = 0,
    BLEND_Masked = 1,
    BLEND_Translucent = 2,
    BLEND_Additive = 3,
    BLEND_Modulate = 4,
    BLEND_AlphaComposite = 5,
    BLEND_AlphaHoldout = 6,
    BLEND_MAX = 7,
};

enum class EBlendSpaceAxis {
    BSA_None = 0,
    BSA_X = 1,
    BSA_Y = 2,
    BSA_Max = 3,
    BSA_Max = 4,
};

enum class EBlendableLocation {
    BL_AfterTonemapping = 0,
    BL_BeforeTonemapping = 1,
    BL_BeforeTranslucency = 2,
    BL_ReplacingTonemapper = 3,
    BL_SSRInput = 4,
    BL_MAX = 5,
};

enum class EBloomMethod {
    BM_SOG = 0,
    BM_FFT = 1,
    BM_MAX = 2,
};

enum class EBlueprintCompileMode {
    Default = 0,
    Development = 1,
    FinalRelease = 2,
    EBlueprintCompileMode_MAX = 3,
};

enum class EBlueprintNativizationFlag {
    Disabled = 0,
    Dependency = 1,
    ExplicitlyEnabled = 2,
    EBlueprintNativizationFlag_MAX = 3,
};

enum class EBlueprintPinStyleType {
    BPST_Original = 0,
    BPST_VariantA = 1,
    BPST_MAX = 2,
};

enum class EBlueprintStatus {
    BS_Unknown = 0,
    BS_Dirty = 1,
    BS_Error = 2,
    BS_UpToDate = 3,
    BS_BeingCreated = 4,
    BS_UpToDateWithWarnings = 5,
    BS_MAX = 6,
};

enum class EBlueprintType {
    BPTYPE_Normal = 0,
    BPTYPE_Const = 1,
    BPTYPE_MacroLibrary = 2,
    BPTYPE_Interface = 3,
    BPTYPE_LevelScript = 4,
    BPTYPE_FunctionLibrary = 5,
    BPTYPE_MAX = 6,
};

enum class EBoneAxis {
    BA_X = 0,
    BA_Y = 1,
    BA_Z = 2,
    BA_MAX = 3,
};

enum class EBoneControlSpace {
    BCS_WorldSpace = 0,
    BCS_ComponentSpace = 1,
    BCS_ParentBoneSpace = 2,
    BCS_BoneSpace = 3,
    BCS_MAX = 4,
};

enum class EBoneFilterActionOption {
    Remove = 0,
    Keep = 1,
    Invalid = 2,
    EBoneFilterActionOption_MAX = 3,
};

enum class EBoneRotationSource {
    BRS_KeepComponentSpaceRotation = 0,
    BRS_KeepLocalSpaceRotation = 1,
    BRS_CopyFromTarget = 2,
    BRS_MAX = 3,
};

enum class EBoneSpaces {
    WorldSpace = 0,
    ComponentSpace = 1,
    EBoneSpaces_MAX = 2,
};

enum class EBoneTranslationRetargetingMode {
    Animation = 0,
    Skeleton = 1,
    AnimationScaled = 2,
    AnimationRelative = 3,
    OrientAndScale = 4,
    EBoneTranslationRetargetingMode_MAX = 5,
};

enum class EBoneVisibilityStatus {
    BVS_HiddenByParent = 0,
    BVS_Visible = 1,
    BVS_ExplicitlyHidden = 2,
    BVS_MAX = 3,
};

enum class EBrushType {
    Brush_Default = 0,
    Brush_Add = 1,
    Brush_Subtract = 2,
    Brush_MAX = 3,
};

enum class ECameraAlphaBlendMode {
    CABM_Linear = 0,
    CABM_Cubic = 1,
    CABM_MAX = 2,
};

enum class ECameraProjectionMode {
    Perspective = 0,
    Orthographic = 1,
    ECameraProjectionMode_MAX = 2,
};

enum class ECameraShakeAttenuation {
    Linear = 0,
    Quadratic = 1,
    ECameraShakeAttenuation_MAX = 2,
};

enum class ECameraShakeDurationType {
    Fixed = 0,
    Infinite = 1,
    Custom = 2,
    ECameraShakeDurationType_MAX = 3,
};

enum class ECameraShakePlaySpace {
    CameraLocal = 0,
    World = 1,
    UserDefined = 2,
    ECameraShakePlaySpace_MAX = 3,
};

enum class ECameraShakeUpdateResultFlags {
    ApplyAsAbsolute = 1,
    SkipAutoScale = 2,
    SkipAutoPlaySpace = 4,
    Default = 0,
    ECameraShakeUpdateResultFlags_MAX = 5,
};

enum class ECanBeCharacterBase {
    ECB_No = 0,
    ECB_Yes = 1,
    ECB_Owner = 2,
    ECB_MAX = 3,
};

enum class ECanCreateConnectionResponse {
    CONNECT_RESPONSE_MAKE = 0,
    CONNECT_RESPONSE_DISALLOW = 1,
    CONNECT_RESPONSE_BREAK_OTHERS_A = 2,
    CONNECT_RESPONSE_BREAK_OTHERS_B = 3,
    CONNECT_RESPONSE_BREAK_OTHERS_AB = 4,
    CONNECT_RESPONSE_MAKE_WITH_CONVERSION_NODE = 5,
    CONNECT_RESPONSE_MAX = 6,
};

enum class EChannelMaskParameterColor {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
    EChannelMaskParameterColor_MAX = 4,
};

enum class EChildActorComponentTreeViewVisualizationMode {
    UseDefault = 0,
    ComponentOnly = 1,
    ComponentWithChildActor = 2,
    ChildActorOnly = 3,
    EChildActorComponentTreeViewVisualizationMode_MAX = 4,
};

enum class EClampMode {
    CMODE_Clamp = 0,
    CMODE_ClampMin = 1,
    CMODE_ClampMax = 2,
    CMODE_MAX = 3,
};

enum class EClearSceneOptions {
    NoClear = 0,
    HardwareClear = 1,
    QuadAtMaxZ = 2,
    EClearSceneOptions_MAX = 3,
};

enum class ECloudStorageDelegate {
    CSD_KeyValueReadComplete = 0,
    CSD_KeyValueWriteComplete = 1,
    CSD_ValueChanged = 2,
    CSD_DocumentQueryComplete = 3,
    CSD_DocumentReadComplete = 4,
    CSD_DocumentWriteComplete = 5,
    CSD_DocumentConflictDetected = 6,
    CSD_MAX = 7,
};

enum class ECollisionChannel {
    ECC_WorldStatic = 0,
    ECC_WorldDynamic = 1,
    ECC_Pawn = 2,
    ECC_Visibility = 3,
    ECC_Camera = 4,
    ECC_PhysicsBody = 5,
    ECC_Vehicle = 6,
    ECC_Destructible = 7,
    ECC_EngineTraceChannel1 = 8,
    ECC_EngineTraceChannel2 = 9,
    ECC_EngineTraceChannel3 = 10,
    ECC_EngineTraceChannel4 = 11,
    ECC_EngineTraceChannel5 = 12,
    ECC_EngineTraceChannel6 = 13,
    ECC_GameTraceChannel1 = 14,
    ECC_GameTraceChannel2 = 15,
    ECC_GameTraceChannel3 = 16,
    ECC_GameTraceChannel4 = 17,
    ECC_GameTraceChannel5 = 18,
    ECC_GameTraceChannel6 = 19,
    ECC_GameTraceChannel7 = 20,
    ECC_GameTraceChannel8 = 21,
    ECC_GameTraceChannel9 = 22,
    ECC_GameTraceChannel10 = 23,
    ECC_GameTraceChannel11 = 24,
    ECC_GameTraceChannel12 = 25,
    ECC_GameTraceChannel13 = 26,
    ECC_GameTraceChannel14 = 27,
    ECC_GameTraceChannel15 = 28,
    ECC_GameTraceChannel16 = 29,
    ECC_GameTraceChannel17 = 30,
    ECC_GameTraceChannel18 = 31,
    ECC_OverlapAll_Deprecated = 32,
    ECC_MAX = 33,
};

enum class ECollisionEnabled {
    NoCollision = 0,
    QueryOnly = 1,
    PhysicsOnly = 2,
    QueryAndPhysics = 3,
    ECollisionEnabled_MAX = 4,
};

enum class ECollisionResponse {
    ECR_Ignore = 0,
    ECR_Overlap = 1,
    ECR_Block = 2,
    ECR_MAX = 3,
};

enum class EComponentCreationMethod {
    Native = 0,
    SimpleConstructionScript = 1,
    UserConstructionScript = 2,
    Instance = 3,
    EComponentCreationMethod_MAX = 4,
};

enum class EComponentMobility {
    Static = 0,
    Stationary = 1,
    Movable = 2,
    EComponentMobility_MAX = 3,
};

enum class EComponentSocketType {
    Invalid = 0,
    Bone = 1,
    Socket = 2,
    EComponentSocketType_MAX = 3,
};

enum class EComponentType {
    None = 0,
    TranslationX = 1,
    TranslationY = 2,
    TranslationZ = 3,
    RotationX = 4,
    RotationY = 5,
    RotationZ = 6,
    Scale = 7,
    ScaleX = 8,
    ScaleY = 9,
    ScaleZ = 10,
    EComponentType_MAX = 11,
};

enum class ECompositeTextureMode {
    CTM_Disabled = 0,
    CTM_NormalRoughnessToRed = 1,
    CTM_NormalRoughnessToGreen = 2,
    CTM_NormalRoughnessToBlue = 3,
    CTM_NormalRoughnessToAlpha = 4,
    CTM_MAX = 5,
};

enum class ECompositingSampleCount {
    One = 1,
    Two = 2,
    Four = 4,
    Eight = 8,
    ECompositingSampleCount_MAX = 9,
};

enum class EConcurrencyVolumeScaleMode {
    Default = 0,
    Distance = 1,
    Priority = 2,
    EConcurrencyVolumeScaleMode_MAX = 3,
};

enum class EConstraintTransform {
    Absolute = 0,
    Relative = 1,
    EConstraintTransform_MAX = 2,
};

enum class EControlConstraint {
    Orientation = 0,
    Translation = 1,
    MAX = 2,
};

enum class EControllerAnalogStick {
    CAS_LeftStick = 0,
    CAS_RightStick = 1,
    CAS_MAX = 2,
};

enum class ECsgOper {
    CSG_Active = 0,
    CSG_Add = 1,
    CSG_Subtract = 2,
    CSG_Intersect = 3,
    CSG_Deintersect = 4,
    CSG_None = 5,
    CSG_MAX = 6,
};

enum class ECurveBlendOption {
    Override = 0,
    DoNotOverride = 1,
    NormalizeByWeight = 2,
    BlendByWeight = 3,
    UseBasePose = 4,
    UseMaxValue = 5,
    UseMinValue = 6,
    ECurveBlendOption_MAX = 7,
};

enum class ECurveTableMode {
    Empty = 0,
    SimpleCurves = 1,
    RichCurves = 2,
    ECurveTableMode_MAX = 3,
};

enum class ECustomAttributeBlendType {
    Override = 0,
    Blend = 1,
    ECustomAttributeBlendType_MAX = 2,
};

enum class ECustomBoneAttributeLookup {
    BoneOnly = 0,
    ImmediateParent = 1,
    ParentHierarchy = 2,
    ECustomBoneAttributeLookup_MAX = 3,
};

enum class ECustomDepthStencil {
    Disabled = 0,
    Enabled = 1,
    EnabledOnDemand = 2,
    EnabledWithStencil = 3,
    ECustomDepthStencil_MAX = 4,
};

enum class ECustomMaterialOutputType {
    CMOT_Float1 = 0,
    CMOT_Float2 = 1,
    CMOT_Float3 = 2,
    CMOT_Float4 = 3,
    CMOT_MaterialAttributes = 4,
    CMOT_MAX = 5,
};

enum class ECustomTimeStepSynchronizationState {
    Closed = 0,
    Error = 1,
    Synchronized = 2,
    Synchronizing = 3,
    ECustomTimeStepSynchronizationState_MAX = 4,
};

enum class EDOFMode {
    Default = 0,
    SixDOF = 1,
    YZPlane = 2,
    XZPlane = 3,
    XYPlane = 4,
    CustomPlane = 5,
    None = 6,
    EDOFMode_MAX = 7,
};

enum class EDecalBlendMode {
    DBM_Translucent = 0,
    DBM_Stain = 1,
    DBM_Normal = 2,
    DBM_Emissive = 3,
    DBM_DBuffer_ColorNormalRoughness = 4,
    DBM_DBuffer_Color = 5,
    DBM_DBuffer_ColorNormal = 6,
    DBM_DBuffer_ColorRoughness = 7,
    DBM_DBuffer_Normal = 8,
    DBM_DBuffer_NormalRoughness = 9,
    DBM_DBuffer_Roughness = 10,
    DBM_DBuffer_Emissive = 11,
    DBM_DBuffer_AlphaComposite = 12,
    DBM_DBuffer_EmissiveAlphaComposite = 13,
    DBM_Volumetric_DistanceFunction = 14,
    DBM_AlphaComposite = 15,
    DBM_AmbientOcclusion = 16,
    DBM_MAX = 17,
};

enum class EDecompressionType {
    DTYPE_Setup = 0,
    DTYPE_Invalid = 1,
    DTYPE_Preview = 2,
    DTYPE_Native = 3,
    DTYPE_RealTime = 4,
    DTYPE_Procedural = 5,
    DTYPE_Xenon = 6,
    DTYPE_Streaming = 7,
    DTYPE_MAX = 8,
};

enum class EDefaultBackBufferPixelFormat {
    DBBPF_B8G8R8A8 = 0,
    DBBPF_A16B16G16R16_DEPRECATED = 1,
    DBBPF_FloatRGB_DEPRECATED = 2,
    DBBPF_FloatRGBA = 3,
    DBBPF_A2B10G10R10 = 4,
    DBBPF_MAX = 5,
};

enum class EDemoPlayFailure {
    Generic = 0,
    DemoNotFound = 1,
    Corrupt = 2,
    InvalidVersion = 3,
    InitBase = 4,
    GameSpecificHeader = 5,
    ReplayStreamerInternal = 6,
    LoadMap = 7,
    Serialization = 8,
    EDemoPlayFailure_MAX = 9,
};

enum class EDepthOfFieldFunctionValue {
    TDOF_NearAndFarMask = 0,
    TDOF_NearMask = 1,
    TDOF_FarMask = 2,
    TDOF_CircleOfConfusionRadius = 3,
    TDOF_MAX = 4,
};

enum class EDepthOfFieldMethod {
    DOFM_BokehDOF = 0,
    DOFM_Gaussian = 1,
    DOFM_CircleDOF = 2,
    DOFM_MAX = 3,
};

enum class EDetachmentRule {
    KeepRelative = 0,
    KeepWorld = 1,
    EDetachmentRule_MAX = 2,
};

enum class EDetailMode {
    DM_Low = 0,
    DM_Medium = 1,
    DM_High = 2,
    DM_MAX = 3,
};

enum class EDistributionVectorLockFlags {
    EDVLF_None = 0,
    EDVLF_XY = 1,
    EDVLF_XZ = 2,
    EDVLF_YZ = 3,
    EDVLF_XYZ = 4,
    EDVLF_MAX = 5,
};

enum class EDistributionVectorMirrorFlags {
    EDVMF_Same = 0,
    EDVMF_Different = 1,
    EDVMF_Mirror = 2,
    EDVMF_MAX = 3,
};

enum class EDrawDebugItemType {
    DirectionalArrow = 0,
    Sphere = 1,
    Line = 2,
    OnScreenMessage = 3,
    CoordinateSystem = 4,
    EDrawDebugItemType_MAX = 5,
};

enum class EDrawDebugTrace {
    None = 0,
    ForOneFrame = 1,
    ForDuration = 2,
    Persistent = 3,
    EDrawDebugTrace_MAX = 4,
};

enum class EDynamicForceFeedbackAction {
    Start = 0,
    Update = 1,
    Stop = 2,
    EDynamicForceFeedbackAction_MAX = 3,
};

enum class EEarlyZPass {
    None = 0,
    OpaqueOnly = 1,
    OpaqueAndMasked = 2,
    Auto = 3,
    EEarlyZPass_MAX = 4,
};

enum class EEasingFunc {
    Linear = 0,
    Step = 1,
    SinusoidalIn = 2,
    SinusoidalOut = 3,
    SinusoidalInOut = 4,
    EaseIn = 5,
    EaseOut = 6,
    EaseInOut = 7,
    ExpoIn = 8,
    ExpoOut = 9,
    ExpoInOut = 10,
    CircularIn = 11,
    CircularOut = 12,
    CircularInOut = 13,
    EEasingFunc_MAX = 14,
};

enum class EEdGraphPinDirection {
    EGPD_Input = 0,
    EGPD_Output = 1,
    EGPD_MAX = 2,
};

enum class EEmitterDynamicParameterValue {
    EDPV_UserSet = 0,
    EDPV_AutoSet = 1,
    EDPV_VelocityX = 2,
    EDPV_VelocityY = 3,
    EDPV_VelocityZ = 4,
    EDPV_VelocityMag = 5,
    EDPV_MAX = 6,
};

enum class EEmitterNormalsMode {
    ENM_CameraFacing = 0,
    ENM_Spherical = 1,
    ENM_Cylindrical = 2,
    ENM_MAX = 3,
};

enum class EEmitterRenderMode {
    ERM_Normal = 0,
    ERM_Point = 1,
    ERM_Cross = 2,
    ERM_LightsOnly = 3,
    ERM_None = 4,
    ERM_MAX = 5,
};

enum class EEndPlayReason {
    Destroyed = 0,
    LevelTransition = 1,
    EndPlayInEditor = 2,
    RemovedFromWorld = 3,
    Quit = 4,
    EEndPlayReason_MAX = 5,
};

enum class EEvaluateCurveTableResult {
    RowFound = 0,
    RowNotFound = 1,
    EEvaluateCurveTableResult_MAX = 2,
};

enum class EEvaluatorDataSource {
    EDS_SourcePose = 0,
    EDS_DestinationPose = 1,
    EDS_MAX = 2,
};

enum class EEvaluatorMode {
    EM_Standard = 0,
    EM_Freeze = 1,
    EM_DelayedFreeze = 2,
    EM_MAX = 3,
};

enum class EFFTPeakInterpolationMethod {
    NearestNeighbor = 0,
    Linear = 1,
    Quadratic = 2,
    ConstantQ = 3,
    EFFTPeakInterpolationMethod_MAX = 4,
};

enum class EFFTSize {
    DefaultSize = 0,
    Min = 1,
    Small = 2,
    Medium = 3,
    Large = 4,
    VeryLarge = 5,
    Max = 6,
    EFFTSize_MAX = 7,
};

enum class EFFTWindowType {
    None = 0,
    Hamming = 1,
    Hann = 2,
    Blackman = 3,
    EFFTWindowType_MAX = 4,
};

enum class EFastArraySerializerDeltaFlags {
    None = 0,
    HasBeenSerialized = 1,
    HasDeltaBeenRequested = 2,
    IsUsingDeltaSerialization = 4,
    EFastArraySerializerDeltaFlags_MAX = 5,
};

enum class EFilterInterpolationType {
    BSIT_Average = 0,
    BSIT_Linear = 1,
    BSIT_Cubic = 2,
    BSIT_MAX = 3,
};

enum class EFixedFoveationLevels {
    Disabled = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    EFixedFoveationLevels_MAX = 4,
};

enum class EFontCacheType {
    Offline = 0,
    Runtime = 1,
    EFontCacheType_MAX = 2,
};

enum class EFontImportCharacterSet {
    FontICS_Default = 0,
    FontICS_Ansi = 1,
    FontICS_Symbol = 2,
    FontICS_MAX = 3,
};

enum class EFormatArgumentType {
    Int = 0,
    UInt = 1,
    Float = 2,
    Double = 3,
    Text = 4,
    Gender = 5,
    EFormatArgumentType_MAX = 6,
};

enum class EFullyLoadPackageType {
    FULLYLOAD_Map = 0,
    FULLYLOAD_Game_PreLoadClass = 1,
    FULLYLOAD_Game_PostLoadClass = 2,
    FULLYLOAD_Always = 3,
    FULLYLOAD_Mutator = 4,
    FULLYLOAD_MAX = 5,
};

enum class EFunctionInputType {
    FunctionInput_Scalar = 0,
    FunctionInput_Vector2 = 1,
    FunctionInput_Vector3 = 2,
    FunctionInput_Vector4 = 3,
    FunctionInput_Texture2D = 4,
    FunctionInput_TextureCube = 5,
    FunctionInput_Texture2DArray = 6,
    FunctionInput_VolumeTexture = 7,
    FunctionInput_StaticBool = 8,
    FunctionInput_MaterialAttributes = 9,
    FunctionInput_TextureExternal = 10,
    FunctionInput_MAX = 11,
};

enum class EGBufferFormat {
    Force8BitsPerChannel = 0,
    Default = 1,
    HighPrecisionNormals = 3,
    Force16BitsPerChannel = 5,
    EGBufferFormat_MAX = 6,
};

enum class EGainParamMode {
    Linear = 0,
    Decibels = 1,
    EGainParamMode_MAX = 2,
};

enum class EGrammaticalGender {
    Neuter = 0,
    Masculine = 1,
    Feminine = 2,
    Mixed = 3,
    EGrammaticalGender_MAX = 4,
};

enum class EGrammaticalNumber {
    Singular = 0,
    Plural = 1,
    EGrammaticalNumber_MAX = 2,
};

enum class EGraphAxisStyle {
    Lines = 0,
    Notches = 1,
    Grid = 2,
    EGraphAxisStyle_MAX = 3,
};

enum class EGraphDataStyle {
    Lines = 0,
    Filled = 1,
    EGraphDataStyle_MAX = 2,
};

enum class EGraphType {
    GT_Function = 0,
    GT_Ubergraph = 1,
    GT_Macro = 2,
    GT_Animation = 3,
    GT_StateMachine = 4,
    GT_MAX = 5,
};

enum class EHasCustomNavigableGeometry {
    No = 0,
    Yes = 1,
    EvenIfNotCollidable = 2,
    DontExport = 3,
    EHasCustomNavigableGeometry_MAX = 4,
};

enum class EHitProxyPriority {
    HPP_World = 0,
    HPP_Wireframe = 1,
    HPP_Foreground = 2,
    HPP_UI = 3,
    HPP_MAX = 4,
};

enum class EHorizTextAligment {
    EHTA_Left = 0,
    EHTA_Center = 1,
    EHTA_Right = 2,
    EHTA_MAX = 3,
};

enum class EImportanceLevel {
    IL_Off = 0,
    IL_Lowest = 1,
    IL_Low = 2,
    IL_Normal = 3,
    IL_High = 4,
    IL_Highest = 5,
    TEMP_BROKEN2 = 6,
    EImportanceLevel_MAX = 7,
};

enum class EImportanceWeight {
    Luminance = 0,
    Red = 1,
    Green = 2,
    Blue = 3,
    Alpha = 4,
    EImportanceWeight_MAX = 5,
};

enum class EIndirectLightingCacheQuality {
    ILCQ_Off = 0,
    ILCQ_Point = 1,
    ILCQ_Volume = 2,
    ILCQ_MAX = 3,
};

enum class EInertializationBoneState {
    Invalid = 0,
    Valid = 1,
    Excluded = 2,
    EInertializationBoneState_MAX = 3,
};

enum class EInertializationSpace {
    Default = 0,
    WorldSpace = 1,
    WorldRotation = 2,
    EInertializationSpace_MAX = 3,
};

enum class EInertializationState {
    Inactive = 0,
    Pending = 1,
    Active = 2,
    EInertializationState_MAX = 3,
};

enum class EInputEvent {
    IE_Pressed = 0,
    IE_Released = 1,
    IE_Repeat = 2,
    IE_DoubleClick = 3,
    IE_Axis = 4,
    IE_MAX = 5,
};

enum class EInterpMoveAxis {
    AXIS_TranslationX = 0,
    AXIS_TranslationY = 1,
    AXIS_TranslationZ = 2,
    AXIS_RotationX = 3,
    AXIS_RotationY = 4,
    AXIS_RotationZ = 5,
    AXIS_MAX = 6,
};

enum class EInterpToBehaviourType {
    OneShot = 0,
    OneShot_Reverse = 1,
    Loop_Reset = 2,
    PingPong = 3,
    EInterpToBehaviourType_MAX = 4,
};

enum class EInterpTrackMoveRotMode {
    IMR_Keyframed = 0,
    IMR_LookAtGroup = 1,
    IMR_Ignore = 2,
    IMR_MAX = 3,
};

enum class EKinematicBonesUpdateToPhysics {
    SkipSimulatingBones = 0,
    SkipAllBones = 1,
    EKinematicBonesUpdateToPhysics_MAX = 2,
};

enum class ELandscapeCullingPrecision {
    High = 0,
    Medium = 1,
    Low = 2,
    ELandscapeCullingPrecision_MAX = 3,
};

enum class ELegendPosition {
    Outside = 0,
    Inside = 1,
    ELegendPosition_MAX = 2,
};

enum class ELerpInterpolationMode {
    QuatInterp = 0,
    EulerInterp = 1,
    DualQuatInterp = 2,
    ELerpInterpolationMode_MAX = 3,
};

enum class ELightMapPaddingType {
    LMPT_NormalPadding = 0,
    LMPT_PrePadding = 1,
    LMPT_NoPadding = 2,
    LMPT_MAX = 3,
};

enum class ELightUnits {
    Unitless = 0,
    Candelas = 1,
    Lumens = 2,
    ELightUnits_MAX = 3,
};

enum class ELightingBuildQuality {
    Quality_Preview = 0,
    Quality_Medium = 1,
    Quality_High = 2,
    Quality_Production = 3,
    Quality_MAX = 4,
};

enum class ELightmapType {
    Default = 0,
    ForceSurface = 1,
    ForceVolumetric = 2,
    ELightmapType_MAX = 3,
};

enum class ELocationBoneSocketSelectionMethod {
    BONESOCKETSEL_Sequential = 0,
    BONESOCKETSEL_Random = 1,
    BONESOCKETSEL_MAX = 2,
};

enum class ELocationBoneSocketSource {
    BONESOCKETSOURCE_Bones = 0,
    BONESOCKETSOURCE_Sockets = 1,
    BONESOCKETSOURCE_MAX = 2,
};

enum class ELocationEmitterSelectionMethod {
    ELESM_Random = 0,
    ELESM_Sequential = 1,
    ELESM_MAX = 2,
};

enum class ELocationSkelVertSurfaceSource {
    VERTSURFACESOURCE_Vert = 0,
    VERTSURFACESOURCE_Surface = 1,
    VERTSURFACESOURCE_MAX = 2,
};

enum class EMIDCreationFlags {
    None = 0,
    Transient = 1,
    EMIDCreationFlags_MAX = 2,
};

enum class EMaterialAttributeBlend {
    Blend = 0,
    UseA = 1,
    UseB = 2,
    EMaterialAttributeBlend_MAX = 3,
};

enum class EMaterialDecalResponse {
    MDR_None = 0,
    MDR_ColorNormalRoughness = 1,
    MDR_Color = 2,
    MDR_ColorNormal = 3,
    MDR_ColorRoughness = 4,
    MDR_Normal = 5,
    MDR_NormalRoughness = 6,
    MDR_Roughness = 7,
    MDR_MAX = 8,
};

enum class EMaterialDomain {
    MD_Surface = 0,
    MD_DeferredDecal = 1,
    MD_LightFunction = 2,
    MD_Volume = 3,
    MD_PostProcess = 4,
    MD_UI = 5,
    MD_RuntimeVirtualTexture = 6,
    MD_MAX = 7,
};

enum class EMaterialExposedTextureProperty {
    TMTM_TextureSize = 0,
    TMTM_TexelSize = 1,
    TMTM_MAX = 2,
};

enum class EMaterialExposedViewProperty {
    MEVP_BufferSize = 0,
    MEVP_FieldOfView = 1,
    MEVP_TanHalfFieldOfView = 2,
    MEVP_ViewSize = 3,
    MEVP_WorldSpaceViewPosition = 4,
    MEVP_WorldSpaceCameraPosition = 5,
    MEVP_ViewportOffset = 6,
    MEVP_TemporalSampleCount = 7,
    MEVP_TemporalSampleIndex = 8,
    MEVP_TemporalSampleOffset = 9,
    MEVP_RuntimeVirtualTextureOutputLevel = 10,
    MEVP_RuntimeVirtualTextureOutputDerivative = 11,
    MEVP_PreExposure = 12,
    MEVP_RuntimeVirtualTextureMaxLevel = 13,
    MEVP_MAX = 14,
};

enum class EMaterialFunctionUsage {
    Default = 0,
    MaterialLayer = 1,
    MaterialLayerBlend = 2,
    EMaterialFunctionUsage_MAX = 3,
};

enum class EMaterialLayerLinkState {
    Uninitialized = 0,
    LinkedToParent = 1,
    UnlinkedFromParent = 2,
    NotFromParent = 3,
    EMaterialLayerLinkState_MAX = 4,
};

enum class EMaterialMergeType {
    MaterialMergeType_Default = 0,
    MaterialMergeType_Simplygon = 1,
    MaterialMergeType_MAX = 2,
};

enum class EMaterialParameterAssociation {
    LayerParameter = 0,
    BlendParameter = 1,
    GlobalParameter = 2,
    EMaterialParameterAssociation_MAX = 3,
};

enum class EMaterialPositionTransformSource {
    TRANSFORMPOSSOURCE_Local = 0,
    TRANSFORMPOSSOURCE_World = 1,
    TRANSFORMPOSSOURCE_TranslatedWorld = 2,
    TRANSFORMPOSSOURCE_View = 3,
    TRANSFORMPOSSOURCE_Camera = 4,
    TRANSFORMPOSSOURCE_Particle = 5,
    TRANSFORMPOSSOURCE_MAX = 6,
};

enum class EMaterialProperty {
    MP_EmissiveColor = 0,
    MP_Opacity = 1,
    MP_OpacityMask = 2,
    MP_DiffuseColor = 3,
    MP_SpecularColor = 4,
    MP_BaseColor = 5,
    MP_Metallic = 6,
    MP_Specular = 7,
    MP_Roughness = 8,
    MP_Anisotropy = 9,
    MP_Normal = 10,
    MP_Tangent = 11,
    MP_WorldPositionOffset = 12,
    MP_WorldDisplacement = 13,
    MP_TessellationMultiplier = 14,
    MP_SubsurfaceColor = 15,
    MP_CustomData0 = 16,
    MP_CustomData1 = 17,
    MP_AmbientOcclusion = 18,
    MP_Refraction = 19,
    MP_CustomizedUVs0 = 20,
    MP_CustomizedUVs1 = 21,
    MP_CustomizedUVs2 = 22,
    MP_CustomizedUVs3 = 23,
    MP_CustomizedUVs4 = 24,
    MP_CustomizedUVs5 = 25,
    MP_CustomizedUVs6 = 26,
    MP_CustomizedUVs7 = 27,
    MP_PixelDepthOffset = 28,
    MP_ShadingModel = 29,
    MP_MaterialAttributes = 30,
    MP_CustomOutput = 31,
    MP_MAX = 32,
};

enum class EMaterialSamplerType {
    SAMPLERTYPE_Color = 0,
    SAMPLERTYPE_Grayscale = 1,
    SAMPLERTYPE_Alpha = 2,
    SAMPLERTYPE_Normal = 3,
    SAMPLERTYPE_Masks = 4,
    SAMPLERTYPE_DistanceFieldFont = 5,
    SAMPLERTYPE_LinearColor = 6,
    SAMPLERTYPE_LinearGrayscale = 7,
    SAMPLERTYPE_Data = 8,
    SAMPLERTYPE_External = 9,
    SAMPLERTYPE_VirtualColor = 10,
    SAMPLERTYPE_VirtualGrayscale = 11,
    SAMPLERTYPE_VirtualAlpha = 12,
    SAMPLERTYPE_VirtualNormal = 13,
    SAMPLERTYPE_VirtualMasks = 14,
    SAMPLERTYPE_VirtualLinearColor = 15,
    SAMPLERTYPE_VirtualLinearGrayscale = 16,
    SAMPLERTYPE_MAX = 17,
};

enum class EMaterialSceneAttributeInputMode {
    Coordinates = 0,
    OffsetFraction = 1,
    EMaterialSceneAttributeInputMode_MAX = 2,
};

enum class EMaterialShadingModel {
    MSM_Unlit = 0,
    MSM_DefaultLit = 1,
    MSM_Subsurface = 2,
    MSM_PreintegratedSkin = 3,
    MSM_ClearCoat = 4,
    MSM_SubsurfaceProfile = 5,
    MSM_TwoSidedFoliage = 6,
    MSM_Hair = 7,
    MSM_Cloth = 8,
    MSM_Eye = 9,
    MSM_SingleLayerWater = 10,
    MSM_ThinTranslucent = 11,
    MSM_NUM = 12,
    MSM_FromMaterialExpression = 13,
    MSM_MAX = 14,
};

enum class EMaterialShadingRate {
    MSR_1x1 = 0,
    MSR_2x1 = 1,
    MSR_1x2 = 2,
    MSR_2x2 = 3,
    MSR_4x2 = 4,
    MSR_2x4 = 5,
    MSR_4x4 = 6,
    MSR_Count = 7,
    MSR_MAX = 8,
};

enum class EMaterialStencilCompare {
    MSC_Less = 0,
    MSC_LessEqual = 1,
    MSC_Greater = 2,
    MSC_GreaterEqual = 3,
    MSC_Equal = 4,
    MSC_NotEqual = 5,
    MSC_Never = 6,
    MSC_Always = 7,
    MSC_Count = 8,
    MSC_MAX = 9,
};

enum class EMaterialTessellationMode {
    MTM_NoTessellation = 0,
    MTM_FlatTessellation = 1,
    MTM_PNTriangles = 2,
    MTM_MAX = 3,
};

enum class EMaterialUsage {
    MATUSAGE_SkeletalMesh = 0,
    MATUSAGE_ParticleSprites = 1,
    MATUSAGE_BeamTrails = 2,
    MATUSAGE_MeshParticles = 3,
    MATUSAGE_StaticLighting = 4,
    MATUSAGE_MorphTargets = 5,
    MATUSAGE_SplineMesh = 6,
    MATUSAGE_InstancedStaticMeshes = 7,
    MATUSAGE_GeometryCollections = 8,
    MATUSAGE_Clothing = 9,
    MATUSAGE_NiagaraSprites = 10,
    MATUSAGE_NiagaraRibbons = 11,
    MATUSAGE_NiagaraMeshParticles = 12,
    MATUSAGE_GeometryCache = 13,
    MATUSAGE_Water = 14,
    MATUSAGE_HairStrands = 15,
    MATUSAGE_LidarPointCloud = 16,
    MATUSAGE_VirtualHeightfieldMesh = 17,
    MATUSAGE_MAX = 18,
};

enum class EMaterialVectorCoordTransform {
    TRANSFORM_Tangent = 0,
    TRANSFORM_Local = 1,
    TRANSFORM_World = 2,
    TRANSFORM_View = 3,
    TRANSFORM_Camera = 4,
    TRANSFORM_ParticleWorld = 5,
    TRANSFORM_MAX = 6,
};

enum class EMaterialVectorCoordTransformSource {
    TRANSFORMSOURCE_Tangent = 0,
    TRANSFORMSOURCE_Local = 1,
    TRANSFORMSOURCE_World = 2,
    TRANSFORMSOURCE_View = 3,
    TRANSFORMSOURCE_Camera = 4,
    TRANSFORMSOURCE_ParticleWorld = 5,
    TRANSFORMSOURCE_MAX = 6,
};

enum class EMatrixColumns {
    First = 0,
    Second = 1,
    Third = 2,
    Fourth = 3,
    EMatrixColumns_MAX = 4,
};

enum class EMaxConcurrentResolutionRule {
    PreventNew = 0,
    StopOldest = 1,
    StopFarthestThenPreventNew = 2,
    StopFarthestThenOldest = 3,
    StopLowestPriority = 4,
    StopQuietest = 5,
    StopLowestPriorityThenPreventNew = 6,
    Count = 7,
    EMaxConcurrentResolutionRule_MAX = 8,
};

enum class EMeshBufferAccess {
    Default = 0,
    ForceCPUAndGPU = 1,
    EMeshBufferAccess_MAX = 2,
};

enum class EMeshCameraFacingOptions {
    XAxisFacing_NoUp = 0,
    XAxisFacing_ZUp = 1,
    XAxisFacing_NegativeZUp = 2,
    XAxisFacing_YUp = 3,
    XAxisFacing_NegativeYUp = 4,
    LockedAxis_ZAxisFacing = 5,
    LockedAxis_NegativeZAxisFacing = 6,
    LockedAxis_YAxisFacing = 7,
    LockedAxis_NegativeYAxisFacing = 8,
    VelocityAligned_ZAxisFacing = 9,
    VelocityAligned_NegativeZAxisFacing = 10,
    VelocityAligned_YAxisFacing = 11,
    VelocityAligned_NegativeYAxisFacing = 12,
    EMeshCameraFacingOptions_MAX = 13,
};

enum class EMeshCameraFacingUpAxis {
    CameraFacing_NoneUP = 0,
    CameraFacing_ZUp = 1,
    CameraFacing_NegativeZUp = 2,
    CameraFacing_YUp = 3,
    CameraFacing_NegativeYUp = 4,
    CameraFacing_MAX = 5,
};

enum class EMeshFeatureImportance {
    Off = 0,
    Lowest = 1,
    Low = 2,
    Normal = 3,
    High = 4,
    Highest = 5,
    EMeshFeatureImportance_MAX = 6,
};

enum class EMeshInstancingReplacementMethod {
    RemoveOriginalActors = 0,
    KeepOriginalActorsAsEditorOnly = 1,
    EMeshInstancingReplacementMethod_MAX = 2,
};

enum class EMeshLODSelectionType {
    AllLODs = 0,
    SpecificLOD = 1,
    CalculateLOD = 2,
    LowestDetailLOD = 3,
    EMeshLODSelectionType_MAX = 4,
};

enum class EMeshMergeType {
    MeshMergeType_Default = 0,
    MeshMergeType_MergeActor = 1,
    MeshMergeType_MAX = 2,
};

enum class EMeshScreenAlignment {
    PSMA_MeshFaceCameraWithRoll = 0,
    PSMA_MeshFaceCameraWithSpin = 1,
    PSMA_MeshFaceCameraWithLockedAxis = 2,
    PSMA_MAX = 3,
};

enum class EMicroTransactionDelegate {
    MTD_PurchaseQueryComplete = 0,
    MTD_PurchaseComplete = 1,
    MTD_MAX = 2,
};

enum class EMicroTransactionResult {
    MTR_Succeeded = 0,
    MTR_Failed = 1,
    MTR_Canceled = 2,
    MTR_RestoredFromServer = 3,
    MTR_MAX = 4,
};

enum class EMobileMSAASampleCount {
    One = 1,
    Two = 2,
    Four = 4,
    Eight = 8,
    EMobileMSAASampleCount_MAX = 9,
};

enum class EMobilePixelProjectedReflectionQuality {
    Disabled = 0,
    BestPerformance = 1,
    BetterQuality = 2,
    BestQuality = 3,
    EMobilePixelProjectedReflectionQuality_MAX = 4,
};

enum class EMobilePlanarReflectionMode {
    Usual = 0,
    MobilePPRExclusive = 1,
    MobilePPR = 2,
    EMobilePlanarReflectionMode_MAX = 3,
};

enum class EMobileReflectionCompression {
    Default = 0,
    On = 1,
    Off = 2,
    EMobileReflectionCompression_MAX = 3,
};

enum class EModulationRouting {
    Disable = 0,
    Inherit = 1,
    Override = 2,
    EModulationRouting_MAX = 3,
};

enum class EModuleType {
    EPMT_General = 0,
    EPMT_TypeData = 1,
    EPMT_Beam = 2,
    EPMT_Trail = 3,
    EPMT_Spawn = 4,
    EPMT_Required = 5,
    EPMT_Event = 6,
    EPMT_Light = 7,
    EPMT_SubUV = 8,
    EPMT_MAX = 9,
};

enum class EMonoChannelUpmixMethod {
    Linear = 0,
    EqualPower = 1,
    FullVolume = 2,
    EMonoChannelUpmixMethod_MAX = 3,
};

enum class EMontageNotifyTickType {
    Queued = 0,
    BranchingPoint = 1,
    EMontageNotifyTickType_MAX = 2,
};

enum class EMontagePlayReturnType {
    MontageLength = 0,
    Duration = 1,
    EMontagePlayReturnType_MAX = 2,
};

enum class EMontageSubStepResult {
    Moved = 0,
    NotMoved = 1,
    InvalidSection = 2,
    InvalidMontage = 3,
    EMontageSubStepResult_MAX = 4,
};

enum class EMouseCaptureMode {
    NoCapture = 0,
    CapturePermanently = 1,
    CapturePermanently_IncludingInitialMouseDown = 2,
    CaptureDuringMouseDown = 3,
    CaptureDuringRightMouseDown = 4,
    EMouseCaptureMode_MAX = 5,
};

enum class EMouseLockMode {
    DoNotLock = 0,
    LockOnCapture = 1,
    LockAlways = 2,
    LockInFullscreen = 3,
    EMouseLockMode_MAX = 4,
};

enum class EMoveComponentAction {
    Move = 0,
    Stop = 1,
    Return = 2,
    EMoveComponentAction_MAX = 3,
};

enum class EMovementMode {
    MOVE_None = 0,
    MOVE_Walking = 1,
    MOVE_NavWalking = 2,
    MOVE_Falling = 3,
    MOVE_Swimming = 4,
    MOVE_Flying = 5,
    MOVE_Custom = 6,
    MOVE_MAX = 7,
};

enum class ENaturalSoundFalloffMode {
    Continues = 0,
    Silent = 1,
    Hold = 2,
    ENaturalSoundFalloffMode_MAX = 3,
};

enum class ENavDataGatheringMode {
    Default = 0,
    Instant = 1,
    Lazy = 2,
    ENavDataGatheringMode_MAX = 3,
};

enum class ENavDataGatheringModeConfig {
    Invalid = 0,
    Instant = 1,
    Lazy = 2,
    ENavDataGatheringModeConfig_MAX = 3,
};

enum class ENavLinkDirection {
    BothWays = 0,
    LeftToRight = 1,
    RightToLeft = 2,
    ENavLinkDirection_MAX = 3,
};

enum class ENavPathEvent {
    Cleared = 0,
    NewPath = 1,
    UpdatedDueToGoalMoved = 2,
    UpdatedDueToNavigationChanged = 3,
    Invalidated = 4,
    RePathFailed = 5,
    MetaPathUpdate = 6,
    Custom = 7,
    ENavPathEvent_MAX = 8,
};

enum class ENavigationOptionFlag {
    Default = 0,
    Enable = 1,
    Disable = 2,
    MAX = 3,
};

enum class ENavigationQueryResult {
    Invalid = 0,
    Error = 1,
    Fail = 2,
    Success = 3,
    ENavigationQueryResult_MAX = 4,
};

enum class ENetDormancy {
    DORM_Never = 0,
    DORM_Awake = 1,
    DORM_DormantAll = 2,
    DORM_DormantPartial = 3,
    DORM_Initial = 4,
    DORM_MAX = 5,
};

enum class ENetRole {
    ROLE_None = 0,
    ROLE_SimulatedProxy = 1,
    ROLE_AutonomousProxy = 2,
    ROLE_Authority = 3,
    ROLE_MAX = 4,
};

enum class ENetworkFailure {
    NetDriverAlreadyExists = 0,
    NetDriverCreateFailure = 1,
    NetDriverListenFailure = 2,
    ConnectionLost = 3,
    ConnectionTimeout = 4,
    FailureReceived = 5,
    OutdatedClient = 6,
    OutdatedServer = 7,
    PendingConnectionFailure = 8,
    NetGuidMismatch = 9,
    NetChecksumMismatch = 10,
    ENetworkFailure_MAX = 11,
};

enum class ENetworkLagState {
    NotLagging = 0,
    Lagging = 1,
    ENetworkLagState_MAX = 2,
};

enum class ENetworkSmoothingMode {
    Disabled = 0,
    Linear = 1,
    Exponential = 2,
    Replay = 3,
    ENetworkSmoothingMode_MAX = 4,
};

enum class ENodeAdvancedPins {
    NoPins = 0,
    Shown = 1,
    Hidden = 2,
    ENodeAdvancedPins_MAX = 3,
};

enum class ENodeEnabledState {
    Enabled = 0,
    Disabled = 1,
    DevelopmentOnly = 2,
    ENodeEnabledState_MAX = 3,
};

enum class ENodeTitleType {
    FullTitle = 0,
    ListView = 1,
    EditableTitle = 2,
    MenuTitle = 3,
    MAX_TitleTypes = 4,
    ENodeTitleType_MAX = 5,
};

enum class ENoiseFunction {
    NOISEFUNCTION_SimplexTex = 0,
    NOISEFUNCTION_GradientTex = 1,
    NOISEFUNCTION_GradientTex3D = 2,
    NOISEFUNCTION_GradientALU = 3,
    NOISEFUNCTION_ValueALU = 4,
    NOISEFUNCTION_VoronoiALU = 5,
    NOISEFUNCTION_MAX = 6,
};

enum class ENormalMode {
    NM_PreserveSmoothingGroups = 0,
    NM_RecalculateNormals = 1,
    NM_RecalculateNormalsSmooth = 2,
    NM_RecalculateNormalsHard = 3,
    TEMP_BROKEN = 4,
    ENormalMode_MAX = 5,
};

enum class ENotifyFilterType {
    NoFiltering = 0,
    LOD = 1,
    ENotifyFilterType_MAX = 2,
};

enum class ENotifyTriggerMode {
    AllAnimations = 0,
    HighestWeightedAnimation = 1,
    None = 2,
    ENotifyTriggerMode_MAX = 3,
};

enum class EObjectTypeQuery {
    ObjectTypeQuery1 = 0,
    ObjectTypeQuery2 = 1,
    ObjectTypeQuery3 = 2,
    ObjectTypeQuery4 = 3,
    ObjectTypeQuery5 = 4,
    ObjectTypeQuery6 = 5,
    ObjectTypeQuery7 = 6,
    ObjectTypeQuery8 = 7,
    ObjectTypeQuery9 = 8,
    ObjectTypeQuery10 = 9,
    ObjectTypeQuery11 = 10,
    ObjectTypeQuery12 = 11,
    ObjectTypeQuery13 = 12,
    ObjectTypeQuery14 = 13,
    ObjectTypeQuery15 = 14,
    ObjectTypeQuery16 = 15,
    ObjectTypeQuery17 = 16,
    ObjectTypeQuery18 = 17,
    ObjectTypeQuery19 = 18,
    ObjectTypeQuery20 = 19,
    ObjectTypeQuery21 = 20,
    ObjectTypeQuery22 = 21,
    ObjectTypeQuery23 = 22,
    ObjectTypeQuery24 = 23,
    ObjectTypeQuery25 = 24,
    ObjectTypeQuery26 = 25,
    ObjectTypeQuery27 = 26,
    ObjectTypeQuery28 = 27,
    ObjectTypeQuery29 = 28,
    ObjectTypeQuery30 = 29,
    ObjectTypeQuery31 = 30,
    ObjectTypeQuery32 = 31,
    ObjectTypeQuery_MAX = 32,
    EObjectTypeQuery_MAX = 33,
};

enum class EOcclusionCombineMode {
    OCM_Minimum = 0,
    OCM_Multiply = 1,
    OCM_MAX = 2,
};

enum class EOpacitySourceMode {
    OSM_Alpha = 0,
    OSM_ColorBrightness = 1,
    OSM_RedChannel = 2,
    OSM_GreenChannel = 3,
    OSM_BlueChannel = 4,
    OSM_MAX = 5,
};

enum class EOptimizationType {
    OT_NumOfTriangles = 0,
    OT_MaxDeviation = 1,
    OT_MAX = 2,
};

enum class EOrbitChainMode {
    EOChainMode_Add = 0,
    EOChainMode_Scale = 1,
    EOChainMode_Link = 2,
    EOChainMode_MAX = 3,
};

enum class EOverlapFilterOption {
    OverlapFilter_All = 0,
    OverlapFilter_DynamicOnly = 1,
    OverlapFilter_StaticOnly = 2,
    OverlapFilter_MAX = 3,
};

enum class EPSCPoolMethod {
    None = 0,
    AutoRelease = 1,
    ManualRelease = 2,
    ManualRelease_OnComplete = 3,
    FreeInPool = 4,
    EPSCPoolMethod_MAX = 5,
};

enum class EPanningMethod {
    Linear = 0,
    EqualPower = 1,
    EPanningMethod_MAX = 2,
};

enum class EParticleAxisLock {
    EPAL_NONE = 0,
    EPAL_X = 1,
    EPAL_Y = 2,
    EPAL_Z = 3,
    EPAL_NEGATIVE_X = 4,
    EPAL_NEGATIVE_Y = 5,
    EPAL_NEGATIVE_Z = 6,
    EPAL_ROTATE_X = 7,
    EPAL_ROTATE_Y = 8,
    EPAL_ROTATE_Z = 9,
    EPAL_MAX = 10,
};

enum class EParticleBurstMethod {
    EPBM_Instant = 0,
    EPBM_Interpolated = 1,
    EPBM_MAX = 2,
};

enum class EParticleCameraOffsetUpdateMethod {
    EPCOUM_DirectSet = 0,
    EPCOUM_Additive = 1,
    EPCOUM_Scalar = 2,
    EPCOUM_MAX = 3,
};

enum class EParticleCollisionComplete {
    EPCC_Kill = 0,
    EPCC_Freeze = 1,
    EPCC_HaltCollisions = 2,
    EPCC_FreezeTranslation = 3,
    EPCC_FreezeRotation = 4,
    EPCC_FreezeMovement = 5,
    EPCC_MAX = 6,
};

enum class EParticleCollisionMode {
    SceneDepth = 0,
    DistanceField = 1,
    EParticleCollisionMode_MAX = 2,
};

enum class EParticleCollisionResponse {
    Bounce = 0,
    Stop = 1,
    Kill = 2,
    EParticleCollisionResponse_MAX = 3,
};

enum class EParticleDetailMode {
    PDM_Low = 0,
    PDM_Medium = 1,
    PDM_High = 2,
    PDM_MAX = 3,
};

enum class EParticleEventType {
    EPET_Any = 0,
    EPET_Spawn = 1,
    EPET_Death = 2,
    EPET_Collision = 3,
    EPET_Burst = 4,
    EPET_Blueprint = 5,
    EPET_MAX = 6,
};

enum class EParticleScreenAlignment {
    PSA_FacingCameraPosition = 0,
    PSA_Square = 1,
    PSA_Rectangle = 2,
    PSA_Velocity = 3,
    PSA_AwayFromCenter = 4,
    PSA_TypeSpecific = 5,
    PSA_FacingCameraDistanceBlend = 6,
    PSA_MAX = 7,
};

enum class EParticleSignificanceLevel {
    Low = 0,
    Medium = 1,
    High = 2,
    Critical = 3,
    Num = 4,
    EParticleSignificanceLevel_MAX = 5,
};

enum class EParticleSortMode {
    PSORTMODE_None = 0,
    PSORTMODE_ViewProjDepth = 1,
    PSORTMODE_DistanceToView = 2,
    PSORTMODE_Age_OldestFirst = 3,
    PSORTMODE_Age_NewestFirst = 4,
    PSORTMODE_MAX = 5,
};

enum class EParticleSourceSelectionMethod {
    EPSSM_Random = 0,
    EPSSM_Sequential = 1,
    EPSSM_MAX = 2,
};

enum class EParticleSubUVInterpMethod {
    PSUVIM_None = 0,
    PSUVIM_Linear = 1,
    PSUVIM_Linear_Blend = 2,
    PSUVIM_Random = 3,
    PSUVIM_Random_Blend = 4,
    PSUVIM_MAX = 5,
};

enum class EParticleSysParamType {
    PSPT_None = 0,
    PSPT_Scalar = 1,
    PSPT_ScalarRand = 2,
    PSPT_Vector = 3,
    PSPT_VectorRand = 4,
    PSPT_Color = 5,
    PSPT_Actor = 6,
    PSPT_Material = 7,
    PSPT_VectorUnitRand = 8,
    PSPT_MAX = 9,
};

enum class EParticleSystemInsignificanceReaction {
    Auto = 0,
    Complete = 1,
    DisableTick = 2,
    DisableTickAndKill = 3,
    Num = 4,
    EParticleSystemInsignificanceReaction_MAX = 5,
};

enum class EParticleSystemOcclusionBoundsMethod {
    EPSOBM_None = 0,
    EPSOBM_ParticleBounds = 1,
    EPSOBM_CustomBounds = 2,
    EPSOBM_MAX = 3,
};

enum class EParticleSystemUpdateMode {
    EPSUM_RealTime = 0,
    EPSUM_FixedTime = 1,
    EPSUM_MAX = 2,
};

enum class EParticleUVFlipMode {
    None = 0,
    FlipUV = 1,
    FlipUOnly = 2,
    FlipVOnly = 3,
    RandomFlipUV = 4,
    RandomFlipUOnly = 5,
    RandomFlipVOnly = 6,
    RandomFlipUVIndependent = 7,
    EParticleUVFlipMode_MAX = 8,
};

enum class EPhysBodyOp {
    PBO_None = 0,
    PBO_Term = 1,
    PBO_MAX = 2,
};

enum class EPhysicalMaterialMaskColor {
    Red = 0,
    Green = 1,
    Blue = 2,
    Cyan = 3,
    Magenta = 4,
    Yellow = 5,
    White = 6,
    Black = 7,
    MAX = 8,
};

enum class EPhysicsAssetSolverType {
    RBAN = 0,
    World = 1,
    EPhysicsAssetSolverType_MAX = 2,
};

enum class EPhysicsTransformUpdateMode {
    SimulationUpatesComponentTransform = 0,
    ComponentTransformIsKinematic = 1,
    EPhysicsTransformUpdateMode_MAX = 2,
};

enum class EPinContainerType {
    None = 0,
    Array = 1,
    Set = 2,
    Map = 3,
    EPinContainerType_MAX = 4,
};

enum class EPinHidingMode {
    NeverAsPin = 0,
    PinHiddenByDefault = 1,
    PinShownByDefault = 2,
    AlwaysAsPin = 3,
    EPinHidingMode_MAX = 4,
};

enum class EPlaneConstraintAxisSetting {
    Custom = 0,
    X = 1,
    Y = 2,
    Z = 3,
    UseGlobalPhysicsSetting = 4,
    EPlaneConstraintAxisSetting_MAX = 5,
};

enum class EPlatformInterfaceDataType {
    PIDT_None = 0,
    PIDT_Int = 1,
    PIDT_Float = 2,
    PIDT_String = 3,
    PIDT_Object = 4,
    PIDT_Custom = 5,
    PIDT_MAX = 6,
};

enum class EPostCopyOperation {
    None = 0,
    LogicalNegateBool = 1,
    EPostCopyOperation_MAX = 2,
};

enum class EPreviewAnimationBlueprintApplicationMethod {
    LinkedLayers = 0,
    LinkedAnimGraph = 1,
    EPreviewAnimationBlueprintApplicationMethod_MAX = 2,
};

enum class EPrimaryAssetCookRule {
    Unknown = 0,
    NeverCook = 1,
    DevelopmentCook = 2,
    DevelopmentAlwaysCook = 3,
    AlwaysCook = 4,
    EPrimaryAssetCookRule_MAX = 5,
};

enum class EPriorityAttenuationMethod {
    Linear = 0,
    CustomCurve = 1,
    Manual = 2,
    EPriorityAttenuationMethod_MAX = 3,
};

enum class EProxyNormalComputationMethod {
    AngleWeighted = 0,
    AreaWeighted = 1,
    EqualWeighted = 2,
    EProxyNormalComputationMethod_MAX = 3,
};

enum class EQuartzCommandDelegateSubType {
    CommandOnFailedToQueue = 0,
    CommandOnQueued = 1,
    CommandOnCanceled = 2,
    CommandOnAboutToStart = 3,
    CommandOnStarted = 4,
    Count = 5,
    EQuartzCommandDelegateSubType_MAX = 6,
};

enum class EQuartzCommandQuantization {
    Bar = 0,
    Beat = 1,
    ThirtySecondNote = 2,
    SixteenthNote = 3,
    EighthNote = 4,
    QuarterNote = 5,
    HalfNote = 6,
    WholeNote = 7,
    DottedSixteenthNote = 8,
    DottedEighthNote = 9,
    DottedQuarterNote = 10,
    DottedHalfNote = 11,
    DottedWholeNote = 12,
    SixteenthNoteTriplet = 13,
    EighthNoteTriplet = 14,
    QuarterNoteTriplet = 15,
    HalfNoteTriplet = 16,
    Tick = 17,
    Count = 18,
    None = 19,
    EQuartzCommandQuantization_MAX = 20,
};

enum class EQuartzDelegateType {
    MetronomeTick = 0,
    CommandEvent = 1,
    Count = 2,
    EQuartzDelegateType_MAX = 3,
};

enum class EQuartzTimeSignatureQuantization {
    HalfNote = 0,
    QuarterNote = 1,
    EighthNote = 2,
    SixteenthNote = 3,
    ThirtySecondNote = 4,
    Count = 5,
    EQuartzTimeSignatureQuantization_MAX = 6,
};

enum class EQuarztQuantizationReference {
    BarRelative = 0,
    TransportRelative = 1,
    CurrentTimeRelative = 2,
    Count = 3,
    EQuarztQuantizationReference_MAX = 4,
};

enum class EQuitPreference {
    Quit = 0,
    Background = 1,
    EQuitPreference_MAX = 2,
};

enum class ERawCurveTrackTypes {
    RCT_Float = 0,
    RCT_Vector = 1,
    RCT_Transform = 2,
    RCT_MAX = 3,
};

enum class ERayTracingGlobalIlluminationType {
    Disabled = 0,
    BruteForce = 1,
    FinalGather = 2,
    ERayTracingGlobalIlluminationType_MAX = 3,
};

enum class EReflectedAndRefractedRayTracedShadows {
    Disabled = 0,
    Hard_shadows = 1,
    Area_shadows = 2,
    EReflectedAndRefractedRayTracedShadows_MAX = 3,
};

enum class EReflectionSourceType {
    CapturedScene = 0,
    SpecifiedCubemap = 1,
    EReflectionSourceType_MAX = 2,
};

enum class EReflectionsType {
    ScreenSpace = 0,
    RayTracing = 1,
    EReflectionsType_MAX = 2,
};

enum class ERefractionMode {
    RM_IndexOfRefraction = 0,
    RM_PixelNormalOffset = 1,
    RM_MAX = 2,
};

enum class ERelativeTransformSpace {
    RTS_World = 0,
    RTS_Actor = 1,
    RTS_Component = 2,
    RTS_ParentBoneSpace = 3,
    RTS_MAX = 4,
};

enum class ERenderFocusRule {
    Always = 0,
    NonPointer = 1,
    NavigationOnly = 2,
    Never = 3,
    ERenderFocusRule_MAX = 4,
};

enum class ERendererStencilMask {
    ERSM_Default = 0,
    ERSM_255 = 1,
    ERSM_1 = 2,
    ERSM_2 = 3,
    ERSM_4 = 4,
    ERSM_8 = 5,
    ERSM_16 = 6,
    ERSM_32 = 7,
    ERSM_64 = 8,
    ERSM_128 = 9,
    ERSM_MAX = 10,
};

enum class EReporterLineStyle {
    Line = 0,
    Dash = 1,
    EReporterLineStyle_MAX = 2,
};

enum class EReverbSendMethod {
    Linear = 0,
    CustomCurve = 1,
    Manual = 2,
    EReverbSendMethod_MAX = 3,
};

enum class ERichCurveCompressionFormat {
    RCCF_Empty = 0,
    RCCF_Constant = 1,
    RCCF_Linear = 2,
    RCCF_Cubic = 3,
    RCCF_Mixed = 4,
    RCCF_Weighted = 5,
    RCCF_MAX = 6,
};

enum class ERichCurveExtrapolation {
    RCCE_Cycle = 0,
    RCCE_CycleWithOffset = 1,
    RCCE_Oscillate = 2,
    RCCE_Linear = 3,
    RCCE_Constant = 4,
    RCCE_None = 5,
    RCCE_MAX = 6,
};

enum class ERichCurveInterpMode {
    RCIM_Linear = 0,
    RCIM_Constant = 1,
    RCIM_Cubic = 2,
    RCIM_None = 3,
    RCIM_MAX = 4,
};

enum class ERichCurveKeyTimeCompressionFormat {
    RCKTCF_uint16 = 0,
    RCKTCF_float32 = 1,
    RCKTCF_MAX = 2,
};

enum class ERichCurveTangentMode {
    RCTM_Auto = 0,
    RCTM_User = 1,
    RCTM_Break = 2,
    RCTM_None = 3,
    RCTM_MAX = 4,
};

enum class ERichCurveTangentWeightMode {
    RCTWM_WeightedNone = 0,
    RCTWM_WeightedArrive = 1,
    RCTWM_WeightedLeave = 2,
    RCTWM_WeightedBoth = 3,
    RCTWM_MAX = 4,
};

enum class ERootMotionAccumulateMode {
    Override = 0,
    Additive = 1,
    ERootMotionAccumulateMode_MAX = 2,
};

enum class ERootMotionFinishVelocityMode {
    MaintainLastRootMotionVelocity = 0,
    SetVelocity = 1,
    ClampVelocity = 2,
    ERootMotionFinishVelocityMode_MAX = 3,
};

enum class ERootMotionMode {
    NoRootMotionExtraction = 0,
    IgnoreRootMotion = 1,
    RootMotionFromEverything = 2,
    RootMotionFromMontagesOnly = 3,
    ERootMotionMode_MAX = 4,
};

enum class ERootMotionRootLock {
    RefPose = 0,
    AnimFirstFrame = 1,
    Zero = 2,
    ERootMotionRootLock_MAX = 3,
};

enum class ERootMotionSourceSettingsFlags {
    UseSensitiveLiftoffCheck = 1,
    DisablePartialEndTick = 2,
    IgnoreZAccumulate = 4,
    ERootMotionSourceSettingsFlags_MAX = 5,
};

enum class ERootMotionSourceStatusFlags {
    Prepared = 1,
    Finished = 2,
    MarkedForRemoval = 4,
    ERootMotionSourceStatusFlags_MAX = 5,
};

enum class ERotatorQuantization {
    ByteComponents = 0,
    ShortComponents = 1,
    ERotatorQuantization_MAX = 2,
};

enum class ERoundingMode {
    HalfToEven = 0,
    HalfFromZero = 1,
    HalfToZero = 2,
    FromZero = 3,
    ToZero = 4,
    ToNegativeInfinity = 5,
    ToPositiveInfinity = 6,
    ERoundingMode_MAX = 7,
};

enum class ERuntimeVirtualTextureMainPassType {
    Never = 0,
    Exclusive = 1,
    Always = 2,
    ERuntimeVirtualTextureMainPassType_MAX = 3,
};

enum class ERuntimeVirtualTextureMaterialType {
    BaseColor = 0,
    BaseColor_Normal_DEPRECATED = 1,
    BaseColor_Normal_Specular = 2,
    BaseColor_Normal_Specular_YCoCg = 3,
    BaseColor_Normal_Specular_Mask_YCoCg = 4,
    WorldHeight = 5,
    Count = 6,
    ERuntimeVirtualTextureMaterialType_MAX = 7,
};

enum class ERuntimeVirtualTextureMipValueMode {
    RVTMVM_None = 0,
    RVTMVM_MipLevel = 1,
    RVTMVM_MipBias = 2,
    RVTMVM_MAX = 3,
};

enum class ERuntimeVirtualTextureTextureAddressMode {
    RVTTA_Clamp = 0,
    RVTTA_Wrap = 1,
    RVTTA_MAX = 2,
};

enum class ESamplerSourceMode {
    SSM_FromTextureAsset = 0,
    SSM_Wrap_WorldGroupSettings = 1,
    SSM_Clamp_WorldGroupSettings = 2,
    SSM_MAX = 3,
};

enum class ESceneCaptureCompositeMode {
    SCCM_Overwrite = 0,
    SCCM_Additive = 1,
    SCCM_Composite = 2,
    SCCM_MAX = 3,
};

enum class ESceneCapturePrimitiveRenderMode {
    PRM_LegacySceneCapture = 0,
    PRM_RenderScenePrimitives = 1,
    PRM_UseShowOnlyList = 2,
    PRM_MAX = 3,
};

enum class ESceneCaptureSource {
    SCS_SceneColorHDR = 0,
    SCS_SceneColorHDRNoAlpha = 1,
    SCS_FinalColorLDR = 2,
    SCS_SceneColorSceneDepth = 3,
    SCS_SceneDepth = 4,
    SCS_DeviceDepth = 5,
    SCS_Normal = 6,
    SCS_BaseColor = 7,
    SCS_FinalColorHDR = 8,
    SCS_FinalToneCurveHDR = 9,
    SCS_MAX = 10,
};

enum class ESceneDepthPriorityGroup {
    SDPG_World = 0,
    SDPG_Foreground = 1,
    SDPG_MAX = 2,
};

enum class ESceneTextureId {
    PPI_SceneColor = 0,
    PPI_SceneDepth = 1,
    PPI_DiffuseColor = 2,
    PPI_SpecularColor = 3,
    PPI_SubsurfaceColor = 4,
    PPI_BaseColor = 5,
    PPI_Specular = 6,
    PPI_Metallic = 7,
    PPI_WorldNormal = 8,
    PPI_SeparateTranslucency = 9,
    PPI_Opacity = 10,
    PPI_Roughness = 11,
    PPI_MaterialAO = 12,
    PPI_CustomDepth = 13,
    PPI_PostProcessInput0 = 14,
    PPI_PostProcessInput1 = 15,
    PPI_PostProcessInput2 = 16,
    PPI_PostProcessInput3 = 17,
    PPI_PostProcessInput4 = 18,
    PPI_PostProcessInput5 = 19,
    PPI_PostProcessInput6 = 20,
    PPI_DecalMask = 21,
    PPI_ShadingModelColor = 22,
    PPI_ShadingModelID = 23,
    PPI_AmbientOcclusion = 24,
    PPI_CustomStencil = 25,
    PPI_StoredBaseColor = 26,
    PPI_StoredSpecular = 27,
    PPI_Velocity = 28,
    PPI_WorldTangent = 29,
    PPI_Anisotropy = 30,
    PPI_MAX = 31,
};

enum class EScreenOrientation {
    Unknown = 0,
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeLeft = 3,
    LandscapeRight = 4,
    FaceUp = 5,
    FaceDown = 6,
    EScreenOrientation_MAX = 7,
};

enum class ESendLevelControlMethod {
    Linear = 0,
    CustomCurve = 1,
    Manual = 2,
    ESendLevelControlMethod_MAX = 3,
};

enum class ESettingsDOF {
    Full3D = 0,
    YZPlane = 1,
    XZPlane = 2,
    XYPlane = 3,
    ESettingsDOF_MAX = 4,
};

enum class ESettingsLockedAxis {
    None = 0,
    X = 1,
    Y = 2,
    Z = 3,
    Invalid = 4,
    ESettingsLockedAxis_MAX = 5,
};

enum class EShadowMapFlags {
    SMF_None = 0,
    SMF_Streamed = 1,
    SMF_MAX = 2,
};

enum class ESkeletalMeshGeoImportVersions {
    Before_Versionning = 0,
    SkeletalMeshBuildRefactor = 1,
    VersionPlusOne = 2,
    LatestVersion = 1,
    ESkeletalMeshGeoImportVersions_MAX = 3,
};

enum class ESkeletalMeshSkinningImportVersions {
    Before_Versionning = 0,
    SkeletalMeshBuildRefactor = 1,
    VersionPlusOne = 2,
    LatestVersion = 1,
    ESkeletalMeshSkinningImportVersions_MAX = 3,
};

enum class ESkinCacheDefaultBehavior {
    Exclusive = 0,
    Inclusive = 1,
    ESkinCacheDefaultBehavior_MAX = 2,
};

enum class ESkinCacheUsage {
    Auto = 0,
    Disabled = 255,
    Enabled = 1,
    ESkinCacheUsage_MAX = 256,
};

enum class ESkyAtmosphereTransformMode {
    PlanetTopAtAbsoluteWorldOrigin = 0,
    PlanetTopAtComponentTransform = 1,
    PlanetCenterAtComponentTransform = 2,
    ESkyAtmosphereTransformMode_MAX = 3,
};

enum class ESkyLightSourceType {
    SLS_CapturedScene = 0,
    SLS_SpecifiedCubemap = 1,
    SLS_MAX = 2,
};

enum class ESlateGesture {
    None = 0,
    Scroll = 1,
    Magnify = 2,
    Swipe = 3,
    Rotate = 4,
    LongPress = 5,
    ESlateGesture_MAX = 6,
};

enum class ESoundDistanceCalc {
    SOUNDDISTANCE_Normal = 0,
    SOUNDDISTANCE_InfiniteXYPlane = 1,
    SOUNDDISTANCE_InfiniteXZPlane = 2,
    SOUNDDISTANCE_InfiniteYZPlane = 3,
    SOUNDDISTANCE_MAX = 4,
};

enum class ESoundGroup {
    SOUNDGROUP_Default = 0,
    SOUNDGROUP_Effects = 1,
    SOUNDGROUP_UI = 2,
    SOUNDGROUP_Music = 3,
    SOUNDGROUP_Voice = 4,
    SOUNDGROUP_GameSoundGroup1 = 5,
    SOUNDGROUP_GameSoundGroup2 = 6,
    SOUNDGROUP_GameSoundGroup3 = 7,
    SOUNDGROUP_GameSoundGroup4 = 8,
    SOUNDGROUP_GameSoundGroup5 = 9,
    SOUNDGROUP_GameSoundGroup6 = 10,
    SOUNDGROUP_GameSoundGroup7 = 11,
    SOUNDGROUP_GameSoundGroup8 = 12,
    SOUNDGROUP_GameSoundGroup9 = 13,
    SOUNDGROUP_GameSoundGroup10 = 14,
    SOUNDGROUP_GameSoundGroup11 = 15,
    SOUNDGROUP_GameSoundGroup12 = 16,
    SOUNDGROUP_GameSoundGroup13 = 17,
    SOUNDGROUP_GameSoundGroup14 = 18,
    SOUNDGROUP_GameSoundGroup15 = 19,
    SOUNDGROUP_GameSoundGroup16 = 20,
    SOUNDGROUP_GameSoundGroup17 = 21,
    SOUNDGROUP_GameSoundGroup18 = 22,
    SOUNDGROUP_GameSoundGroup19 = 23,
    SOUNDGROUP_GameSoundGroup20 = 24,
    SOUNDGROUP_MAX = 25,
};

enum class ESoundSpatializationAlgorithm {
    SPATIALIZATION_Default = 0,
    SPATIALIZATION_HRTF = 1,
    SPATIALIZATION_MAX = 2,
};

enum class ESoundWaveFFTSize {
    VerySmall_64 = 0,
    Small_256 = 1,
    Medium_512 = 2,
    Large_1024 = 3,
    VeryLarge_2048 = 4,
    ESoundWaveFFTSize_MAX = 5,
};

enum class ESoundWaveLoadingBehavior {
    Inherited = 0,
    RetainOnLoad = 1,
    PrimeOnLoad = 2,
    LoadOnDemand = 3,
    ForceInline = 4,
    Uninitialized = 255,
    ESoundWaveLoadingBehavior_MAX = 256,
};

enum class ESourceBusChannels {
    Mono = 0,
    Stereo = 1,
    ESourceBusChannels_MAX = 2,
};

enum class ESourceBusSendLevelControlMethod {
    Linear = 0,
    CustomCurve = 1,
    Manual = 2,
    ESourceBusSendLevelControlMethod_MAX = 3,
};

enum class ESpawnActorCollisionHandlingMethod {
    Undefined = 0,
    AlwaysSpawn = 1,
    AdjustIfPossibleButAlwaysSpawn = 2,
    AdjustIfPossibleButDontSpawnIfColliding = 3,
    DontSpawnIfColliding = 4,
    ESpawnActorCollisionHandlingMethod_MAX = 5,
};

enum class ESpeedTreeGeometryType {
    STG_Branch = 0,
    STG_Frond = 1,
    STG_Leaf = 2,
    STG_FacingLeaf = 3,
    STG_Billboard = 4,
    STG_MAX = 5,
};

enum class ESpeedTreeLODType {
    STLOD_Pop = 0,
    STLOD_Smooth = 1,
    STLOD_MAX = 2,
};

enum class ESpeedTreeWindType {
    STW_None = 0,
    STW_Fastest = 1,
    STW_Fast = 2,
    STW_Better = 3,
    STW_Best = 4,
    STW_Palm = 5,
    STW_BestPlus = 6,
    STW_MAX = 7,
};

enum class ESplineCoordinateSpace {
    Local = 0,
    World = 1,
    ESplineCoordinateSpace_MAX = 2,
};

enum class ESplineMeshAxis {
    X = 0,
    Y = 1,
    Z = 2,
    ESplineMeshAxis_MAX = 3,
};

enum class ESplinePointType {
    Linear = 0,
    Curve = 1,
    Constant = 2,
    CurveClamped = 3,
    CurveCustomTangent = 4,
    ESplinePointType_MAX = 5,
};

enum class EStandbyType {
    STDBY_Rx = 0,
    STDBY_Tx = 1,
    STDBY_BadPing = 2,
    STDBY_MAX = 3,
};

enum class EStaticMeshReductionTerimationCriterion {
    Triangles = 0,
    Vertices = 1,
    Any = 2,
    EStaticMeshReductionTerimationCriterion_MAX = 3,
};

enum class EStereoLayerShape {
    SLSH_QuadLayer = 0,
    SLSH_CylinderLayer = 1,
    SLSH_CubemapLayer = 2,
    SLSH_EquirectLayer = 3,
    SLSH_MAX = 4,
};

enum class EStereoLayerType {
    SLT_WorldLocked = 0,
    SLT_TrackerLocked = 1,
    SLT_FaceLocked = 2,
    SLT_MAX = 3,
};

enum class EStreamingVolumeUsage {
    SVB_Loading = 0,
    SVB_LoadingAndVisibility = 1,
    SVB_VisibilityBlockingOnLoad = 2,
    SVB_BlockingOnLoad = 3,
    SVB_LoadingNotVisible = 4,
    SVB_MAX = 5,
};

enum class ESubUVBoundingVertexCount {
    BVC_FourVertices = 0,
    BVC_EightVertices = 1,
    BVC_MAX = 2,
};

enum class ESubmixSendMethod {
    Linear = 0,
    CustomCurve = 1,
    Manual = 2,
    ESubmixSendMethod_MAX = 3,
};

enum class ESubmixSendStage {
    PostDistanceAttenuation = 0,
    PreDistanceAttenuation = 1,
    ESubmixSendStage_MAX = 2,
};

enum class ESuggestProjVelocityTraceOption {
    DoNotTrace = 0,
    TraceFullPath = 1,
    OnlyTraceWhileAscending = 2,
    ESuggestProjVelocityTraceOption_MAX = 3,
};

enum class ESyncOption {
    Drive = 0,
    Passive = 1,
    Disabled = 2,
    ESyncOption_MAX = 3,
};

enum class ETeleportType {
    None = 0,
    TeleportPhysics = 1,
    ResetPhysics = 2,
    ETeleportType_MAX = 3,
};

enum class ETemperatureMethod {
    TEMP_WhiteBalance = 0,
    TEMP_ColorTemperature = 1,
    TEMP_MAX = 2,
};

enum class ETemperatureSeverityType {
    Unknown = 0,
    Good = 1,
    Bad = 2,
    Serious = 3,
    Critical = 4,
    NumSeverities = 5,
    ETemperatureSeverityType_MAX = 6,
};

enum class ETextGender {
    Masculine = 0,
    Feminine = 1,
    Neuter = 2,
    ETextGender_MAX = 3,
};

enum class ETextureColorChannel {
    TCC_Red = 0,
    TCC_Green = 1,
    TCC_Blue = 2,
    TCC_Alpha = 3,
    TCC_MAX = 4,
};

enum class ETextureCompressionQuality {
    TCQ_Default = 0,
    TCQ_Lowest = 1,
    TCQ_Low = 2,
    TCQ_Medium = 3,
    TCQ_High = 4,
    TCQ_Highest = 5,
    TCQ_MAX = 6,
};

enum class ETextureDownscaleOptions {
    Default = 0,
    Unfiltered = 1,
    SimpleAverage = 2,
    Sharpen0 = 3,
    Sharpen1 = 4,
    Sharpen2 = 5,
    Sharpen3 = 6,
    Sharpen4 = 7,
    Sharpen5 = 8,
    Sharpen6 = 9,
    Sharpen7 = 10,
    Sharpen8 = 11,
    Sharpen9 = 12,
    Sharpen10 = 13,
    ETextureDownscaleOptions_MAX = 14,
};

enum class ETextureLossyCompressionAmount {
    TLCA_Default = 0,
    TLCA_None = 1,
    TLCA_Lowest = 2,
    TLCA_Low = 3,
    TLCA_Medium = 4,
    TLCA_High = 5,
    TLCA_Highest = 6,
    TLCA_MAX = 7,
};

enum class ETextureMipCount {
    TMC_ResidentMips = 0,
    TMC_AllMips = 1,
    TMC_AllMipsBiased = 2,
    TMC_MAX = 3,
};

enum class ETextureMipLoadOptions {
    Default = 0,
    AllMips = 1,
    OnlyFirstMip = 2,
    ETextureMipLoadOptions_MAX = 3,
};

enum class ETextureMipValueMode {
    TMVM_None = 0,
    TMVM_MipLevel = 1,
    TMVM_MipBias = 2,
    TMVM_Derivative = 3,
    TMVM_MAX = 4,
};

enum class ETexturePowerOfTwoSetting {
    None = 0,
    PadToPowerOfTwo = 1,
    PadToSquarePowerOfTwo = 2,
    ETexturePowerOfTwoSetting_MAX = 3,
};

enum class ETextureRenderTargetFormat {
    RTF_R8 = 0,
    RTF_RG8 = 1,
    RTF_RGBA8 = 2,
    RTF_RGBA8_SRGB = 3,
    RTF_R16f = 4,
    RTF_RG16f = 5,
    RTF_RGBA16f = 6,
    RTF_R32f = 7,
    RTF_RG32f = 8,
    RTF_RGBA32f = 9,
    RTF_RGB10A2 = 10,
    RTF_MAX = 11,
};

enum class ETextureSamplerFilter {
    Point = 0,
    Bilinear = 1,
    Trilinear = 2,
    AnisotropicPoint = 3,
    AnisotropicLinear = 4,
    ETextureSamplerFilter_MAX = 5,
};

enum class ETextureSizingType {
    TextureSizingType_UseSingleTextureSize = 0,
    TextureSizingType_UseAutomaticBiasedSizes = 1,
    TextureSizingType_UseManualOverrideTextureSize = 2,
    TextureSizingType_UseSimplygonAutomaticSizing = 3,
    TextureSizingType_MAX = 4,
};

enum class ETextureSourceArtType {
    TSAT_Uncompressed = 0,
    TSAT_PNGCompressed = 1,
    TSAT_DDSFile = 2,
    TSAT_MAX = 3,
};

enum class ETextureSourceFormat {
    TSF_Invalid = 0,
    TSF_G8 = 1,
    TSF_BGRA8 = 2,
    TSF_BGRE8 = 3,
    TSF_RGBA16 = 4,
    TSF_RGBA16F = 5,
    TSF_RGBA8 = 6,
    TSF_RGBE8 = 7,
    TSF_G16 = 8,
    TSF_MAX = 9,
};

enum class ETickingGroup {
    TG_PrePhysics = 0,
    TG_StartPhysics = 1,
    TG_DuringPhysics = 2,
    TG_EndPhysics = 3,
    TG_PostPhysics = 4,
    TG_PostUpdateWork = 5,
    TG_LastDemotable = 6,
    TG_NewlySpawned = 7,
    TG_MAX = 8,
};

enum class ETimeStretchCurveMapping {
    T_Original = 0,
    T_TargetMin = 1,
    T_TargetMax = 2,
    MAX = 3,
};

enum class ETimecodeProviderSynchronizationState {
    Closed = 0,
    Error = 1,
    Synchronized = 2,
    Synchronizing = 3,
    ETimecodeProviderSynchronizationState_MAX = 4,
};

enum class ETimelineDirection {
    Forward = 0,
    Backward = 1,
    ETimelineDirection_MAX = 2,
};

enum class ETimelineLengthMode {
    TL_TimelineLength = 0,
    TL_LastKeyFrame = 1,
    TL_MAX = 2,
};

enum class ETimelineSigType {
    ETS_EventSignature = 0,
    ETS_FloatSignature = 1,
    ETS_VectorSignature = 2,
    ETS_LinearColorSignature = 3,
    ETS_InvalidSignature = 4,
    ETS_MAX = 5,
};

enum class ETraceTypeQuery {
    TraceTypeQuery1 = 0,
    TraceTypeQuery2 = 1,
    TraceTypeQuery3 = 2,
    TraceTypeQuery4 = 3,
    TraceTypeQuery5 = 4,
    TraceTypeQuery6 = 5,
    TraceTypeQuery7 = 6,
    TraceTypeQuery8 = 7,
    TraceTypeQuery9 = 8,
    TraceTypeQuery10 = 9,
    TraceTypeQuery11 = 10,
    TraceTypeQuery12 = 11,
    TraceTypeQuery13 = 12,
    TraceTypeQuery14 = 13,
    TraceTypeQuery15 = 14,
    TraceTypeQuery16 = 15,
    TraceTypeQuery17 = 16,
    TraceTypeQuery18 = 17,
    TraceTypeQuery19 = 18,
    TraceTypeQuery20 = 19,
    TraceTypeQuery21 = 20,
    TraceTypeQuery22 = 21,
    TraceTypeQuery23 = 22,
    TraceTypeQuery24 = 23,
    TraceTypeQuery25 = 24,
    TraceTypeQuery26 = 25,
    TraceTypeQuery27 = 26,
    TraceTypeQuery28 = 27,
    TraceTypeQuery29 = 28,
    TraceTypeQuery30 = 29,
    TraceTypeQuery31 = 30,
    TraceTypeQuery32 = 31,
    TraceTypeQuery_MAX = 32,
    ETraceTypeQuery_MAX = 33,
};

enum class ETrackActiveCondition {
    ETAC_Always = 0,
    ETAC_GoreEnabled = 1,
    ETAC_GoreDisabled = 2,
    ETAC_MAX = 3,
};

enum class ETrackToggleAction {
    ETTA_Off = 0,
    ETTA_On = 1,
    ETTA_Toggle = 2,
    ETTA_Trigger = 3,
    ETTA_MAX = 4,
};

enum class ETrail2SourceMethod {
    PET2SRCM_Default = 0,
    PET2SRCM_Particle = 1,
    PET2SRCM_Actor = 2,
    PET2SRCM_MAX = 3,
};

enum class ETrailWidthMode {
    ETrailWidthMode_FromCentre = 0,
    ETrailWidthMode_FromFirst = 1,
    ETrailWidthMode_FromSecond = 2,
    ETrailWidthMode_MAX = 3,
};

enum class ETrailsRenderAxisOption {
    Trails_CameraUp = 0,
    Trails_SourceUp = 1,
    Trails_WorldUp = 2,
    Trails_MAX = 3,
};

enum class ETransitionBlendMode {
    TBM_Linear = 0,
    TBM_Cubic = 1,
    TBM_MAX = 2,
};

enum class ETransitionLogicType {
    TLT_StandardBlend = 0,
    TLT_Inertialization = 1,
    TLT_Custom = 2,
    TLT_MAX = 3,
};

enum class ETransitionType {
    None = 0,
    Paused = 1,
    Loading = 2,
    Saving = 3,
    Connecting = 4,
    Precaching = 5,
    WaitingToConnect = 6,
    MAX = 7,
};

enum class ETranslucencyLightingMode {
    TLM_VolumetricNonDirectional = 0,
    TLM_VolumetricDirectional = 1,
    TLM_VolumetricPerVertexNonDirectional = 2,
    TLM_VolumetricPerVertexDirectional = 3,
    TLM_Surface = 4,
    TLM_SurfacePerPixelLighting = 5,
    TLM_MAX = 6,
};

enum class ETranslucencyType {
    Raster = 0,
    RayTracing = 1,
    ETranslucencyType_MAX = 2,
};

enum class ETranslucentSortPolicy {
    SortByDistance = 0,
    SortByProjectedZ = 1,
    SortAlongAxis = 2,
    ETranslucentSortPolicy_MAX = 3,
};

enum class ETravelFailure {
    NoLevel = 0,
    LoadMapFailure = 1,
    InvalidURL = 2,
    PackageMissing = 3,
    PackageVersion = 4,
    NoDownload = 5,
    TravelFailure = 6,
    CheatCommands = 7,
    PendingNetGameCreateFailure = 8,
    CloudSaveFailure = 9,
    ServerTravelFailure = 10,
    ClientTravelFailure = 11,
    ETravelFailure_MAX = 12,
};

enum class ETravelType {
    TRAVEL_Absolute = 0,
    TRAVEL_Partial = 1,
    TRAVEL_Relative = 2,
    TRAVEL_MAX = 3,
};

enum class ETwitterIntegrationDelegate {
    TID_AuthorizeComplete = 0,
    TID_TweetUIComplete = 1,
    TID_RequestComplete = 2,
    TID_MAX = 3,
};

enum class ETwitterRequestMethod {
    TRM_Get = 0,
    TRM_Post = 1,
    TRM_Delete = 2,
    TRM_MAX = 3,
};

enum class ETypeAdvanceAnim {
    ETAA_Default = 0,
    ETAA_Finished = 1,
    ETAA_Looped = 2,
    ETAA_MAX = 3,
};

enum class EUIScalingRule {
    ShortestSide = 0,
    LongestSide = 1,
    Horizontal = 2,
    Vertical = 3,
    ScaleToFit = 4,
    Custom = 5,
    EUIScalingRule_MAX = 6,
};

enum class EUVOutput {
    DoNotOutputChannel = 0,
    OutputChannel = 1,
    EUVOutput_MAX = 2,
};

enum class EUpdateRateShiftBucket {
    ShiftBucket0 = 0,
    ShiftBucket1 = 1,
    ShiftBucket2 = 2,
    ShiftBucket3 = 3,
    ShiftBucket4 = 4,
    ShiftBucket5 = 5,
    ShiftBucketMax = 6,
    EUpdateRateShiftBucket_MAX = 7,
};

enum class EUserDefinedStructureStatus {
    UDSS_UpToDate = 0,
    UDSS_Dirty = 1,
    UDSS_Error = 2,
    UDSS_Duplicate = 3,
    UDSS_MAX = 4,
};

enum class EVectorFieldConstructionOp {
    VFCO_Extrude = 0,
    VFCO_Revolve = 1,
    VFCO_MAX = 2,
};

enum class EVectorNoiseFunction {
    VNF_CellnoiseALU = 0,
    VNF_VectorALU = 1,
    VNF_GradientALU = 2,
    VNF_CurlALU = 3,
    VNF_VoronoiALU = 4,
    VNF_MAX = 5,
};

enum class EVectorQuantization {
    RoundWholeNumber = 0,
    RoundOneDecimal = 1,
    RoundTwoDecimals = 2,
    EVectorQuantization_MAX = 3,
};

enum class EVertexOffsetUsageType {
    None = 0,
    PreSkinningOffset = 1,
    PostSkinningOffset = 2,
    EVertexOffsetUsageType_MAX = 3,
};

enum class EVertexPaintAxis {
    X = 0,
    Y = 1,
    Z = 2,
    EVertexPaintAxis_MAX = 3,
};

enum class EVerticalTextAligment {
    EVRTA_TextTop = 0,
    EVRTA_TextCenter = 1,
    EVRTA_TextBottom = 2,
    EVRTA_QuadTop = 3,
    EVRTA_MAX = 4,
};

enum class EViewModeIndex {
    VMI_BrushWireframe = 0,
    VMI_Wireframe = 1,
    VMI_Unlit = 2,
    VMI_Lit = 3,
    VMI_Lit_DetailLighting = 4,
    VMI_LightingOnly = 5,
    VMI_LightComplexity = 6,
    VMI_ShaderComplexity = 8,
    VMI_LightmapDensity = 9,
    VMI_LitLightmapDensity = 10,
    VMI_ReflectionOverride = 11,
    VMI_VisualizeBuffer = 12,
    VMI_StationaryLightOverlap = 14,
    VMI_CollisionPawn = 15,
    VMI_CollisionVisibility = 16,
    VMI_LODColoration = 18,
    VMI_QuadOverdraw = 19,
    VMI_PrimitiveDistanceAccuracy = 20,
    VMI_MeshUVDensityAccuracy = 21,
    VMI_ShaderComplexityWithQuadOverdraw = 22,
    VMI_HLODColoration = 23,
    VMI_GroupLODColoration = 24,
    VMI_MaterialTextureScaleAccuracy = 25,
    VMI_RequiredTextureResolution = 26,
    VMI_PathTracing = 27,
    VMI_RayTracingDebug = 28,
    VMI_Max = 29,
    VMI_Unknown = 255,
    VMI_Max = 256,
};

enum class EViewTargetBlendFunction {
    VTBlend_Linear = 0,
    VTBlend_Cubic = 1,
    VTBlend_EaseIn = 2,
    VTBlend_EaseOut = 3,
    VTBlend_EaseInOut = 4,
    VTBlend_PreBlended = 5,
    VTBlend_MAX = 6,
};

enum class EVirtualizationMode {
    Disabled = 0,
    PlayWhenSilent = 1,
    Restart = 2,
    EVirtualizationMode_MAX = 3,
};

enum class EVisibilityAggressiveness {
    VIS_LeastAggressive = 0,
    VIS_ModeratelyAggressive = 1,
    VIS_MostAggressive = 2,
    VIS_Max = 3,
    VIS_Max = 4,
};

enum class EVisibilityBasedAnimTickOption {
    AlwaysTickPoseAndRefreshBones = 0,
    AlwaysTickPose = 1,
    OnlyTickMontagesWhenNotRendered = 2,
    OnlyTickPoseWhenRendered = 3,
    EVisibilityBasedAnimTickOption_MAX = 4,
};

enum class EVisibilityTrackAction {
    EVTA_Hide = 0,
    EVTA_Show = 1,
    EVTA_Toggle = 2,
    EVTA_MAX = 3,
};

enum class EVisibilityTrackCondition {
    EVTC_Always = 0,
    EVTC_GoreEnabled = 1,
    EVTC_GoreDisabled = 2,
    EVTC_MAX = 3,
};

enum class EVoiceSampleRate {
    Low16000Hz = 16000,
    Normal24000Hz = 24000,
    EVoiceSampleRate_MAX = 24001,
};

enum class EVolumeLightingMethod {
    VLM_VolumetricLightmap = 0,
    VLM_SparseVolumeLightingSamples = 1,
    VLM_MAX = 2,
};

enum class EWalkableSlopeBehavior {
    WalkableSlope_Default = 0,
    WalkableSlope_Increase = 1,
    WalkableSlope_Decrease = 2,
    WalkableSlope_Unwalkable = 3,
    WalkableSlope_Max = 4,
    WalkableSlope_Max = 5,
};

enum class EWindSourceType {
    Directional = 0,
    Point = 1,
    EWindSourceType_MAX = 2,
};

enum class EWindowMode {
    Fullscreen = 0,
    WindowedFullscreen = 1,
    Windowed = 2,
    EWindowMode_MAX = 3,
};

enum class EWindowTitleBarMode {
    Overlay = 0,
    VerticalBox = 1,
    EWindowTitleBarMode_MAX = 2,
};

enum class EWorldPositionIncludedOffsets {
    WPT_Default = 0,
    WPT_ExcludeAllShaderOffsets = 1,
    WPT_CameraRelative = 2,
    WPT_CameraRelativeNoOffsets = 3,
    WPT_MAX = 4,
};

// Size: 0xb0
class UEdGraph : public UObject {
    /* 0x0030 */ UClass* Schema;
    /* 0x0038 */ TArray<UEdGraphNode*> Nodes;
    /* 0x0048 */ bool bEditable;
    /* 0x0048 */ bool bAllowDeletion;
    /* 0x0048 */ bool bAllowRenaming;
    /* 0x0050 */ TArray<UEdGraph*> SubGraphs;
    /* 0x0060 */ FGuid GraphGuid;
    /* 0x0070 */ FGuid InterfaceGuid;
};

// Size: 0xc8
class UEdGraphNode : public UObject {
    /* 0x0040 */ TArray<UEdGraphPin_Deprecated*> DeprecatedPins;
    /* 0x0050 */ int32_t NodePosX;
    /* 0x0054 */ int32_t NodePosY;
    /* 0x0058 */ int32_t NodeWidth;
    /* 0x005c */ int32_t NodeHeight;
    /* 0x0060 */ uint8_t AdvancedPinDisplay;
    /* 0x0061 */ ENodeEnabledState EnabledState;
    /* 0x0063 */ bool bDisplayAsDisabled;
    /* 0x0063 */ bool bUserSetEnabledState;
    /* 0x0063 */ bool bIsNodeEnabled;
    /* 0x0063 */ bool bCanResizeNode;
    /* 0x0064 */ bool bHasCompilerMessage;
    /* 0x0064 */ bool bCommentBubblePinned;
    /* 0x0064 */ bool bCommentBubbleVisible;
    /* 0x0064 */ bool bCommentBubbleMakeVisible;
    /* 0x0064 */ bool bCanRenameNode;
    /* 0x0068 */ FText NodeUpgradeMessage;
    /* 0x0080 */ FString NodeComment;
    /* 0x0090 */ int32_t ErrorType;
    /* 0x0098 */ FString ErrorMsg;
    /* 0x00a8 */ FGuid NodeGuid;
};

// Size: 0xe8
class UEdGraphNode_Documentation : public UEdGraphNode {
    /* 0x00c8 */ FString Link;
    /* 0x00d8 */ FString Excerpt;
};

// Size: 0x18
struct FEdGraphPinReference {
    /* 0x0000 */ TWeakObjectPtr<UEdGraphNode> OwningNode;
    /* 0x0008 */ FGuid PinId;
};

// Size: 0x70
struct FEdGraphPinType {
    /* 0x0000 */ FName PinCategory;
    /* 0x000c */ FName PinSubCategory;
    /* 0x0018 */ TWeakObjectPtr<UObject> PinSubCategoryObject;
    /* 0x0020 */ FSimpleMemberReference PinSubCategoryMemberReference;
    /* 0x0048 */ FEdGraphTerminalType PinValueType;
    /* 0x006c */ EPinContainerType ContainerType;
    /* 0x006d */ bool bIsArray;
    /* 0x006d */ bool bIsReference;
    /* 0x006d */ bool bIsConst;
    /* 0x006d */ bool bIsWeakPointer;
    /* 0x006d */ bool bIsUObjectWrapper;
};

// Size: 0x168
class UEdGraphPin_Deprecated : public UObject {
    /* 0x0030 */ FString PinName;
    /* 0x0040 */ FText PinFriendlyName;
    /* 0x0058 */ FString PinToolTip;
    /* 0x0068 */ uint8_t Direction;
    /* 0x0070 */ FEdGraphPinType PinType;
    /* 0x00e0 */ FString DefaultValue;
    /* 0x00f0 */ FString AutogeneratedDefaultValue;
    /* 0x0100 */ UObject* DefaultObject;
    /* 0x0108 */ FText DefaultTextValue;
    /* 0x0120 */ TArray<UEdGraphPin_Deprecated*> LinkedTo;
    /* 0x0130 */ TArray<UEdGraphPin_Deprecated*> SubPins;
    /* 0x0140 */ UEdGraphPin_Deprecated* ParentPin;
    /* 0x0148 */ UEdGraphPin_Deprecated* ReferencePassThroughConnection;
    /* 0x0150 */ bool bHidden;
    /* 0x0150 */ bool bNotConnectable;
    /* 0x0150 */ bool bDefaultValueIsReadOnly;
    /* 0x0150 */ bool bDefaultValueIsIgnored;
    /* 0x0150 */ bool bIsDiffing;
    /* 0x0150 */ bool bAdvancedView;
    /* 0x0150 */ bool bDisplayAsMutableRef;
    /* 0x0154 */ FGuid PersistentGuid;
};

// Size: 0x30
class UEdGraphSchema : public UObject {
};

// Size: 0x100
struct FEdGraphSchemaAction {
    /* 0x0008 */ FText MenuDescription;
    /* 0x0020 */ FText TooltipDescription;
    /* 0x0038 */ FText Category;
    /* 0x0050 */ FText Keywords;
    /* 0x0068 */ int32_t Grouping;
    /* 0x006c */ int32_t SectionID;
    /* 0x0070 */ TArray<FString> MenuDescriptionArray;
    /* 0x0080 */ TArray<FString> FullSearchTitlesArray;
    /* 0x0090 */ TArray<FString> FullSearchKeywordsArray;
    /* 0x00a0 */ TArray<FString> FullSearchCategoryArray;
    /* 0x00b0 */ TArray<FString> LocalizedMenuDescriptionArray;
    /* 0x00c0 */ TArray<FString> LocalizedFullSearchTitlesArray;
    /* 0x00d0 */ TArray<FString> LocalizedFullSearchKeywordsArray;
    /* 0x00e0 */ TArray<FString> LocalizedFullSearchCategoryArray;
    /* 0x00f0 */ FString SearchText;
};

// Size: 0x108
struct FEdGraphSchemaAction_NewNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UEdGraphNode* NodeTemplate;
};

// Size: 0x24
struct FEdGraphTerminalType {
    /* 0x0000 */ FName TerminalCategory;
    /* 0x000c */ FName TerminalSubCategory;
    /* 0x0018 */ TWeakObjectPtr<UObject> TerminalSubCategoryObject;
    /* 0x0020 */ bool bTerminalIsConst;
    /* 0x0021 */ bool bTerminalIsWeakPointer;
    /* 0x0022 */ bool bTerminalIsUObjectWrapper;
};

// Size: 0x38
struct FEditedDocumentInfo {
    /* 0x0000 */ FSoftObjectPath EditedObjectPath;
    /* 0x0020 */ FVector2D SavedViewOffset;
    /* 0x0028 */ float SavedZoomAmount;
    /* 0x0030 */ UObject* EditedObject;
};

// Size: 0x18
struct FEditorElement {
    /* 0x0000 */ int32_t Indices[3];
    /* 0x000c */ float Weights[3];
};

// Size: 0x38
struct FEditorImportExportTestDefinition {
    /* 0x0000 */ FFilePath ImportFilePath;
    /* 0x0010 */ FString ExportFileExtension;
    /* 0x0020 */ bool bSkipExport;
    /* 0x0028 */ TArray<FImportFactorySettingValues> FactorySettings;
};

// Size: 0x20
struct FEditorImportWorkflowDefinition {
    /* 0x0000 */ FFilePath ImportFilePath;
    /* 0x0010 */ TArray<FImportFactorySettingValues> FactorySettings;
};

// Size: 0x28
struct FEditorMapPerformanceTestDefinition {
    /* 0x0000 */ FSoftObjectPath PerformanceTestmap;
    /* 0x0020 */ int32_t TestTimer;
};

// Size: 0x358
class AEmitter : public AActor {
    /* 0x02f8 */ UParticleSystemComponent* ParticleSystemComponent;
    /* 0x0300 */ bool bDestroyOnSystemFinish;
    /* 0x0300 */ bool bPostUpdateTickGroup;
    /* 0x0300 */ bool bCurrentlyActive;
    /* 0x0308 */ FMulticastInlineDelegate OnParticleSpawn;
    /* 0x0318 */ FMulticastInlineDelegate OnParticleBurst;
    /* 0x0328 */ FMulticastInlineDelegate OnParticleDeath;
    /* 0x0338 */ FMulticastInlineDelegate OnParticleCollide;
    /* 0x0348 */ UBillboardComponent* SpriteComponent;
    /* 0x0350 */ UArrowComponent* ArrowComponent;

    void Activate();
    void Deactivate();
    bool IsActive() const;
    void OnParticleSystemFinished(UParticleSystemComponent* FinishedComponent);
    void OnRep_bCurrentlyActive();
    void SetActorParameter(FName ParameterName, AActor* Param);
    void SetColorParameter(FName ParameterName, FLinearColor Param);
    void SetFloatParameter(FName ParameterName, float Param);
    void SetMaterialParameter(FName ParameterName, UMaterialInterface* Param);
    void SetTemplate(UParticleSystem* NewTemplate);
    void SetVectorParameter(FName ParameterName, FVector Param);
    void ToggleActive();
};

// Size: 0x3c0
class AEmitterCameraLensEffectBase : public AEmitter {
    /* 0x0358 */ UParticleSystem* PS_CameraEffect;
    /* 0x0360 */ UParticleSystem* PS_CameraEffectNonExtremeContent;
    /* 0x0368 */ APlayerCameraManager* BaseCamera;
    /* 0x0370 */ FTransform RelativeTransform;
    /* 0x03a0 */ float BaseFOV;
    /* 0x03a4 */ bool bAllowMultipleInstances;
    /* 0x03a4 */ bool bResetWhenRetriggered;
    /* 0x03a8 */ TArray<UClass*> EmittersToTreatAsSame;
    /* 0x03b8 */ float DistFromCamera;
};

// Size: 0x48
struct FEmitterDynamicParameter {
    /* 0x0000 */ FName ParamName;
    /* 0x000c */ bool bUseEmitterTime;
    /* 0x000c */ bool bSpawnTimeOnly;
    /* 0x0010 */ uint8_t ValueMethod;
    /* 0x0014 */ bool bScaleVelocityByParamValue;
    /* 0x0018 */ FRawDistributionFloat ParamValue;
};

// Size: 0x30
struct FEndPhysicsTickFunction : public FTickFunction {
};

// Size: 0x68
class UEndpointSubmix : public USoundSubmixBase {
    /* 0x0048 */ FName EndpointType;
    /* 0x0058 */ UClass* EndpointSettingsClass;
    /* 0x0060 */ UAudioEndpointSettingsBase* EndpointSettings;
};

// Size: 0x1100
class UEngine : public UObject {
    /* 0x0038 */ UFont* TinyFont;
    /* 0x0040 */ FSoftObjectPath TinyFontName;
    /* 0x0060 */ UFont* SmallFont;
    /* 0x0068 */ FSoftObjectPath SmallFontName;
    /* 0x0088 */ UFont* MediumFont;
    /* 0x0090 */ FSoftObjectPath MediumFontName;
    /* 0x00b0 */ UFont* LargeFont;
    /* 0x00b8 */ FSoftObjectPath LargeFontName;
    /* 0x00d8 */ UFont* SubtitleFont;
    /* 0x00e0 */ FSoftObjectPath SubtitleFontName;
    /* 0x0100 */ TArray<UFont*> AdditionalFonts;
    /* 0x0110 */ TArray<FString> AdditionalFontNames;
    /* 0x0120 */ UClass* ConsoleClass;
    /* 0x0128 */ FSoftClassPath ConsoleClassName;
    /* 0x0148 */ UClass* GameViewportClientClass;
    /* 0x0150 */ FSoftClassPath GameViewportClientClassName;
    /* 0x0170 */ UClass* LocalPlayerClass;
    /* 0x0178 */ FSoftClassPath LocalPlayerClassName;
    /* 0x0198 */ UClass* WorldSettingsClass;
    /* 0x01a0 */ FSoftClassPath WorldSettingsClassName;
    /* 0x01c0 */ FSoftClassPath NavigationSystemClassName;
    /* 0x01e0 */ UClass* NavigationSystemClass;
    /* 0x01e8 */ FSoftClassPath NavigationSystemConfigClassName;
    /* 0x0208 */ UClass* NavigationSystemConfigClass;
    /* 0x0210 */ FSoftClassPath AvoidanceManagerClassName;
    /* 0x0230 */ UClass* AvoidanceManagerClass;
    /* 0x0238 */ FSoftClassPath AIControllerClassName;
    /* 0x0258 */ UClass* PhysicsCollisionHandlerClass;
    /* 0x0260 */ FSoftClassPath PhysicsCollisionHandlerClassName;
    /* 0x0280 */ FSoftClassPath GameUserSettingsClassName;
    /* 0x02a0 */ UClass* GameUserSettingsClass;
    /* 0x02a8 */ UGameUserSettings* GameUserSettings;
    /* 0x02b0 */ UClass* LevelScriptActorClass;
    /* 0x02b8 */ FSoftClassPath LevelScriptActorClassName;
    /* 0x02d8 */ FSoftClassPath DefaultBlueprintBaseClassName;
    /* 0x02f8 */ FSoftClassPath GameSingletonClassName;
    /* 0x0318 */ UObject* GameSingleton;
    /* 0x0320 */ FSoftClassPath AssetManagerClassName;
    /* 0x0340 */ UAssetManager* AssetManager;
    /* 0x0348 */ UTexture2D* DefaultTexture;
    /* 0x0350 */ FSoftObjectPath DefaultTextureName;
    /* 0x0370 */ UTexture* DefaultDiffuseTexture;
    /* 0x0378 */ FSoftObjectPath DefaultDiffuseTextureName;
    /* 0x0398 */ UTexture2D* DefaultBSPVertexTexture;
    /* 0x03a0 */ FSoftObjectPath DefaultBSPVertexTextureName;
    /* 0x03c0 */ UTexture2D* HighFrequencyNoiseTexture;
    /* 0x03c8 */ FSoftObjectPath HighFrequencyNoiseTextureName;
    /* 0x03e8 */ UTexture2D* DefaultBokehTexture;
    /* 0x03f0 */ FSoftObjectPath DefaultBokehTextureName;
    /* 0x0410 */ UTexture2D* DefaultBloomKernelTexture;
    /* 0x0418 */ FSoftObjectPath DefaultBloomKernelTextureName;
    /* 0x0438 */ UMaterial* WireframeMaterial;
    /* 0x0440 */ FString WireframeMaterialName;
    /* 0x0450 */ UMaterial* GeomMaterial;
    /* 0x0458 */ FSoftObjectPath GeomMaterialName;
    /* 0x0478 */ UMaterial* DebugMeshMaterial;
    /* 0x0480 */ FSoftObjectPath DebugMeshMaterialName;
    /* 0x04a0 */ UMaterial* EmissiveMeshMaterial;
    /* 0x04a8 */ FSoftObjectPath EmissiveMeshMaterialName;
    /* 0x04c8 */ UMaterial* LevelColorationLitMaterial;
    /* 0x04d0 */ FString LevelColorationLitMaterialName;
    /* 0x04e0 */ UMaterial* LevelColorationUnlitMaterial;
    /* 0x04e8 */ FString LevelColorationUnlitMaterialName;
    /* 0x04f8 */ UMaterial* LightingTexelDensityMaterial;
    /* 0x0500 */ FString LightingTexelDensityName;
    /* 0x0510 */ UMaterial* ShadedLevelColorationLitMaterial;
    /* 0x0518 */ FString ShadedLevelColorationLitMaterialName;
    /* 0x0528 */ UMaterial* ShadedLevelColorationUnlitMaterial;
    /* 0x0530 */ FString ShadedLevelColorationUnlitMaterialName;
    /* 0x0540 */ UMaterial* RemoveSurfaceMaterial;
    /* 0x0548 */ FSoftObjectPath RemoveSurfaceMaterialName;
    /* 0x0568 */ UMaterial* VertexColorMaterial;
    /* 0x0570 */ FString VertexColorMaterialName;
    /* 0x0580 */ UMaterial* VertexColorViewModeMaterial_ColorOnly;
    /* 0x0588 */ FString VertexColorViewModeMaterialName_ColorOnly;
    /* 0x0598 */ UMaterial* VertexColorViewModeMaterial_AlphaAsColor;
    /* 0x05a0 */ FString VertexColorViewModeMaterialName_AlphaAsColor;
    /* 0x05b0 */ UMaterial* VertexColorViewModeMaterial_RedOnly;
    /* 0x05b8 */ FString VertexColorViewModeMaterialName_RedOnly;
    /* 0x05c8 */ UMaterial* VertexColorViewModeMaterial_GreenOnly;
    /* 0x05d0 */ FString VertexColorViewModeMaterialName_GreenOnly;
    /* 0x05e0 */ UMaterial* VertexColorViewModeMaterial_BlueOnly;
    /* 0x05e8 */ FString VertexColorViewModeMaterialName_BlueOnly;
    /* 0x05f8 */ UMaterial* BoneWeightMaterial;
    /* 0x0600 */ FSoftObjectPath BoneWeightMaterialName;
    /* 0x0620 */ UMaterial* ClothPaintMaterial;
    /* 0x0628 */ UMaterial* ClothPaintMaterialWireframe;
    /* 0x0630 */ UMaterialInstanceDynamic* ClothPaintMaterialInstance;
    /* 0x0638 */ UMaterialInstanceDynamic* ClothPaintMaterialWireframeInstance;
    /* 0x0640 */ FSoftObjectPath ClothPaintMaterialName;
    /* 0x0660 */ FSoftObjectPath ClothPaintMaterialWireframeName;
    /* 0x0680 */ UMaterial* PhysicalMaterialMaskMaterial;
    /* 0x0688 */ FSoftObjectPath PhysicalMaterialMaskMaterialName;
    /* 0x06a8 */ UMaterial* DebugEditorMaterial;
    /* 0x06b0 */ FSoftObjectPath DebugEditorMaterialName;
    /* 0x06d0 */ UMaterial* ConstraintLimitMaterial;
    /* 0x06d8 */ UMaterialInstanceDynamic* ConstraintLimitMaterialX;
    /* 0x06e0 */ UMaterialInstanceDynamic* ConstraintLimitMaterialXAxis;
    /* 0x06e8 */ UMaterialInstanceDynamic* ConstraintLimitMaterialY;
    /* 0x06f0 */ UMaterialInstanceDynamic* ConstraintLimitMaterialYAxis;
    /* 0x06f8 */ UMaterialInstanceDynamic* ConstraintLimitMaterialZ;
    /* 0x0700 */ UMaterialInstanceDynamic* ConstraintLimitMaterialZAxis;
    /* 0x0708 */ UMaterialInstanceDynamic* ConstraintLimitMaterialPrismatic;
    /* 0x0710 */ UMaterial* InvalidLightmapSettingsMaterial;
    /* 0x0718 */ FSoftObjectPath InvalidLightmapSettingsMaterialName;
    /* 0x0738 */ UMaterial* PreviewShadowsIndicatorMaterial;
    /* 0x0740 */ FSoftObjectPath PreviewShadowsIndicatorMaterialName;
    /* 0x0760 */ UMaterial* ArrowMaterial;
    /* 0x0768 */ UMaterialInstanceDynamic* ArrowMaterialYellow;
    /* 0x0770 */ FSoftObjectPath ArrowMaterialName;
    /* 0x0790 */ FLinearColor LightingOnlyBrightness;
    /* 0x07a0 */ TArray<FLinearColor> ShaderComplexityColors;
    /* 0x07b0 */ TArray<FLinearColor> QuadComplexityColors;
    /* 0x07c0 */ TArray<FLinearColor> LightComplexityColors;
    /* 0x07d0 */ TArray<FLinearColor> StationaryLightOverlapColors;
    /* 0x07e0 */ TArray<FLinearColor> LODColorationColors;
    /* 0x07f0 */ TArray<FLinearColor> HLODColorationColors;
    /* 0x0800 */ TArray<FLinearColor> StreamingAccuracyColors;
    /* 0x0810 */ float MaxPixelShaderAdditiveComplexityCount;
    /* 0x0814 */ float MaxES3PixelShaderAdditiveComplexityCount;
    /* 0x0818 */ float MinLightMapDensity;
    /* 0x081c */ float IdealLightMapDensity;
    /* 0x0820 */ float MaxLightMapDensity;
    /* 0x0824 */ bool bRenderLightMapDensityGrayscale;
    /* 0x0828 */ float RenderLightMapDensityGrayscaleScale;
    /* 0x082c */ float RenderLightMapDensityColorScale;
    /* 0x0830 */ FLinearColor LightMapDensityVertexMappedColor;
    /* 0x0840 */ FLinearColor LightMapDensitySelectedColor;
    /* 0x0850 */ TArray<FStatColorMapping> StatColorMappings;
    /* 0x0860 */ UMaterial* EditorBrushMaterial;
    /* 0x0868 */ FSoftObjectPath EditorBrushMaterialName;
    /* 0x0888 */ UPhysicalMaterial* DefaultPhysMaterial;
    /* 0x0890 */ FSoftObjectPath DefaultPhysMaterialName;
    /* 0x08b0 */ TArray<FGameNameRedirect> ActiveGameNameRedirects;
    /* 0x08c0 */ TArray<FClassRedirect> ActiveClassRedirects;
    /* 0x08d0 */ TArray<FPluginRedirect> ActivePluginRedirects;
    /* 0x08e0 */ TArray<FStructRedirect> ActiveStructRedirects;
    /* 0x08f0 */ UTexture2D* PreIntegratedSkinBRDFTexture;
    /* 0x08f8 */ FSoftObjectPath PreIntegratedSkinBRDFTextureName;
    /* 0x0918 */ UTexture2D* BlueNoiseTexture;
    /* 0x0920 */ FSoftObjectPath BlueNoiseTextureName;
    /* 0x0940 */ UTexture2D* MiniFontTexture;
    /* 0x0948 */ FSoftObjectPath MiniFontTextureName;
    /* 0x0968 */ UTexture* WeightMapPlaceholderTexture;
    /* 0x0970 */ FSoftObjectPath WeightMapPlaceholderTextureName;
    /* 0x0990 */ UTexture2D* LightMapDensityTexture;
    /* 0x0998 */ FSoftObjectPath LightMapDensityTextureName;
    /* 0x09c0 */ UGameViewportClient* GameViewport;
    /* 0x09c8 */ TArray<FString> DeferredCommands;
    /* 0x09d8 */ float NearClipPlane;
    /* 0x09dc */ bool bSubtitlesEnabled;
    /* 0x09dc */ bool bSubtitlesForcedOff;
    /* 0x09e0 */ int32_t MaximumLoopIterationCount;
    /* 0x09e4 */ bool bCanBlueprintsTickByDefault;
    /* 0x09e4 */ bool bOptimizeAnimBlueprintMemberVariableAccess;
    /* 0x09e4 */ bool bAllowMultiThreadedAnimationUpdate;
    /* 0x09e4 */ bool bEnableEditorPSysRealtimeLOD;
    /* 0x09e4 */ bool bSmoothFrameRate;
    /* 0x09e4 */ bool bUseFixedFrameRate;
    /* 0x09e8 */ float FixedFrameRate;
    /* 0x09ec */ FFloatRange SmoothedFrameRateRange;
    /* 0x0a00 */ UEngineCustomTimeStep* CustomTimeStep;
    /* 0x0a28 */ FSoftClassPath CustomTimeStepClassName;
    /* 0x0a48 */ UTimecodeProvider* TimecodeProvider;
    /* 0x0a70 */ FSoftClassPath TimecodeProviderClassName;
    /* 0x0a90 */ bool bGenerateDefaultTimecode;
    /* 0x0a94 */ FFrameRate GenerateDefaultTimecodeFrameRate;
    /* 0x0a9c */ float GenerateDefaultTimecodeFrameDelay;
    /* 0x0aa0 */ bool bCheckForMultiplePawnsSpawnedInAFrame;
    /* 0x0aa4 */ int32_t NumPawnsAllowedToBeSpawnedInAFrame;
    /* 0x0aa8 */ bool bShouldGenerateLowQualityLightmaps;
    /* 0x0aac */ FColor C_WorldBox;
    /* 0x0ab0 */ FColor C_BrushWire;
    /* 0x0ab4 */ FColor C_AddWire;
    /* 0x0ab8 */ FColor C_SubtractWire;
    /* 0x0abc */ FColor C_SemiSolidWire;
    /* 0x0ac0 */ FColor C_NonSolidWire;
    /* 0x0ac4 */ FColor C_WireBackground;
    /* 0x0ac8 */ FColor C_ScaleBoxHi;
    /* 0x0acc */ FColor C_VolumeCollision;
    /* 0x0ad0 */ FColor C_BSPCollision;
    /* 0x0ad4 */ FColor C_OrthoBackground;
    /* 0x0ad8 */ FColor C_Volume;
    /* 0x0adc */ FColor C_BrushShape;
    /* 0x0ae0 */ float StreamingDistanceFactor;
    /* 0x0ae8 */ FDirectoryPath GameScreenshotSaveDirectory;
    /* 0x0af8 */ ETransitionType TransitionType;
    /* 0x0b00 */ FString TransitionDescription;
    /* 0x0b10 */ FString TransitionGameMode;
    /* 0x0b20 */ bool bAllowMatureLanguage;
    /* 0x0b24 */ float CameraRotationThreshold;
    /* 0x0b28 */ float CameraTranslationThreshold;
    /* 0x0b2c */ float PrimitiveProbablyVisibleTime;
    /* 0x0b30 */ float MaxOcclusionPixelsFraction;
    /* 0x0b34 */ bool bPauseOnLossOfFocus;
    /* 0x0b38 */ int32_t MaxParticleResize;
    /* 0x0b3c */ int32_t MaxParticleResizeWarn;
    /* 0x0b40 */ TArray<FDropNoteInfo> PendingDroppedNotes;
    /* 0x0b50 */ float NetClientTicksPerSecond;
    /* 0x0b54 */ float DisplayGamma;
    /* 0x0b58 */ float MinDesiredFrameRate;
    /* 0x0b5c */ FLinearColor DefaultSelectedMaterialColor;
    /* 0x0b6c */ FLinearColor SelectedMaterialColor;
    /* 0x0b7c */ FLinearColor SelectionOutlineColor;
    /* 0x0b8c */ FLinearColor SubduedSelectionOutlineColor;
    /* 0x0b9c */ FLinearColor SelectedMaterialColorOverride;
    /* 0x0bac */ bool bIsOverridingSelectedColor;
    /* 0x0bb0 */ bool bEnableOnScreenDebugMessages;
    /* 0x0bb0 */ bool bEnableOnScreenDebugMessagesDisplay;
    /* 0x0bb0 */ bool bSuppressMapWarnings;
    /* 0x0bb0 */ bool bDisableAILogging;
    /* 0x0bb4 */ uint32_t bEnableVisualLogRecordingOnStart;
    /* 0x0bb8 */ int32_t ScreenSaverInhibitorSemaphore;
    /* 0x0bbc */ bool bLockReadOnlyLevels;
    /* 0x0bc0 */ FString ParticleEventManagerClassPath;
    /* 0x0bd0 */ float SelectionHighlightIntensity;
    /* 0x0bd4 */ float BSPSelectionHighlightIntensity;
    /* 0x0bd8 */ float SelectionHighlightIntensityBillboards;
    /* 0x0fc0 */ TArray<FNetDriverDefinition> NetDriverDefinitions;
    /* 0x0fd0 */ TArray<FString> ServerActors;
    /* 0x0fe0 */ TArray<FString> RuntimeServerActors;
    /* 0x0ff0 */ float NetErrorLogInterval;
    /* 0x0ff4 */ bool bStartedLoadMapMovie;
    /* 0x1028 */ int32_t NextWorldContextHandle;
};

// Size: 0x30
class UEngineBaseTypes : public UObject {
};

// Size: 0x30
class UEngineCustomTimeStep : public UObject {
};

// Size: 0x30
class UEngineHandlerComponentFactory : public UHandlerComponentFactory {
};

// Size: 0xb0
class UEngineMessage : public ULocalMessage {
    /* 0x0030 */ FString FailedPlaceMessage;
    /* 0x0040 */ FString MaxedOutMessage;
    /* 0x0050 */ FString EnteredMessage;
    /* 0x0060 */ FString LeftMessage;
    /* 0x0070 */ FString GlobalNameChange;
    /* 0x0080 */ FString SpecEnteredMessage;
    /* 0x0090 */ FString NewPlayerMessage;
    /* 0x00a0 */ FString NewSpecMessage;
};

// Size: 0x18
struct FEngineShowFlagsSetting {
    /* 0x0000 */ FString ShowFlagName;
    /* 0x0010 */ bool Enabled;
};

// Size: 0x38
class UEngineSubsystem : public UDynamicSubsystem {
};

// Size: 0x30
class UEngineTypes : public UObject {
};

// Size: 0x48
struct FEquirectProps {
    /* 0x0000 */ FBox2D LeftUVRect;
    /* 0x0014 */ FBox2D RightUVRect;
    /* 0x0028 */ FVector2D LeftScale;
    /* 0x0030 */ FVector2D RightScale;
    /* 0x0038 */ FVector2D LeftBias;
    /* 0x0040 */ FVector2D RightBias;
};

// Size: 0x10
struct FEventGraphFastCallPair {
    /* 0x0000 */ UFunction* FunctionToPatch;
    /* 0x0008 */ int32_t EventGraphCallOffset;
};

// Size: 0x10
struct FEventTrackKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ FName EventName;
};

// Size: 0x310
class AExponentialHeightFog : public AInfo {
    /* 0x0300 */ UExponentialHeightFogComponent* Component;
    /* 0x0308 */ bool bEnabled;

    void OnRep_bEnabled();
};

// Size: 0x2d0
class UExponentialHeightFogComponent : public USceneComponent {
    /* 0x0228 */ float FogDensity;
    /* 0x022c */ float FogHeightFalloff;
    /* 0x0230 */ FExponentialHeightFogData SecondFogData;
    /* 0x023c */ FLinearColor FogInscatteringColor;
    /* 0x0250 */ UTextureCube* InscatteringColorCubemap;
    /* 0x0258 */ float InscatteringColorCubemapAngle;
    /* 0x025c */ FLinearColor InscatteringTextureTint;
    /* 0x026c */ float FullyDirectionalInscatteringColorDistance;
    /* 0x0270 */ float NonDirectionalInscatteringColorDistance;
    /* 0x0274 */ float DirectionalInscatteringExponent;
    /* 0x0278 */ float DirectionalInscatteringStartDistance;
    /* 0x027c */ FLinearColor DirectionalInscatteringColor;
    /* 0x028c */ float FogMaxOpacity;
    /* 0x0290 */ float StartDistance;
    /* 0x0294 */ float FogCutoffDistance;
    /* 0x0298 */ bool bEnableVolumetricFog;
    /* 0x029c */ float VolumetricFogScatteringDistribution;
    /* 0x02a0 */ FColor VolumetricFogAlbedo;
    /* 0x02a4 */ FLinearColor VolumetricFogEmissive;
    /* 0x02b4 */ float VolumetricFogExtinctionScale;
    /* 0x02b8 */ float VolumetricFogDistance;
    /* 0x02bc */ float VolumetricFogStaticLightingScatteringIntensity;
    /* 0x02c0 */ bool bOverrideLightColorsWithFogInscatteringColors;

    void SetDirectionalInscatteringColor(FLinearColor Value);
    void SetDirectionalInscatteringExponent(float Value);
    void SetDirectionalInscatteringStartDistance(float Value);
    void SetFogCutoffDistance(float Value);
    void SetFogDensity(float Value);
    void SetFogHeightFalloff(float Value);
    void SetFogInscatteringColor(FLinearColor Value);
    void SetFogMaxOpacity(float Value);
    void SetFullyDirectionalInscatteringColorDistance(float Value);
    void SetInscatteringColorCubemap(UTextureCube* Value);
    void SetInscatteringColorCubemapAngle(float Value);
    void SetInscatteringTextureTint(FLinearColor Value);
    void SetNonDirectionalInscatteringColorDistance(float Value);
    void SetStartDistance(float Value);
    void SetVolumetricFog(bool bNewValue);
    void SetVolumetricFogAlbedo(FColor NewValue);
    void SetVolumetricFogDistance(float NewValue);
    void SetVolumetricFogEmissive(FLinearColor NewValue);
    void SetVolumetricFogExtinctionScale(float NewValue);
    void SetVolumetricFogScatteringDistribution(float NewValue);
};

// Size: 0xc
struct FExponentialHeightFogData {
    /* 0x0000 */ float FogDensity;
    /* 0x0004 */ float FogHeightFalloff;
    /* 0x0008 */ float FogHeightOffset;
};

// Size: 0x80
class UExporter : public UObject {
    /* 0x0030 */ UClass* SupportedClass;
    /* 0x0038 */ UObject* ExportRootScope;
    /* 0x0040 */ TArray<FString> FormatExtension;
    /* 0x0050 */ TArray<FString> FormatDescription;
    /* 0x0060 */ int32_t PreferredFormatIndex;
    /* 0x0064 */ int32_t TextIndent;
    /* 0x0068 */ bool bText;
    /* 0x0068 */ bool bSelectedOnly;
    /* 0x0068 */ bool bForceFileOperations;
    /* 0x0070 */ UAssetExportTask* ExportTask;

    static bool RunAssetExportTask(UAssetExportTask* Task);
    static bool RunAssetExportTasks(const TArray<UAssetExportTask*>& ExportTasks);
    bool ScriptRunAssetExportTask(UAssetExportTask* Task);
};

// Size: 0x8
struct FExposedValueCopyRecord {
    /* 0x0000 */ int32_t CopyIndex;
    /* 0x0004 */ EPostCopyOperation PostCopyOperation;
};

// Size: 0x68
struct FExposedValueHandler {
    /* 0x0000 */ FName BoundFunction;
    /* 0x0010 */ TArray<FExposedValueCopyRecord> CopyRecords;
    /* 0x0020 */ UFunction* Function;
    /* 0x0028 */ FFieldPath ValueHandlerNodeProperty;
};

// Size: 0x8
struct FExposureSettings {
    /* 0x0000 */ float FixedEV100;
    /* 0x0004 */ bool bFixed;
};

// Size: 0x38
struct FExpressionInput {
    /* 0x0000 */ UMaterialExpression* Expression;
    /* 0x0008 */ int32_t OutputIndex;
    /* 0x000c */ FName InputName;
    /* 0x0018 */ int32_t mask;
    /* 0x001c */ int32_t MaskR;
    /* 0x0020 */ int32_t MaskG;
    /* 0x0024 */ int32_t MaskB;
    /* 0x0028 */ int32_t MaskA;
    /* 0x002c */ FName ExpressionName;
};

// Size: 0x20
struct FExpressionOutput {
    /* 0x0000 */ FName OutputName;
    /* 0x000c */ int32_t mask;
    /* 0x0010 */ int32_t MaskR;
    /* 0x0014 */ int32_t MaskG;
    /* 0x0018 */ int32_t MaskB;
    /* 0x001c */ int32_t MaskA;
};

// Size: 0x60
struct FExternalToolDefinition {
    /* 0x0000 */ FString ToolName;
    /* 0x0010 */ FFilePath ExecutablePath;
    /* 0x0020 */ FString CommandLineOptions;
    /* 0x0030 */ FDirectoryPath WorkingDirectory;
    /* 0x0040 */ FString ScriptExtension;
    /* 0x0050 */ FDirectoryPath ScriptDirectory;
};

enum class FDataDrivenCVarType {
    CVarFloat = 0,
    CVarInt = 1,
    CVarBool = 2,
    FDataDrivenCVarType_MAX = 3,
};

enum class FNavigationSystemRunMode {
    InvalidMode = 0,
    GameMode = 1,
    EditorMode = 2,
    SimulationMode = 3,
    PIEMode = 4,
    InferFromWorldMode = 5,
    FNavigationSystemRunMode_MAX = 6,
};

// Size: 0x40
class UFXSystemAsset : public UObject {
    /* 0x0030 */ uint32_t MaxPoolSize;
    /* 0x0034 */ uint32_t PoolPrimeSize;
};

// Size: 0x4e0
class UFXSystemComponent : public UPrimitiveComponent {

    UFXSystemAsset* GetFXSystemAsset() const;
    void ReleaseToPool();
    void SetActorParameter(FName ParameterName, AActor* Param);
    void SetAutoAttachmentParameters(USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule);
    void SetBoolParameter(FName ParameterName, bool Param);
    void SetColorParameter(FName ParameterName, FLinearColor Param);
    void SetEmitterEnable(FName EmitterName, bool bNewEnableState);
    void SetFloatParameter(FName ParameterName, float Param);
    void SetIntParameter(FName ParameterName, int32_t Param);
    void SetUseAutoManageAttachment(bool bAutoManage);
    void SetVectorParameter(FName ParameterName, FVector Param);
};

// Size: 0x108
struct FFastArraySerializer {
    /* 0x0054 */ int32_t ArrayReplicationKey;
    /* 0x0100 */ EFastArraySerializerDeltaFlags DeltaFlags;
};

// Size: 0xc
struct FFastArraySerializerItem {
    /* 0x0000 */ int32_t ReplicationID;
    /* 0x0004 */ int32_t ReplicationKey;
    /* 0x0008 */ int32_t MostRecentArrayReplicationKey;
};

// Size: 0x10
struct FFilePath {
    /* 0x0000 */ FString FilePath;
};

// Size: 0x14
struct FFilmStockSettings {
    /* 0x0000 */ float Slope;
    /* 0x0004 */ float Toe;
    /* 0x0008 */ float Shoulder;
    /* 0x000c */ float BlackClip;
    /* 0x0010 */ float WhiteClip;
};

// Size: 0x9c
struct FFindFloorResult {
    /* 0x0000 */ bool bBlockingHit;
    /* 0x0000 */ bool bWalkableFloor;
    /* 0x0000 */ bool bLineTrace;
    /* 0x0004 */ float FloorDist;
    /* 0x0008 */ float LineDist;
    /* 0x000c */ FHitResult HitResult;
};

// Size: 0xb0
struct FFloatCurve : public FAnimCurveBase {
    /* 0x0030 */ FRichCurve FloatCurve;
};

// Size: 0x20
struct FFloatDistribution {
    /* 0x0000 */ FDistributionLookupTable Table;
};

// Size: 0x8
struct FFloatRK4SpringInterpolator {
    /* 0x0000 */ float StiffnessConstant;
    /* 0x0004 */ float DampeningRatio;
};

// Size: 0x8
struct FFloatSpringState {
};

// Size: 0x168
class UFloatingPawnMovement : public UPawnMovementComponent {
    /* 0x0150 */ float MaxSpeed;
    /* 0x0154 */ float Acceleration;
    /* 0x0158 */ float Deceleration;
    /* 0x015c */ float TurningBoost;
    /* 0x0160 */ bool bPositionCorrected;
};

// Size: 0x1e8
class UFont : public UObject {
    /* 0x0038 */ EFontCacheType FontCacheType;
    /* 0x0040 */ TArray<FFontCharacter> Characters;
    /* 0x0050 */ TArray<UTexture2D*> Textures;
    /* 0x0060 */ int32_t IsRemapped;
    /* 0x0064 */ float EmScale;
    /* 0x0068 */ float Ascent;
    /* 0x006c */ float Descent;
    /* 0x0070 */ float Leading;
    /* 0x0074 */ int32_t Kerning;
    /* 0x0078 */ FFontImportOptionsData ImportOptions;
    /* 0x0128 */ int32_t NumCharacters;
    /* 0x0130 */ TArray<int32_t> MaxCharHeight;
    /* 0x0140 */ float ScalingFactor;
    /* 0x0144 */ int32_t LegacyFontSize;
    /* 0x0148 */ FName LegacyFontName;
    /* 0x0158 */ FCompositeFont CompositeFont;
};

// Size: 0x18
struct FFontCharacter {
    /* 0x0000 */ int32_t StartU;
    /* 0x0004 */ int32_t StartV;
    /* 0x0008 */ int32_t USize;
    /* 0x000c */ int32_t VSize;
    /* 0x0010 */ uint8_t TextureIndex;
    /* 0x0014 */ int32_t VerticalOffset;
};

// Size: 0x80
class UFontFace : public UObject {
    /* 0x0038 */ FString SourceFilename;
    /* 0x0048 */ EFontHinting Hinting;
    /* 0x0049 */ EFontLoadingPolicy LoadingPolicy;
    /* 0x004a */ EFontLayoutMethod LayoutMethod;
    /* 0x0060 */ TArray<uint8_t> FontFaceData;
    /* 0x0070 */ TArray<FString> SubFaces;
};

// Size: 0xe0
class UFontImportOptions : public UObject {
    /* 0x0030 */ FFontImportOptionsData Data;
};

// Size: 0xb0
struct FFontImportOptionsData {
    /* 0x0000 */ FString FontName;
    /* 0x0010 */ float Height;
    /* 0x0014 */ bool bEnableAntialiasing;
    /* 0x0014 */ bool bEnableBold;
    /* 0x0014 */ bool bEnableItalic;
    /* 0x0014 */ bool bEnableUnderline;
    /* 0x0014 */ bool bAlphaOnly;
    /* 0x0018 */ uint8_t CharacterSet;
    /* 0x0020 */ FString Chars;
    /* 0x0030 */ FString UnicodeRange;
    /* 0x0040 */ FString CharsFilePath;
    /* 0x0050 */ FString CharsFileWildcard;
    /* 0x0060 */ bool bCreatePrintableOnly;
    /* 0x0060 */ bool bIncludeASCIIRange;
    /* 0x0064 */ FLinearColor ForegroundColor;
    /* 0x0074 */ bool bEnableDropShadow;
    /* 0x0078 */ int32_t TexturePageWidth;
    /* 0x007c */ int32_t TexturePageMaxHeight;
    /* 0x0080 */ int32_t XPadding;
    /* 0x0084 */ int32_t YPadding;
    /* 0x0088 */ int32_t ExtendBoxTop;
    /* 0x008c */ int32_t ExtendBoxBottom;
    /* 0x0090 */ int32_t ExtendBoxRight;
    /* 0x0094 */ int32_t ExtendBoxLeft;
    /* 0x0098 */ bool bEnableLegacyMode;
    /* 0x009c */ int32_t Kerning;
    /* 0x00a0 */ bool bUseDistanceFieldAlpha;
    /* 0x00a4 */ int32_t DistanceFieldScaleFactor;
    /* 0x00a8 */ float DistanceFieldScanRadiusScale;
};

// Size: 0x40
struct FFontParameterValue {
    /* 0x0000 */ FName ParameterName;
    /* 0x000c */ FMaterialParameterInfo ParameterInfo;
    /* 0x0020 */ UFont* FontValue;
    /* 0x0028 */ int32_t FontPage;
    /* 0x002c */ FGuid ExpressionGUID;
};

// Size: 0x28
struct FFontRenderInfo {
    /* 0x0000 */ bool bClipText;
    /* 0x0000 */ bool bEnableShadow;
    /* 0x0004 */ FDepthFieldGlowInfo GlowInfo;
};

// Size: 0xe0
class UForceFeedbackAttenuation : public UObject {
    /* 0x0030 */ FForceFeedbackAttenuationSettings Attenuation;
};

// Size: 0xb0
struct FForceFeedbackAttenuationSettings : public FBaseAttenuationSettings {
};

// Size: 0x90
struct FForceFeedbackChannelDetails {
    /* 0x0000 */ bool bAffectsLeftLarge;
    /* 0x0000 */ bool bAffectsLeftSmall;
    /* 0x0000 */ bool bAffectsRightLarge;
    /* 0x0000 */ bool bAffectsRightSmall;
    /* 0x0008 */ FRuntimeFloatCurve Curve;
};

// Size: 0x310
class UForceFeedbackComponent : public USceneComponent {
    /* 0x0228 */ UForceFeedbackEffect* ForceFeedbackEffect;
    /* 0x0230 */ bool bAutoDestroy;
    /* 0x0230 */ bool bStopWhenOwnerDestroyed;
    /* 0x0230 */ bool bLooping;
    /* 0x0230 */ bool bIgnoreTimeDilation;
    /* 0x0230 */ bool bOverrideAttenuation;
    /* 0x0234 */ float IntensityMultiplier;
    /* 0x0238 */ UForceFeedbackAttenuation* AttenuationSettings;
    /* 0x0240 */ FForceFeedbackAttenuationSettings AttenuationOverrides;
    /* 0x02f0 */ FMulticastInlineDelegate OnForceFeedbackFinished;

    void AdjustAttenuation(const FForceFeedbackAttenuationSettings& InAttenuationSettings);
    bool BP_GetAttenuationSettingsToApply(FForceFeedbackAttenuationSettings& OutAttenuationSettings) const;
    void Play(float StartTime);
    void SetForceFeedbackEffect(UForceFeedbackEffect* NewForceFeedbackEffect);
    void SetIntensityMultiplier(float NewIntensityMultiplier);
    void Stop();
};

// Size: 0x48
class UForceFeedbackEffect : public UObject {
    /* 0x0030 */ TArray<FForceFeedbackChannelDetails> ChannelDetails;
    /* 0x0040 */ float Duration;
};

// Size: 0x10
struct FForceFeedbackParameters {
    /* 0x0000 */ FName Tag;
    /* 0x000c */ bool bLooping;
    /* 0x000d */ bool bIgnoreTimeDilation;
    /* 0x000e */ bool bPlayWhilePaused;
};

// Size: 0x40
struct FFormatArgumentData {
    /* 0x0000 */ FString ArgumentName;
    /* 0x0010 */ uint8_t ArgumentValueType;
    /* 0x0018 */ FText ArgumentValue;
    /* 0x0030 */ int32_t ArgumentValueInt;
    /* 0x0034 */ float ArgumentValueFloat;
    /* 0x0038 */ ETextGender ArgumentValueGender;
};

// Size: 0x10
struct FFractureEffect {
    /* 0x0000 */ UParticleSystem* ParticleSystem;
    /* 0x0008 */ USoundBase* Sound;
};

// Size: 0x40
struct FFreezablePerPlatformInt {
};

// Size: 0x38
struct FFullyLoadedPackagesInfo {
    /* 0x0000 */ uint8_t FullyLoadType;
    /* 0x0008 */ FString Tag;
    /* 0x0018 */ TArray<FName> PackagesToLoad;
    /* 0x0028 */ TArray<UObject*> LoadedObjects;
};

// Size: 0x50
struct FFunctionExpressionInput {
    /* 0x0000 */ UMaterialExpressionFunctionInput* ExpressionInput;
    /* 0x0008 */ FGuid ExpressionInputId;
    /* 0x0018 */ FExpressionInput Input;
};

// Size: 0x38
struct FFunctionExpressionOutput {
    /* 0x0000 */ UMaterialExpressionFunctionOutput* ExpressionOutput;
    /* 0x0008 */ FGuid ExpressionOutputId;
    /* 0x0018 */ FExpressionOutput Output;
};

// Size: 0x280
struct FGPUSpriteEmitterInfo {
    /* 0x0000 */ UParticleModuleRequired* RequiredModule;
    /* 0x0008 */ UParticleModuleSpawn* SpawnModule;
    /* 0x0010 */ UParticleModuleSpawnPerUnit* SpawnPerUnitModule;
    /* 0x0018 */ TArray<UParticleModule*> SpawnModules;
    /* 0x0030 */ FGPUSpriteLocalVectorFieldInfo LocalVectorField;
    /* 0x00a0 */ FFloatDistribution VectorFieldScale;
    /* 0x00c0 */ FFloatDistribution DragCoefficient;
    /* 0x00e0 */ FFloatDistribution PointAttractorStrength;
    /* 0x0100 */ FFloatDistribution Resilience;
    /* 0x0120 */ FVector ConstantAcceleration;
    /* 0x012c */ FVector PointAttractorPosition;
    /* 0x0138 */ float PointAttractorRadiusSq;
    /* 0x013c */ FVector OrbitOffsetBase;
    /* 0x0148 */ FVector OrbitOffsetRange;
    /* 0x0154 */ FVector2D InvMaxSize;
    /* 0x015c */ float InvRotationRateScale;
    /* 0x0160 */ float MaxLifetime;
    /* 0x0164 */ int32_t MaxParticleCount;
    /* 0x0168 */ uint8_t ScreenAlignment;
    /* 0x0169 */ uint8_t LockAxisFlag;
    /* 0x016c */ bool bEnableCollision;
    /* 0x0170 */ uint8_t CollisionMode;
    /* 0x0174 */ bool bRemoveHMDRoll;
    /* 0x0178 */ float MinFacingCameraBlendDistance;
    /* 0x017c */ float MaxFacingCameraBlendDistance;
    /* 0x0180 */ FRawDistributionVector DynamicColor;
    /* 0x01c8 */ FRawDistributionFloat DynamicAlpha;
    /* 0x01f8 */ FRawDistributionVector DynamicColorScale;
    /* 0x0240 */ FRawDistributionFloat DynamicAlphaScale;
};

// Size: 0x70
struct FGPUSpriteLocalVectorFieldInfo {
    /* 0x0000 */ UVectorField* Field;
    /* 0x0010 */ FTransform Transform;
    /* 0x0040 */ FRotator MinInitialRotation;
    /* 0x004c */ FRotator MaxInitialRotation;
    /* 0x0058 */ FRotator RotationRate;
    /* 0x0064 */ float Intensity;
    /* 0x0068 */ float Tightness;
    /* 0x006c */ bool bIgnoreComponentTransform;
    /* 0x006c */ bool bTileX;
    /* 0x006c */ bool bTileY;
    /* 0x006c */ bool bTileZ;
    /* 0x006c */ bool bUseFixDT;
};

// Size: 0x160
struct FGPUSpriteResourceData {
    /* 0x0000 */ TArray<FColor> QuantizedColorSamples;
    /* 0x0010 */ TArray<FColor> QuantizedMiscSamples;
    /* 0x0020 */ TArray<FColor> QuantizedSimulationAttrSamples;
    /* 0x0030 */ FVector4 ColorScale;
    /* 0x0040 */ FVector4 ColorBias;
    /* 0x0050 */ FVector4 MiscScale;
    /* 0x0060 */ FVector4 MiscBias;
    /* 0x0070 */ FVector4 SimulationAttrCurveScale;
    /* 0x0080 */ FVector4 SimulationAttrCurveBias;
    /* 0x0090 */ FVector4 SubImageSize;
    /* 0x00a0 */ FVector4 SizeBySpeed;
    /* 0x00b0 */ FVector ConstantAcceleration;
    /* 0x00bc */ FVector OrbitOffsetBase;
    /* 0x00c8 */ FVector OrbitOffsetRange;
    /* 0x00d4 */ FVector OrbitFrequencyBase;
    /* 0x00e0 */ FVector OrbitFrequencyRange;
    /* 0x00ec */ FVector OrbitPhaseBase;
    /* 0x00f8 */ FVector OrbitPhaseRange;
    /* 0x0104 */ float GlobalVectorFieldScale;
    /* 0x0108 */ float GlobalVectorFieldTightness;
    /* 0x010c */ float PerParticleVectorFieldScale;
    /* 0x0110 */ float PerParticleVectorFieldBias;
    /* 0x0114 */ float DragCoefficientScale;
    /* 0x0118 */ float DragCoefficientBias;
    /* 0x011c */ float ResilienceScale;
    /* 0x0120 */ float ResilienceBias;
    /* 0x0124 */ float CollisionRadiusScale;
    /* 0x0128 */ float CollisionRadiusBias;
    /* 0x012c */ float CollisionTimeBias;
    /* 0x0130 */ float CollisionRandomSpread;
    /* 0x0134 */ float CollisionRandomDistribution;
    /* 0x0138 */ float OneMinusFriction;
    /* 0x013c */ float RotationRateScale;
    /* 0x0140 */ float CameraMotionBlurAmount;
    /* 0x0144 */ uint8_t ScreenAlignment;
    /* 0x0145 */ uint8_t LockAxisFlag;
    /* 0x0148 */ FVector2D PivotOffset;
    /* 0x0150 */ bool bRemoveHMDRoll;
    /* 0x0154 */ float MinFacingCameraBlendDistance;
    /* 0x0158 */ float MaxFacingCameraBlendDistance;
};

// Size: 0x1150
class UGameEngine : public UEngine {
    /* 0x1100 */ float MaxDeltaTime;
    /* 0x1104 */ float ServerFlushLogInterval;
    /* 0x1108 */ UGameInstance* GameInstance;
};

// Size: 0x1b8
class UGameInstance : public UObject {
    /* 0x0040 */ TArray<ULocalPlayer*> LocalPlayers;
    /* 0x0050 */ UOnlineSession* OnlineSession;
    /* 0x0058 */ TArray<UObject*> ReferencedObjects;
    /* 0x0080 */ FMulticastInlineDelegate OnPawnControllerChangedDelegates;

    void DebugCreatePlayer(int32_t ControllerId);
    void DebugRemovePlayer(int32_t ControllerId);
    void HandleNetworkError(uint8_t FailureType, bool bIsServer);
    void HandleTravelError(uint8_t FailureType);
    void ReceiveInit();
    void ReceiveShutdown();
};

// Size: 0x38
class UGameInstanceSubsystem : public USubsystem {
};

// Size: 0x3f0
class AGameMode : public AGameModeBase {
    /* 0x03a0 */ FName MatchState;
    /* 0x03ac */ bool bDelayedStart;
    /* 0x03b0 */ int32_t NumSpectators;
    /* 0x03b4 */ int32_t NumPlayers;
    /* 0x03b8 */ int32_t NumBots;
    /* 0x03bc */ float MinRespawnDelay;
    /* 0x03c0 */ int32_t NumTravellingPlayers;
    /* 0x03c8 */ UClass* EngineMessageClass;
    /* 0x03d0 */ TArray<APlayerState*> InactivePlayerArray;
    /* 0x03e0 */ float InactivePlayerStateLifeSpan;
    /* 0x03e4 */ int32_t MaxInactivePlayers;
    /* 0x03e8 */ bool bHandleDedicatedServerReplays;

    void AbortMatch();
    void EndMatch();
    FName GetMatchState() const;
    bool IsMatchInProgress() const;
    void K2_OnSetMatchState(FName NewState);
    bool ReadyToEndMatch();
    bool ReadyToStartMatch();
    void RestartGame();
    void Say(FString Msg);
    void SetBandwidthLimit(float AsyncIOBandwidthLimit);
    void StartMatch();
};

// Size: 0x3a0
class AGameModeBase : public AInfo {
    /* 0x0300 */ FString OptionsString;
    /* 0x0310 */ UClass* GameSessionClass;
    /* 0x0318 */ UClass* GameStateClass;
    /* 0x0320 */ UClass* PlayerControllerClass;
    /* 0x0328 */ UClass* PlayerStateClass;
    /* 0x0330 */ UClass* HUDClass;
    /* 0x0338 */ UClass* DefaultPawnClass;
    /* 0x0340 */ UClass* SpectatorClass;
    /* 0x0348 */ UClass* ReplaySpectatorPlayerControllerClass;
    /* 0x0350 */ UClass* ServerStatReplicatorClass;
    /* 0x0358 */ AGameSession* GameSession;
    /* 0x0360 */ AGameStateBase* GameState;
    /* 0x0368 */ AServerStatReplicator* ServerStatReplicator;
    /* 0x0370 */ FText DefaultPlayerName;
    /* 0x0388 */ bool bUseSeamlessTravel;
    /* 0x0388 */ bool bStartPlayersAsSpectators;
    /* 0x0388 */ bool bPauseable;

    bool CanSpectate(APlayerController* Viewer, APlayerState* ViewTarget);
    void ChangeName(AController* Controller, FString NewName, bool bNameChange);
    AActor* ChoosePlayerStart(AController* Player);
    AActor* FindPlayerStart(AController* Player, FString IncomingName);
    UClass* GetDefaultPawnClassForController(AController* InController);
    int32_t GetNumPlayers();
    int32_t GetNumSpectators();
    void HandleStartingNewPlayer(APlayerController* NewPlayer);
    bool HasMatchEnded() const;
    bool HasMatchStarted() const;
    void InitStartSpot(AActor* StartSpot, AController* NewPlayer);
    void InitializeHUDForPlayer(APlayerController* NewPlayer);
    AActor* K2_FindPlayerStart(AController* Player, FString IncomingName);
    void K2_OnChangeName(AController* Other, FString NewName, bool bNameChange);
    void K2_OnLogout(AController* ExitingController);
    void K2_OnRestartPlayer(AController* NewPlayer);
    void K2_OnSwapPlayerControllers(APlayerController* OldPC, APlayerController* NewPC);
    void K2_PostLogin(APlayerController* NewPlayer);
    bool MustSpectate(APlayerController* NewPlayerController) const;
    bool PlayerCanRestart(APlayerController* Player);
    void ResetLevel();
    void RestartPlayer(AController* NewPlayer);
    void RestartPlayerAtPlayerStart(AController* NewPlayer, AActor* StartSpot);
    void RestartPlayerAtTransform(AController* NewPlayer, const FTransform& SpawnTransform);
    void ReturnToMainMenuHost();
    bool ShouldReset(AActor* ActorToReset);
    APawn* SpawnDefaultPawnAtTransform(AController* NewPlayer, const FTransform& SpawnTransform);
    APawn* SpawnDefaultPawnFor(AController* NewPlayer, AActor* StartSpot);
    void StartPlay();
};

// Size: 0x18
struct FGameNameRedirect {
    /* 0x0000 */ FName OldGameName;
    /* 0x000c */ FName NewGameName;
};

// Size: 0x3b0
class AGameNetworkManager : public AInfo {
    /* 0x0300 */ float BadPacketLossThreshold;
    /* 0x0304 */ float SeverePacketLossThreshold;
    /* 0x0308 */ int32_t BadPingThreshold;
    /* 0x030c */ int32_t SeverePingThreshold;
    /* 0x0310 */ int32_t AdjustedNetSpeed;
    /* 0x0314 */ float LastNetSpeedUpdateTime;
    /* 0x0318 */ int32_t TotalNetBandwidth;
    /* 0x031c */ int32_t MinDynamicBandwidth;
    /* 0x0320 */ int32_t MaxDynamicBandwidth;
    /* 0x0324 */ bool bIsStandbyCheckingEnabled;
    /* 0x0324 */ bool bHasStandbyCheatTriggered;
    /* 0x0328 */ float StandbyRxCheatTime;
    /* 0x032c */ float StandbyTxCheatTime;
    /* 0x0330 */ float PercentMissingForRxStandby;
    /* 0x0334 */ float PercentMissingForTxStandby;
    /* 0x0338 */ float PercentForBadPing;
    /* 0x033c */ float JoinInProgressStandbyWaitTime;
    /* 0x0340 */ float MoveRepSize;
    /* 0x0344 */ float MAXPOSITIONERRORSQUARED;
    /* 0x0348 */ float MAXNEARZEROVELOCITYSQUARED;
    /* 0x034c */ float CLIENTADJUSTUPDATECOST;
    /* 0x0350 */ float MAXCLIENTUPDATEINTERVAL;
    /* 0x0354 */ float MaxClientForcedUpdateDuration;
    /* 0x0358 */ float ServerForcedUpdateHitchThreshold;
    /* 0x035c */ float ServerForcedUpdateHitchCooldown;
    /* 0x0360 */ float MaxMoveDeltaTime;
    /* 0x0364 */ float MaxClientSmoothingDeltaTime;
    /* 0x0368 */ float ClientNetSendMoveDeltaTime;
    /* 0x036c */ float ClientNetSendMoveDeltaTimeThrottled;
    /* 0x0370 */ float ClientNetSendMoveDeltaTimeStationary;
    /* 0x0374 */ int32_t ClientNetSendMoveThrottleAtNetSpeed;
    /* 0x0378 */ int32_t ClientNetSendMoveThrottleOverPlayerCount;
    /* 0x037c */ bool ClientAuthorativePosition;
    /* 0x0380 */ float ClientErrorUpdateRateLimit;
    /* 0x0384 */ float ClientNetCamUpdateDeltaTime;
    /* 0x0388 */ float ClientNetCamUpdatePositionLimit;
    /* 0x038c */ bool bMovementTimeDiscrepancyDetection;
    /* 0x038d */ bool bMovementTimeDiscrepancyResolution;
    /* 0x0390 */ float MovementTimeDiscrepancyMaxTimeMargin;
    /* 0x0394 */ float MovementTimeDiscrepancyMinTimeMargin;
    /* 0x0398 */ float MovementTimeDiscrepancyResolutionRate;
    /* 0x039c */ float MovementTimeDiscrepancyDriftAllowance;
    /* 0x03a0 */ bool bMovementTimeDiscrepancyForceCorrectionsDuringResolution;
    /* 0x03a1 */ bool bUseDistanceBasedRelevancy;
};

// Size: 0x320
class AGameSession : public AInfo {
    /* 0x0300 */ int32_t MaxSpectators;
    /* 0x0304 */ int32_t MaxPlayers;
    /* 0x0308 */ int32_t MaxPartySize;
    /* 0x030c */ uint8_t MaxSplitscreensPerConnection;
    /* 0x030d */ bool bRequiresPushToTalk;
    /* 0x0310 */ FName SessionName;
};

// Size: 0x378
class AGameState : public AGameStateBase {
    /* 0x0350 */ FName MatchState;
    /* 0x035c */ FName PreviousMatchState;
    /* 0x0368 */ int32_t ElapsedTime;

    void OnRep_ElapsedTime();
    void OnRep_MatchState();
};

// Size: 0x350
class AGameStateBase : public AInfo {
    /* 0x0300 */ UClass* GameModeClass;
    /* 0x0308 */ AGameModeBase* AuthorityGameMode;
    /* 0x0310 */ UClass* SpectatorClass;
    /* 0x0318 */ TArray<APlayerState*> PlayerArray;
    /* 0x0328 */ bool bReplicatedHasBegunPlay;
    /* 0x032c */ float ReplicatedWorldTimeSeconds;
    /* 0x0330 */ float ServerWorldTimeSecondsDelta;
    /* 0x0334 */ float ServerWorldTimeSecondsUpdateFrequency;

    float GetPlayerRespawnDelay(AController* Controller) const;
    float GetPlayerStartTime(AController* Controller) const;
    float GetServerWorldTimeSeconds() const;
    bool HasBegunPlay() const;
    bool HasMatchEnded() const;
    bool HasMatchStarted() const;
    void OnRep_GameModeClass();
    void OnRep_ReplicatedHasBegunPlay();
    void OnRep_ReplicatedWorldTimeSeconds();
    void OnRep_SpectatorClass();
};

// Size: 0x128
class UGameUserSettings : public UObject {
    /* 0x0030 */ bool bUseVSync;
    /* 0x0031 */ bool bUseDynamicResolution;
    /* 0x0088 */ uint32_t ResolutionSizeX;
    /* 0x008c */ uint32_t ResolutionSizeY;
    /* 0x0090 */ uint32_t LastUserConfirmedResolutionSizeX;
    /* 0x0094 */ uint32_t LastUserConfirmedResolutionSizeY;
    /* 0x0098 */ int32_t WindowPosX;
    /* 0x009c */ int32_t WindowPosY;
    /* 0x00a0 */ int32_t FullscreenMode;
    /* 0x00a4 */ int32_t LastConfirmedFullscreenMode;
    /* 0x00a8 */ int32_t PreferredFullscreenMode;
    /* 0x00ac */ uint32_t Version;
    /* 0x00b0 */ int32_t AudioQualityLevel;
    /* 0x00b4 */ int32_t LastConfirmedAudioQualityLevel;
    /* 0x00b8 */ float FrameRateLimit;
    /* 0x00c0 */ int32_t DesiredScreenWidth;
    /* 0x00c4 */ bool bUseDesiredScreenHeight;
    /* 0x00c8 */ int32_t DesiredScreenHeight;
    /* 0x00cc */ int32_t LastUserConfirmedDesiredScreenWidth;
    /* 0x00d0 */ int32_t LastUserConfirmedDesiredScreenHeight;
    /* 0x00d4 */ float LastRecommendedScreenWidth;
    /* 0x00d8 */ float LastRecommendedScreenHeight;
    /* 0x00dc */ float LastCPUBenchmarkResult;
    /* 0x00e0 */ float LastGPUBenchmarkResult;
    /* 0x00e8 */ TArray<float> LastCPUBenchmarkSteps;
    /* 0x00f8 */ TArray<float> LastGPUBenchmarkSteps;
    /* 0x0108 */ float LastGPUBenchmarkMultiplier;
    /* 0x010c */ bool bUseHDRDisplayOutput;
    /* 0x0110 */ int32_t HDRDisplayOutputNits;
    /* 0x0118 */ FMulticastInlineDelegate OnGameUserSettingsUINeedsUpdate;

    void ApplyHardwareBenchmarkResults();
    void ApplyNonResolutionSettings();
    void ApplyResolutionSettings(bool bCheckForCommandLineOverrides);
    void ApplySettings(bool bCheckForCommandLineOverrides);
    void ConfirmVideoMode();
    void EnableHDRDisplayOutput(bool bEnable, int32_t DisplayNits);
    int32_t GetAntiAliasingQuality() const;
    int32_t GetAudioQualityLevel() const;
    int32_t GetCurrentHDRDisplayNits() const;
    static FIntPoint GetDefaultResolution();
    float GetDefaultResolutionScale();
    static uint8_t GetDefaultWindowMode();
    static FIntPoint GetDefaultWindowPosition();
    FIntPoint GetDesktopResolution() const;
    int32_t GetFoliageQuality() const;
    static int32_t GetFramePace();
    float GetFrameRateLimit() const;
    uint8_t GetFullscreenMode() const;
    static UGameUserSettings* GetGameUserSettings();
    uint8_t GetLastConfirmedFullscreenMode() const;
    FIntPoint GetLastConfirmedScreenResolution() const;
    int32_t GetOverallScalabilityLevel() const;
    int32_t GetPostProcessingQuality() const;
    uint8_t GetPreferredFullscreenMode() const;
    float GetRecommendedResolutionScale();
    void GetResolutionScaleInformation(float& CurrentScaleNormalized, int32_t& CurrentScaleValue, int32_t& MinScaleValue, int32_t& MaxScaleValue) const;
    void GetResolutionScaleInformationEx(float& CurrentScaleNormalized, float& CurrentScaleValue, float& MinScaleValue, float& MaxScaleValue) const;
    float GetResolutionScaleNormalized() const;
    FIntPoint GetScreenResolution() const;
    int32_t GetShadingQuality() const;
    int32_t GetShadowQuality() const;
    static int32_t GetSyncInterval();
    int32_t GetTextureQuality() const;
    int32_t GetViewDistanceQuality() const;
    int32_t GetVisualEffectQuality() const;
    bool IsDirty() const;
    bool IsDynamicResolutionDirty() const;
    bool IsDynamicResolutionEnabled() const;
    bool IsFullscreenModeDirty() const;
    bool IsHDREnabled() const;
    bool IsScreenResolutionDirty() const;
    bool IsVSyncDirty() const;
    bool IsVSyncEnabled() const;
    void LoadSettings(bool bForceReload);
    void ResetToCurrentSettings();
    void RevertVideoMode();
    void RunHardwareBenchmark(int32_t WorkScale, float CPUMultiplier, float GPUMultiplier);
    void SaveSettings();
    void SetAntiAliasingQuality(int32_t Value);
    void SetAudioQualityLevel(int32_t QualityLevel);
    void SetBenchmarkFallbackValues();
    void SetDynamicResolutionEnabled(bool bEnable);
    void SetFoliageQuality(int32_t Value);
    void SetFrameRateLimit(float NewLimit);
    void SetFullscreenMode(uint8_t InFullscreenMode);
    void SetOverallScalabilityLevel(int32_t Value);
    void SetPostProcessingQuality(int32_t Value);
    void SetResolutionScaleNormalized(float NewScaleNormalized);
    void SetResolutionScaleValue(int32_t NewScaleValue);
    void SetResolutionScaleValueEx(float NewScaleValue);
    void SetScreenResolution(FIntPoint Resolution);
    void SetShadingQuality(int32_t Value);
    void SetShadowQuality(int32_t Value);
    void SetTextureQuality(int32_t Value);
    void SetToDefaults();
    void SetVSyncEnabled(bool bEnable);
    void SetViewDistanceQuality(int32_t Value);
    void SetVisualEffectQuality(int32_t Value);
    bool SupportsHDRDisplayOutput() const;
    void ValidateSettings();
};

// Size: 0x390
class UGameViewportClient : public UScriptViewportClient {
    /* 0x0048 */ UConsole* ViewportConsole;
    /* 0x0050 */ TArray<FDebugDisplayProperty> DebugProperties;
    /* 0x0070 */ int32_t MaxSplitscreenPlayers;
    /* 0x0080 */ UWorld* World;
    /* 0x0088 */ UGameInstance* GameInstance;

    void SSSwapControllers();
    void SetConsoleTarget(int32_t PlayerIndex);
    void ShowTitleSafeArea();
};

// Size: 0x30
class UGameplayStatics : public UBlueprintFunctionLibrary {

    static void ActivateReverbEffect(const UObject* WorldContextObject, UReverbEffect* ReverbEffect, FName TagName, float Priority, float Volume, float FadeTime);
    static void AnnounceAccessibleString(FString AnnouncementString);
    static float ApplyDamage(AActor* DamagedActor, float BaseDamage, AController* EventInstigator, AActor* DamageCauser, UClass* DamageTypeClass);
    static float ApplyPointDamage(AActor* DamagedActor, float BaseDamage, const FVector& HitFromDirection, const FHitResult& HitInfo, AController* EventInstigator, AActor* DamageCauser, UClass* DamageTypeClass);
    static bool ApplyRadialDamage(const UObject* WorldContextObject, float BaseDamage, const FVector& Origin, float DamageRadius, UClass* DamageTypeClass, const TArray<AActor*>& IgnoreActors, AActor* DamageCauser, AController* InstigatedByController, bool bDoFullDamage, uint8_t DamagePreventionChannel);
    static bool ApplyRadialDamageWithFalloff(const UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, UClass* DamageTypeClass, const TArray<AActor*>& IgnoreActors, AActor* DamageCauser, AController* InstigatedByController, uint8_t DamagePreventionChannel);
    static bool AreAnyListenersWithinRange(const UObject* WorldContextObject, const FVector& Location, float MaximumRange);
    static bool AreSubtitlesEnabled();
    static AActor* BeginDeferredActorSpawnFromClass(const UObject* WorldContextObject, UClass* ActorClass, const FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, AActor* Owner);
    static AActor* BeginSpawningActorFromBlueprint(const UObject* WorldContextObject, const UBlueprint* Blueprint, const FTransform& SpawnTransform, bool bNoCollisionFail);
    static AActor* BeginSpawningActorFromClass(const UObject* WorldContextObject, UClass* ActorClass, const FTransform& SpawnTransform, bool bNoCollisionFail, AActor* Owner);
    static bool BlueprintSuggestProjectileVelocity(const UObject* WorldContextObject, FVector& TossVelocity, FVector StartLocation, FVector EndLocation, float LaunchSpeed, float OverrideGravityZ, uint8_t TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug);
    static bool Blueprint_PredictProjectilePath_Advanced(const UObject* WorldContextObject, const FPredictProjectilePathParams& PredictParams, FPredictProjectilePathResult& PredictResult);
    static bool Blueprint_PredictProjectilePath_ByObjectType(const UObject* WorldContextObject, FHitResult& OutHit, TArray<FVector>& OutPathPositions, FVector& OutLastTraceDestination, FVector StartPos, FVector LaunchVelocity, bool bTracePath, float ProjectileRadius, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
    static bool Blueprint_PredictProjectilePath_ByTraceChannel(const UObject* WorldContextObject, FHitResult& OutHit, TArray<FVector>& OutPathPositions, FVector& OutLastTraceDestination, FVector StartPos, FVector LaunchVelocity, bool bTracePath, float ProjectileRadius, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
    static void BreakHitResult(const FHitResult& Hit, bool& bBlockingHit, bool& bInitialOverlap, float& Time, float& Distance, FVector& Location, FVector& ImpactPoint, FVector& Normal, FVector& ImpactNormal, UPhysicalMaterial*& PhysMat, AActor*& HitActor, UPrimitiveComponent*& HitComponent, FName& HitBoneName, int32_t& HitItem, int32_t& ElementIndex, int32_t& FaceIndex, FVector& TraceStart, FVector& TraceEnd);
    static void CancelAsyncLoading();
    static void ClearSoundMixClassOverride(const UObject* WorldContextObject, USoundMix* InSoundMixModifier, USoundClass* InSoundClass, float FadeOutTime);
    static void ClearSoundMixModifiers(const UObject* WorldContextObject);
    static APlayerController* CreatePlayer(const UObject* WorldContextObject, int32_t ControllerId, bool bSpawnPlayerController);
    static USaveGame* CreateSaveGameObject(UClass* SaveGameClass);
    static UAudioComponent* CreateSound2D(const UObject* WorldContextObject, USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy);
    static void DeactivateReverbEffect(const UObject* WorldContextObject, FName TagName);
    static bool DeleteGameInSlot(FString SlotName, const int32_t UserIndex);
    static bool DeprojectScreenToWorld(APlayerController* Player, const FVector2D& ScreenPosition, FVector& WorldPosition, FVector& WorldDirection);
    static bool DoesSaveGameExist(FString SlotName, const int32_t UserIndex);
    static void EnableLiveStreaming(bool Enable);
    static bool FindCollisionUV(const FHitResult& Hit, int32_t UVChannel, FVector2D& UV);
    static AActor* FindNearestActor(FVector Origin, const TArray<AActor*>& ActorsToCheck, float& Distance);
    static AActor* FinishSpawningActor(AActor* Actor, const FTransform& SpawnTransform);
    static void FlushLevelStreaming(const UObject* WorldContextObject);
    static void GetAccurateRealTime(int32_t& Seconds, float& PartialSeconds);
    static FVector GetActorArrayAverageLocation(const TArray<AActor*>& Actors);
    static void GetActorArrayBounds(const TArray<AActor*>& Actors, bool bOnlyCollidingComponents, FVector& Center, FVector& BoxExtent);
    static AActor* GetActorOfClass(const UObject* WorldContextObject, UClass* ActorClass);
    static void GetAllActorsOfClass(const UObject* WorldContextObject, UClass* ActorClass, TArray<AActor*>& OutActors);
    static void GetAllActorsOfClassWithTag(const UObject* WorldContextObject, UClass* ActorClass, FName Tag, TArray<AActor*>& OutActors);
    static void GetAllActorsWithInterface(const UObject* WorldContextObject, UClass* Interface, TArray<AActor*>& OutActors);
    static void GetAllActorsWithTag(const UObject* WorldContextObject, FName Tag, TArray<AActor*>& OutActors);
    static float GetAudioTimeSeconds(const UObject* WorldContextObject);
    static bool GetClosestListenerLocation(const UObject* WorldContextObject, const FVector& Location, float MaximumRange, const bool bAllowAttenuationOverride, FVector& ListenerPosition);
    static FString GetCurrentLevelName(const UObject* WorldContextObject, bool bRemovePrefixString);
    static UReverbEffect* GetCurrentReverbEffect(const UObject* WorldContextObject);
    static bool GetEnableWorldRendering(const UObject* WorldContextObject);
    static UGameInstance* GetGameInstance(const UObject* WorldContextObject);
    static AGameModeBase* GetGameMode(const UObject* WorldContextObject);
    static AGameStateBase* GetGameState(const UObject* WorldContextObject);
    static float GetGlobalTimeDilation(const UObject* WorldContextObject);
    static int32_t GetIntOption(FString Options, FString Key, int32_t DefaultValue);
    static void GetKeyValue(FString Pair, FString& Key, FString& Value);
    static int32_t GetMaxAudioChannelCount(const UObject* WorldContextObject);
    static UClass* GetObjectClass(const UObject* Object);
    static FString GetPlatformName();
    static APlayerCameraManager* GetPlayerCameraManager(const UObject* WorldContextObject, int32_t PlayerIndex);
    static ACharacter* GetPlayerCharacter(const UObject* WorldContextObject, int32_t PlayerIndex);
    static APlayerController* GetPlayerController(const UObject* WorldContextObject, int32_t PlayerIndex);
    static APlayerController* GetPlayerControllerFromID(const UObject* WorldContextObject, int32_t ControllerId);
    static int32_t GetPlayerControllerID(APlayerController* Player);
    static APawn* GetPlayerPawn(const UObject* WorldContextObject, int32_t PlayerIndex);
    static float GetRealTimeSeconds(const UObject* WorldContextObject);
    static ULevelStreaming* GetStreamingLevel(const UObject* WorldContextObject, FName PackageName);
    static uint8_t GetSurfaceType(const FHitResult& Hit);
    static float GetTimeSeconds(const UObject* WorldContextObject);
    static float GetUnpausedTimeSeconds(const UObject* WorldContextObject);
    static void GetViewProjectionMatrix(FMinimalViewInfo DesiredView, FMatrix& ViewMatrix, FMatrix& ProjectionMatrix, FMatrix& ViewProjectionMatrix);
    static EMouseCaptureMode GetViewportMouseCaptureMode(const UObject* WorldContextObject);
    static float GetWorldDeltaSeconds(const UObject* WorldContextObject);
    static FIntVector GetWorldOriginLocation(const UObject* WorldContextObject);
    static int32_t GrassOverlappingSphereCount(const UObject* WorldContextObject, const UStaticMesh* StaticMesh, FVector CenterPosition, float Radius);
    static bool HasLaunchOption(FString OptionToCheck);
    static bool HasOption(FString Options, FString InKey);
    static bool IsGamePaused(const UObject* WorldContextObject);
    static bool IsSplitscreenForceDisabled(const UObject* WorldContextObject);
    static USaveGame* LoadGameFromSlot(FString SlotName, const int32_t UserIndex);
    static void LoadStreamLevel(const UObject* WorldContextObject, FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo LatentInfo);
    static void LoadStreamLevelBySoftObjectPtr(const UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo LatentInfo);
    static FHitResult MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, float Distance, FVector Location, FVector ImpactPoint, FVector Normal, FVector ImpactNormal, UPhysicalMaterial* PhysMat, AActor* HitActor, UPrimitiveComponent* HitComponent, FName HitBoneName, int32_t HitItem, int32_t ElementIndex, int32_t FaceIndex, FVector TraceStart, FVector TraceEnd);
    static void OpenLevel(const UObject* WorldContextObject, FName LevelName, bool bAbsolute, FString Options);
    static void OpenLevelBySoftObjectPtr(const UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, bool bAbsolute, FString Options);
    static FString ParseOption(FString Options, FString Key);
    static void PlayDialogue2D(const UObject* WorldContextObject, UDialogueWave* Dialogue, const FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime);
    static void PlayDialogueAtLocation(const UObject* WorldContextObject, UDialogueWave* Dialogue, const FDialogueContext& Context, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation* AttenuationSettings);
    static void PlaySound2D(const UObject* WorldContextObject, USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundConcurrency* ConcurrencySettings, AActor* OwningActor, bool bIsUISound);
    static void PlaySoundAtLocation(const UObject* WorldContextObject, USoundBase* Sound, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation* AttenuationSettings, USoundConcurrency* ConcurrencySettings, AActor* OwningActor);
    static void PlayWorldCameraShake(const UObject* WorldContextObject, UClass* Shake, FVector Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter);
    static void PopSoundMixModifier(const UObject* WorldContextObject, USoundMix* InSoundMixModifier);
    static void PrimeAllSoundsInSoundClass(USoundClass* InSoundClass);
    static void PrimeSound(USoundBase* InSound);
    static bool ProjectWorldToScreen(APlayerController* Player, const FVector& WorldPosition, FVector2D& ScreenPosition, bool bPlayerViewportRelative);
    static void PushSoundMixModifier(const UObject* WorldContextObject, USoundMix* InSoundMixModifier);
    static FVector RebaseLocalOriginOntoZero(UObject* WorldContextObject, FVector WorldLocation);
    static FVector RebaseZeroOriginOntoLocal(UObject* WorldContextObject, FVector WorldLocation);
    static void RemovePlayer(APlayerController* Player, bool bDestroyPawn);
    static bool SaveGameToSlot(USaveGame* SaveGameObject, FString SlotName, const int32_t UserIndex);
    static void SetBaseSoundMix(const UObject* WorldContextObject, USoundMix* InSoundMix);
    static void SetEnableWorldRendering(const UObject* WorldContextObject, bool bEnable);
    static void SetForceDisableSplitscreen(const UObject* WorldContextObject, bool bDisable);
    static bool SetGamePaused(const UObject* WorldContextObject, bool bPaused);
    static void SetGlobalListenerFocusParameters(const UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale);
    static void SetGlobalPitchModulation(const UObject* WorldContextObject, float PitchModulation, float TimeSec);
    static void SetGlobalTimeDilation(const UObject* WorldContextObject, float TimeDilation);
    static void SetMaxAudioChannelsScaled(const UObject* WorldContextObject, float MaxChannelCountScale);
    static void SetPlayerControllerID(APlayerController* Player, int32_t ControllerId);
    static void SetSoundClassDistanceScale(const UObject* WorldContextObject, USoundClass* SoundClass, float DistanceAttenuationScale, float TimeSec);
    static void SetSoundMixClassOverride(const UObject* WorldContextObject, USoundMix* InSoundMixModifier, USoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren);
    static void SetSubtitlesEnabled(bool bEnabled);
    static void SetViewportMouseCaptureMode(const UObject* WorldContextObject, const EMouseCaptureMode MouseCaptureMode);
    static void SetWorldOriginLocation(const UObject* WorldContextObject, FIntVector NewLocation);
    static UDecalComponent* SpawnDecalAtLocation(const UObject* WorldContextObject, UMaterialInterface* DecalMaterial, FVector DecalSize, FVector Location, FRotator Rotation, float LifeSpan);
    static UDecalComponent* SpawnDecalAttached(UMaterialInterface* DecalMaterial, FVector DecalSize, USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, uint8_t LocationType, float LifeSpan);
    static UAudioComponent* SpawnDialogue2D(const UObject* WorldContextObject, UDialogueWave* Dialogue, const FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy);
    static UAudioComponent* SpawnDialogueAtLocation(const UObject* WorldContextObject, UDialogueWave* Dialogue, const FDialogueContext& Context, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
    static UAudioComponent* SpawnDialogueAttached(UDialogueWave* Dialogue, const FDialogueContext& Context, USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, uint8_t LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
    static UParticleSystemComponent* SpawnEmitterAtLocation(const UObject* WorldContextObject, UParticleSystem* EmitterTemplate, FVector Location, FRotator Rotation, FVector Scale, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivateSystem);
    static UParticleSystemComponent* SpawnEmitterAttached(UParticleSystem* EmitterTemplate, USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, FVector Scale, uint8_t LocationType, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivate);
    static UForceFeedbackComponent* SpawnForceFeedbackAtLocation(const UObject* WorldContextObject, UForceFeedbackEffect* ForceFeedbackEffect, FVector Location, FRotator Rotation, bool bLooping, float IntensityMultiplier, float StartTime, UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
    static UForceFeedbackComponent* SpawnForceFeedbackAttached(UForceFeedbackEffect* ForceFeedbackEffect, USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, uint8_t LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
    static UObject* SpawnObject(UClass* ObjectClass, UObject* Outer);
    static UAudioComponent* SpawnSound2D(const UObject* WorldContextObject, USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy);
    static UAudioComponent* SpawnSoundAtLocation(const UObject* WorldContextObject, USoundBase* Sound, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation* AttenuationSettings, USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
    static UAudioComponent* SpawnSoundAttached(USoundBase* Sound, USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, uint8_t LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation* AttenuationSettings, USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
    static bool SuggestProjectileVelocity_CustomArc(const UObject* WorldContextObject, FVector& OutLaunchVelocity, FVector StartPos, FVector EndPos, float OverrideGravityZ, float ArcParam);
    static void UnRetainAllSoundsInSoundClass(USoundClass* InSoundClass);
    static void UnloadStreamLevel(const UObject* WorldContextObject, FName LevelName, FLatentActionInfo LatentInfo, bool bShouldBlockOnUnload);
    static void UnloadStreamLevelBySoftObjectPtr(const UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, FLatentActionInfo LatentInfo, bool bShouldBlockOnUnload);
};

// Size: 0x80
class UGarbageCollectionSettings : public UDeveloperSettings {
    /* 0x0060 */ float TimeBetweenPurgingPendingKillObjects;
    /* 0x0064 */ bool FlushStreamingOnGC;
    /* 0x0064 */ bool AllowParallelGC;
    /* 0x0064 */ bool IncrementalBeginDestroyEnabled;
    /* 0x0064 */ bool MultithreadedDestructionEnabled;
    /* 0x0064 */ bool CreateGCClusters;
    /* 0x0064 */ bool AssetClusteringEnabled;
    /* 0x0064 */ bool ActorClusteringEnabled;
    /* 0x0064 */ bool BlueprintClusteringEnabled;
    /* 0x0065 */ bool UseDisregardForGCOnDedicatedServers;
    /* 0x0068 */ int32_t MinGCClusterSize;
    /* 0x006c */ int32_t NumRetriesBeforeForcingGC;
    /* 0x0070 */ int32_t MaxObjectsNotConsideredByGC;
    /* 0x0074 */ int32_t SizeOfPermanentObjectPool;
    /* 0x0078 */ int32_t MaxObjectsInGame;
    /* 0x007c */ int32_t MaxObjectsInEditor;
};

// Size: 0x84
struct FGaussianSumBloomSettings {
    /* 0x0000 */ float Intensity;
    /* 0x0004 */ float Threshold;
    /* 0x0008 */ float SizeScale;
    /* 0x000c */ float Filter1Size;
    /* 0x0010 */ float Filter2Size;
    /* 0x0014 */ float Filter3Size;
    /* 0x0018 */ float Filter4Size;
    /* 0x001c */ float Filter5Size;
    /* 0x0020 */ float Filter6Size;
    /* 0x0024 */ FLinearColor Filter1Tint;
    /* 0x0034 */ FLinearColor Filter2Tint;
    /* 0x0044 */ FLinearColor Filter3Tint;
    /* 0x0054 */ FLinearColor Filter4Tint;
    /* 0x0064 */ FLinearColor Filter5Tint;
    /* 0x0074 */ FLinearColor Filter6Tint;
};

// Size: 0x318
class AGeneratedMeshAreaLight : public ASpotLight {
};

// Size: 0x4
struct FGenericStruct {
    /* 0x0000 */ int32_t Data;
};

// Size: 0xc
struct FGeomSelection {
    /* 0x0000 */ int32_t Type;
    /* 0x0004 */ int32_t index;
    /* 0x0008 */ int32_t SelectionIndex;
};

// Size: 0x10
struct FGraphAssetPlayerInformation {
    /* 0x0000 */ TArray<int32_t> PlayerNodeIndices;
};

// Size: 0x58
class UGraphNodeContextMenuContext : public UObject {
    /* 0x0030 */ UBlueprint* Blueprint;
    /* 0x0038 */ UEdGraph* Graph;
    /* 0x0040 */ UEdGraphNode* Node;
    /* 0x0050 */ bool bIsDebugging;
};

// Size: 0x20
struct FGraphReference {
    /* 0x0000 */ UEdGraph* MacroGraph;
    /* 0x0008 */ UBlueprint* GraphBlueprint;
    /* 0x0010 */ FGuid GraphGuid;
};

// Size: 0x1c
struct FGridBlendSample {
    /* 0x0000 */ FEditorElement GridElement;
    /* 0x0018 */ float BlendWeight;
};

// Size: 0x58
class UHLODEngineSubsystem : public UEngineSubsystem {
};

// Size: 0x20
struct FHLODISMComponentDesc {
    /* 0x0000 */ UStaticMesh* StaticMesh;
    /* 0x0008 */ UMaterialInterface* Material;
    /* 0x0010 */ TArray<FTransform> Instances;
};

// Size: 0x10
struct FHLODInstancingKey {
    /* 0x0000 */ UStaticMesh* StaticMesh;
    /* 0x0008 */ UMaterialInterface* Material;
};

// Size: 0xc0
class UHLODProxy : public UObject {
    /* 0x0030 */ TSoftObjectPtr<UWorld> OwningMap;
    /* 0x0060 */ TArray<FHLODProxyMesh> ProxyMeshes;
    /* 0x0070 */ TMap<UHLODProxyDesc*, FHLODProxyMesh> HLODActors;
};

// Size: 0x170
class UHLODProxyDesc : public UObject {
    /* 0x0030 */ TArray<FName> SubActors;
    /* 0x0040 */ UStaticMesh* StaticMesh;
    /* 0x0048 */ TArray<FHLODISMComponentDesc> ISMComponentsDesc;
    /* 0x0058 */ float LODDrawDistance;
    /* 0x005c */ bool bOverrideMaterialMergeSettings;
    /* 0x0060 */ FMaterialProxySettings MaterialSettings;
    /* 0x00e8 */ bool bOverrideTransitionScreenSize;
    /* 0x00ec */ float TransitionScreenSize;
    /* 0x00f0 */ bool bOverrideScreenSize;
    /* 0x00f4 */ int32_t ScreenSize;
    /* 0x00f8 */ FName Key;
    /* 0x0104 */ int32_t LODLevel;
    /* 0x0108 */ FString LODActorTag;
    /* 0x0118 */ FVector Location;
    /* 0x0130 */ FTransform HLODBakingTransform;
    /* 0x0160 */ TArray<TSoftObjectPtr<UHLODProxyDesc>> SubHLODDescs;
};

// Size: 0x38
struct FHLODProxyMesh {
    /* 0x0000 */ TLazyObjectPtr<ALODActor> LODActor;
    /* 0x0020 */ UStaticMesh* StaticMesh;
    /* 0x0028 */ FName Key;
};

// Size: 0x3e8
class AHUD : public AActor {
    /* 0x02f8 */ APlayerController* PlayerOwner;
    /* 0x0300 */ bool bLostFocusPaused;
    /* 0x0300 */ bool bShowHUD;
    /* 0x0300 */ bool bShowDebugInfo;
    /* 0x0304 */ int32_t CurrentTargetIndex;
    /* 0x0308 */ bool bShowHitBoxDebugInfo;
    /* 0x0308 */ bool bShowOverlays;
    /* 0x0308 */ bool bEnableDebugTextShadow;
    /* 0x0310 */ TArray<AActor*> PostRenderedActors;
    /* 0x0328 */ TArray<FName> DebugDisplay;
    /* 0x0338 */ TArray<FName> ToggledDebugCategories;
    /* 0x0348 */ UCanvas* Canvas;
    /* 0x0350 */ UCanvas* DebugCanvas;
    /* 0x0358 */ TArray<FDebugTextInfo> DebugTextList;
    /* 0x0368 */ UClass* ShowDebugTargetDesiredClass;
    /* 0x0370 */ AActor* ShowDebugTargetActor;

    void AddDebugText(FString DebugText, AActor* SrcActor, float Duration, FVector Offset, FVector DesiredOffset, FColor TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, UFont* InFont, float FontScale, bool bDrawShadow);
    void AddHitBox(FVector2D Position, FVector2D Size, FName InName, bool bConsumesInput, int32_t Priority);
    void Deproject(float ScreenX, float ScreenY, FVector& WorldPosition, FVector& WorldDirection) const;
    void DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, FLinearColor LineColor, float LineThickness);
    void DrawMaterial(UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, FVector2D RotPivot);
    void DrawMaterialSimple(UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition);
    void DrawMaterialTriangle(UMaterialInterface* Material, FVector2D V0_Pos, FVector2D V1_Pos, FVector2D V2_Pos, FVector2D V0_UV, FVector2D V1_UV, FVector2D V2_UV, FLinearColor V0_Color, FLinearColor V1_Color, FLinearColor V2_Color);
    void DrawRect(FLinearColor RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH);
    void DrawText(FString text, FLinearColor TextColor, float ScreenX, float ScreenY, UFont* Font, float Scale, bool bScalePosition);
    void DrawTexture(UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, FLinearColor TintColor, uint8_t BlendMode, float Scale, bool bScalePosition, float Rotation, FVector2D RotPivot);
    void DrawTextureSimple(UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition);
    void GetActorsInSelectionRectangle(UClass* ClassFilter, const FVector2D& FirstPoint, const FVector2D& SecondPoint, TArray<AActor*>& OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed);
    APawn* GetOwningPawn() const;
    APlayerController* GetOwningPlayerController() const;
    void GetTextSize(FString text, float& OutWidth, float& OutHeight, UFont* Font, float Scale) const;
    void NextDebugTarget();
    void PreviousDebugTarget();
    FVector Project(FVector Location) const;
    void ReceiveDrawHUD(int32_t SizeX, int32_t SizeY);
    void ReceiveHitBoxBeginCursorOver(const FName BoxName);
    void ReceiveHitBoxClick(const FName BoxName);
    void ReceiveHitBoxEndCursorOver(const FName BoxName);
    void ReceiveHitBoxRelease(const FName BoxName);
    void RemoveAllDebugStrings();
    void RemoveDebugText(AActor* SrcActor, bool bLeaveDurationText);
    void ShowDebug(FName DebugType);
    void ShowDebugForReticleTargetToggle(UClass* DesiredClass);
    void ShowDebugToggleSubCategory(FName Category);
    void ShowHUD();
};

// Size: 0x110
struct FHapticFeedbackDetails_Curve {
    /* 0x0000 */ FRuntimeFloatCurve Frequency;
    /* 0x0088 */ FRuntimeFloatCurve Amplitude;
};

// Size: 0x30
class UHapticFeedbackEffect_Base : public UObject {
};

// Size: 0x70
class UHapticFeedbackEffect_Buffer : public UHapticFeedbackEffect_Base {
    /* 0x0030 */ TArray<uint8_t> Amplitudes;
    /* 0x0040 */ int32_t SampleRate;
};

// Size: 0x140
class UHapticFeedbackEffect_Curve : public UHapticFeedbackEffect_Base {
    /* 0x0030 */ FHapticFeedbackDetails_Curve HapticDetails;
};

// Size: 0x68
class UHapticFeedbackEffect_SoundWave : public UHapticFeedbackEffect_Base {
    /* 0x0030 */ USoundWave* SoundWave;
};

// Size: 0x14
struct FHardwareCursorReference {
    /* 0x0000 */ FName CursorPath;
    /* 0x000c */ FVector2D HotSpot;
};

// Size: 0x30
class UHealthSnapshotBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void LogPerformanceSnapshot(const FString SnapshotTitle, bool bResetStats);
    static void StartPerformanceSnapshots();
    static void StopPerformanceSnapshots();
};

// Size: 0x790
class UHierarchicalInstancedStaticMeshComponent : public UInstancedStaticMeshComponent {
    /* 0x06a8 */ TArray<int32_t> SortedInstances;
    /* 0x06b8 */ int32_t NumBuiltInstances;
    /* 0x06c0 */ FBox BuiltInstanceBounds;
    /* 0x06dc */ FBox UnbuiltInstanceBounds;
    /* 0x06f8 */ TArray<FBox> UnbuiltInstanceBoundsList;
    /* 0x0708 */ bool bEnableDensityScaling;
    /* 0x0710 */ int32_t OcclusionLayerNumNodes;
    /* 0x0714 */ FBoxSphereBounds CacheMeshExtendedBounds;
    /* 0x0730 */ bool bDisableCollision;
    /* 0x0734 */ int32_t InstanceCountToRender;

    bool RemoveInstances(const TArray<int32_t>& InstancesToRemove);
};

// Size: 0x70
class UHierarchicalLODSetup : public UObject {
    /* 0x0030 */ TArray<FHierarchicalSimplification> HierarchicalLODSetup;
    /* 0x0040 */ TSoftObjectPtr<UMaterialInterface> OverrideBaseMaterial;
};

// Size: 0x178
struct FHierarchicalSimplification {
    /* 0x0000 */ float TransitionScreenSize;
    /* 0x0004 */ float OverrideDrawDistance;
    /* 0x0008 */ bool bUseOverrideDrawDistance;
    /* 0x0008 */ bool bAllowSpecificExclusion;
    /* 0x0008 */ bool bSimplifyMesh;
    /* 0x0008 */ bool bOnlyGenerateClustersForVolumes;
    /* 0x0008 */ bool bReusePreviousLevelClusters;
    /* 0x000c */ FMeshProxySettings ProxySetting;
    /* 0x00c0 */ FMeshMergingSettings MergeSetting;
    /* 0x016c */ float DesiredBoundRadius;
    /* 0x0170 */ float DesiredFillingPercentage;
    /* 0x0174 */ int32_t MinNumberOfActorsToBuild;
};

// Size: 0x90
struct FHitResult {
    /* 0x0000 */ int32_t FaceIndex;
    /* 0x0004 */ float Time;
    /* 0x0008 */ float Distance;
    /* 0x000c */ FVector_NetQuantize Location;
    /* 0x0018 */ FVector_NetQuantize ImpactPoint;
    /* 0x0024 */ FVector_NetQuantizeNormal Normal;
    /* 0x0030 */ FVector_NetQuantizeNormal ImpactNormal;
    /* 0x003c */ FVector_NetQuantize TraceStart;
    /* 0x0048 */ FVector_NetQuantize TraceEnd;
    /* 0x0054 */ float PenetrationDepth;
    /* 0x0058 */ int32_t Item;
    /* 0x005c */ uint8_t ElementIndex;
    /* 0x005d */ bool bBlockingHit;
    /* 0x005d */ bool bStartPenetrating;
    /* 0x0060 */ TWeakObjectPtr<UPhysicalMaterial> PhysMaterial;
    /* 0x0068 */ TWeakObjectPtr<AActor> Actor;
    /* 0x0070 */ TWeakObjectPtr<UPrimitiveComponent> Component;
    /* 0x0078 */ FName BoneName;
    /* 0x0084 */ FName MyBoneName;
};

// Size: 0x20
struct FImportFactorySettingValues {
    /* 0x0000 */ FString SettingName;
    /* 0x0010 */ FString Value;
};

// Size: 0x30
class UImportanceSamplingLibrary : public UBlueprintFunctionLibrary {

    static void BreakImportanceTexture(const FImportanceTexture& ImportanceTexture, UTexture2D*& Texture, uint8_t& WeightingFunc);
    static void ImportanceSample(const FImportanceTexture& Texture, const FVector2D& Rand, int32_t Samples, float Intensity, FVector2D& SamplePosition, FLinearColor& SampleColor, float& SampleIntensity, float& SampleSize);
    static FImportanceTexture MakeImportanceTexture(UTexture2D* Texture, uint8_t WeightingFunc);
    static FVector2D NextSobolCell2D(int32_t index, int32_t NumCells, FVector2D PreviousValue);
    static FVector NextSobolCell3D(int32_t index, int32_t NumCells, FVector PreviousValue);
    static float NextSobolFloat(int32_t index, int32_t Dimension, float PreviousValue);
    static FVector2D RandomSobolCell2D(int32_t index, int32_t NumCells, FVector2D Cell, FVector2D Seed);
    static FVector RandomSobolCell3D(int32_t index, int32_t NumCells, FVector Cell, FVector Seed);
    static float RandomSobolFloat(int32_t index, int32_t Dimension, float Seed);
};

// Size: 0x50
struct FImportanceTexture {
    /* 0x0000 */ FIntPoint Size;
    /* 0x0008 */ int32_t NumMips;
    /* 0x0010 */ TArray<float> MarginalCDF;
    /* 0x0020 */ TArray<float> ConditionalCDF;
    /* 0x0030 */ TArray<FColor> TextureData;
    /* 0x0040 */ TWeakObjectPtr<UTexture2D> Texture;
    /* 0x0048 */ uint8_t Weighting;
};

// Size: 0x30
class IImportantToggleSettingInterface : public UInterface {
};

// Size: 0x68
class UInGameAdManager : public UPlatformInterfaceBase {
    /* 0x0040 */ bool bShouldPauseWhileAdOpen;
    /* 0x0048 */ TArray<FDelegate> ClickedBannerDelegates;
    /* 0x0058 */ TArray<FDelegate> ClosedAdDelegates;
};

// Size: 0x68
struct FIndexedCurve {
    /* 0x0008 */ FKeyHandleMap KeyHandlesToIndices;
};

// Size: 0x3c
struct FInertializationBoneDiff {
};

// Size: 0x8
struct FInertializationCurveDiff {
};

// Size: 0xa0
struct FInertializationPose {
};

// Size: 0x28
struct FInertializationPoseDiff {
};

// Size: 0x300
class AInfo : public AActor {
    /* 0x02f8 */ UBillboardComponent* SpriteComponent;
};

// Size: 0x50
class UInheritableComponentHandler : public UObject {
    /* 0x0030 */ TArray<FComponentOverrideRecord> Records;
    /* 0x0040 */ TArray<UActorComponent*> UnnecessaryComponents;
};

// Size: 0x40
class UInputActionDelegateBinding : public UInputDelegateBinding {
    /* 0x0030 */ TArray<FBlueprintInputActionDelegateBinding> InputActionDelegateBindings;
};

// Size: 0x30
struct FInputActionKeyMapping {
    /* 0x0000 */ FName ActionName;
    /* 0x000c */ bool bShift;
    /* 0x000c */ bool bCtrl;
    /* 0x000c */ bool bAlt;
    /* 0x000c */ bool bCmd;
    /* 0x0010 */ FKey Key;
};

// Size: 0x18
struct FInputActionSpeechMapping {
    /* 0x0000 */ FName ActionName;
    /* 0x000c */ FName SpeechKeyword;
};

// Size: 0x48
struct FInputAlphaBoolBlend {
    /* 0x0000 */ float BlendInTime;
    /* 0x0004 */ float BlendOutTime;
    /* 0x0008 */ EAlphaBlendOption BlendOption;
    /* 0x0009 */ bool bInitialized;
    /* 0x0010 */ UCurveFloat* CustomCurve;
    /* 0x0018 */ FAlphaBlend AlphaBlend;
};

// Size: 0x1c
struct FInputAxisConfigEntry {
    /* 0x0000 */ FName AxisKeyName;
    /* 0x000c */ FInputAxisProperties AxisProperties;
};

// Size: 0x40
class UInputAxisDelegateBinding : public UInputDelegateBinding {
    /* 0x0030 */ TArray<FBlueprintInputAxisDelegateBinding> InputAxisDelegateBindings;
};

// Size: 0x40
class UInputAxisKeyDelegateBinding : public UInputDelegateBinding {
    /* 0x0030 */ TArray<FBlueprintInputAxisKeyDelegateBinding> InputAxisKeyDelegateBindings;
};

// Size: 0x30
struct FInputAxisKeyMapping {
    /* 0x0000 */ FName AxisName;
    /* 0x000c */ float Scale;
    /* 0x0010 */ FKey Key;
};

// Size: 0x10
struct FInputAxisProperties {
    /* 0x0000 */ float DeadZone;
    /* 0x0004 */ float Sensitivity;
    /* 0x0008 */ float Exponent;
    /* 0x000c */ bool bInvert;
};

// Size: 0x10
struct FInputBlendPose {
    /* 0x0000 */ TArray<FBranchFilter> BranchFilters;
};

// Size: 0x148
class UInputComponent : public UActorComponent {
    /* 0x0130 */ TArray<FCachedKeyToActionInfo> CachedKeyToActionInfo;

    float GetControllerAnalogKeyState(FKey Key) const;
    void GetControllerAnalogStickState(uint8_t WhichStick, float& StickX, float& StickY) const;
    float GetControllerKeyTimeDown(FKey Key) const;
    void GetControllerMouseDelta(float& DeltaX, float& DeltaY) const;
    FVector GetControllerVectorKeyState(FKey Key) const;
    void GetTouchState(int32_t FingerIndex, float& LocationX, float& LocationY, bool& bIsCurrentlyPressed) const;
    bool IsControllerKeyDown(FKey Key) const;
    bool WasControllerKeyJustPressed(FKey Key) const;
    bool WasControllerKeyJustReleased(FKey Key) const;
};

// Size: 0x30
class UInputDelegateBinding : public UDynamicBlueprintBinding {
};

// Size: 0x40
class UInputKeyDelegateBinding : public UInputDelegateBinding {
    /* 0x0030 */ TArray<FBlueprintInputKeyDelegateBinding> InputKeyDelegateBindings;
};

// Size: 0x8
struct FInputRange {
    /* 0x0000 */ float Min;
    /* 0x0004 */ float Max;
};

// Size: 0x8
struct FInputScaleBias {
    /* 0x0000 */ float Scale;
    /* 0x0004 */ float Bias;
};

// Size: 0x30
struct FInputScaleBiasClamp {
    /* 0x0000 */ bool bMapRange;
    /* 0x0001 */ bool bClampResult;
    /* 0x0002 */ bool bInterpResult;
    /* 0x0004 */ FInputRange InRange;
    /* 0x000c */ FInputRange OutRange;
    /* 0x0014 */ float Scale;
    /* 0x0018 */ float Bias;
    /* 0x001c */ float ClampMin;
    /* 0x0020 */ float ClampMax;
    /* 0x0024 */ float InterpSpeedIncreasing;
    /* 0x0028 */ float InterpSpeedDecreasing;
};

// Size: 0x168
class UInputSettings : public UObject {
    /* 0x0030 */ TArray<FInputAxisConfigEntry> AxisConfig;
    /* 0x0040 */ bool bAltEnterTogglesFullscreen;
    /* 0x0040 */ bool bF11TogglesFullscreen;
    /* 0x0040 */ bool bUseMouseForTouch;
    /* 0x0040 */ bool bEnableMouseSmoothing;
    /* 0x0040 */ bool bEnableFOVScaling;
    /* 0x0040 */ bool bCaptureMouseOnLaunch;
    /* 0x0040 */ bool bDefaultViewportMouseLock;
    /* 0x0040 */ bool bAlwaysShowTouchInterface;
    /* 0x0041 */ bool bShowConsoleOnFourFingerTap;
    /* 0x0041 */ bool bEnableGestureRecognizer;
    /* 0x0042 */ bool bUseAutocorrect;
    /* 0x0048 */ TArray<FString> ExcludedAutocorrectOS;
    /* 0x0058 */ TArray<FString> ExcludedAutocorrectCultures;
    /* 0x0068 */ TArray<FString> ExcludedAutocorrectDeviceModels;
    /* 0x0078 */ EMouseCaptureMode DefaultViewportMouseCaptureMode;
    /* 0x0079 */ EMouseLockMode DefaultViewportMouseLockMode;
    /* 0x007c */ float FOVScale;
    /* 0x0080 */ float DoubleClickTime;
    /* 0x0088 */ TArray<FInputActionKeyMapping> ActionMappings;
    /* 0x0098 */ TArray<FInputAxisKeyMapping> AxisMappings;
    /* 0x00a8 */ TArray<FInputActionSpeechMapping> SpeechMappings;
    /* 0x00b8 */ TSoftClassPtr<UPlayerInput> DefaultPlayerInputClass;
    /* 0x00e8 */ TSoftClassPtr<UInputComponent> DefaultInputComponentClass;
    /* 0x0118 */ FSoftObjectPath DefaultTouchInterface;
    /* 0x0138 */ FKey ConsoleKey;
    /* 0x0158 */ TArray<FKey> ConsoleKeys;

    void AddActionMapping(const FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    void AddAxisMapping(const FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    void ForceRebuildKeymaps();
    void GetActionMappingByName(const FName InActionName, TArray<FInputActionKeyMapping>& OutMappings) const;
    void GetActionNames(TArray<FName>& ActionNames) const;
    void GetAxisMappingByName(const FName InAxisName, TArray<FInputAxisKeyMapping>& OutMappings) const;
    void GetAxisNames(TArray<FName>& AxisNames) const;
    static UInputSettings* GetInputSettings();
    void RemoveActionMapping(const FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    void RemoveAxisMapping(const FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    void SaveKeyMappings();
};

// Size: 0x40
class UInputTouchDelegateBinding : public UInputDelegateBinding {
    /* 0x0030 */ TArray<FBlueprintInputTouchDelegateBinding> InputTouchDelegateBindings;
};

// Size: 0x40
class UInputVectorAxisDelegateBinding : public UInputAxisKeyDelegateBinding {
};

// Size: 0x6a0
class UInstancedStaticMeshComponent : public UStaticMeshComponent {
    /* 0x05c8 */ TArray<FInstancedStaticMeshInstanceData> PerInstanceSMData;
    /* 0x05d8 */ int32_t NumCustomDataFloats;
    /* 0x05e0 */ TArray<float> PerInstanceSMCustomData;
    /* 0x05f0 */ int32_t InstancingRandomSeed;
    /* 0x05f4 */ int32_t InstanceStartCullDistance;
    /* 0x05f8 */ int32_t InstanceEndCullDistance;
    /* 0x0600 */ TArray<int32_t> InstanceReorderTable;
    /* 0x0680 */ int32_t NumPendingLightmaps;
    /* 0x0688 */ TArray<FInstancedStaticMeshMappingInfo> CachedMappings;

    int32_t AddInstance(const FTransform& InstanceTransform);
    int32_t AddInstanceWorldSpace(const FTransform& WorldTransform);
    TArray<int32_t> AddInstances(const TArray<FTransform>& InstanceTransforms, bool bShouldReturnIndices);
    bool BatchUpdateInstancesTransform(int32_t StartInstanceIndex, int32_t NumInstances, const FTransform& NewInstancesTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
    bool BatchUpdateInstancesTransforms(int32_t StartInstanceIndex, const TArray<FTransform>& NewInstancesTransforms, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
    void ClearInstances();
    int32_t GetInstanceCount() const;
    bool GetInstanceTransform(int32_t InstanceIndex, FTransform& OutInstanceTransform, bool bWorldSpace) const;
    TArray<int32_t> GetInstancesOverlappingBox(const FBox& Box, bool bBoxInWorldSpace) const;
    TArray<int32_t> GetInstancesOverlappingSphere(const FVector& Center, float Radius, bool bSphereInWorldSpace) const;
    bool RemoveInstance(int32_t InstanceIndex);
    void SetCullDistances(int32_t StartCullDistance, int32_t EndCullDistance);
    bool SetCustomDataValue(int32_t InstanceIndex, int32_t CustomDataIndex, float CustomDataValue, bool bMarkRenderStateDirty);
    bool UpdateInstanceTransform(int32_t InstanceIndex, const FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
};

// Size: 0x150
struct FInstancedStaticMeshComponentInstanceData : public FSceneComponentInstanceData {
    /* 0x00b8 */ UStaticMesh* StaticMesh;
    /* 0x00c0 */ FInstancedStaticMeshLightMapInstanceData CachedStaticLighting;
    /* 0x0100 */ TArray<FInstancedStaticMeshInstanceData> PerInstanceSMData;
    /* 0x0110 */ TArray<float> PerInstanceSMCustomData;
    /* 0x0140 */ int32_t InstancingRandomSeed;
};

// Size: 0x40
struct FInstancedStaticMeshInstanceData {
    /* 0x0000 */ FMatrix Transform;
};

// Size: 0x40
struct FInstancedStaticMeshLightMapInstanceData {
    /* 0x0000 */ FTransform Transform;
    /* 0x0030 */ TArray<FGuid> MapBuildDataIds;
};

// Size: 0x8
struct FInstancedStaticMeshMappingInfo {
};

// Size: 0x58
class UIntSerialization : public UObject {
    /* 0x0030 */ uint16_t UnsignedInt16Variable;
    /* 0x0034 */ uint32_t UnsignedInt32Variable;
    /* 0x0038 */ uint64_t UnsignedInt64Variable;
    /* 0x0040 */ int8_t SignedInt8Variable;
    /* 0x0042 */ int16_t SignedInt16Variable;
    /* 0x0048 */ int64_t SignedInt64Variable;
    /* 0x0050 */ uint8_t UnsignedInt8Variable;
    /* 0x0054 */ int32_t SignedInt32Variable;
};

// Size: 0x80
struct FIntegralCurve : public FIndexedCurve {
    /* 0x0068 */ TArray<FIntegralKey> Keys;
    /* 0x0078 */ int32_t DefaultValue;
    /* 0x007c */ bool bUseDefaultValueBeforeFirstKey;
};

// Size: 0x8
struct FIntegralKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ int32_t Value;
};

// Size: 0x30
class IInterface_ActorSubobject : public UInterface {
};

// Size: 0x30
class IInterface_AssetUserData : public UInterface {
};

// Size: 0x30
class IInterface_CollisionDataProvider : public UInterface {
};

// Size: 0x30
class IInterface_PostProcessVolume : public UInterface {
};

// Size: 0x30
class IInterface_PreviewMeshProvider : public UInterface {
};

// Size: 0x24
struct FInteriorSettings {
    /* 0x0000 */ bool bIsWorldSettings;
    /* 0x0004 */ float ExteriorVolume;
    /* 0x0008 */ float ExteriorTime;
    /* 0x000c */ float ExteriorLPF;
    /* 0x0010 */ float ExteriorLPFTime;
    /* 0x0014 */ float InteriorVolume;
    /* 0x0018 */ float InteriorTime;
    /* 0x001c */ float InteriorLPF;
    /* 0x0020 */ float InteriorLPFTime;
};

// Size: 0x1c
struct FInterpControlPoint {
    /* 0x0000 */ FVector PositionControlPoint;
    /* 0x000c */ bool bPositionIsRelative;
};

// Size: 0x48
class UInterpCurveEdSetup : public UObject {
    /* 0x0030 */ TArray<FCurveEdTab> Tabs;
    /* 0x0040 */ int32_t ActiveTab;
};

// Size: 0xa0
class UInterpData : public UObject {
    /* 0x0030 */ float InterpLength;
    /* 0x0034 */ float PathBuildTime;
    /* 0x0038 */ TArray<UInterpGroup*> InterpGroups;
    /* 0x0048 */ UInterpCurveEdSetup* CurveEdSetup;
    /* 0x0050 */ TArray<UInterpFilter*> InterpFilters;
    /* 0x0060 */ UInterpFilter* SelectedFilter;
    /* 0x0068 */ TArray<UInterpFilter*> DefaultFilters;
    /* 0x0078 */ float EdSectionStart;
    /* 0x007c */ float EdSectionEnd;
    /* 0x0080 */ bool bShouldBakeAndPrune;
    /* 0x0088 */ UInterpGroupDirector* CachedDirectorGroup;
    /* 0x0090 */ TArray<FName> AllEventNames;
};

// Size: 0x18
struct FInterpEdSelKey {
    /* 0x0000 */ UInterpGroup* Group;
    /* 0x0008 */ UInterpTrack* Track;
    /* 0x0010 */ int32_t KeyIndex;
    /* 0x0014 */ float UnsnappedPosition;
};

// Size: 0x40
class UInterpFilter : public UObject {
    /* 0x0030 */ FString Caption;
};

// Size: 0x58
class UInterpFilter_Classes : public UInterpFilter {
    /* 0x0040 */ UClass* ClassToFilterBy;
    /* 0x0048 */ TArray<UClass*> TrackClasses;
};

// Size: 0x50
class UInterpFilter_Custom : public UInterpFilter {
    /* 0x0040 */ TArray<UInterpGroup*> GroupsToInclude;
};

// Size: 0x60
class UInterpGroup : public UObject {
    /* 0x0038 */ TArray<UInterpTrack*> InterpTracks;
    /* 0x0048 */ FName GroupName;
    /* 0x0054 */ FColor GroupColor;
    /* 0x0058 */ bool bCollapsed;
    /* 0x0058 */ bool bVisible;
    /* 0x0058 */ bool bIsFolder;
    /* 0x0058 */ bool bIsParented;
    /* 0x0058 */ bool bIsSelected;
};

// Size: 0x20
struct FInterpGroupActorInfo {
    /* 0x0000 */ FName ObjectName;
    /* 0x0010 */ TArray<AActor*> Actors;
};

// Size: 0xa0
class UInterpGroupCamera : public UInterpGroup {
    /* 0x0060 */ UCameraAnim* CameraAnimInst;
    /* 0x0068 */ FCameraPreviewInfo Target;
    /* 0x0098 */ float CompressTolerance;
};

// Size: 0x60
class UInterpGroupDirector : public UInterpGroup {
};

// Size: 0x50
class UInterpGroupInst : public UObject {
    /* 0x0030 */ UInterpGroup* Group;
    /* 0x0038 */ AActor* GroupActor;
    /* 0x0040 */ TArray<UInterpTrackInst*> TrackInst;
};

// Size: 0x50
class UInterpGroupInstCamera : public UInterpGroupInst {
};

// Size: 0x50
class UInterpGroupInstDirector : public UInterpGroupInst {
};

// Size: 0x10
struct FInterpLookupPoint {
    /* 0x0000 */ FName GroupName;
    /* 0x000c */ float Time;
};

// Size: 0x10
struct FInterpLookupTrack {
    /* 0x0000 */ TArray<FInterpLookupPoint> Points;
};

// Size: 0x1a0
class UInterpToMovementComponent : public UMovementComponent {
    /* 0x0100 */ float Duration;
    /* 0x0104 */ bool bPauseOnImpact;
    /* 0x0108 */ bool bSweep;
    /* 0x0109 */ ETeleportType TeleportType;
    /* 0x010a */ EInterpToBehaviourType BehaviourType;
    /* 0x010b */ bool bCheckIfStillInWorld;
    /* 0x010c */ bool bForceSubStepping;
    /* 0x0110 */ FMulticastInlineDelegate OnInterpToReverse;
    /* 0x0120 */ FMulticastInlineDelegate OnInterpToStop;
    /* 0x0130 */ FMulticastInlineDelegate OnWaitBeginDelegate;
    /* 0x0140 */ FMulticastInlineDelegate OnWaitEndDelegate;
    /* 0x0150 */ FMulticastInlineDelegate OnResetDelegate;
    /* 0x0160 */ float MaxSimulationTimeStep;
    /* 0x0164 */ int32_t MaxSimulationIterations;
    /* 0x0168 */ TArray<FInterpControlPoint> ControlPoints;

    void AddControlPointPosition(FVector Pos, bool bPositionIsRelative);
    void FinaliseControlPoints();
    void OnInterpToResetDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToReverseDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToStopDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToWaitBeginDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToWaitEndDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void ResetControlPoints();
    void RestartMovement(float InitialDirection);
    void StopSimulating(const FHitResult& HitResult);
};

// Size: 0xa8
class UInterpTrack : public UObject {
    /* 0x0040 */ TArray<UInterpTrack*> SubTracks;
    /* 0x0050 */ TArray<FSubTrackGroup> SubTrackGroups;
    /* 0x0060 */ TArray<FSupportedSubTrackInfo> SupportedSubTracks;
    /* 0x0070 */ UClass* TrackInstClass;
    /* 0x0078 */ uint8_t ActiveCondition;
    /* 0x0080 */ FString TrackTitle;
    /* 0x0090 */ bool bOnePerGroup;
    /* 0x0090 */ bool bDirGroupOnly;
    /* 0x0090 */ bool bDisableTrack;
    /* 0x0090 */ bool bIsSelected;
    /* 0x0098 */ UTexture2D* TrackIcon;
    /* 0x00a0 */ bool bIsAnimControlTrack;
    /* 0x00a0 */ bool bSubTrackOnly;
    /* 0x00a0 */ bool bVisible;
    /* 0x00a0 */ bool bIsRecording;
    /* 0x00a0 */ bool bIsCollapsed;
};

// Size: 0xf0
class UInterpTrackAnimControl : public UInterpTrackFloatBase {
    /* 0x00c8 */ FName SlotName;
    /* 0x00d8 */ TArray<FAnimControlTrackKey> AnimSeqs;
    /* 0x00e8 */ bool bSkipAnimNotifiers;
};

// Size: 0xc8
class UInterpTrackAudioMaster : public UInterpTrackVectorBase {
};

// Size: 0xc8
class UInterpTrackBoolProp : public UInterpTrack {
    /* 0x00a8 */ TArray<FBoolTrackKey> BoolTrack;
    /* 0x00b8 */ FName PropertyName;
};

// Size: 0xd8
class UInterpTrackColorProp : public UInterpTrackVectorBase {
    /* 0x00c8 */ FName PropertyName;
};

// Size: 0xc8
class UInterpTrackColorScale : public UInterpTrackVectorBase {
};

// Size: 0xc8
class UInterpTrackDirector : public UInterpTrack {
    /* 0x00a8 */ TArray<FDirectorTrackCut> CutTrack;
    /* 0x00b8 */ bool bSimulateCameraCutsOnClients;
    /* 0x00c0 */ ACameraActor* PreviewCamera;
};

// Size: 0xc0
class UInterpTrackEvent : public UInterpTrack {
    /* 0x00a8 */ TArray<FEventTrackKey> EventTrack;
    /* 0x00b8 */ bool bFireEventsWhenForwards;
    /* 0x00b8 */ bool bFireEventsWhenBackwards;
    /* 0x00b8 */ bool bFireEventsWhenJumpingForwards;
    /* 0x00b8 */ bool bUseCustomEventName;
};

// Size: 0xe0
class UInterpTrackFade : public UInterpTrackFloatBase {
    /* 0x00c8 */ bool bPersistFade;
    /* 0x00c8 */ bool bFadeAudio;
    /* 0x00cc */ FLinearColor FadeColor;
};

// Size: 0xe8
class UInterpTrackFloatAnimBPParam : public UInterpTrackFloatBase {
    /* 0x00c8 */ UAnimBlueprintGeneratedClass* AnimBlueprintClass;
    /* 0x00d0 */ UClass* AnimClass;
    /* 0x00d8 */ FName ParamName;
};

// Size: 0xc8
class UInterpTrackFloatBase : public UInterpTrack {
    /* 0x00a8 */ FInterpCurveFloat FloatTrack;
    /* 0x00c0 */ float CurveTension;
};

// Size: 0xe8
class UInterpTrackFloatMaterialParam : public UInterpTrackFloatBase {
    /* 0x00c8 */ TArray<UMaterialInterface*> TargetMaterials;
    /* 0x00d8 */ FName ParamName;
};

// Size: 0xd8
class UInterpTrackFloatParticleParam : public UInterpTrackFloatBase {
    /* 0x00c8 */ FName ParamName;
};

// Size: 0xd8
class UInterpTrackFloatProp : public UInterpTrackFloatBase {
    /* 0x00c8 */ FName PropertyName;
};

// Size: 0x30
class UInterpTrackInst : public UObject {
};

// Size: 0x50
class UInterpTrackInstAnimControl : public UInterpTrackInst {
    /* 0x0030 */ float LastUpdatePosition;
    /* 0x0034 */ FVector InitPosition;
    /* 0x0040 */ FRotator InitRotation;
};

// Size: 0x30
class UInterpTrackInstAudioMaster : public UInterpTrackInst {
};

// Size: 0x80
class UInterpTrackInstBoolProp : public UInterpTrackInstProperty {
    /* 0x0078 */ bool ResetBool;
};

// Size: 0x78
class UInterpTrackInstColorProp : public UInterpTrackInstProperty {
    /* 0x0070 */ FColor ResetColor;
};

// Size: 0x30
class UInterpTrackInstColorScale : public UInterpTrackInst {
};

// Size: 0x38
class UInterpTrackInstDirector : public UInterpTrackInst {
    /* 0x0030 */ AActor* OldViewTarget;
};

// Size: 0x38
class UInterpTrackInstEvent : public UInterpTrackInst {
    /* 0x0030 */ float LastUpdatePosition;
};

// Size: 0x30
class UInterpTrackInstFade : public UInterpTrackInst {
};

// Size: 0x48
class UInterpTrackInstFloatAnimBPParam : public UInterpTrackInst {
    /* 0x0030 */ UAnimInstance* AnimScriptInstance;
    /* 0x0038 */ float ResetFloat;
};

// Size: 0x68
class UInterpTrackInstFloatMaterialParam : public UInterpTrackInst {
    /* 0x0030 */ TArray<UMaterialInstanceDynamic*> MaterialInstances;
    /* 0x0040 */ TArray<float> ResetFloats;
    /* 0x0050 */ TArray<FPrimitiveMaterialRef> PrimitiveMaterialRefs;
    /* 0x0060 */ UInterpTrackFloatMaterialParam* InstancedTrack;
};

// Size: 0x38
class UInterpTrackInstFloatParticleParam : public UInterpTrackInst {
    /* 0x0030 */ float ResetFloat;
};

// Size: 0x78
class UInterpTrackInstFloatProp : public UInterpTrackInstProperty {
    /* 0x0070 */ float ResetFloat;
};

// Size: 0x80
class UInterpTrackInstLinearColorProp : public UInterpTrackInstProperty {
    /* 0x0070 */ FLinearColor ResetColor;
};

// Size: 0x48
class UInterpTrackInstMove : public UInterpTrackInst {
    /* 0x0030 */ FVector ResetLocation;
    /* 0x003c */ FRotator ResetRotation;
};

// Size: 0x38
class UInterpTrackInstParticleReplay : public UInterpTrackInst {
    /* 0x0030 */ float LastUpdatePosition;
};

// Size: 0x68
class UInterpTrackInstProperty : public UInterpTrackInst {
    /* 0x0030 */ FFieldPath InterpProperty;
    /* 0x0060 */ UObject* PropertyOuterObjectInst;
};

// Size: 0x38
class UInterpTrackInstSlomo : public UInterpTrackInst {
    /* 0x0030 */ float OldTimeDilation;
};

// Size: 0x40
class UInterpTrackInstSound : public UInterpTrackInst {
    /* 0x0030 */ float LastUpdatePosition;
    /* 0x0038 */ UAudioComponent* PlayAudioComp;
};

// Size: 0x40
class UInterpTrackInstToggle : public UInterpTrackInst {
    /* 0x0030 */ uint8_t Action;
    /* 0x0034 */ float LastUpdatePosition;
    /* 0x0038 */ bool bSavedActiveState;
};

// Size: 0x68
class UInterpTrackInstVectorMaterialParam : public UInterpTrackInst {
    /* 0x0030 */ TArray<UMaterialInstanceDynamic*> MaterialInstances;
    /* 0x0040 */ TArray<FVector> ResetVectors;
    /* 0x0050 */ TArray<FPrimitiveMaterialRef> PrimitiveMaterialRefs;
    /* 0x0060 */ UInterpTrackVectorMaterialParam* InstancedTrack;
};

// Size: 0x80
class UInterpTrackInstVectorProp : public UInterpTrackInstProperty {
    /* 0x0070 */ FVector ResetVector;
};

// Size: 0x38
class UInterpTrackInstVisibility : public UInterpTrackInst {
    /* 0x0030 */ uint8_t Action;
    /* 0x0034 */ float LastUpdatePosition;
};

// Size: 0xc8
class UInterpTrackLinearColorBase : public UInterpTrack {
    /* 0x00a8 */ FInterpCurveLinearColor LinearColorTrack;
    /* 0x00c0 */ float CurveTension;
};

// Size: 0xd8
class UInterpTrackLinearColorProp : public UInterpTrackLinearColorBase {
    /* 0x00c8 */ FName PropertyName;
};

// Size: 0x108
class UInterpTrackMove : public UInterpTrack {
    /* 0x00a8 */ FInterpCurveVector PosTrack;
    /* 0x00c0 */ FInterpCurveVector EulerTrack;
    /* 0x00d8 */ FInterpLookupTrack LookupTrack;
    /* 0x00e8 */ FName LookAtGroupName;
    /* 0x00f4 */ float LinCurveTension;
    /* 0x00f8 */ float AngCurveTension;
    /* 0x00fc */ bool bUseQuatInterpolation;
    /* 0x00fc */ bool bShowArrowAtKeys;
    /* 0x00fc */ bool bDisableMovement;
    /* 0x00fc */ bool bShowTranslationOnCurveEd;
    /* 0x00fc */ bool bShowRotationOnCurveEd;
    /* 0x00fc */ bool bHide3DTrack;
    /* 0x0100 */ uint8_t RotMode;
};

// Size: 0xe0
class UInterpTrackMoveAxis : public UInterpTrackFloatBase {
    /* 0x00c8 */ uint8_t MoveAxis;
    /* 0x00d0 */ FInterpLookupTrack LookupTrack;
};

// Size: 0xc0
class UInterpTrackParticleReplay : public UInterpTrack {
    /* 0x00a8 */ TArray<FParticleReplayTrackKey> TrackKeys;
    /* 0x00b8 */ bool bIsCapturingReplay;
    /* 0x00bc */ float FixedTimeStep;
};

// Size: 0xc8
class UInterpTrackSlomo : public UInterpTrackFloatBase {
};

// Size: 0xe0
class UInterpTrackSound : public UInterpTrackVectorBase {
    /* 0x00c8 */ TArray<FSoundTrackKey> Sounds;
    /* 0x00d8 */ bool bPlayOnReverse;
    /* 0x00d8 */ bool bContinueSoundOnMatineeEnd;
    /* 0x00d8 */ bool bSuppressSubtitles;
    /* 0x00d8 */ bool bTreatAsDialogue;
    /* 0x00d8 */ bool bAttach;
};

// Size: 0xc0
class UInterpTrackToggle : public UInterpTrack {
    /* 0x00a8 */ TArray<FToggleTrackKey> ToggleTrack;
    /* 0x00b8 */ bool bActivateSystemEachUpdate;
    /* 0x00b8 */ bool bActivateWithJustAttachedFlag;
    /* 0x00b8 */ bool bFireEventsWhenForwards;
    /* 0x00b8 */ bool bFireEventsWhenBackwards;
    /* 0x00b8 */ bool bFireEventsWhenJumpingForwards;
};

// Size: 0xc8
class UInterpTrackVectorBase : public UInterpTrack {
    /* 0x00a8 */ FInterpCurveVector VectorTrack;
    /* 0x00c0 */ float CurveTension;
};

// Size: 0xe8
class UInterpTrackVectorMaterialParam : public UInterpTrackVectorBase {
    /* 0x00c8 */ TArray<UMaterialInterface*> TargetMaterials;
    /* 0x00d8 */ FName ParamName;
};

// Size: 0xd8
class UInterpTrackVectorProp : public UInterpTrackVectorBase {
    /* 0x00c8 */ FName PropertyName;
};

// Size: 0xc0
class UInterpTrackVisibility : public UInterpTrack {
    /* 0x00a8 */ TArray<FVisibilityTrackKey> VisibilityTrack;
    /* 0x00b8 */ bool bFireEventsWhenForwards;
    /* 0x00b8 */ bool bFireEventsWhenBackwards;
    /* 0x00b8 */ bool bFireEventsWhenJumpingForwards;
};

// Size: 0x8
struct FInterpolationParameter {
    /* 0x0000 */ float InterpolationTime;
    /* 0x0004 */ uint8_t InterpolationType;
};

// Size: 0x58
struct FKAggregateGeom {
    /* 0x0000 */ TArray<FKSphereElem> SphereElems;
    /* 0x0010 */ TArray<FKBoxElem> BoxElems;
    /* 0x0020 */ TArray<FKSphylElem> SphylElems;
    /* 0x0030 */ TArray<FKConvexElem> ConvexElems;
    /* 0x0040 */ TArray<FKTaperedCapsuleElem> TaperedCapsuleElems;
};

// Size: 0xc0
struct FKBoxElem : public FKShapeElem {
    /* 0x0040 */ FMatrix TM;
    /* 0x0080 */ FQuat Orientation;
    /* 0x0090 */ FVector Center;
    /* 0x009c */ FRotator Rotation;
    /* 0x00a8 */ float X;
    /* 0x00ac */ float Y;
    /* 0x00b0 */ float Z;
};

// Size: 0xc0
struct FKConvexElem : public FKShapeElem {
    /* 0x0038 */ TArray<FVector> VertexData;
    /* 0x0048 */ TArray<int32_t> IndexData;
    /* 0x0058 */ FBox ElemBox;
    /* 0x0080 */ FTransform Transform;
};

// Size: 0x38
struct FKShapeElem {
    /* 0x0008 */ float RestOffset;
    /* 0x000c */ bool bIsGenerated;
    /* 0x0010 */ FName Name;
    /* 0x0020 */ bool bContributeToMass;
    /* 0x0021 */ uint8_t CollisionEnabled;
};

// Size: 0x90
struct FKSphereElem : public FKShapeElem {
    /* 0x0040 */ FMatrix TM;
    /* 0x0080 */ FVector Center;
    /* 0x008c */ float Radius;
};

// Size: 0xb0
struct FKSphylElem : public FKShapeElem {
    /* 0x0040 */ FMatrix TM;
    /* 0x0080 */ FQuat Orientation;
    /* 0x0090 */ FVector Center;
    /* 0x009c */ FRotator Rotation;
    /* 0x00a8 */ float Radius;
    /* 0x00ac */ float Length;
};

// Size: 0x60
struct FKTaperedCapsuleElem : public FKShapeElem {
    /* 0x0038 */ FVector Center;
    /* 0x0044 */ FRotator Rotation;
    /* 0x0050 */ float Radius0;
    /* 0x0054 */ float Radius1;
    /* 0x0058 */ float Length;
};

// Size: 0x38
struct FKeyBind {
    /* 0x0000 */ FKey Key;
    /* 0x0020 */ FString Command;
    /* 0x0030 */ bool Control;
    /* 0x0030 */ bool Shift;
    /* 0x0030 */ bool Alt;
    /* 0x0030 */ bool Cmd;
    /* 0x0030 */ bool bIgnoreCtrl;
    /* 0x0030 */ bool bIgnoreShift;
    /* 0x0030 */ bool bIgnoreAlt;
    /* 0x0030 */ bool bIgnoreCmd;
    /* 0x0031 */ bool bDisabled;
};

// Size: 0x60
struct FKeyHandleLookupTable {
};

// Size: 0x60
struct FKeyHandleMap {
};

// Size: 0x348
class AKillZVolume : public APhysicsVolume {
};

// Size: 0x30
class UKismetArrayLibrary : public UBlueprintFunctionLibrary {

    static int32_t Array_Add(const TArray<int32_t>& TargetArray, const int32_t& NewItem);
    static int32_t Array_AddUnique(const TArray<int32_t>& TargetArray, const int32_t& NewItem);
    static void Array_Append(const TArray<int32_t>& TargetArray, const TArray<int32_t>& SourceArray);
    static void Array_Clear(const TArray<int32_t>& TargetArray);
    static bool Array_Contains(const TArray<int32_t>& TargetArray, const int32_t& ItemToFind);
    static int32_t Array_Find(const TArray<int32_t>& TargetArray, const int32_t& ItemToFind);
    static void Array_Get(const TArray<int32_t>& TargetArray, int32_t index, int32_t& Item);
    static bool Array_Identical(const TArray<int32_t>& ArrayA, const TArray<int32_t>& ArrayB);
    static void Array_Insert(const TArray<int32_t>& TargetArray, const int32_t& NewItem, int32_t index);
    static bool Array_IsValidIndex(const TArray<int32_t>& TargetArray, int32_t IndexToTest);
    static int32_t Array_LastIndex(const TArray<int32_t>& TargetArray);
    static int32_t Array_Length(const TArray<int32_t>& TargetArray);
    static void Array_Random(const TArray<int32_t>& TargetArray, int32_t& OutItem, int32_t& OutIndex);
    static void Array_RandomFromStream(const TArray<int32_t>& TargetArray, FRandomStream& RandomStream, int32_t& OutItem, int32_t& OutIndex);
    static void Array_Remove(const TArray<int32_t>& TargetArray, int32_t IndexToRemove);
    static bool Array_RemoveItem(const TArray<int32_t>& TargetArray, const int32_t& Item);
    static void Array_Resize(const TArray<int32_t>& TargetArray, int32_t Size);
    static void Array_Reverse(const TArray<int32_t>& TargetArray);
    static void Array_Set(const TArray<int32_t>& TargetArray, int32_t index, const int32_t& Item, bool bSizeToFit);
    static void Array_Shuffle(const TArray<int32_t>& TargetArray);
    static void Array_Swap(const TArray<int32_t>& TargetArray, int32_t FirstIndex, int32_t SecondIndex);
    static void FilterArray(const TArray<AActor*>& TargetArray, UClass* FilterClass, TArray<AActor*>& FilteredArray);
    static void SetArrayPropertyByName(UObject* Object, FName PropertyName, const TArray<int32_t>& Value);
};

// Size: 0x30
class UKismetGuidLibrary : public UBlueprintFunctionLibrary {

    static FString Conv_GuidToString(const FGuid& InGuid);
    static bool EqualEqual_GuidGuid(const FGuid& A, const FGuid& B);
    static void Invalidate_Guid(FGuid& InGuid);
    static bool IsValid_Guid(const FGuid& InGuid);
    static FGuid NewGuid();
    static bool NotEqual_GuidGuid(const FGuid& A, const FGuid& B);
    static void Parse_StringToGuid(FString GuidString, FGuid& OutGuid, bool& Success);
};

// Size: 0x30
class UKismetInputLibrary : public UBlueprintFunctionLibrary {

    static void CalibrateTilt();
    static bool EqualEqual_InputChordInputChord(FInputChord A, FInputChord B);
    static bool EqualEqual_KeyKey(FKey A, FKey B);
    static float GetAnalogValue(const FAnalogInputEvent& Input);
    static FKey GetKey(const FKeyEvent& Input);
    static int32_t GetUserIndex(const FKeyEvent& Input);
    static FText InputChord_GetDisplayName(const FInputChord& Key);
    static bool InputEvent_IsAltDown(const FInputEvent& Input);
    static bool InputEvent_IsCommandDown(const FInputEvent& Input);
    static bool InputEvent_IsControlDown(const FInputEvent& Input);
    static bool InputEvent_IsLeftAltDown(const FInputEvent& Input);
    static bool InputEvent_IsLeftCommandDown(const FInputEvent& Input);
    static bool InputEvent_IsLeftControlDown(const FInputEvent& Input);
    static bool InputEvent_IsLeftShiftDown(const FInputEvent& Input);
    static bool InputEvent_IsRepeat(const FInputEvent& Input);
    static bool InputEvent_IsRightAltDown(const FInputEvent& Input);
    static bool InputEvent_IsRightCommandDown(const FInputEvent& Input);
    static bool InputEvent_IsRightControlDown(const FInputEvent& Input);
    static bool InputEvent_IsRightShiftDown(const FInputEvent& Input);
    static bool InputEvent_IsShiftDown(const FInputEvent& Input);
    static FText Key_GetDisplayName(const FKey& Key);
    static EUINavigationAction Key_GetNavigationAction(const FKey& InKey);
    static EUINavigationAction Key_GetNavigationActionFromKey(const FKeyEvent& InKeyEvent);
    static EUINavigation Key_GetNavigationDirectionFromAnalog(const FAnalogInputEvent& InAnalogEvent);
    static EUINavigation Key_GetNavigationDirectionFromKey(const FKeyEvent& InKeyEvent);
    static bool Key_IsAnalog(const FKey& Key);
    static bool Key_IsAxis1D(const FKey& Key);
    static bool Key_IsAxis2D(const FKey& Key);
    static bool Key_IsAxis3D(const FKey& Key);
    static bool Key_IsButtonAxis(const FKey& Key);
    static bool Key_IsDigital(const FKey& Key);
    static bool Key_IsGamepadKey(const FKey& Key);
    static bool Key_IsKeyboardKey(const FKey& Key);
    static bool Key_IsModifierKey(const FKey& Key);
    static bool Key_IsMouseButton(const FKey& Key);
    static bool Key_IsValid(const FKey& Key);
    static bool Key_IsVectorAxis(const FKey& Key);
    static FVector2D PointerEvent_GetCursorDelta(const FPointerEvent& Input);
    static FKey PointerEvent_GetEffectingButton(const FPointerEvent& Input);
    static FVector2D PointerEvent_GetGestureDelta(const FPointerEvent& Input);
    static ESlateGesture PointerEvent_GetGestureType(const FPointerEvent& Input);
    static FVector2D PointerEvent_GetLastScreenSpacePosition(const FPointerEvent& Input);
    static int32_t PointerEvent_GetPointerIndex(const FPointerEvent& Input);
    static FVector2D PointerEvent_GetScreenSpacePosition(const FPointerEvent& Input);
    static int32_t PointerEvent_GetTouchpadIndex(const FPointerEvent& Input);
    static int32_t PointerEvent_GetUserIndex(const FPointerEvent& Input);
    static float PointerEvent_GetWheelDelta(const FPointerEvent& Input);
    static bool PointerEvent_IsMouseButtonDown(const FPointerEvent& Input, FKey MouseButton);
    static bool PointerEvent_IsTouchEvent(const FPointerEvent& Input);
};

// Size: 0x30
class UKismetInternationalizationLibrary : public UBlueprintFunctionLibrary {

    static void ClearCurrentAssetGroupCulture(const FName AssetGroup, const bool SaveToConfig);
    static FString GetCultureDisplayName(FString Culture, const bool Localized);
    static FString GetCurrentAssetGroupCulture(const FName AssetGroup);
    static FString GetCurrentCulture();
    static FString GetCurrentLanguage();
    static FString GetCurrentLocale();
    static TArray<FString> GetLocalizedCultures(const bool IncludeGame, const bool IncludeEngine, const bool IncludeEditor, const bool IncludeAdditional);
    static FString GetNativeCulture(const ELocalizedTextSourceCategory TextCategory);
    static FString GetSuitableCulture(const TArray<FString>& AvailableCultures, FString CultureToMatch, FString FallbackCulture);
    static bool SetCurrentAssetGroupCulture(const FName AssetGroup, FString Culture, const bool SaveToConfig);
    static bool SetCurrentCulture(FString Culture, const bool SaveToConfig);
    static bool SetCurrentLanguage(FString Culture, const bool SaveToConfig);
    static bool SetCurrentLanguageAndLocale(FString Culture, const bool SaveToConfig);
    static bool SetCurrentLocale(FString Culture, const bool SaveToConfig);
};

// Size: 0x30
class UKismetMaterialLibrary : public UBlueprintFunctionLibrary {

    static UMaterialInstanceDynamic* CreateDynamicMaterialInstance(UObject* WorldContextObject, UMaterialInterface* Parent, FName OptionalName, EMIDCreationFlags CreationFlags);
    static float GetScalarParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName);
    static FLinearColor GetVectorParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName);
    static void SetScalarParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue);
    static void SetVectorParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, const FLinearColor& ParameterValue);
};

// Size: 0x30
class UKismetMathLibrary : public UBlueprintFunctionLibrary {

    static float Abs(float A);
    static int32_t Abs_Int(int32_t A);
    static int64_t Abs_Int64(int64_t A);
    static float Acos(float A);
    static uint8_t Add_ByteByte(uint8_t A, uint8_t B);
    static FDateTime Add_DateTimeDateTime(FDateTime A, FDateTime B);
    static FDateTime Add_DateTimeTimespan(FDateTime A, FTimespan B);
    static float Add_FloatFloat(float A, float B);
    static int64_t Add_Int64Int64(int64_t A, int64_t B);
    static int32_t Add_IntInt(int32_t A, int32_t B);
    static FIntPoint Add_IntPointInt(FIntPoint A, int32_t B);
    static FIntPoint Add_IntPointIntPoint(FIntPoint A, FIntPoint B);
    static FLinearColor Add_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    static FMatrix Add_MatrixMatrix(const FMatrix& A, const FMatrix& B);
    static FQuat Add_QuatQuat(const FQuat& A, const FQuat& B);
    static FTimespan Add_TimespanTimespan(FTimespan A, FTimespan B);
    static FVector2D Add_Vector2DFloat(FVector2D A, float B);
    static FVector2D Add_Vector2DVector2D(FVector2D A, FVector2D B);
    static FVector4 Add_Vector4Vector4(const FVector4& A, const FVector4& B);
    static FVector Add_VectorFloat(FVector A, float B);
    static FVector Add_VectorInt(FVector A, int32_t B);
    static FVector Add_VectorVector(FVector A, FVector B);
    static int64_t And_Int64Int64(int64_t A, int64_t B);
    static int32_t And_IntInt(int32_t A, int32_t B);
    static float Asin(float A);
    static float Atan(float A);
    static float Atan2(float Y, float X);
    static uint8_t BMax(uint8_t A, uint8_t B);
    static uint8_t BMin(uint8_t A, uint8_t B);
    static bool BooleanAND(bool A, bool B);
    static bool BooleanNAND(bool A, bool B);
    static bool BooleanNOR(bool A, bool B);
    static bool BooleanOR(bool A, bool B);
    static bool BooleanXOR(bool A, bool B);
    static void BreakColor(FLinearColor InColor, float& R, float& G, float& B, float& A);
    static void BreakDateTime(FDateTime InDateTime, int32_t& Year, int32_t& Month, int32_t& Day, int32_t& Hour, int32_t& Minute, int32_t& Second, int32_t& Millisecond);
    static void BreakFrameRate(const FFrameRate& InFrameRate, int32_t& Numerator, int32_t& Denominator);
    static void BreakQualifiedFrameTime(const FQualifiedFrameTime& InFrameTime, FFrameNumber& Frame, FFrameRate& FrameRate, float& SubFrame);
    static void BreakRandomStream(const FRandomStream& InRandomStream, int32_t& InitialSeed);
    static void BreakRotIntoAxes(const FRotator& InRot, FVector& X, FVector& Y, FVector& Z);
    static void BreakRotator(FRotator InRot, float& Roll, float& Pitch, float& Yaw);
    static void BreakTimespan(FTimespan InTimespan, int32_t& Days, int32_t& Hours, int32_t& Minutes, int32_t& Seconds, int32_t& Milliseconds);
    static void BreakTimespan2(FTimespan InTimespan, int32_t& Days, int32_t& Hours, int32_t& Minutes, int32_t& Seconds, int32_t& FractionNano);
    static void BreakTransform(const FTransform& InTransform, FVector& Location, FRotator& Rotation, FVector& Scale);
    static void BreakVector(FVector InVec, float& X, float& Y, float& Z);
    static void BreakVector2D(FVector2D InVec, float& X, float& Y);
    static void BreakVector4(const FVector4& InVec, float& X, float& Y, float& Z, float& W);
    static FLinearColor CInterpTo(FLinearColor Current, FLinearColor Target, float DeltaTime, float InterpSpeed);
    static int32_t Clamp(int32_t Value, int32_t Min, int32_t Max);
    static float ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees);
    static FVector2D ClampAxes2D(FVector2D A, float MinAxisVal, float MaxAxisVal);
    static float ClampAxis(float Angle);
    static int64_t ClampInt64(int64_t Value, int64_t Min, int64_t Max);
    static FVector ClampVectorSize(FVector A, float Min, float Max);
    static bool ClassIsChildOf(UClass* TestClass, UClass* ParentClass);
    static FRotator ComposeRotators(FRotator A, FRotator B);
    static FTransform ComposeTransforms(const FTransform& A, const FTransform& B);
    static uint8_t Conv_BoolToByte(bool InBool);
    static float Conv_BoolToFloat(bool InBool);
    static int32_t Conv_BoolToInt(bool InBool);
    static float Conv_ByteToFloat(uint8_t InByte);
    static int32_t Conv_ByteToInt(uint8_t InByte);
    static FLinearColor Conv_ColorToLinearColor(FColor InColor);
    static FLinearColor Conv_FloatToLinearColor(float InFloat);
    static FVector Conv_FloatToVector(float InFloat);
    static uint8_t Conv_Int64ToByte(int64_t inInt);
    static int32_t Conv_Int64ToInt(int64_t inInt);
    static FVector2D Conv_IntPointToVector2D(FIntPoint InIntPoint);
    static bool Conv_IntToBool(int32_t inInt);
    static uint8_t Conv_IntToByte(int32_t inInt);
    static float Conv_IntToFloat(int32_t inInt);
    static int64_t Conv_IntToInt64(int32_t inInt);
    static FIntVector Conv_IntToIntVector(int32_t inInt);
    static FVector Conv_IntVectorToVector(const FIntVector& InIntVector);
    static FColor Conv_LinearColorToColor(FLinearColor InLinearColor, bool InUseSRGB);
    static FVector Conv_LinearColorToVector(FLinearColor InLinearColor);
    static FRotator Conv_MatrixToRotator(const FMatrix& InMatrix);
    static FTransform Conv_MatrixToTransform(const FMatrix& InMatrix);
    static FTransform Conv_RotatorToTransform(const FRotator& InRotator);
    static FVector Conv_RotatorToVector(FRotator InRot);
    static FMatrix Conv_TransformToMatrix(const FTransform& Transform);
    static FIntPoint Conv_Vector2DToIntPoint(FVector2D InVector2D);
    static FVector Conv_Vector2DToVector(FVector2D InVector2D, float Z);
    static FQuat Conv_Vector4ToQuaternion(const FVector4& InVec);
    static FRotator Conv_Vector4ToRotator(const FVector4& InVec);
    static FVector Conv_Vector4ToVector(const FVector4& InVector4);
    static FLinearColor Conv_VectorToLinearColor(FVector InVec);
    static FQuat Conv_VectorToQuaternion(FVector InVec);
    static FRotator Conv_VectorToRotator(FVector InVec);
    static FTransform Conv_VectorToTransform(FVector InLocation);
    static FVector2D Conv_VectorToVector2D(FVector InVector);
    static FTransform ConvertTransformToRelative(const FTransform& Transform, const FTransform& ParentTransform);
    static float Cos(float A);
    static FVector CreateVectorFromYawPitch(float Yaw, float Pitch, float Length);
    static float CrossProduct2D(FVector2D A, FVector2D B);
    static FVector Cross_VectorVector(FVector A, FVector B);
    static bool DateTimeFromIsoString(FString IsoString, FDateTime& Result);
    static bool DateTimeFromString(FString DateTimeString, FDateTime& Result);
    static FDateTime DateTimeMaxValue();
    static FDateTime DateTimeMinValue();
    static int32_t DaysInMonth(int32_t Year, int32_t Month);
    static int32_t DaysInYear(int32_t Year);
    static float DegAcos(float A);
    static float DegAsin(float A);
    static float DegAtan(float A);
    static float DegAtan2(float Y, float X);
    static float DegCos(float A);
    static float DegSin(float A);
    static float DegTan(float A);
    static float DegreesToRadians(float A);
    static float Distance2D(FVector2D v1, FVector2D v2);
    static float DistanceSquared2D(FVector2D v1, FVector2D v2);
    static uint8_t Divide_ByteByte(uint8_t A, uint8_t B);
    static float Divide_FloatFloat(float A, float B);
    static int64_t Divide_Int64Int64(int64_t A, int64_t B);
    static int32_t Divide_IntInt(int32_t A, int32_t B);
    static FIntPoint Divide_IntPointInt(FIntPoint A, int32_t B);
    static FIntPoint Divide_IntPointIntPoint(FIntPoint A, FIntPoint B);
    static FLinearColor Divide_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    static FTimespan Divide_TimespanFloat(FTimespan A, float Scalar);
    static FVector2D Divide_Vector2DFloat(FVector2D A, float B);
    static FVector2D Divide_Vector2DVector2D(FVector2D A, FVector2D B);
    static FVector4 Divide_Vector4Vector4(const FVector4& A, const FVector4& B);
    static FVector Divide_VectorFloat(FVector A, float B);
    static FVector Divide_VectorInt(FVector A, int32_t B);
    static FVector Divide_VectorVector(FVector A, FVector B);
    static float DotProduct2D(FVector2D A, FVector2D B);
    static float Dot_VectorVector(FVector A, FVector B);
    static FRotator DynamicWeightedMovingAverage_FRotator(FRotator CurrentSample, FRotator PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    static FVector DynamicWeightedMovingAverage_FVector(FVector CurrentSample, FVector PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    static float DynamicWeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    static float Ease(float A, float B, float Alpha, uint8_t EasingFunc, float BlendExp, int32_t Steps);
    static bool EqualEqual_BoolBool(bool A, bool B);
    static bool EqualEqual_ByteByte(uint8_t A, uint8_t B);
    static bool EqualEqual_ClassClass(UClass* A, UClass* B);
    static bool EqualEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    static bool EqualEqual_FloatFloat(float A, float B);
    static bool EqualEqual_Int64Int64(int64_t A, int64_t B);
    static bool EqualEqual_IntInt(int32_t A, int32_t B);
    static bool EqualEqual_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    static bool EqualEqual_MatrixMatrix(const FMatrix& A, const FMatrix& B, float Tolerance);
    static bool EqualEqual_NameName(FName A, FName B);
    static bool EqualEqual_ObjectObject(UObject* A, UObject* B);
    static bool EqualEqual_QuatQuat(const FQuat& A, const FQuat& B, float Tolerance);
    static bool EqualEqual_RotatorRotator(FRotator A, FRotator B, float ErrorTolerance);
    static bool EqualEqual_TimespanTimespan(FTimespan A, FTimespan B);
    static bool EqualEqual_TransformTransform(const FTransform& A, const FTransform& B);
    static bool EqualEqual_Vector2DVector2D(FVector2D A, FVector2D B, float ErrorTolerance);
    static bool EqualEqual_Vector4Vector4(const FVector4& A, const FVector4& B, float ErrorTolerance);
    static bool EqualEqual_VectorVector(FVector A, FVector B, float ErrorTolerance);
    static bool EqualExactly_Vector2DVector2D(FVector2D A, FVector2D B);
    static bool EqualExactly_Vector4Vector4(const FVector4& A, const FVector4& B);
    static bool EqualExactly_VectorVector(FVector A, FVector B);
    static bool Equal_IntPointIntPoint(FIntPoint A, FIntPoint B);
    static float Exp(float A);
    static int32_t FCeil(float A);
    static int64_t FCeil64(float A);
    static float FClamp(float Value, float Min, float Max);
    static int32_t FFloor(float A);
    static int64_t FFloor64(float A);
    static float FInterpEaseInOut(float A, float B, float Alpha, float Exponent);
    static float FInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed);
    static float FInterpTo_Constant(float Current, float Target, float DeltaTime, float InterpSpeed);
    static float FMax(float A, float B);
    static float FMin(float A, float B);
    static int32_t FMod(float Dividend, float Divisor, float& Remainder);
    static int32_t FTrunc(float A);
    static int64_t FTrunc64(float A);
    static FIntVector FTruncVector(const FVector& InVector);
    static float FWrap(float Value, float Min, float Max);
    static FVector FindClosestPointOnLine(FVector Point, FVector LineOrigin, FVector LineDirection);
    static FVector FindClosestPointOnSegment(FVector Point, FVector SegmentStart, FVector SegmentEnd);
    static FRotator FindLookAtRotation(const FVector& Start, const FVector& Target);
    static void FindNearestPointsOnLineSegments(FVector Segment1Start, FVector Segment1End, FVector Segment2Start, FVector Segment2End, FVector& Segment1Point, FVector& Segment2Point);
    static float FixedTurn(float InCurrent, float InDesired, float InDeltaRate);
    static float FloatSpringInterp(float Current, float Target, FFloatSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass);
    static float Fraction(float A);
    static FTimespan FromDays(float Days);
    static FTimespan FromHours(float Hours);
    static FTimespan FromMilliseconds(float Milliseconds);
    static FTimespan FromMinutes(float Minutes);
    static FTimespan FromSeconds(float Seconds);
    static FVector2D GetAbs2D(FVector2D A);
    static float GetAbsMax2D(FVector2D A);
    static void GetAxes(FRotator A, FVector& X, FVector& Y, FVector& Z);
    static void GetAzimuthAndElevation(FVector InDirection, const FTransform& ReferenceFrame, float& Azimuth, float& Elevation);
    static FDateTime GetDate(FDateTime A);
    static int32_t GetDay(FDateTime A);
    static int32_t GetDayOfYear(FDateTime A);
    static int32_t GetDays(FTimespan A);
    static FVector GetDirectionUnitVector(FVector From, FVector To);
    static FTimespan GetDuration(FTimespan A);
    static FVector GetForwardVector(FRotator InRot);
    static int32_t GetHour(FDateTime A);
    static int32_t GetHour12(FDateTime A);
    static int32_t GetHours(FTimespan A);
    static float GetMax2D(FVector2D A);
    static float GetMaxElement(FVector A);
    static int32_t GetMillisecond(FDateTime A);
    static int32_t GetMilliseconds(FTimespan A);
    static float GetMin2D(FVector2D A);
    static float GetMinElement(FVector A);
    static int32_t GetMinute(FDateTime A);
    static int32_t GetMinutes(FTimespan A);
    static int32_t GetMonth(FDateTime A);
    static float GetPI();
    static float GetPointDistanceToLine(FVector Point, FVector LineOrigin, FVector LineDirection);
    static float GetPointDistanceToSegment(FVector Point, FVector SegmentStart, FVector SegmentEnd);
    static FVector GetReflectionVector(FVector Direction, FVector SurfaceNormal);
    static FVector GetRightVector(FRotator InRot);
    static FVector2D GetRotated2D(FVector2D A, float AngleDeg);
    static int32_t GetSecond(FDateTime A);
    static int32_t GetSeconds(FTimespan A);
    static void GetSlopeDegreeAngles(const FVector& MyRightYAxis, const FVector& FloorNormal, const FVector& UpVector, float& OutSlopePitchDegreeAngle, float& OutSlopeRollDegreeAngle);
    static float GetTAU();
    static FTimespan GetTimeOfDay(FDateTime A);
    static float GetTotalDays(FTimespan A);
    static float GetTotalHours(FTimespan A);
    static float GetTotalMilliseconds(FTimespan A);
    static float GetTotalMinutes(FTimespan A);
    static float GetTotalSeconds(FTimespan A);
    static FVector GetUpVector(FRotator InRot);
    static FVector GetVectorArrayAverage(const TArray<FVector>& Vectors);
    static void GetYawPitchFromVector(FVector InVec, float& Yaw, float& Pitch);
    static int32_t GetYear(FDateTime A);
    static bool GreaterEqual_ByteByte(uint8_t A, uint8_t B);
    static bool GreaterEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    static bool GreaterEqual_FloatFloat(float A, float B);
    static bool GreaterEqual_Int64Int64(int64_t A, int64_t B);
    static bool GreaterEqual_IntInt(int32_t A, int32_t B);
    static bool GreaterEqual_TimespanTimespan(FTimespan A, FTimespan B);
    static FVector GreaterGreater_VectorRotator(FVector A, FRotator B);
    static bool Greater_ByteByte(uint8_t A, uint8_t B);
    static bool Greater_DateTimeDateTime(FDateTime A, FDateTime B);
    static bool Greater_FloatFloat(float A, float B);
    static bool Greater_Int64Int64(int64_t A, int64_t B);
    static bool Greater_IntInt(int32_t A, int32_t B);
    static bool Greater_TimespanTimespan(FTimespan A, FTimespan B);
    static float GridSnap_Float(float Location, float GridSize);
    static FLinearColor HSVToRGB(float H, float S, float V, float A);
    static FLinearColor HSVToRGBLinear(FLinearColor HSV);
    static void HSVToRGB_Vector(FLinearColor HSV, FLinearColor& RGB);
    static float Hypotenuse(float Width, float Height);
    static bool InRange_FloatFloat(float Value, float Min, float Max, bool InclusiveMin, bool InclusiveMax);
    static bool InRange_Int64Int64(int64_t Value, int64_t Min, int64_t Max, bool InclusiveMin, bool InclusiveMax);
    static bool InRange_IntInt(int32_t Value, int32_t Min, int32_t Max, bool InclusiveMin, bool InclusiveMax);
    static FIntPoint IntPoint_Down();
    static FIntPoint IntPoint_Left();
    static FIntPoint IntPoint_One();
    static FIntPoint IntPoint_Right();
    static FIntPoint IntPoint_Up();
    static FIntPoint IntPoint_Zero();
    static FVector InverseTransformDirection(const FTransform& T, FVector Direction);
    static FVector InverseTransformLocation(const FTransform& T, FVector Location);
    static FRotator InverseTransformRotation(const FTransform& T, FRotator Rotation);
    static FTransform InvertTransform(const FTransform& T);
    static bool IsAfternoon(FDateTime A);
    static bool IsLeapYear(int32_t Year);
    static bool IsMorning(FDateTime A);
    static bool IsNearlyZero2D(const FVector2D& A, float Tolerance);
    static bool IsPointInBox(FVector Point, FVector BoxOrigin, FVector BoxExtent);
    static bool IsPointInBoxWithTransform(FVector Point, const FTransform& BoxWorldTransform, FVector BoxExtent);
    static bool IsZero2D(const FVector2D& A);
    static float Lerp(float A, float B, float Alpha);
    static bool LessEqual_ByteByte(uint8_t A, uint8_t B);
    static bool LessEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    static bool LessEqual_FloatFloat(float A, float B);
    static bool LessEqual_Int64Int64(int64_t A, int64_t B);
    static bool LessEqual_IntInt(int32_t A, int32_t B);
    static bool LessEqual_TimespanTimespan(FTimespan A, FTimespan B);
    static FVector LessLess_VectorRotator(FVector A, FRotator B);
    static bool Less_ByteByte(uint8_t A, uint8_t B);
    static bool Less_DateTimeDateTime(FDateTime A, FDateTime B);
    static bool Less_FloatFloat(float A, float B);
    static bool Less_Int64Int64(int64_t A, int64_t B);
    static bool Less_IntInt(int32_t A, int32_t B);
    static bool Less_TimespanTimespan(FTimespan A, FTimespan B);
    static bool LinePlaneIntersection(const FVector& LineStart, const FVector& LineEnd, const FPlane& APlane, float& T, FVector& Intersection);
    static bool LinePlaneIntersection_OriginNormal(const FVector& LineStart, const FVector& LineEnd, FVector PlaneOrigin, FVector PlaneNormal, float& T, FVector& Intersection);
    static FLinearColor LinearColorLerp(FLinearColor A, FLinearColor B, float Alpha);
    static FLinearColor LinearColorLerpUsingHSV(FLinearColor A, FLinearColor B, float Alpha);
    static FLinearColor LinearColor_Black();
    static FLinearColor LinearColor_Blue();
    static FLinearColor LinearColor_Desaturated(FLinearColor InColor, float InDesaturation);
    static float LinearColor_Distance(FLinearColor C1, FLinearColor C2);
    static float LinearColor_GetLuminance(FLinearColor InColor);
    static float LinearColor_GetMax(FLinearColor InColor);
    static float LinearColor_GetMin(FLinearColor InColor);
    static FLinearColor LinearColor_Gray();
    static FLinearColor LinearColor_Green();
    static bool LinearColor_IsNearEqual(FLinearColor A, FLinearColor B, float Tolerance);
    static FColor LinearColor_Quantize(FLinearColor InColor);
    static FColor LinearColor_QuantizeRound(FLinearColor InColor);
    static FLinearColor LinearColor_Red();
    static void LinearColor_Set(FLinearColor& InOutColor, FLinearColor InColor);
    static void LinearColor_SetFromHSV(FLinearColor& InOutColor, float H, float S, float V, float A);
    static void LinearColor_SetFromPow22(FLinearColor& InOutColor, const FColor& InColor);
    static void LinearColor_SetFromSRGB(FLinearColor& InOutColor, const FColor& InSRGB);
    static void LinearColor_SetRGBA(FLinearColor& InOutColor, float R, float G, float B, float A);
    static void LinearColor_SetRandomHue(FLinearColor& InOutColor);
    static void LinearColor_SetTemperature(FLinearColor& InOutColor, float InTemperature);
    static FLinearColor LinearColor_ToNewOpacity(FLinearColor InColor, float InOpacity);
    static FColor LinearColor_ToRGBE(FLinearColor InLinearColor);
    static FLinearColor LinearColor_Transparent();
    static FLinearColor LinearColor_White();
    static FLinearColor LinearColor_Yellow();
    static float Log(float A, float Base);
    static float Loge(float A);
    static FBox MakeBox(FVector Min, FVector Max);
    static FBox2D MakeBox2D(FVector2D Min, FVector2D Max);
    static FLinearColor MakeColor(float R, float G, float B, float A);
    static FDateTime MakeDateTime(int32_t Year, int32_t Month, int32_t Day, int32_t Hour, int32_t Minute, int32_t Second, int32_t Millisecond);
    static FFrameRate MakeFrameRate(int32_t Numerator, int32_t Denominator);
    static FPlane MakePlaneFromPointAndNormal(FVector Point, FVector Normal);
    static float MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase);
    static FQualifiedFrameTime MakeQualifiedFrameTime(FFrameNumber Frame, FFrameRate FrameRate, float SubFrame);
    static FRandomStream MakeRandomStream(int32_t InitialSeed);
    static FTransform MakeRelativeTransform(const FTransform& A, const FTransform& RelativeTo);
    static FRotator MakeRotFromX(const FVector& X);
    static FRotator MakeRotFromXY(const FVector& X, const FVector& Y);
    static FRotator MakeRotFromXZ(const FVector& X, const FVector& Z);
    static FRotator MakeRotFromY(const FVector& Y);
    static FRotator MakeRotFromYX(const FVector& Y, const FVector& X);
    static FRotator MakeRotFromYZ(const FVector& Y, const FVector& Z);
    static FRotator MakeRotFromZ(const FVector& Z);
    static FRotator MakeRotFromZX(const FVector& Z, const FVector& X);
    static FRotator MakeRotFromZY(const FVector& Z, const FVector& Y);
    static FRotator MakeRotationFromAxes(FVector Forward, FVector Right, FVector Up);
    static FRotator MakeRotator(float Roll, float Pitch, float Yaw);
    static FTimespan MakeTimespan(int32_t Days, int32_t Hours, int32_t Minutes, int32_t Seconds, int32_t Milliseconds);
    static FTimespan MakeTimespan2(int32_t Days, int32_t Hours, int32_t Minutes, int32_t Seconds, int32_t FractionNano);
    static FTransform MakeTransform(FVector Location, FRotator Rotation, FVector Scale);
    static FVector MakeVector(float X, float Y, float Z);
    static FVector2D MakeVector2D(float X, float Y);
    static FVector4 MakeVector4(float X, float Y, float Z, float W);
    static float MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB);
    static float MapRangeUnclamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB);
    static FMatrix Matrix_ApplyScale(const FMatrix& M, float Scale);
    static FMatrix Matrix_ConcatenateTranslation(const FMatrix& M, FVector Translation);
    static bool Matrix_ContainsNaN(const FMatrix& M);
    static FVector Matrix_GetColumn(const FMatrix& M, uint8_t Column);
    static float Matrix_GetDeterminant(const FMatrix& M);
    static bool Matrix_GetFrustumBottomPlane(const FMatrix& M, FPlane& OutPlane);
    static bool Matrix_GetFrustumFarPlane(const FMatrix& M, FPlane& OutPlane);
    static bool Matrix_GetFrustumLeftPlane(const FMatrix& M, FPlane& OutPlane);
    static bool Matrix_GetFrustumNearPlane(const FMatrix& M, FPlane& OutPlane);
    static bool Matrix_GetFrustumRightPlane(const FMatrix& M, FPlane& OutPlane);
    static bool Matrix_GetFrustumTopPlane(const FMatrix& M, FPlane& OutPlane);
    static FMatrix Matrix_GetInverse(const FMatrix& M);
    static FMatrix Matrix_GetMatrixWithoutScale(const FMatrix& M, float Tolerance);
    static float Matrix_GetMaximumAxisScale(const FMatrix& M);
    static FVector Matrix_GetOrigin(const FMatrix& InMatrix);
    static float Matrix_GetRotDeterminant(const FMatrix& M);
    static FRotator Matrix_GetRotator(const FMatrix& M);
    static FVector Matrix_GetScaleVector(const FMatrix& M, float Tolerance);
    static void Matrix_GetScaledAxes(const FMatrix& M, FVector& X, FVector& Y, FVector& Z);
    static FVector Matrix_GetScaledAxis(const FMatrix& M, uint8_t Axis);
    static FMatrix Matrix_GetTransposeAdjoint(const FMatrix& M);
    static FMatrix Matrix_GetTransposed(const FMatrix& M);
    static void Matrix_GetUnitAxes(const FMatrix& M, FVector& X, FVector& Y, FVector& Z);
    static FVector Matrix_GetUnitAxis(const FMatrix& M, uint8_t Axis);
    static FMatrix Matrix_Identity();
    static FVector Matrix_InverseTransformPosition(const FMatrix& M, FVector V);
    static FVector Matrix_InverseTransformVector(const FMatrix& M, FVector V);
    static FMatrix Matrix_Mirror(const FMatrix& M, uint8_t MirrorAxis, uint8_t FlipAxis);
    static void Matrix_RemoveScaling(FMatrix& M, float Tolerance);
    static FMatrix Matrix_RemoveTranslation(const FMatrix& M);
    static FMatrix Matrix_ScaleTranslation(const FMatrix& M, FVector Scale3D);
    static void Matrix_SetAxis(FMatrix& M, uint8_t Axis, FVector AxisVector);
    static void Matrix_SetColumn(FMatrix& M, uint8_t Column, FVector Value);
    static void Matrix_SetOrigin(FMatrix& M, FVector NewOrigin);
    static FQuat Matrix_ToQuat(const FMatrix& M);
    static FVector4 Matrix_TransformPosition(const FMatrix& M, FVector V);
    static FVector4 Matrix_TransformVector(const FMatrix& M, FVector V);
    static FVector4 Matrix_TransformVector4(const FMatrix& M, FVector4 V);
    static int32_t Max(int32_t A, int32_t B);
    static int64_t MaxInt64(int64_t A, int64_t B);
    static void MaxOfByteArray(const TArray<uint8_t>& ByteArray, int32_t& IndexOfMaxValue, uint8_t& MaxValue);
    static void MaxOfFloatArray(const TArray<float>& FloatArray, int32_t& IndexOfMaxValue, float& MaxValue);
    static void MaxOfIntArray(const TArray<int32_t>& IntArray, int32_t& IndexOfMaxValue, int32_t& MaxValue);
    static int32_t Min(int32_t A, int32_t B);
    static int64_t MinInt64(int64_t A, int64_t B);
    static void MinOfByteArray(const TArray<uint8_t>& ByteArray, int32_t& IndexOfMinValue, uint8_t& MinValue);
    static void MinOfFloatArray(const TArray<float>& FloatArray, int32_t& IndexOfMinValue, float& MinValue);
    static void MinOfIntArray(const TArray<int32_t>& IntArray, int32_t& IndexOfMinValue, int32_t& MinValue);
    static void MinimumAreaRectangle(UObject* WorldContextObject, const TArray<FVector>& InVerts, const FVector& SampleSurfaceNormal, FVector& OutRectCenter, FRotator& OutRectRotation, float& OutSideLengthX, float& OutSideLengthY, bool bDebugDraw);
    static FVector MirrorVectorByNormal(FVector InVect, FVector InNormal);
    static float MultiplyByPi(float Value);
    static float MultiplyMultiply_FloatFloat(float Base, float Exp);
    static uint8_t Multiply_ByteByte(uint8_t A, uint8_t B);
    static float Multiply_FloatFloat(float A, float B);
    static int64_t Multiply_Int64Int64(int64_t A, int64_t B);
    static float Multiply_IntFloat(int32_t A, float B);
    static int32_t Multiply_IntInt(int32_t A, int32_t B);
    static FIntPoint Multiply_IntPointInt(FIntPoint A, int32_t B);
    static FIntPoint Multiply_IntPointIntPoint(FIntPoint A, FIntPoint B);
    static FLinearColor Multiply_LinearColorFloat(FLinearColor A, float B);
    static FLinearColor Multiply_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    static FMatrix Multiply_MatrixFloat(const FMatrix& A, float B);
    static FMatrix Multiply_MatrixMatrix(const FMatrix& A, const FMatrix& B);
    static FQuat Multiply_QuatQuat(const FQuat& A, const FQuat& B);
    static FRotator Multiply_RotatorFloat(FRotator A, float B);
    static FRotator Multiply_RotatorInt(FRotator A, int32_t B);
    static FTimespan Multiply_TimespanFloat(FTimespan A, float Scalar);
    static FVector2D Multiply_Vector2DFloat(FVector2D A, float B);
    static FVector2D Multiply_Vector2DVector2D(FVector2D A, FVector2D B);
    static FVector4 Multiply_Vector4Vector4(const FVector4& A, const FVector4& B);
    static FVector Multiply_VectorFloat(FVector A, float B);
    static FVector Multiply_VectorInt(FVector A, int32_t B);
    static FVector Multiply_VectorVector(FVector A, FVector B);
    static bool NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance);
    static bool NearlyEqual_TransformTransform(const FTransform& A, const FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance);
    static FRotator NegateRotator(FRotator A);
    static FVector NegateVector(FVector A);
    static FVector2D Negated2D(const FVector2D& A);
    static FVector Normal(FVector A, float Tolerance);
    static FVector2D Normal2D(FVector2D A);
    static FVector2D NormalSafe2D(FVector2D A, float Tolerance);
    static void Normalize2D(FVector2D& A, float Tolerance);
    static float NormalizeAxis(float Angle);
    static float NormalizeToRange(float Value, float RangeMin, float RangeMax);
    static FRotator NormalizedDeltaRotator(FRotator A, FRotator B);
    static bool NotEqualExactly_Vector2DVector2D(FVector2D A, FVector2D B);
    static bool NotEqualExactly_Vector4Vector4(const FVector4& A, const FVector4& B);
    static bool NotEqualExactly_VectorVector(FVector A, FVector B);
    static bool NotEqual_BoolBool(bool A, bool B);
    static bool NotEqual_ByteByte(uint8_t A, uint8_t B);
    static bool NotEqual_ClassClass(UClass* A, UClass* B);
    static bool NotEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    static bool NotEqual_FloatFloat(float A, float B);
    static bool NotEqual_Int64Int64(int64_t A, int64_t B);
    static bool NotEqual_IntInt(int32_t A, int32_t B);
    static bool NotEqual_IntPointIntPoint(FIntPoint A, FIntPoint B);
    static bool NotEqual_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    static bool NotEqual_MatrixMatrix(const FMatrix& A, const FMatrix& B, float Tolerance);
    static bool NotEqual_NameName(FName A, FName B);
    static bool NotEqual_ObjectObject(UObject* A, UObject* B);
    static bool NotEqual_QuatQuat(const FQuat& A, const FQuat& B, float ErrorTolerance);
    static bool NotEqual_RotatorRotator(FRotator A, FRotator B, float ErrorTolerance);
    static bool NotEqual_TimespanTimespan(FTimespan A, FTimespan B);
    static bool NotEqual_Vector2DVector2D(FVector2D A, FVector2D B, float ErrorTolerance);
    static bool NotEqual_Vector4Vector4(const FVector4& A, const FVector4& B, float ErrorTolerance);
    static bool NotEqual_VectorVector(FVector A, FVector B, float ErrorTolerance);
    static int32_t Not_Int(int32_t A);
    static int64_t Not_Int64(int64_t A);
    static bool Not_PreBool(bool A);
    static FDateTime Now();
    static int64_t Or_Int64Int64(int64_t A, int64_t B);
    static int32_t Or_IntInt(int32_t A, int32_t B);
    static uint8_t Percent_ByteByte(uint8_t A, uint8_t B);
    static float Percent_FloatFloat(float A, float B);
    static int32_t Percent_IntInt(int32_t A, int32_t B);
    static float PerlinNoise1D(const float Value);
    static bool PointsAreCoplanar(const TArray<FVector>& Points, float Tolerance);
    static FVector ProjectPointOnToPlane(FVector Point, FVector PlaneBase, FVector PlaneNormal);
    static FVector ProjectVectorOnToPlane(FVector V, FVector PlaneNormal);
    static FVector ProjectVectorOnToVector(FVector V, FVector Target);
    static float Quat_AngularDistance(const FQuat& A, const FQuat& B);
    static void Quat_EnforceShortestArcWith(FQuat& A, const FQuat& B);
    static FVector Quat_Euler(const FQuat& Q);
    static FQuat Quat_Exp(const FQuat& Q);
    static float Quat_GetAngle(const FQuat& Q);
    static FVector Quat_GetAxisX(const FQuat& Q);
    static FVector Quat_GetAxisY(const FQuat& Q);
    static FVector Quat_GetAxisZ(const FQuat& Q);
    static FVector Quat_GetRotationAxis(const FQuat& Q);
    static FQuat Quat_Identity();
    static FQuat Quat_Inversed(const FQuat& Q);
    static bool Quat_IsFinite(const FQuat& Q);
    static bool Quat_IsIdentity(const FQuat& Q, float Tolerance);
    static bool Quat_IsNonFinite(const FQuat& Q);
    static bool Quat_IsNormalized(const FQuat& Q);
    static FQuat Quat_Log(const FQuat& Q);
    static FQuat Quat_MakeFromEuler(const FVector& Euler);
    static void Quat_Normalize(FQuat& Q, float Tolerance);
    static FQuat Quat_Normalized(const FQuat& Q, float Tolerance);
    static FVector Quat_RotateVector(const FQuat& Q, const FVector& V);
    static FRotator Quat_Rotator(const FQuat& Q);
    static void Quat_SetComponents(FQuat& Q, float X, float Y, float Z, float W);
    static void Quat_SetFromEuler(FQuat& Q, const FVector& Euler);
    static float Quat_Size(const FQuat& Q);
    static float Quat_SizeSquared(const FQuat& Q);
    static FVector Quat_UnrotateVector(const FQuat& Q, const FVector& V);
    static FVector Quat_VectorForward(const FQuat& Q);
    static FVector Quat_VectorRight(const FQuat& Q);
    static FVector Quat_VectorUp(const FQuat& Q);
    static FRotator REase(FRotator A, FRotator B, float Alpha, bool bShortestPath, uint8_t EasingFunc, float BlendExp, int32_t Steps);
    static FLinearColor RGBLinearToHSV(FLinearColor RGB);
    static void RGBToHSV(FLinearColor InColor, float& H, float& S, float& V, float& A);
    static void RGBToHSV_Vector(FLinearColor RGB, FLinearColor& HSV);
    static FRotator RInterpTo(FRotator Current, FRotator Target, float DeltaTime, float InterpSpeed);
    static FRotator RInterpTo_Constant(FRotator Current, FRotator Target, float DeltaTime, float InterpSpeed);
    static FRotator RLerp(FRotator A, FRotator B, float Alpha, bool bShortestPath);
    static float RadiansToDegrees(float A);
    static bool RandomBool();
    static bool RandomBoolFromStream(const FRandomStream& Stream);
    static bool RandomBoolWithWeight(float Weight);
    static bool RandomBoolWithWeightFromStream(float Weight, const FRandomStream& RandomStream);
    static float RandomFloat();
    static float RandomFloatFromStream(const FRandomStream& Stream);
    static float RandomFloatInRange(float Min, float Max);
    static float RandomFloatInRangeFromStream(float Min, float Max, const FRandomStream& Stream);
    static int32_t RandomInteger(int32_t Max);
    static int64_t RandomInteger64(int64_t Max);
    static int64_t RandomInteger64InRange(int64_t Min, int64_t Max);
    static int32_t RandomIntegerFromStream(int32_t Max, const FRandomStream& Stream);
    static int32_t RandomIntegerInRange(int32_t Min, int32_t Max);
    static int32_t RandomIntegerInRangeFromStream(int32_t Min, int32_t Max, const FRandomStream& Stream);
    static FVector RandomPointInBoundingBox(FVector Origin, FVector BoxExtent);
    static FRotator RandomRotator(bool bRoll);
    static FRotator RandomRotatorFromStream(bool bRoll, const FRandomStream& Stream);
    static FVector RandomUnitVector();
    static FVector RandomUnitVectorFromStream(const FRandomStream& Stream);
    static FVector RandomUnitVectorInConeInDegrees(FVector ConeDir, float ConeHalfAngleInDegrees);
    static FVector RandomUnitVectorInConeInDegreesFromStream(const FVector& ConeDir, float ConeHalfAngleInDegrees, const FRandomStream& Stream);
    static FVector RandomUnitVectorInConeInRadians(FVector ConeDir, float ConeHalfAngleInRadians);
    static FVector RandomUnitVectorInConeInRadiansFromStream(const FVector& ConeDir, float ConeHalfAngleInRadians, const FRandomStream& Stream);
    static FVector RandomUnitVectorInEllipticalConeInDegrees(FVector ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees);
    static FVector RandomUnitVectorInEllipticalConeInDegreesFromStream(const FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees, const FRandomStream& Stream);
    static FVector RandomUnitVectorInEllipticalConeInRadians(FVector ConeDir, float MaxYawInRadians, float MaxPitchInRadians);
    static FVector RandomUnitVectorInEllipticalConeInRadiansFromStream(const FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians, const FRandomStream& Stream);
    static void ResetFloatSpringState(FFloatSpringState& SpringState);
    static void ResetRandomStream(const FRandomStream& Stream);
    static void ResetVectorSpringState(FVectorSpringState& SpringState);
    static FVector RotateAngleAxis(FVector InVect, float AngleDeg, FVector Axis);
    static FRotator RotatorFromAxisAndAngle(FVector Axis, float Angle);
    static int32_t Round(float A);
    static int64_t Round64(float A);
    static float SafeDivide(float A, float B);
    static void SeedRandomStream(FRandomStream& Stream);
    static UClass* SelectClass(UClass* A, UClass* B, bool bSelectA);
    static FLinearColor SelectColor(FLinearColor A, FLinearColor B, bool bPickA);
    static float SelectFloat(float A, float B, bool bPickA);
    static int32_t SelectInt(int32_t A, int32_t B, bool bPickA);
    static UObject* SelectObject(UObject* A, UObject* B, bool bSelectA);
    static FRotator SelectRotator(FRotator A, FRotator B, bool bPickA);
    static FString SelectString(FString A, FString B, bool bPickA);
    static FTransform SelectTransform(const FTransform& A, const FTransform& B, bool bPickA);
    static FVector SelectVector(FVector A, FVector B, bool bPickA);
    static void Set2D(FVector2D& A, float X, float Y);
    static void SetRandomStreamSeed(FRandomStream& Stream, int32_t NewSeed);
    static float SignOfFloat(float A);
    static int32_t SignOfInteger(int32_t A);
    static int64_t SignOfInteger64(int64_t A);
    static float Sin(float A);
    static FVector Spherical2DToUnitCartesian(FVector2D A);
    static float Sqrt(float A);
    static float Square(float A);
    static uint8_t Subtract_ByteByte(uint8_t A, uint8_t B);
    static FTimespan Subtract_DateTimeDateTime(FDateTime A, FDateTime B);
    static FDateTime Subtract_DateTimeTimespan(FDateTime A, FTimespan B);
    static float Subtract_FloatFloat(float A, float B);
    static int64_t Subtract_Int64Int64(int64_t A, int64_t B);
    static int32_t Subtract_IntInt(int32_t A, int32_t B);
    static FIntPoint Subtract_IntPointInt(FIntPoint A, int32_t B);
    static FIntPoint Subtract_IntPointIntPoint(FIntPoint A, FIntPoint B);
    static FLinearColor Subtract_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    static FQuat Subtract_QuatQuat(const FQuat& A, const FQuat& B);
    static FTimespan Subtract_TimespanTimespan(FTimespan A, FTimespan B);
    static FVector2D Subtract_Vector2DFloat(FVector2D A, float B);
    static FVector2D Subtract_Vector2DVector2D(FVector2D A, FVector2D B);
    static FVector4 Subtract_Vector4Vector4(const FVector4& A, const FVector4& B);
    static FVector Subtract_VectorFloat(FVector A, float B);
    static FVector Subtract_VectorInt(FVector A, int32_t B);
    static FVector Subtract_VectorVector(FVector A, FVector B);
    static FTransform TEase(const FTransform& A, const FTransform& B, float Alpha, uint8_t EasingFunc, float BlendExp, int32_t Steps);
    static FTransform TInterpTo(const FTransform& Current, const FTransform& Target, float DeltaTime, float InterpSpeed);
    static FTransform TLerp(const FTransform& A, const FTransform& B, float Alpha, uint8_t InterpMode);
    static float Tan(float A);
    static bool TimespanFromString(FString TimespanString, FTimespan& Result);
    static FTimespan TimespanMaxValue();
    static FTimespan TimespanMinValue();
    static float TimespanRatio(FTimespan A, FTimespan B);
    static FTimespan TimespanZeroValue();
    static void ToDirectionAndLength2D(FVector2D A, FVector2D& OutDir, float& OutLength);
    static FVector2D ToRounded2D(FVector2D A);
    static FVector2D ToSign2D(FVector2D A);
    static FDateTime Today();
    static FVector TransformDirection(const FTransform& T, FVector Direction);
    static FVector TransformLocation(const FTransform& T, FVector Location);
    static FRotator TransformRotation(const FTransform& T, FRotator Rotation);
    static FVector4 TransformVector4(const FMatrix& Matrix, const FVector4& Vec4);
    static float Transform_Determinant(const FTransform& Transform);
    static FDateTime UtcNow();
    static FVector VEase(FVector A, FVector B, float Alpha, uint8_t EasingFunc, float BlendExp, int32_t Steps);
    static FVector VInterpTo(FVector Current, FVector Target, float DeltaTime, float InterpSpeed);
    static FVector VInterpTo_Constant(FVector Current, FVector Target, float DeltaTime, float InterpSpeed);
    static FVector VLerp(FVector A, FVector B, float Alpha);
    static float VSize(FVector A);
    static float VSize2D(FVector2D A);
    static float VSize2DSquared(FVector2D A);
    static float VSizeSquared(FVector A);
    static float VSizeXY(FVector A);
    static float VSizeXYSquared(FVector A);
    static FVector2D Vector2DInterpTo(FVector2D Current, FVector2D Target, float DeltaTime, float InterpSpeed);
    static FVector2D Vector2DInterpTo_Constant(FVector2D Current, FVector2D Target, float DeltaTime, float InterpSpeed);
    static FVector2D Vector2D_One();
    static FVector2D Vector2D_Unit45Deg();
    static FVector2D Vector2D_Zero();
    static void Vector4_Assign(FVector4& A, const FVector4& InVector);
    static FVector4 Vector4_CrossProduct3(const FVector4& A, const FVector4& B);
    static float Vector4_DotProduct(const FVector4& A, const FVector4& B);
    static float Vector4_DotProduct3(const FVector4& A, const FVector4& B);
    static bool Vector4_IsNAN(const FVector4& A);
    static bool Vector4_IsNearlyZero3(const FVector4& A, float Tolerance);
    static bool Vector4_IsNormal3(const FVector4& A);
    static bool Vector4_IsUnit3(const FVector4& A, float SquaredLenthTolerance);
    static bool Vector4_IsZero(const FVector4& A);
    static FVector4 Vector4_MirrorByVector3(const FVector4& Direction, const FVector4& SurfaceNormal);
    static FVector4 Vector4_Negated(const FVector4& A);
    static FVector4 Vector4_Normal3(const FVector4& A, float Tolerance);
    static FVector4 Vector4_NormalUnsafe3(const FVector4& A);
    static void Vector4_Normalize3(FVector4& A, float Tolerance);
    static void Vector4_Set(FVector4& A, float X, float Y, float Z, float W);
    static float Vector4_Size(const FVector4& A);
    static float Vector4_Size3(const FVector4& A);
    static float Vector4_SizeSquared(const FVector4& A);
    static float Vector4_SizeSquared3(const FVector4& A);
    static FVector4 Vector4_Zero();
    static FVector VectorSpringInterp(FVector Current, FVector Target, FVectorSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass);
    static void Vector_AddBounded(FVector& A, FVector InAddVect, float InRadius);
    static void Vector_Assign(FVector& A, const FVector& InVector);
    static FVector Vector_Backward();
    static FVector Vector_BoundedToBox(FVector InVect, FVector InBoxMin, FVector InBoxMax);
    static FVector Vector_BoundedToCube(FVector InVect, float InRadius);
    static FVector Vector_ClampSize2D(FVector A, float Min, float Max);
    static FVector Vector_ClampSizeMax(FVector A, float Max);
    static FVector Vector_ClampSizeMax2D(FVector A, float Max);
    static FVector Vector_ComponentMax(FVector A, FVector B);
    static FVector Vector_ComponentMin(FVector A, FVector B);
    static float Vector_CosineAngle2D(FVector A, FVector B);
    static float Vector_Distance(FVector v1, FVector v2);
    static float Vector_Distance2D(FVector v1, FVector v2);
    static float Vector_Distance2DSquared(FVector v1, FVector v2);
    static float Vector_DistanceSquared(FVector v1, FVector v2);
    static FVector Vector_Down();
    static FVector Vector_Forward();
    static FVector Vector_GetAbs(FVector A);
    static float Vector_GetAbsMax(FVector A);
    static float Vector_GetAbsMin(FVector A);
    static FVector Vector_GetProjection(FVector A);
    static FVector Vector_GetSignVector(FVector A);
    static float Vector_HeadingAngle(FVector A);
    static bool Vector_IsNAN(const FVector& A);
    static bool Vector_IsNearlyZero(const FVector& A, float Tolerance);
    static bool Vector_IsNormal(const FVector& A);
    static bool Vector_IsUniform(const FVector& A, float Tolerance);
    static bool Vector_IsUnit(const FVector& A, float SquaredLenthTolerance);
    static bool Vector_IsZero(const FVector& A);
    static FVector Vector_Left();
    static FVector Vector_MirrorByPlane(FVector A, const FPlane& InPlane);
    static FVector Vector_Normal2D(FVector A, float Tolerance);
    static FVector Vector_NormalUnsafe(const FVector& A);
    static void Vector_Normalize(FVector& A, float Tolerance);
    static FVector Vector_One();
    static FVector Vector_ProjectOnToNormal(FVector V, FVector InNormal);
    static FVector Vector_Reciprocal(const FVector& A);
    static FVector Vector_Right();
    static void Vector_Set(FVector& A, float X, float Y, float Z);
    static FVector Vector_SnappedToGrid(FVector InVect, float InGridSize);
    static FVector Vector_ToDegrees(FVector A);
    static FVector Vector_ToRadians(FVector A);
    static FVector2D Vector_UnitCartesianToSpherical(FVector A);
    static void Vector_UnwindEuler(FVector& A);
    static FVector Vector_Up();
    static FVector Vector_Zero();
    static FRotator WeightedMovingAverage_FRotator(FRotator CurrentSample, FRotator PreviousSample, float Weight);
    static FVector WeightedMovingAverage_FVector(FVector CurrentSample, FVector PreviousSample, float Weight);
    static float WeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float Weight);
    static int32_t Wrap(int32_t Value, int32_t Min, int32_t Max);
    static int64_t Xor_Int64Int64(int64_t A, int64_t B);
    static int32_t Xor_IntInt(int32_t A, int32_t B);
};

// Size: 0x30
class UKismetNodeHelperLibrary : public UBlueprintFunctionLibrary {

    static bool BitIsMarked(int32_t Data, int32_t index);
    static void ClearAllBits(int32_t& Data);
    static void ClearBit(int32_t& Data, int32_t index);
    static FName GetEnumeratorName(const UEnum* Enum, uint8_t EnumeratorValue);
    static FString GetEnumeratorUserFriendlyName(const UEnum* Enum, uint8_t EnumeratorValue);
    static uint8_t GetEnumeratorValueFromIndex(const UEnum* Enum, uint8_t EnumeratorIndex);
    static int32_t GetFirstUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits);
    static int32_t GetRandomUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits);
    static int32_t GetUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits, bool bRandom);
    static uint8_t GetValidValue(const UEnum* Enum, uint8_t EnumeratorValue);
    static bool HasMarkedBit(int32_t Data, int32_t NumBits);
    static bool HasUnmarkedBit(int32_t Data, int32_t NumBits);
    static void MarkBit(int32_t& Data, int32_t index);
};

// Size: 0x30
class UKismetRenderingLibrary : public UBlueprintFunctionLibrary {

    static void BeginDrawCanvasToRenderTarget(UObject* WorldContextObject, UTextureRenderTarget2D* TextureRenderTarget, UCanvas*& Canvas, FVector2D& Size, FDrawToRenderTargetContext& Context);
    static void BreakSkinWeightInfo(FSkelMeshSkinWeightInfo InWeight, int32_t& Bone0, uint8_t& Weight0, int32_t& Bone1, uint8_t& Weight1, int32_t& Bone2, uint8_t& Weight2, int32_t& Bone3, uint8_t& Weight3);
    static void ClearRenderTarget2D(UObject* WorldContextObject, UTextureRenderTarget2D* TextureRenderTarget, FLinearColor ClearColor);
    static void ConvertRenderTargetToTexture2DEditorOnly(UObject* WorldContextObject, UTextureRenderTarget2D* RenderTarget, UTexture2D* Texture);
    static UTextureRenderTarget2D* CreateRenderTarget2D(UObject* WorldContextObject, int32_t Width, int32_t Height, uint8_t Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps);
    static UTextureRenderTarget2DArray* CreateRenderTarget2DArray(UObject* WorldContextObject, int32_t Width, int32_t Height, int32_t Slices, uint8_t Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps);
    static UTextureRenderTargetVolume* CreateRenderTargetVolume(UObject* WorldContextObject, int32_t Width, int32_t Height, int32_t Depth, uint8_t Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps);
    static void DrawMaterialToRenderTarget(UObject* WorldContextObject, UTextureRenderTarget2D* TextureRenderTarget, UMaterialInterface* Material);
    static void EndDrawCanvasToRenderTarget(UObject* WorldContextObject, const FDrawToRenderTargetContext& Context);
    static void ExportRenderTarget(UObject* WorldContextObject, UTextureRenderTarget2D* TextureRenderTarget, FString FilePath, FString Filename);
    static void ExportTexture2D(UObject* WorldContextObject, UTexture2D* Texture, FString FilePath, FString Filename);
    static UTexture2D* ImportBufferAsTexture2D(UObject* WorldContextObject, const TArray<uint8_t>& Buffer);
    static UTexture2D* ImportFileAsTexture2D(UObject* WorldContextObject, FString Filename);
    static FSkelMeshSkinWeightInfo MakeSkinWeightInfo(int32_t Bone0, uint8_t Weight0, int32_t Bone1, uint8_t Weight1, int32_t Bone2, uint8_t Weight2, int32_t Bone3, uint8_t Weight3);
    static FColor ReadRenderTargetPixel(UObject* WorldContextObject, UTextureRenderTarget2D* TextureRenderTarget, int32_t X, int32_t Y);
    static FLinearColor ReadRenderTargetRawPixel(UObject* WorldContextObject, UTextureRenderTarget2D* TextureRenderTarget, int32_t X, int32_t Y);
    static FLinearColor ReadRenderTargetRawUV(UObject* WorldContextObject, UTextureRenderTarget2D* TextureRenderTarget, float U, float V);
    static FColor ReadRenderTargetUV(UObject* WorldContextObject, UTextureRenderTarget2D* TextureRenderTarget, float U, float V);
    static void ReleaseRenderTarget2D(UTextureRenderTarget2D* TextureRenderTarget);
    static UTexture2D* RenderTargetCreateStaticTexture2DEditorOnly(UTextureRenderTarget2D* RenderTarget, FString Name, uint8_t CompressionSettings, uint8_t MipSettings);
    static void SetCastInsetShadowForAllAttachments(UPrimitiveComponent* PrimitiveComponent, bool bCastInsetShadow, bool bLightAttachmentsAsGroup);
};

// Size: 0x30
class UKismetStringLibrary : public UBlueprintFunctionLibrary {

    static FString BuildString_Bool(FString AppendTo, FString Prefix, bool InBool, FString Suffix);
    static FString BuildString_Color(FString AppendTo, FString Prefix, FLinearColor InColor, FString Suffix);
    static FString BuildString_Float(FString AppendTo, FString Prefix, float InFloat, FString Suffix);
    static FString BuildString_Int(FString AppendTo, FString Prefix, int32_t inInt, FString Suffix);
    static FString BuildString_IntVector(FString AppendTo, FString Prefix, FIntVector InIntVector, FString Suffix);
    static FString BuildString_Name(FString AppendTo, FString Prefix, FName InName, FString Suffix);
    static FString BuildString_Object(FString AppendTo, FString Prefix, UObject* InObj, FString Suffix);
    static FString BuildString_Rotator(FString AppendTo, FString Prefix, FRotator InRot, FString Suffix);
    static FString BuildString_Vector(FString AppendTo, FString Prefix, FVector InVector, FString Suffix);
    static FString BuildString_Vector2d(FString AppendTo, FString Prefix, FVector2D InVector2D, FString Suffix);
    static FString Concat_StrStr(FString A, FString B);
    static bool Contains(FString SearchIn, FString Substring, bool bUseCase, bool bSearchFromEnd);
    static FString Conv_BoolToString(bool InBool);
    static FString Conv_ByteToString(uint8_t InByte);
    static FString Conv_ColorToString(FLinearColor InColor);
    static FString Conv_FloatToString(float InFloat);
    static FString Conv_IntPointToString(FIntPoint InIntPoint);
    static FString Conv_IntToString(int32_t inInt);
    static FString Conv_IntVectorToString(FIntVector InIntVec);
    static FString Conv_MatrixToString(const FMatrix& InMatrix);
    static FString Conv_NameToString(FName InName);
    static FString Conv_ObjectToString(UObject* InObj);
    static FString Conv_RotatorToString(FRotator InRot);
    static void Conv_StringToColor(FString inString, FLinearColor& OutConvertedColor, bool& OutIsValid);
    static float Conv_StringToFloat(FString inString);
    static int32_t Conv_StringToInt(FString inString);
    static FName Conv_StringToName(FString inString);
    static void Conv_StringToRotator(FString inString, FRotator& OutConvertedRotator, bool& OutIsValid);
    static void Conv_StringToVector(FString inString, FVector& OutConvertedVector, bool& OutIsValid);
    static void Conv_StringToVector2D(FString inString, FVector2D& OutConvertedVector2D, bool& OutIsValid);
    static FString Conv_TransformToString(const FTransform& InTrans);
    static FString Conv_Vector2dToString(FVector2D InVec);
    static FString Conv_VectorToString(FVector InVec);
    static int32_t CullArray(FString SourceString, TArray<FString>& inArray);
    static bool EndsWith(FString SourceString, FString InSuffix, uint8_t SearchCase);
    static bool EqualEqual_StrStr(FString A, FString B);
    static bool EqualEqual_StriStri(FString A, FString B);
    static int32_t FindSubstring(FString SearchIn, FString Substring, bool bUseCase, bool bSearchFromEnd, int32_t StartPosition);
    static TArray<FString> GetCharacterArrayFromString(FString SourceString);
    static int32_t GetCharacterAsNumber(FString SourceString, int32_t index);
    static FString GetSubstring(FString SourceString, int32_t StartIndex, int32_t Length);
    static bool IsEmpty(FString inString);
    static bool IsNumeric(FString SourceString);
    static FString JoinStringArray(const TArray<FString>& SourceArray, FString Separator);
    static FString Left(FString SourceString, int32_t Count);
    static FString LeftChop(FString SourceString, int32_t Count);
    static FString LeftPad(FString SourceString, int32_t ChCount);
    static int32_t Len(FString S);
    static bool MatchesWildcard(FString SourceString, FString wildcard, uint8_t SearchCase);
    static FString Mid(FString SourceString, int32_t Start, int32_t Count);
    static bool NotEqual_StrStr(FString A, FString B);
    static bool NotEqual_StriStri(FString A, FString B);
    static TArray<FString> ParseIntoArray(FString SourceString, FString Delimiter, const bool CullEmptyStrings);
    static FString Replace(FString SourceString, FString From, FString To, uint8_t SearchCase);
    static int32_t ReplaceInline(FString& SourceString, FString SearchText, FString ReplacementText, uint8_t SearchCase);
    static FString Reverse(FString SourceString);
    static FString Right(FString SourceString, int32_t Count);
    static FString RightChop(FString SourceString, int32_t Count);
    static FString RightPad(FString SourceString, int32_t ChCount);
    static bool Split(FString SourceString, FString InStr, FString& LeftS, FString& RightS, uint8_t SearchCase, uint8_t SearchDir);
    static bool StartsWith(FString SourceString, FString InPrefix, uint8_t SearchCase);
    static FString TimeSecondsToString(float InSeconds);
    static FString ToLower(FString SourceString);
    static FString ToUpper(FString SourceString);
    static FString Trim(FString SourceString);
    static FString TrimTrailing(FString SourceString);
};

// Size: 0x30
class UKismetStringTableLibrary : public UBlueprintFunctionLibrary {

    static TArray<FString> GetKeysFromStringTable(const FName TableId);
    static TArray<FName> GetMetaDataIdsFromStringTableEntry(const FName TableId, FString Key);
    static TArray<FName> GetRegisteredStringTables();
    static FString GetTableEntryMetaData(const FName TableId, FString Key, const FName MetaDataId);
    static FString GetTableEntrySourceString(const FName TableId, FString Key);
    static FString GetTableNamespace(const FName TableId);
    static bool IsRegisteredTableEntry(const FName TableId, FString Key);
    static bool IsRegisteredTableId(const FName TableId);
};

// Size: 0x30
class UKismetSystemLibrary : public UBlueprintFunctionLibrary {

    static FDebugFloatHistory AddFloatHistorySample(float Value, const FDebugFloatHistory& FloatHistory);
    static int32_t BeginTransaction(FString Context, FText Description, UObject* PrimaryObject);
    static bool BoxOverlapActors(const UObject* WorldContextObject, const FVector BoxPos, FVector BoxExtent, const TArray<uint8_t>& ObjectTypes, UClass* ActorClassFilter, const TArray<AActor*>& ActorsToIgnore, TArray<AActor*>& OutActors);
    static bool BoxOverlapComponents(const UObject* WorldContextObject, const FVector BoxPos, FVector Extent, const TArray<uint8_t>& ObjectTypes, UClass* ComponentClassFilter, const TArray<AActor*>& ActorsToIgnore, TArray<UPrimitiveComponent*>& OutComponents);
    static bool BoxTraceMulti(const UObject* WorldContextObject, const FVector Start, const FVector End, FVector HalfSize, const FRotator Orientation, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool BoxTraceMultiByProfile(const UObject* WorldContextObject, const FVector Start, const FVector End, FVector HalfSize, const FRotator Orientation, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool BoxTraceMultiForObjects(const UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool BoxTraceSingle(const UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool BoxTraceSingleByProfile(const UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool BoxTraceSingleForObjects(const UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static void BreakSoftClassPath(FSoftClassPath InSoftClassPath, FString& PathString);
    static void BreakSoftObjectPath(FSoftObjectPath InSoftObjectPath, FString& PathString);
    static bool CanLaunchURL(FString URL);
    static void CancelTransaction(const int32_t index);
    static bool CapsuleOverlapActors(const UObject* WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, const TArray<uint8_t>& ObjectTypes, UClass* ActorClassFilter, const TArray<AActor*>& ActorsToIgnore, TArray<AActor*>& OutActors);
    static bool CapsuleOverlapComponents(const UObject* WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, const TArray<uint8_t>& ObjectTypes, UClass* ComponentClassFilter, const TArray<AActor*>& ActorsToIgnore, TArray<UPrimitiveComponent*>& OutComponents);
    static bool CapsuleTraceMulti(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool CapsuleTraceMultiByProfile(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool CapsuleTraceMultiForObjects(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool CapsuleTraceSingle(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool CapsuleTraceSingleByProfile(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool CapsuleTraceSingleForObjects(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static void CollectGarbage();
    static bool ComponentOverlapActors(UPrimitiveComponent* Component, const FTransform& ComponentTransform, const TArray<uint8_t>& ObjectTypes, UClass* ActorClassFilter, const TArray<AActor*>& ActorsToIgnore, TArray<AActor*>& OutActors);
    static bool ComponentOverlapComponents(UPrimitiveComponent* Component, const FTransform& ComponentTransform, const TArray<uint8_t>& ObjectTypes, UClass* ComponentClassFilter, const TArray<AActor*>& ActorsToIgnore, TArray<UPrimitiveComponent*>& OutComponents);
    static void ControlScreensaver(bool bAllowScreenSaver);
    static TSoftClassPtr<UObject> Conv_ClassToSoftClassReference(const UClass*& Class);
    static UObject* Conv_InterfaceToObject(const TScriptInterface<UInterface>& Interface);
    static TSoftObjectPtr<UObject> Conv_ObjectToSoftObjectReference(UObject* Object);
    static FString Conv_PrimaryAssetIdToString(FPrimaryAssetId PrimaryAssetId);
    static FString Conv_PrimaryAssetTypeToString(FPrimaryAssetType PrimaryAssetType);
    static TSoftClassPtr<UObject> Conv_SoftClassPathToSoftClassRef(const FSoftClassPath& SoftClassPath);
    static UClass* Conv_SoftClassReferenceToClass(const TSoftClassPtr<UObject>& softclass);
    static FString Conv_SoftClassReferenceToString(const TSoftClassPtr<UObject>& SoftClassReference);
    static TSoftObjectPtr<UObject> Conv_SoftObjPathToSoftObjRef(const FSoftObjectPath& SoftObjectPath);
    static UObject* Conv_SoftObjectReferenceToObject(const TSoftObjectPtr<UObject>& softobject);
    static FString Conv_SoftObjectReferenceToString(const TSoftObjectPtr<UObject>& SoftObjectReference);
    static FString ConvertToAbsolutePath(FString Filename);
    static FString ConvertToRelativePath(FString Filename);
    static void CreateCopyForUndoBuffer(UObject* ObjectToModify);
    static void Delay(const UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo);
    static bool DoesImplementInterface(const UObject* TestObject, UClass* Interface);
    static void DrawDebugArrow(const UObject* WorldContextObject, const FVector LineStart, const FVector LineEnd, float ArrowSize, FLinearColor LineColor, float Duration, float Thickness);
    static void DrawDebugBox(const UObject* WorldContextObject, const FVector Center, FVector Extent, FLinearColor LineColor, const FRotator Rotation, float Duration, float Thickness);
    static void DrawDebugCamera(const ACameraActor* CameraActor, FLinearColor CameraColor, float Duration);
    static void DrawDebugCapsule(const UObject* WorldContextObject, const FVector Center, float HalfHeight, float Radius, const FRotator Rotation, FLinearColor LineColor, float Duration, float Thickness);
    static void DrawDebugCircle(const UObject* WorldContextObject, FVector Center, float Radius, int32_t NumSegments, FLinearColor LineColor, float Duration, float Thickness, FVector YAxis, FVector ZAxis, bool bDrawAxis);
    static void DrawDebugCone(const UObject* WorldContextObject, const FVector Origin, const FVector Direction, float Length, float AngleWidth, float AngleHeight, int32_t NumSides, FLinearColor LineColor, float Duration, float Thickness);
    static void DrawDebugConeInDegrees(const UObject* WorldContextObject, const FVector Origin, const FVector Direction, float Length, float AngleWidth, float AngleHeight, int32_t NumSides, FLinearColor LineColor, float Duration, float Thickness);
    static void DrawDebugCoordinateSystem(const UObject* WorldContextObject, const FVector AxisLoc, const FRotator AxisRot, float Scale, float Duration, float Thickness);
    static void DrawDebugCylinder(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, int32_t Segments, FLinearColor LineColor, float Duration, float Thickness);
    static void DrawDebugFloatHistoryLocation(const UObject* WorldContextObject, const FDebugFloatHistory& FloatHistory, FVector DrawLocation, FVector2D DrawSize, FLinearColor DrawColor, float Duration);
    static void DrawDebugFloatHistoryTransform(const UObject* WorldContextObject, const FDebugFloatHistory& FloatHistory, const FTransform& DrawTransform, FVector2D DrawSize, FLinearColor DrawColor, float Duration);
    static void DrawDebugFrustum(const UObject* WorldContextObject, const FTransform& FrustumTransform, FLinearColor FrustumColor, float Duration, float Thickness);
    static void DrawDebugLine(const UObject* WorldContextObject, const FVector LineStart, const FVector LineEnd, FLinearColor LineColor, float Duration, float Thickness);
    static void DrawDebugPlane(const UObject* WorldContextObject, const FPlane& PlaneCoordinates, const FVector Location, float Size, FLinearColor PlaneColor, float Duration);
    static void DrawDebugPoint(const UObject* WorldContextObject, const FVector Position, float Size, FLinearColor PointColor, float Duration);
    static void DrawDebugSphere(const UObject* WorldContextObject, const FVector Center, float Radius, int32_t Segments, FLinearColor LineColor, float Duration, float Thickness);
    static void DrawDebugString(const UObject* WorldContextObject, const FVector TextLocation, FString text, AActor* TestBaseActor, FLinearColor TextColor, float Duration);
    static int32_t EndTransaction();
    static bool EqualEqual_PrimaryAssetId(FPrimaryAssetId A, FPrimaryAssetId B);
    static bool EqualEqual_PrimaryAssetType(FPrimaryAssetType A, FPrimaryAssetType B);
    static bool EqualEqual_SoftClassReference(const TSoftClassPtr<UObject>& A, const TSoftClassPtr<UObject>& B);
    static bool EqualEqual_SoftObjectReference(const TSoftObjectPtr<UObject>& A, const TSoftObjectPtr<UObject>& B);
    static void ExecuteConsoleCommand(const UObject* WorldContextObject, FString Command, APlayerController* SpecificPlayer);
    static void FlushDebugStrings(const UObject* WorldContextObject);
    static void FlushPersistentDebugLines(const UObject* WorldContextObject);
    static void ForceCloseAdBanner();
    static void GetActorBounds(const AActor* Actor, FVector& Origin, FVector& BoxExtent);
    static void GetActorListFromComponentList(const TArray<UPrimitiveComponent*>& ComponentList, UClass* ActorClassFilter, TArray<AActor*>& OutActorList);
    static int32_t GetAdIDCount();
    static FString GetClassDisplayName(UClass* Class);
    static UClass* GetClassFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    static FString GetCommandLine();
    static void GetComponentBounds(const USceneComponent* Component, FVector& Origin, FVector& BoxExtent, float& SphereRadius);
    static bool GetConsoleVariableBoolValue(FString VariableName);
    static float GetConsoleVariableFloatValue(FString VariableName);
    static int32_t GetConsoleVariableIntValue(FString VariableName);
    static bool GetConvenientWindowedResolutions(TArray<FIntPoint>& Resolutions);
    static bool GetCurrentBundleState(FPrimaryAssetId PrimaryAssetId, bool bForceCurrentState, TArray<FName>& OutBundles);
    static FString GetDefaultLanguage();
    static FString GetDefaultLocale();
    static FString GetDeviceId();
    static FString GetDisplayName(const UObject* Object);
    static bool GetEditorProperty(UObject* Object, const FName PropertyName, int32_t& PropertyValue);
    static FString GetEngineVersion();
    static int64_t GetFrameCount();
    static FString GetGameBundleId();
    static FString GetGameName();
    static float GetGameTimeInSeconds(const UObject* WorldContextObject);
    static UTexture2D* GetGamepadButtonGlyph(FString ButtonKey, int32_t ControllerIndex);
    static FString GetGamepadControllerName(int32_t ControllerId);
    static FString GetLocalCurrencyCode();
    static FString GetLocalCurrencySymbol();
    static int32_t GetMinYResolutionFor3DView();
    static int32_t GetMinYResolutionForUI();
    static UObject* GetObjectFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    static FString GetObjectName(const UObject* Object);
    static UObject* GetOuterObject(const UObject* Object);
    static FString GetPathName(const UObject* Object);
    static FString GetPlatformUserDir();
    static FString GetPlatformUserName();
    static TArray<FString> GetPreferredLanguages();
    static FPrimaryAssetId GetPrimaryAssetIdFromClass(UClass* Class);
    static FPrimaryAssetId GetPrimaryAssetIdFromObject(UObject* Object);
    static FPrimaryAssetId GetPrimaryAssetIdFromSoftClassReference(TSoftClassPtr<UObject> SoftClassReference);
    static FPrimaryAssetId GetPrimaryAssetIdFromSoftObjectReference(TSoftObjectPtr<UObject> SoftObjectReference);
    static void GetPrimaryAssetIdList(FPrimaryAssetType PrimaryAssetType, TArray<FPrimaryAssetId>& OutPrimaryAssetIdList);
    static void GetPrimaryAssetsWithBundleState(const TArray<FName>& RequiredBundles, const TArray<FName>& ExcludedBundles, const TArray<FPrimaryAssetType>& ValidTypes, bool bForceCurrentState, TArray<FPrimaryAssetId>& OutPrimaryAssetIdList);
    static FString GetProjectContentDirectory();
    static FString GetProjectDirectory();
    static FString GetProjectSavedDirectory();
    static int32_t GetRenderingDetailMode();
    static int32_t GetRenderingMaterialQualityLevel();
    static TSoftClassPtr<UObject> GetSoftClassReferenceFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    static TSoftObjectPtr<UObject> GetSoftObjectReferenceFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    static bool GetSupportedFullscreenResolutions(TArray<FIntPoint>& Resolutions);
    static FString GetSystemPath(const UObject* Object);
    static FString GetUniqueDeviceId();
    static bool GetVolumeButtonsHandledBySystem();
    static void HideAdBanner();
    static bool IsControllerAssignedToGamepad(int32_t ControllerId);
    static bool IsDedicatedServer(const UObject* WorldContextObject);
    static bool IsInterstitialAdAvailable();
    static bool IsInterstitialAdRequested();
    static bool IsLoggedIn(const APlayerController* SpecificPlayer);
    static bool IsPackagedForDistribution();
    static bool IsScreensaverEnabled();
    static bool IsServer(const UObject* WorldContextObject);
    static bool IsSplitScreen(const UObject* WorldContextObject);
    static bool IsStandalone(const UObject* WorldContextObject);
    static bool IsUnattended();
    static bool IsValid(const UObject* Object);
    static bool IsValidClass(UClass* Class);
    static bool IsValidPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    static bool IsValidPrimaryAssetType(FPrimaryAssetType PrimaryAssetType);
    static bool IsValidSoftClassReference(const TSoftClassPtr<UObject>& SoftClassReference);
    static bool IsValidSoftObjectReference(const TSoftObjectPtr<UObject>& SoftObjectReference);
    static void K2_ClearAndInvalidateTimerHandle(const UObject* WorldContextObject, FTimerHandle& Handle);
    static void K2_ClearTimer(UObject* Object, FString FunctionName);
    static void K2_ClearTimerDelegate(FDelegate delegate);
    static void K2_ClearTimerHandle(const UObject* WorldContextObject, FTimerHandle Handle);
    static float K2_GetTimerElapsedTime(UObject* Object, FString FunctionName);
    static float K2_GetTimerElapsedTimeDelegate(FDelegate delegate);
    static float K2_GetTimerElapsedTimeHandle(const UObject* WorldContextObject, FTimerHandle Handle);
    static float K2_GetTimerRemainingTime(UObject* Object, FString FunctionName);
    static float K2_GetTimerRemainingTimeDelegate(FDelegate delegate);
    static float K2_GetTimerRemainingTimeHandle(const UObject* WorldContextObject, FTimerHandle Handle);
    static FTimerHandle K2_InvalidateTimerHandle(FTimerHandle& Handle);
    static bool K2_IsTimerActive(UObject* Object, FString FunctionName);
    static bool K2_IsTimerActiveDelegate(FDelegate delegate);
    static bool K2_IsTimerActiveHandle(const UObject* WorldContextObject, FTimerHandle Handle);
    static bool K2_IsTimerPaused(UObject* Object, FString FunctionName);
    static bool K2_IsTimerPausedDelegate(FDelegate delegate);
    static bool K2_IsTimerPausedHandle(const UObject* WorldContextObject, FTimerHandle Handle);
    static bool K2_IsValidTimerHandle(FTimerHandle Handle);
    static void K2_PauseTimer(UObject* Object, FString FunctionName);
    static void K2_PauseTimerDelegate(FDelegate delegate);
    static void K2_PauseTimerHandle(const UObject* WorldContextObject, FTimerHandle Handle);
    static FTimerHandle K2_SetTimer(UObject* Object, FString FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
    static FTimerHandle K2_SetTimerDelegate(FDelegate delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
    static bool K2_TimerExists(UObject* Object, FString FunctionName);
    static bool K2_TimerExistsDelegate(FDelegate delegate);
    static bool K2_TimerExistsHandle(const UObject* WorldContextObject, FTimerHandle Handle);
    static void K2_UnPauseTimer(UObject* Object, FString FunctionName);
    static void K2_UnPauseTimerDelegate(FDelegate delegate);
    static void K2_UnPauseTimerHandle(const UObject* WorldContextObject, FTimerHandle Handle);
    static void LaunchURL(FString URL);
    static bool LineTraceMulti(const UObject* WorldContextObject, const FVector Start, const FVector End, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool LineTraceMultiByProfile(const UObject* WorldContextObject, const FVector Start, const FVector End, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool LineTraceMultiForObjects(const UObject* WorldContextObject, const FVector Start, const FVector End, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool LineTraceSingle(const UObject* WorldContextObject, const FVector Start, const FVector End, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool LineTraceSingleByProfile(const UObject* WorldContextObject, const FVector Start, const FVector End, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool LineTraceSingleForObjects(const UObject* WorldContextObject, const FVector Start, const FVector End, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static void LoadAsset(const UObject* WorldContextObject, TSoftObjectPtr<UObject> Asset, FDelegate OnLoaded, FLatentActionInfo LatentInfo);
    static void LoadAssetClass(const UObject* WorldContextObject, TSoftClassPtr<UObject> AssetClass, FDelegate OnLoaded, FLatentActionInfo LatentInfo);
    static UObject* LoadAsset_Blocking(TSoftObjectPtr<UObject> Asset);
    static UClass* LoadClassAsset_Blocking(TSoftClassPtr<UObject> AssetClass);
    static void LoadInterstitialAd(int32_t AdIdIndex);
    static bool MakeLiteralBool(bool Value);
    static uint8_t MakeLiteralByte(uint8_t Value);
    static float MakeLiteralFloat(float Value);
    static int32_t MakeLiteralInt(int32_t Value);
    static FName MakeLiteralName(FName Value);
    static FString MakeLiteralString(FString Value);
    static FText MakeLiteralText(FText Value);
    static FSoftClassPath MakeSoftClassPath(FString PathString);
    static FSoftObjectPath MakeSoftObjectPath(FString PathString);
    static void MoveComponentTo(USceneComponent* Component, FVector TargetRelativeLocation, FRotator TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, uint8_t MoveAction, FLatentActionInfo LatentInfo);
    static FString NormalizeFilename(FString InFilename);
    static bool NotEqual_PrimaryAssetId(FPrimaryAssetId A, FPrimaryAssetId B);
    static bool NotEqual_PrimaryAssetType(FPrimaryAssetType A, FPrimaryAssetType B);
    static bool NotEqual_SoftClassReference(const TSoftClassPtr<UObject>& A, const TSoftClassPtr<UObject>& B);
    static bool NotEqual_SoftObjectReference(const TSoftObjectPtr<UObject>& A, const TSoftObjectPtr<UObject>& B);
    void OnAssetClassLoaded__DelegateSignature(UClass* Loaded);
    void OnAssetLoaded__DelegateSignature(UObject* Loaded);
    static void ParseCommandLine(FString InCmdLine, TArray<FString>& OutTokens, TArray<FString>& OutSwitches, TMap<FString, FString>& OutParams);
    static bool ParseParam(FString inString, FString InParam);
    static bool ParseParamValue(FString inString, FString InParam, FString& OutValue);
    static void PrintString(const UObject* WorldContextObject, FString inString, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration);
    static void PrintText(const UObject* WorldContextObject, const FText InText, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration);
    static void PrintWarning(FString inString);
    static void QuitEditor();
    static void QuitGame(const UObject* WorldContextObject, APlayerController* SpecificPlayer, uint8_t QuitPreference, bool bIgnorePlatformRestrictions);
    static void RegisterForRemoteNotifications();
    static void ResetGamepadAssignmentToController(int32_t ControllerId);
    static void ResetGamepadAssignments();
    static void RetriggerableDelay(const UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo);
    static void SetBoolPropertyByName(UObject* Object, FName PropertyName, bool Value);
    static void SetBytePropertyByName(UObject* Object, FName PropertyName, uint8_t Value);
    static void SetClassPropertyByName(UObject* Object, FName PropertyName, UClass* Value);
    static void SetCollisionProfileNameProperty(UObject* Object, FName PropertyName, const FCollisionProfileName& Value);
    static void SetColorPropertyByName(UObject* Object, FName PropertyName, const FColor& Value);
    static bool SetEditorProperty(UObject* Object, const FName PropertyName, const int32_t& PropertyValue, const EPropertyAccessChangeNotifyMode ChangeNotifyMode);
    static void SetFieldPathPropertyByName(UObject* Object, FName PropertyName, const FFieldPath& Value);
    static void SetFloatPropertyByName(UObject* Object, FName PropertyName, float Value);
    static void SetGamepadsBlockDeviceFeedback(bool bBlock);
    static void SetInt64PropertyByName(UObject* Object, FName PropertyName, int64_t Value);
    static void SetIntPropertyByName(UObject* Object, FName PropertyName, int32_t Value);
    static void SetInterfacePropertyByName(UObject* Object, FName PropertyName, const TScriptInterface<UInterface>& Value);
    static void SetLinearColorPropertyByName(UObject* Object, FName PropertyName, const FLinearColor& Value);
    static void SetNamePropertyByName(UObject* Object, FName PropertyName, const FName& Value);
    static void SetObjectPropertyByName(UObject* Object, FName PropertyName, UObject* Value);
    static void SetRotatorPropertyByName(UObject* Object, FName PropertyName, const FRotator& Value);
    static void SetSoftClassPropertyByName(UObject* Object, FName PropertyName, const TSoftClassPtr<UObject>& Value);
    static void SetSoftObjectPropertyByName(UObject* Object, FName PropertyName, const TSoftObjectPtr<UObject>& Value);
    static void SetStringPropertyByName(UObject* Object, FName PropertyName, FString Value);
    static void SetStructurePropertyByName(UObject* Object, FName PropertyName, const FGenericStruct& Value);
    static void SetSuppressViewportTransitionMessage(const UObject* WorldContextObject, bool bState);
    static void SetTextPropertyByName(UObject* Object, FName PropertyName, const FText& Value);
    static void SetTransformPropertyByName(UObject* Object, FName PropertyName, const FTransform& Value);
    static void SetUserActivity(const FUserActivity& UserActivity);
    static void SetVectorPropertyByName(UObject* Object, FName PropertyName, const FVector& Value);
    static void SetVolumeButtonsHandledBySystem(bool bEnabled);
    static void SetWindowTitle(const FText& Title);
    static void ShowAdBanner(int32_t AdIdIndex, bool bShowOnBottomOfScreen);
    static void ShowInterstitialAd();
    static void ShowPlatformSpecificAchievementsScreen(const APlayerController* SpecificPlayer);
    static void ShowPlatformSpecificLeaderboardScreen(FString CategoryName);
    static void SnapshotObject(UObject* Object);
    static bool SphereOverlapActors(const UObject* WorldContextObject, const FVector SpherePos, float SphereRadius, const TArray<uint8_t>& ObjectTypes, UClass* ActorClassFilter, const TArray<AActor*>& ActorsToIgnore, TArray<AActor*>& OutActors);
    static bool SphereOverlapComponents(const UObject* WorldContextObject, const FVector SpherePos, float SphereRadius, const TArray<uint8_t>& ObjectTypes, UClass* ComponentClassFilter, const TArray<AActor*>& ActorsToIgnore, TArray<UPrimitiveComponent*>& OutComponents);
    static bool SphereTraceMulti(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool SphereTraceMultiByProfile(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool SphereTraceMultiForObjects(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool SphereTraceSingle(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, uint8_t TraceChannel, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool SphereTraceSingleByProfile(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static bool SphereTraceSingleForObjects(const UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, uint8_t DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    static void StackTrace();
    static void TransactObject(UObject* Object);
    static void UnloadPrimaryAsset(FPrimaryAssetId PrimaryAssetId);
    static void UnloadPrimaryAssetList(const TArray<FPrimaryAssetId>& PrimaryAssetIdList);
    static void UnregisterForRemoteNotifications();
};

// Size: 0x30
class UKismetTextLibrary : public UBlueprintFunctionLibrary {

    static FText AsCurrencyBase(int32_t BaseValue, FString CurrencyCode);
    static FText AsCurrency_Float(float Value, uint8_t RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits, FString CurrencyCode);
    static FText AsCurrency_Integer(int32_t Value, uint8_t RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits, FString CurrencyCode);
    static FText AsDateTime_DateTime(const FDateTime& In);
    static FText AsDate_DateTime(const FDateTime& InDateTime);
    static FText AsPercent_Float(float Value, uint8_t RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits);
    static FText AsTimeZoneDateTime_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    static FText AsTimeZoneDate_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    static FText AsTimeZoneTime_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    static FText AsTime_DateTime(const FDateTime& In);
    static FText AsTimespan_Timespan(const FTimespan& InTimespan);
    static FText Conv_BoolToText(bool InBool);
    static FText Conv_ByteToText(uint8_t Value);
    static FText Conv_ColorToText(FLinearColor InColor);
    static FText Conv_FloatToText(float Value, uint8_t RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits);
    static FText Conv_Int64ToText(int64_t Value, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits);
    static FText Conv_IntToText(int32_t Value, bool bAlwaysSign, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits);
    static FText Conv_NameToText(FName InName);
    static FText Conv_ObjectToText(UObject* InObj);
    static FText Conv_RotatorToText(FRotator InRot);
    static FText Conv_StringToText(FString inString);
    static FString Conv_TextToString(const FText& InText);
    static FText Conv_TransformToText(const FTransform& InTrans);
    static FText Conv_Vector2dToText(FVector2D InVec);
    static FText Conv_VectorToText(FVector InVec);
    static bool EqualEqual_IgnoreCase_TextText(const FText& A, const FText& B);
    static bool EqualEqual_TextText(const FText& A, const FText& B);
    static bool FindTextInLocalizationTable(FString Namespace, FString Key, FText& OutText);
    static FText Format(FText InPattern, TArray<FFormatArgumentData> InArgs);
    static FText GetEmptyText();
    static void IsPolyglotDataValid(const FPolyglotTextData& PolyglotData, bool& IsValid, FText& ErrorMessage);
    static bool NotEqual_IgnoreCase_TextText(const FText& A, const FText& B);
    static bool NotEqual_TextText(const FText& A, const FText& B);
    static FText PolyglotDataToText(const FPolyglotTextData& PolyglotData);
    static bool StringTableIdAndKeyFromText(FText text, FName& OutTableId, FString& OutKey);
    static FText TextFromStringTable(const FName TableId, FString Key);
    static bool TextIsCultureInvariant(const FText& InText);
    static bool TextIsEmpty(const FText& InText);
    static bool TextIsFromStringTable(const FText& text);
    static bool TextIsTransient(const FText& InText);
    static FText TextToLower(const FText& InText);
    static FText TextToUpper(const FText& InText);
    static FText TextTrimPreceding(const FText& InText);
    static FText TextTrimPrecedingAndTrailing(const FText& InText);
    static FText TextTrimTrailing(const FText& InText);
};

// Size: 0x460
class ALODActor : public AActor {
    /* 0x02f8 */ UStaticMeshComponent* StaticMeshComponent;
    /* 0x0300 */ TMap<FHLODInstancingKey, UInstancedStaticMeshComponent*> InstancedStaticMeshComponents;
    /* 0x0350 */ UHLODProxy* Proxy;
    /* 0x0358 */ FName Key;
    /* 0x0364 */ float LODDrawDistance;
    /* 0x0368 */ int32_t LODLevel;
    /* 0x0370 */ TArray<AActor*> SubActors;
    /* 0x0380 */ uint8_t CachedNumHLODLevels;
    /* 0x0384 */ uint32_t NumTrianglesInSubActors;
    /* 0x0388 */ uint32_t NumTrianglesInMergedMesh;
    /* 0x038c */ bool bOverrideMaterialMergeSettings;
    /* 0x0390 */ FMaterialProxySettings MaterialSettings;
    /* 0x0418 */ bool bOverrideTransitionScreenSize;
    /* 0x041c */ float TransitionScreenSize;
    /* 0x0420 */ bool bOverrideScreenSize;
    /* 0x0424 */ int32_t ScreenSize;
    /* 0x0440 */ FString LODActorTag;
    /* 0x0450 */ bool bBuiltFromHLODDesc;
    /* 0x0458 */ UHLODProxyDesc* ProxyDesc;
};

// Size: 0x20
struct FLODMappingData {
    /* 0x0000 */ TArray<int32_t> Mapping;
    /* 0x0010 */ TArray<int32_t> InverseMapping;
};

// Size: 0x10
struct FLODSoloTrack {
    /* 0x0000 */ TArray<uint8_t> SoloEnableSetting;
};

// Size: 0x150
class ULODSyncComponent : public UActorComponent {
    /* 0x00c0 */ int32_t NumLODs;
    /* 0x00c4 */ int32_t ForcedLOD;
    /* 0x00c8 */ TArray<FComponentSync> ComponentsToSync;
    /* 0x00d8 */ TMap<FName, FLODMappingData> CustomLODMapping;
    /* 0x0128 */ int32_t CurrentLOD;
    /* 0x012c */ int32_t CurrentNumLODs;
    /* 0x0130 */ TArray<UPrimitiveComponent*> DriveComponents;
    /* 0x0140 */ TArray<UPrimitiveComponent*> SubComponents;

    FString GetLODSyncDebugText() const;
};

// Size: 0x30
class ILODSyncInterface : public UInterface {
};

// Size: 0x20
struct FLatentActionInfo {
    /* 0x0000 */ int32_t Linkage;
    /* 0x0004 */ int32_t UUID;
    /* 0x0008 */ FName ExecutionFunction;
    /* 0x0018 */ UObject* CallbackTarget;
};

// Size: 0x60
struct FLatentActionManager {
};

// Size: 0x20
struct FLaunchOnTestSettings {
    /* 0x0000 */ FFilePath LaunchOnTestmap;
    /* 0x0010 */ FString DeviceID;
};

// Size: 0x50
class ULayer : public UObject {
    /* 0x0030 */ FName LayerName;
    /* 0x003c */ bool bIsVisible;
    /* 0x0040 */ TArray<FLayerActorStats> ActorStats;
};

// Size: 0x10
struct FLayerActorStats {
    /* 0x0000 */ UClass* Type;
    /* 0x0008 */ int32_t Total;
};

// Size: 0xb8
struct FLensBloomSettings {
    /* 0x0000 */ FGaussianSumBloomSettings GaussianSum;
    /* 0x0088 */ FConvolutionBloomSettings Convolution;
    /* 0x00b0 */ uint8_t Method;
};

// Size: 0x20
struct FLensImperfectionSettings {
    /* 0x0000 */ UTexture* DirtMask;
    /* 0x0008 */ float DirtMaskIntensity;
    /* 0x000c */ FLinearColor DirtMaskTint;
};

// Size: 0xe0
struct FLensSettings {
    /* 0x0000 */ FLensBloomSettings Bloom;
    /* 0x00b8 */ FLensImperfectionSettings Imperfections;
    /* 0x00d8 */ float ChromaticAberration;
};

// Size: 0x7d0
class ULevel : public UObject {
    /* 0x00c0 */ UWorld* OwningWorld;
    /* 0x00c8 */ UModel* Model;
    /* 0x00d0 */ TArray<UModelComponent*> ModelComponents;
    /* 0x00e0 */ ULevelActorContainer* ActorCluster;
    /* 0x00e8 */ ULevelScriptBlueprint* LevelScriptBlueprint;
    /* 0x00f0 */ TArray<FGuid> TextureStreamingResourceGuids;
    /* 0x0100 */ int32_t NumTextureStreamingUnbuiltComponents;
    /* 0x0104 */ int32_t NumTextureStreamingDirtyResources;
    /* 0x0108 */ ALevelScriptActor* LevelScriptActor;
    /* 0x0110 */ ANavigationObjectBase* NavListStart;
    /* 0x0118 */ ANavigationObjectBase* NavListEnd;
    /* 0x0120 */ TArray<UNavigationDataChunk*> NavDataChunks;
    /* 0x0130 */ float LightmapTotalSize;
    /* 0x0134 */ float ShadowmapTotalSize;
    /* 0x0138 */ TArray<FVector> StaticNavigableGeometry;
    /* 0x0148 */ TArray<FGuid> StreamingTextureGuids;
    /* 0x01f0 */ FGuid LevelBuildDataId;
    /* 0x0200 */ UMapBuildDataRegistry* MapBuildData;
    /* 0x0208 */ FIntVector LightBuildLevelOffset;
    /* 0x0214 */ bool bIsLightingScenario;
    /* 0x0214 */ bool bTextureStreamingRotationChanged;
    /* 0x0214 */ bool bStaticComponentsRegisteredInStreamingManager;
    /* 0x0214 */ bool bIsVisible;
    /* 0x0214 */ bool bLocked;
    /* 0x0258 */ FLevelSimplificationDetails LevelSimplification[4];
    /* 0x0708 */ FLinearColor LevelColor;
    /* 0x0720 */ bool bLevelOkayForPlacementWhileCheckedIn;
    /* 0x0734 */ bool bUseExternalActors;
    /* 0x0750 */ AWorldSettings* WorldSettings;
    /* 0x0760 */ TArray<UAssetUserData*> AssetUserData;
    /* 0x0780 */ TArray<FReplicatedStaticActorDestructionInfo> DestroyedReplicatedStaticActors;
    /* 0x0790 */ TScriptInterface<ILevelPartitionInterface> LevelPartition;
    /* 0x07a0 */ TSoftObjectPtr<UObject> OwnerLevelPartition;
};

// Size: 0x40
class ULevelActorContainer : public UObject {
    /* 0x0030 */ TArray<AActor*> Actors;
};

// Size: 0x328
class ALevelBounds : public AActor {
    /* 0x0300 */ UBoxComponent* BoxComponent;
    /* 0x0308 */ bool bAutoUpdateBounds;
};

// Size: 0x78
struct FLevelCollection {
    /* 0x0008 */ AGameStateBase* GameState;
    /* 0x0010 */ UNetDriver* NetDriver;
    /* 0x0018 */ UDemoNetDriver* DemoNetDriver;
    /* 0x0020 */ ULevel* PersistentLevel;
    /* 0x0028 */ TSet<ULevel*> Levels;
};

// Size: 0x18
struct FLevelNameAndTime {
    /* 0x0000 */ FString LevelName;
    /* 0x0010 */ uint32_t LevelChangeTimeInMS;
};

// Size: 0x30
class ILevelPartitionInterface : public UInterface {
};

// Size: 0x300
class ALevelScriptActor : public AActor {
    /* 0x02f8 */ bool bInputEnabled;

    void LevelReset();
    bool RemoteEvent(FName EventName);
    void SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
    void WorldOriginLocationChanged(FIntVector OldOriginLocation, FIntVector NewOriginLocation);
};

// Size: 0x4e8
class ULevelScriptBlueprint : public UBlueprint {
    /* 0x04d8 */ FString FriendlyName;
};

// Size: 0x12c
struct FLevelSimplificationDetails {
    /* 0x0000 */ bool bCreatePackagePerAsset;
    /* 0x0004 */ float DetailsPercentage;
    /* 0x0008 */ FMaterialProxySettings StaticMeshMaterialSettings;
    /* 0x0090 */ bool bOverrideLandscapeExportLOD;
    /* 0x0094 */ int32_t LandscapeExportLOD;
    /* 0x0098 */ FMaterialProxySettings LandscapeMaterialSettings;
    /* 0x0120 */ bool bBakeFoliageToLandscape;
    /* 0x0121 */ bool bBakeGrassToLandscape;
    /* 0x0122 */ bool bGenerateMeshNormalMap;
    /* 0x0123 */ bool bGenerateMeshMetallicMap;
    /* 0x0124 */ bool bGenerateMeshRoughnessMap;
    /* 0x0125 */ bool bGenerateMeshSpecularMap;
    /* 0x0126 */ bool bGenerateLandscapeNormalMap;
    /* 0x0127 */ bool bGenerateLandscapeMetallicMap;
    /* 0x0128 */ bool bGenerateLandscapeRoughnessMap;
    /* 0x0129 */ bool bGenerateLandscapeSpecularMap;
};

// Size: 0x190
class ULevelStreaming : public UObject {
    /* 0x0030 */ FName PackageName;
    /* 0x0040 */ TSoftObjectPtr<UWorld> WorldAsset;
    /* 0x0070 */ FName PackageNameToLoad;
    /* 0x0080 */ TArray<FName> LODPackageNames;
    /* 0x00a0 */ FTransform LevelTransform;
    /* 0x00d0 */ int32_t LevelLODIndex;
    /* 0x00d4 */ int32_t StreamingPriority;
    /* 0x00da */ bool bShouldBeVisibleInEditor;
    /* 0x00da */ bool bShouldBeVisible;
    /* 0x00da */ bool bShouldBeLoaded;
    /* 0x00da */ bool bLocked;
    /* 0x00da */ bool bIsStatic;
    /* 0x00db */ bool bShouldBlockOnLoad;
    /* 0x00db */ bool bShouldBlockOnUnload;
    /* 0x00db */ bool bDisableDistanceStreaming;
    /* 0x00db */ bool bDrawOnLevelStatusMap;
    /* 0x00dc */ FColor DrawColor;
    /* 0x00e0 */ FLinearColor LevelColor;
    /* 0x00f0 */ TArray<ALevelStreamingVolume*> EditorStreamingVolumes;
    /* 0x0100 */ float MinTimeBetweenVolumeUnloadRequests;
    /* 0x0108 */ TArray<FString> Keywords;
    /* 0x0118 */ FMulticastInlineDelegate OnLevelLoaded;
    /* 0x0128 */ FMulticastInlineDelegate OnLevelUnloaded;
    /* 0x0138 */ FMulticastInlineDelegate OnLevelShown;
    /* 0x0148 */ FMulticastInlineDelegate OnLevelHidden;
    /* 0x0158 */ ULevel* LoadedLevel;
    /* 0x0160 */ ULevel* PendingUnloadLevel;
    /* 0x0168 */ FName FolderPath;

    ULevelStreaming* CreateInstance(FString UniqueInstanceName);
    bool GetIsRequestingUnloadAndRemoval() const;
    ALevelScriptActor* GetLevelScriptActor();
    ULevel* GetLoadedLevel() const;
    FName GetWorldAssetPackageFName() const;
    bool IsLevelLoaded() const;
    bool IsLevelVisible() const;
    bool IsStreamingStatePending() const;
    void SetIsRequestingUnloadAndRemoval(bool bInIsRequestingUnloadAndRemoval);
    void SetLevelLODIndex(int32_t LODIndex);
    void SetPriority(int32_t NewPriority);
    void SetShouldBeLoaded(bool bInShouldBeLoaded);
    void SetShouldBeVisible(bool bInShouldBeVisible);
    bool ShouldBeLoaded() const;
};

// Size: 0x190
class ULevelStreamingAlwaysLoaded : public ULevelStreaming {
};

// Size: 0x1a0
class ULevelStreamingDynamic : public ULevelStreaming {
    /* 0x0190 */ bool bInitiallyLoaded;
    /* 0x0190 */ bool bInitiallyVisible;

    static ULevelStreamingDynamic* LoadLevelInstance(UObject* WorldContextObject, FString LevelName, FVector Location, FRotator Rotation, bool& bOutSuccess, FString OptionalLevelNameOverride);
    static ULevelStreamingDynamic* LoadLevelInstanceBySoftObjectPtr(UObject* WorldContextObject, TSoftObjectPtr<UWorld> Level, FVector Location, FRotator Rotation, bool& bOutSuccess, FString OptionalLevelNameOverride);
};

// Size: 0x190
class ULevelStreamingPersistent : public ULevelStreaming {
};

// Size: 0x14
struct FLevelStreamingStatus {
    /* 0x0000 */ FName PackageName;
    /* 0x000c */ bool bShouldBeLoaded;
    /* 0x000c */ bool bShouldBeVisible;
    /* 0x0010 */ uint32_t LODIndex;
};

// Size: 0x350
class ALevelStreamingVolume : public AVolume {
    /* 0x0338 */ TArray<FName> StreamingLevelNames;
    /* 0x0348 */ bool bEditorPreVisOnly;
    /* 0x0348 */ bool bDisabled;
    /* 0x034c */ uint8_t StreamingUsage;
};

// Size: 0x20
struct FLevelViewportInfo {
    /* 0x0000 */ FVector CamPosition;
    /* 0x000c */ FRotator CamRotation;
    /* 0x0018 */ float CamOrthoZoom;
    /* 0x001c */ bool CamUpdated;
};

// Size: 0x308
class ALight : public AActor {
    /* 0x02f8 */ ULightComponent* LightComponent;
    /* 0x0300 */ bool bEnabled;

    float GetBrightness() const;
    FLinearColor GetLightColor() const;
    bool IsEnabled() const;
    void OnRep_bEnabled();
    void SetAffectTranslucentLighting(bool bNewValue);
    void SetBrightness(float NewBrightness);
    void SetCastShadows(bool bNewValue);
    void SetEnabled(bool bSetEnabled);
    void SetLightColor(FLinearColor NewLightColor);
    void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
    void SetLightFunctionMaterial(UMaterialInterface* NewLightFunctionMaterial);
    void SetLightFunctionScale(FVector NewLightFunctionScale);
    void ToggleEnabled();
};

// Size: 0x380
class ULightComponent : public ULightComponentBase {
    /* 0x0278 */ float Temperature;
    /* 0x027c */ float MaxDrawDistance;
    /* 0x0280 */ float MaxDistanceFadeRange;
    /* 0x0284 */ bool bUseTemperature;
    /* 0x0288 */ int32_t ShadowMapChannel;
    /* 0x0290 */ float MinRoughness;
    /* 0x0294 */ float SpecularScale;
    /* 0x0298 */ float ShadowResolutionScale;
    /* 0x029c */ float ShadowBias;
    /* 0x02a0 */ float ShadowSlopeBias;
    /* 0x02a4 */ float ShadowSharpen;
    /* 0x02a8 */ float ContactShadowLength;
    /* 0x02ac */ bool ContactShadowLengthInWS;
    /* 0x02ac */ bool InverseSquaredFalloff;
    /* 0x02ac */ bool CastTranslucentShadows;
    /* 0x02ac */ bool bCastShadowsFromCinematicObjectsOnly;
    /* 0x02ac */ bool bAffectDynamicIndirectLighting;
    /* 0x02ac */ bool bForceCachedShadowsForMovablePrimitives;
    /* 0x02b0 */ FLightingChannels LightingChannels;
    /* 0x02b8 */ UMaterialInterface* LightFunctionMaterial;
    /* 0x02c0 */ FVector LightFunctionScale;
    /* 0x02d0 */ UTextureLightProfile* IESTexture;
    /* 0x02d8 */ bool bUseIESBrightness;
    /* 0x02dc */ float IESBrightnessScale;
    /* 0x02e0 */ float LightFunctionFadeDistance;
    /* 0x02e4 */ float DisabledBrightness;
    /* 0x02e8 */ bool bEnableLightShaftBloom;
    /* 0x02ec */ float BloomScale;
    /* 0x02f0 */ float BloomThreshold;
    /* 0x02f4 */ float BloomMaxBrightness;
    /* 0x02f8 */ FColor BloomTint;
    /* 0x02fc */ bool bUseRayTracedDistanceFieldShadows;
    /* 0x0300 */ float RayStartOffsetDepthScale;

    void SetAffectDynamicIndirectLighting(bool bNewValue);
    void SetAffectTranslucentLighting(bool bNewValue);
    void SetBloomMaxBrightness(float NewValue);
    void SetBloomScale(float NewValue);
    void SetBloomThreshold(float NewValue);
    void SetBloomTint(FColor NewValue);
    void SetEnableLightShaftBloom(bool bNewValue);
    void SetForceCachedShadowsForMovablePrimitives(bool bNewValue);
    void SetIESBrightnessScale(float NewValue);
    void SetIESTexture(UTextureLightProfile* NewValue);
    void SetIndirectLightingIntensity(float NewIntensity);
    void SetIntensity(float NewIntensity);
    void SetLightColor(FLinearColor NewLightColor, bool bSRGB);
    void SetLightFunctionDisabledBrightness(float NewValue);
    void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
    void SetLightFunctionMaterial(UMaterialInterface* NewLightFunctionMaterial);
    void SetLightFunctionScale(FVector NewLightFunctionScale);
    void SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2);
    void SetShadowBias(float NewValue);
    void SetShadowSlopeBias(float NewValue);
    void SetSpecularScale(float NewValue);
    void SetTemperature(float NewTemperature);
    void SetTransmission(bool bNewValue);
    void SetUseIESBrightness(bool bNewValue);
    void SetUseTemperature(bool bNewValue);
    void SetVolumetricScatteringIntensity(float NewIntensity);
};

// Size: 0x280
class ULightComponentBase : public USceneComponent {
    /* 0x0228 */ FGuid LightGuid;
    /* 0x0238 */ float Brightness;
    /* 0x023c */ float Intensity;
    /* 0x0240 */ FColor LightColor;
    /* 0x0244 */ bool bAffectsWorld;
    /* 0x0244 */ bool CastShadows;
    /* 0x0244 */ bool CastStaticShadows;
    /* 0x0244 */ bool CastDynamicShadows;
    /* 0x0244 */ bool bAffectTranslucentLighting;
    /* 0x0244 */ bool bTransmission;
    /* 0x0244 */ bool bCastVolumetricShadow;
    /* 0x0244 */ bool bCastDeepShadow;
    /* 0x0245 */ bool bCastRaytracedShadow;
    /* 0x0245 */ bool bAffectReflection;
    /* 0x0245 */ bool bAffectGlobalIllumination;
    /* 0x0248 */ float DeepShadowLayerDistribution;
    /* 0x024c */ float IndirectLightingIntensity;
    /* 0x0250 */ float VolumetricScatteringIntensity;
    /* 0x0254 */ int32_t SamplesPerPixel;
    /* 0x0258 */ UTexture2D* StaticEditorTexture;
    /* 0x0260 */ float StaticEditorTextureScale;
    /* 0x0268 */ UTexture2D* DynamicEditorTexture;
    /* 0x0270 */ float DynamicEditorTextureScale;

    FLinearColor GetLightColor() const;
    void SetAffectGlobalIllumination(bool bNewValue);
    void SetAffectReflection(bool bNewValue);
    void SetCastDeepShadow(bool bNewValue);
    void SetCastRaytracedShadow(bool bNewValue);
    void SetCastShadows(bool bNewValue);
    void SetCastVolumetricShadow(bool bNewValue);
    void SetSamplesPerPixel(int32_t NewValue);
};

// Size: 0x420
class ULightMapTexture2D : public UTexture2D {
};

// Size: 0x30
class ULightMapVirtualTexture : public UVirtualTexture {
};

// Size: 0x430
class ULightMapVirtualTexture2D : public UTexture2D {
    /* 0x0410 */ TArray<int8_t> TypeToLayer;
};

// Size: 0x1
struct FLightingChannels {
    /* 0x0000 */ bool bChannel0;
    /* 0x0000 */ bool bChannel1;
    /* 0x0000 */ bool bChannel2;
};

// Size: 0x48
class ULightmappedSurfaceCollection : public UObject {
    /* 0x0030 */ UModel* SourceModel;
    /* 0x0038 */ TArray<int32_t> Surfaces;
};

// Size: 0x338
class ALightmassCharacterIndirectDetailVolume : public AVolume {
};

// Size: 0x10
struct FLightmassDebugOptions {
    /* 0x0000 */ bool bDebugMode;
    /* 0x0000 */ bool bStatsEnabled;
    /* 0x0000 */ bool bGatherBSPSurfacesAcrossComponents;
    /* 0x0004 */ float CoplanarTolerance;
    /* 0x0008 */ bool bUseImmediateImport;
    /* 0x0008 */ bool bImmediateProcessMappings;
    /* 0x0008 */ bool bSortMappings;
    /* 0x0008 */ bool bDumpBinaryFiles;
    /* 0x0008 */ bool bDebugMaterials;
    /* 0x0008 */ bool bPadMappings;
    /* 0x0008 */ bool bDebugPaddings;
    /* 0x0008 */ bool bOnlyCalcDebugTexelMappings;
    /* 0x0009 */ bool bUseRandomColors;
    /* 0x0009 */ bool bColorBordersGreen;
    /* 0x0009 */ bool bColorByExecutionTime;
    /* 0x000c */ float ExecutionTimeDivisor;
};

// Size: 0x10
struct FLightmassDirectionalLightSettings : public FLightmassLightSettings {
    /* 0x000c */ float LightSourceAngle;
};

// Size: 0x338
class ALightmassImportanceVolume : public AVolume {
};

// Size: 0xc
struct FLightmassLightSettings {
    /* 0x0000 */ float IndirectLightingSaturation;
    /* 0x0004 */ float ShadowExponent;
    /* 0x0008 */ bool bUseAreaShadowsForStationaryLight;
};

// Size: 0x10
struct FLightmassMaterialInterfaceSettings {
    /* 0x0000 */ float EmissiveBoost;
    /* 0x0004 */ float DiffuseBoost;
    /* 0x0008 */ float ExportResolutionScale;
    /* 0x000c */ bool bCastShadowAsMasked;
    /* 0x000c */ bool bOverrideCastShadowAsMasked;
    /* 0x000c */ bool bOverrideEmissiveBoost;
    /* 0x000c */ bool bOverrideDiffuseBoost;
    /* 0x000c */ bool bOverrideExportResolutionScale;
};

// Size: 0xc
struct FLightmassPointLightSettings : public FLightmassLightSettings {
};

// Size: 0x308
class ALightmassPortal : public AActor {
    /* 0x02f8 */ ULightmassPortalComponent* PortalComponent;
    /* 0x0300 */ UBillboardComponent* SpriteComponent;
};

// Size: 0x230
class ULightmassPortalComponent : public USceneComponent {
    /* 0x0228 */ UBoxComponent* PreviewBox;
};

// Size: 0x18
struct FLightmassPrimitiveSettings {
    /* 0x0000 */ bool bUseTwoSidedLighting;
    /* 0x0000 */ bool bShadowIndirectOnly;
    /* 0x0000 */ bool bUseEmissiveForStaticLighting;
    /* 0x0000 */ bool bUseVertexNormalForHemisphereGather;
    /* 0x0004 */ float EmissiveLightFalloffExponent;
    /* 0x0008 */ float EmissiveLightExplicitInfluenceRadius;
    /* 0x000c */ float EmissiveBoost;
    /* 0x0010 */ float DiffuseBoost;
    /* 0x0014 */ float FullyOccludedSamplesFraction;
};

// Size: 0x48
class ULightmassPrimitiveSettingsObject : public UObject {
    /* 0x0030 */ FLightmassPrimitiveSettings LightmassSettings;
};

// Size: 0x4c
struct FLightmassWorldInfoSettings {
    /* 0x0000 */ float StaticLightingLevelScale;
    /* 0x0004 */ int32_t NumIndirectLightingBounces;
    /* 0x0008 */ int32_t NumSkyLightingBounces;
    /* 0x000c */ float IndirectLightingQuality;
    /* 0x0010 */ float IndirectLightingSmoothness;
    /* 0x0014 */ FColor EnvironmentColor;
    /* 0x0018 */ float EnvironmentIntensity;
    /* 0x001c */ float EmissiveBoost;
    /* 0x0020 */ float DiffuseBoost;
    /* 0x0024 */ uint8_t VolumeLightingMethod;
    /* 0x0025 */ bool bUseAmbientOcclusion;
    /* 0x0025 */ bool bGenerateAmbientOcclusionMaterialMask;
    /* 0x0025 */ bool bVisualizeMaterialDiffuse;
    /* 0x0025 */ bool bVisualizeAmbientOcclusion;
    /* 0x0025 */ bool bCompressLightmaps;
    /* 0x0028 */ float VolumetricLightmapDetailCellSize;
    /* 0x002c */ float VolumetricLightmapMaximumBrickMemoryMb;
    /* 0x0030 */ float VolumetricLightmapSphericalHarmonicSmoothing;
    /* 0x0034 */ float VolumeLightSamplePlacementScale;
    /* 0x0038 */ float DirectIlluminationOcclusionFraction;
    /* 0x003c */ float IndirectIlluminationOcclusionFraction;
    /* 0x0040 */ float OcclusionExponent;
    /* 0x0044 */ float FullyOccludedSamplesFraction;
    /* 0x0048 */ float MaxOcclusionDistance;
};

// Size: 0x520
class ULineBatchComponent : public UPrimitiveComponent {
};

// Size: 0x1c
struct FLinearConstraint : public FConstraintBaseParams {
    /* 0x0014 */ float Limit;
    /* 0x0018 */ uint8_t XMotion;
    /* 0x0019 */ uint8_t YMotion;
    /* 0x001a */ uint8_t ZMotion;
};

// Size: 0x4c
struct FLinearDriveConstraint {
    /* 0x0000 */ FVector PositionTarget;
    /* 0x000c */ FVector VelocityTarget;
    /* 0x0018 */ FConstraintDrive XDrive;
    /* 0x0028 */ FConstraintDrive YDrive;
    /* 0x0038 */ FConstraintDrive ZDrive;
    /* 0x0048 */ bool bEnablePositionDrive;
};

// Size: 0x390
class ULocalLightComponent : public ULightComponent {
    /* 0x0378 */ ELightUnits IntensityUnits;
    /* 0x037c */ float Radius;
    /* 0x0380 */ float AttenuationRadius;
    /* 0x0384 */ FLightmassPointLightSettings LightmassSettings;

    static float GetUnitsConversionFactor(ELightUnits SrcUnits, ELightUnits TargetUnits, float CosHalfConeAngle);
    void SetAttenuationRadius(float NewRadius);
    void SetIntensityUnits(ELightUnits NewIntensityUnits);
};

// Size: 0x30
class ULocalMessage : public UObject {
};

// Size: 0x268
class ULocalPlayer : public UPlayer {
    /* 0x0078 */ UGameViewportClient* ViewportClient;
    /* 0x009c */ uint8_t AspectRatioAxisConstraint;
    /* 0x00a0 */ UClass* PendingLevelPlayerControllerClass;
    /* 0x00a8 */ bool bSentSplitJoin;
    /* 0x00c0 */ int32_t ControllerId;
};

// Size: 0x38
class ULocalPlayerSubsystem : public USubsystem {
};

// Size: 0x20
struct FLocalSpacePose {
    /* 0x0000 */ TArray<FTransform> Transforms;
    /* 0x0010 */ TArray<FName> Names;
};

// Size: 0x18
struct FLocationBoneSocketInfo {
    /* 0x0000 */ FName BoneSocketName;
    /* 0x000c */ FVector Offset;
};

// Size: 0x10
struct FMTDResult {
    /* 0x0000 */ FVector Direction;
    /* 0x000c */ float Distance;
};

// Size: 0x240
class UMapBuildDataRegistry : public UObject {
    /* 0x0030 */ uint8_t LevelLightingQuality;
};

// Size: 0x1c
struct FMarkerSyncAnimPosition {
    /* 0x0000 */ FName PreviousMarkerName;
    /* 0x000c */ FName NextMarkerName;
    /* 0x0018 */ float PositionBetweenMarkers;
};

// Size: 0x20
struct FMarkerSyncData {
    /* 0x0000 */ TArray<FAnimSyncMarker> AuthoredSyncMarkers;
};

// Size: 0xe78
class UMaterial : public UMaterialInterface {
    /* 0x0190 */ UPhysicalMaterial* PhysMaterial;
    /* 0x0198 */ UPhysicalMaterialMask* PhysMaterialMask;
    /* 0x01a0 */ UPhysicalMaterial* PhysicalMaterialMap[8];
    /* 0x01e0 */ FColorMaterialInput DiffuseColor;
    /* 0x0220 */ FColorMaterialInput SpecularColor;
    /* 0x0260 */ FColorMaterialInput BaseColor;
    /* 0x02a0 */ FScalarMaterialInput Metallic;
    /* 0x02e0 */ FScalarMaterialInput Specular;
    /* 0x0320 */ FScalarMaterialInput Roughness;
    /* 0x0360 */ FScalarMaterialInput Anisotropy;
    /* 0x03a0 */ FVectorMaterialInput Normal;
    /* 0x03e8 */ FVectorMaterialInput Tangent;
    /* 0x0430 */ FColorMaterialInput EmissiveColor;
    /* 0x0470 */ FScalarMaterialInput Opacity;
    /* 0x04b0 */ FScalarMaterialInput OpacityMask;
    /* 0x04f0 */ uint8_t MaterialDomain;
    /* 0x04f1 */ uint8_t BlendMode;
    /* 0x04f2 */ uint8_t DecalBlendMode;
    /* 0x04f3 */ uint8_t MaterialDecalResponse;
    /* 0x04f4 */ uint8_t ShadingModel;
    /* 0x04f5 */ bool bCastDynamicShadowAsMasked;
    /* 0x04f6 */ FMaterialShadingModelField ShadingModels;
    /* 0x04f8 */ FString UsedShadingModels;
    /* 0x0508 */ float OpacityMaskClipValue;
    /* 0x0510 */ FVectorMaterialInput WorldPositionOffset;
    /* 0x0558 */ FVectorMaterialInput WorldDisplacement;
    /* 0x05a0 */ FScalarMaterialInput TessellationMultiplier;
    /* 0x05e0 */ FColorMaterialInput SubsurfaceColor;
    /* 0x0620 */ FScalarMaterialInput ClearCoat;
    /* 0x0660 */ FScalarMaterialInput ClearCoatRoughness;
    /* 0x06a0 */ FScalarMaterialInput AmbientOcclusion;
    /* 0x06e0 */ FScalarMaterialInput Refraction;
    /* 0x0720 */ FVector2MaterialInput CustomizedUVs[8];
    /* 0x0960 */ FMaterialAttributesInput MaterialAttributes;
    /* 0x09a0 */ FScalarMaterialInput PixelDepthOffset;
    /* 0x09e0 */ FShadingModelMaterialInput ShadingModelFromMaterialExpression;
    /* 0x0a20 */ bool bEnableSeparateTranslucency;
    /* 0x0a20 */ bool bEnableResponsiveAA;
    /* 0x0a20 */ bool bScreenSpaceReflections;
    /* 0x0a20 */ bool bContactShadows;
    /* 0x0a20 */ bool TwoSided;
    /* 0x0a20 */ bool DitheredLODTransition;
    /* 0x0a20 */ bool DitherOpacityMask;
    /* 0x0a20 */ bool bAllowNegativeEmissiveColor;
    /* 0x0a21 */ uint8_t TranslucencyLightingMode;
    /* 0x0a22 */ bool bEnableMobileSeparateTranslucency;
    /* 0x0a24 */ int32_t NumCustomizedUVs;
    /* 0x0a28 */ float TranslucencyDirectionalLightingIntensity;
    /* 0x0a2c */ float TranslucentShadowDensityScale;
    /* 0x0a30 */ float TranslucentSelfShadowDensityScale;
    /* 0x0a34 */ float TranslucentSelfShadowSecondDensityScale;
    /* 0x0a38 */ float TranslucentSelfShadowSecondOpacity;
    /* 0x0a3c */ float TranslucentBackscatteringExponent;
    /* 0x0a40 */ FLinearColor TranslucentMultipleScatteringExtinction;
    /* 0x0a50 */ float TranslucentShadowStartOffset;
    /* 0x0a54 */ bool bDisableDepthTest;
    /* 0x0a54 */ bool bWriteOnlyAlpha;
    /* 0x0a54 */ bool bGenerateSphericalParticleNormals;
    /* 0x0a54 */ bool bTangentSpaceNormal;
    /* 0x0a54 */ bool bUseEmissiveForDynamicAreaLighting;
    /* 0x0a54 */ bool bBlockGI;
    /* 0x0a54 */ bool bUsedAsSpecialEngineMaterial;
    /* 0x0a54 */ bool bUsedWithSkeletalMesh;
    /* 0x0a55 */ bool bUsedWithEditorCompositing;
    /* 0x0a55 */ bool bUsedWithParticleSprites;
    /* 0x0a55 */ bool bUsedWithBeamTrails;
    /* 0x0a55 */ bool bUsedWithMeshParticles;
    /* 0x0a55 */ bool bUsedWithNiagaraSprites;
    /* 0x0a55 */ bool bUsedWithNiagaraRibbons;
    /* 0x0a55 */ bool bUsedWithNiagaraMeshParticles;
    /* 0x0a55 */ bool bUsedWithGeometryCache;
    /* 0x0a56 */ bool bUsedWithStaticLighting;
    /* 0x0a56 */ bool bUsedWithMorphTargets;
    /* 0x0a56 */ bool bUsedWithSplineMeshes;
    /* 0x0a56 */ bool bUsedWithInstancedStaticMeshes;
    /* 0x0a56 */ bool bUsedWithGeometryCollections;
    /* 0x0a56 */ bool bUsesDistortion;
    /* 0x0a56 */ bool bUsedWithClothing;
    /* 0x0a58 */ bool bUsedWithWater;
    /* 0x0a58 */ bool bUsedWithHairStrands;
    /* 0x0a58 */ bool bUsedWithLidarPointCloud;
    /* 0x0a58 */ bool bUsedWithVirtualHeightfieldMesh;
    /* 0x0a5c */ bool bUsedWithUI;
    /* 0x0a5c */ bool bAutomaticallySetUsageInEditor;
    /* 0x0a5c */ bool bFullyRough;
    /* 0x0a5c */ bool bUseFullPrecision;
    /* 0x0a5c */ bool bUseLightmapDirectionality;
    /* 0x0a5c */ bool bUseAlphaToCoverage;
    /* 0x0a60 */ bool bForwardRenderUsePreintegratedGFForSimpleIBL;
    /* 0x0a64 */ bool bUseHQForwardReflections;
    /* 0x0a64 */ bool bForwardBlendsSkyLightCubemaps;
    /* 0x0a64 */ bool bUsePlanarForwardReflections;
    /* 0x0a64 */ bool bNormalCurvatureToRoughness;
    /* 0x0a65 */ uint8_t D3D11TessellationMode;
    /* 0x0a66 */ bool bEnableCrackFreeDisplacement;
    /* 0x0a66 */ bool bEnableAdaptiveTessellation;
    /* 0x0a66 */ bool AllowTranslucentCustomDepthWrites;
    /* 0x0a66 */ bool Wireframe;
    /* 0x0a66 */ bool WriteDepthToTranslucentMaterial;
    /* 0x0a67 */ uint8_t ShadingRate;
    /* 0x0a68 */ int32_t EditorX;
    /* 0x0a6c */ int32_t EditorY;
    /* 0x0a70 */ int32_t EditorPitch;
    /* 0x0a74 */ int32_t EditorYaw;
    /* 0x0a78 */ TArray<UMaterialExpression*> Expressions;
    /* 0x0a88 */ TArray<UMaterialExpressionComment*> EditorComments;
    /* 0x0a98 */ TArray<FParameterGroupData> ParameterGroupData;
    /* 0x0aa8 */ bool bCanMaskedBeAssumedOpaque;
    /* 0x0aa8 */ bool bIsMasked;
    /* 0x0aa8 */ bool bIsPreviewMaterial;
    /* 0x0aa8 */ bool bIsFunctionPreviewMaterial;
    /* 0x0aa8 */ bool bUseMaterialAttributes;
    /* 0x0aa8 */ bool bCastRayTracedShadows;
    /* 0x0aa8 */ bool bUseTranslucencyVertexFog;
    /* 0x0aa8 */ bool bApplyCloudFogging;
    /* 0x0aa9 */ bool bIsSky;
    /* 0x0aa9 */ bool bComputeFogPerPixel;
    /* 0x0aa9 */ bool bOutputTranslucentVelocity;
    /* 0x0aa9 */ bool bAllowDevelopmentShaderCompile;
    /* 0x0aa9 */ bool bIsMaterialEditorStatsMaterial;
    /* 0x0aaa */ uint8_t BlendableLocation;
    /* 0x0aab */ bool BlendableOutputAlpha;
    /* 0x0aab */ bool bEnableStencilTest;
    /* 0x0aac */ uint8_t StencilCompare;
    /* 0x0aad */ uint8_t StencilRefValue;
    /* 0x0aae */ uint8_t RefractionMode;
    /* 0x0ab0 */ int32_t BlendablePriority;
    /* 0x0ab4 */ bool bIsBlendable;
    /* 0x0ab8 */ uint32_t UsageFlagWarnings;
    /* 0x0abc */ float RefractionDepthBias;
    /* 0x0ac0 */ FGuid StateId;
    /* 0x0ad0 */ float MaxDisplacement;
    /* 0x0bb0 */ FMaterialCachedExpressionData CachedExpressionData;
    /* 0x0e68 */ TArray<FGuid> ReferencedTextureGuids;
};

// Size: 0x40
struct FMaterialAttributesInput : public FExpressionInput {
    /* 0x0038 */ int32_t PropertyConnectedBitmask;
};

// Size: 0x4f0
class UMaterialBillboardComponent : public UPrimitiveComponent {
    /* 0x04d8 */ TArray<FMaterialSpriteElement> Elements;

    void AddElement(UMaterialInterface* Material, UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, UCurveFloat* DistanceToSizeCurve);
    void SetElements(const TArray<FMaterialSpriteElement>& NewElements);
};

// Size: 0x2b8
struct FMaterialCachedExpressionData {
    /* 0x0000 */ FMaterialCachedParameters Parameters;
    /* 0x0230 */ TArray<UObject*> ReferencedTextures;
    /* 0x0240 */ TArray<FMaterialFunctionInfo> FunctionInfos;
    /* 0x0250 */ TArray<FMaterialParameterCollectionInfo> ParameterCollectionInfos;
    /* 0x0260 */ TArray<UMaterialFunctionInterface*> DefaultLayers;
    /* 0x0270 */ TArray<UMaterialFunctionInterface*> DefaultLayerBlends;
    /* 0x0280 */ TArray<ULandscapeGrassType*> GrassTypes;
    /* 0x0290 */ TArray<FName> DynamicParameterNames;
    /* 0x02a0 */ TArray<bool> QualityLevelsUsed;
    /* 0x02b0 */ bool bHasRuntimeVirtualTextureOutput;
    /* 0x02b0 */ bool bHasSceneColor;
};

// Size: 0x30
struct FMaterialCachedParameterEntry {
    /* 0x0000 */ TArray<uint64_t> NameHashes;
    /* 0x0010 */ TArray<FMaterialParameterInfo> ParameterInfos;
    /* 0x0020 */ TArray<FGuid> ExpressionGuids;
};

// Size: 0x230
struct FMaterialCachedParameters {
    /* 0x0000 */ FMaterialCachedParameterEntry RuntimeEntries[5];
    /* 0x00f0 */ TArray<float> ScalarValues;
    /* 0x0100 */ TArray<FLinearColor> VectorValues;
    /* 0x0110 */ TArray<UTexture*> TextureValues;
    /* 0x0120 */ TArray<UFont*> FontValues;
    /* 0x0130 */ TArray<int32_t> FontPageValues;
    /* 0x0140 */ TArray<URuntimeVirtualTexture*> RuntimeVirtualTextureValues;
    /* 0x0150 */ FMaterialCachedParameterEntry EditorOnlyEntries[2];
    /* 0x01b0 */ TArray<bool> StaticSwitchValues;
    /* 0x01c0 */ TArray<FStaticComponentMaskValue> StaticComponentMaskValues;
    /* 0x01d0 */ TArray<FVector2D> ScalarMinMaxValues;
    /* 0x01e0 */ TArray<UCurveLinearColor*> ScalarCurveValues;
    /* 0x01f0 */ TArray<UCurveLinearColorAtlas*> ScalarCurveAtlasValues;
    /* 0x0200 */ TArray<FParameterChannelNames> VectorChannelNameValues;
    /* 0x0210 */ TArray<bool> VectorUsedAsChannelMaskValues;
    /* 0x0220 */ TArray<FParameterChannelNames> TextureChannelNameValues;
};

// Size: 0x30
struct FMaterialEditorPromotionSettings {
    /* 0x0000 */ FFilePath DefaultMaterialAsset;
    /* 0x0010 */ FFilePath DefaultDiffuseTexture;
    /* 0x0020 */ FFilePath DefaultNormalTexture;
};

// Size: 0xb0
class UMaterialExpression : public UObject {
    /* 0x0030 */ int32_t MaterialExpressionEditorX;
    /* 0x0034 */ int32_t MaterialExpressionEditorY;
    /* 0x0038 */ UEdGraphNode* GraphNode;
    /* 0x0050 */ FGuid MaterialExpressionGuid;
    /* 0x0060 */ UMaterial* Material;
    /* 0x0068 */ UMaterialFunction* Function;
    /* 0x0070 */ FString Desc;
    /* 0x0080 */ bool bRealtimePreview;
    /* 0x0080 */ bool bNeedToUpdatePreview;
    /* 0x0084 */ bool bIsParameterExpression;
    /* 0x0088 */ bool bCommentBubbleVisible;
    /* 0x0088 */ bool bShowOutputNameOnPin;
    /* 0x0088 */ bool bShowMaskColorsOnPin;
    /* 0x0088 */ bool bHidePreviewWindow;
    /* 0x0088 */ bool bCollapsed;
    /* 0x0088 */ bool bShaderInputData;
    /* 0x0088 */ bool bShowInputs;
    /* 0x0088 */ bool bShowOutputs;
    /* 0x0090 */ TArray<FText> MenuCategories;
    /* 0x00a0 */ TArray<FExpressionOutput> Outputs;
};

// Size: 0xe8
class UMaterialExpressionAbs : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xb0
class UMaterialExpressionActorPositionWS : public UMaterialExpression {
};

// Size: 0x128
class UMaterialExpressionAdd : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ float ConstA;
    /* 0x0124 */ float ConstB;
};

// Size: 0x2b0
class UMaterialExpressionAntialiasedTextureMask : public UMaterialExpressionTextureSampleParameter2D {
    /* 0x02a8 */ float Threshold;
    /* 0x02ac */ uint8_t Channel;
};

// Size: 0x120
class UMaterialExpressionAppendVector : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
};

// Size: 0xe8
class UMaterialExpressionArccosine : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xe8
class UMaterialExpressionArccosineFast : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xe8
class UMaterialExpressionArcsine : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xe8
class UMaterialExpressionArcsineFast : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xe8
class UMaterialExpressionArctangent : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0x120
class UMaterialExpressionArctangent2 : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Y;
    /* 0x00e8 */ FExpressionInput X;
};

// Size: 0x120
class UMaterialExpressionArctangent2Fast : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Y;
    /* 0x00e8 */ FExpressionInput X;
};

// Size: 0xe8
class UMaterialExpressionArctangentFast : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xe8
class UMaterialExpressionAtmosphericFogColor : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput WorldPosition;
};

// Size: 0xb0
class UMaterialExpressionAtmosphericLightColor : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionAtmosphericLightVector : public UMaterialExpression {
};

// Size: 0xe8
class UMaterialExpressionBentNormalCustomOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xe8
class UMaterialExpressionBlackBody : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Temp;
};

// Size: 0x170
class UMaterialExpressionBlendMaterialAttributes : public UMaterialExpression {
    /* 0x00b0 */ FMaterialAttributesInput A;
    /* 0x00f0 */ FMaterialAttributesInput B;
    /* 0x0130 */ FExpressionInput Alpha;
    /* 0x0168 */ uint8_t PixelAttributeBlendType;
    /* 0x0169 */ uint8_t VertexAttributeBlendType;
};

// Size: 0xf0
class UMaterialExpressionBreakMaterialAttributes : public UMaterialExpression {
    /* 0x00b0 */ FMaterialAttributesInput MaterialAttributes;
};

// Size: 0x168
class UMaterialExpressionBumpOffset : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Coordinate;
    /* 0x00e8 */ FExpressionInput Height;
    /* 0x0120 */ FExpressionInput HeightRatioInput;
    /* 0x0158 */ float HeightRatio;
    /* 0x015c */ float ReferencePlane;
    /* 0x0160 */ uint32_t ConstCoordinate;
};

// Size: 0xb0
class UMaterialExpressionCameraPositionWS : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionCameraVectorWS : public UMaterialExpression {
};

// Size: 0xe8
class UMaterialExpressionCeil : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0x198
class UMaterialExpressionChannelMaskParameter : public UMaterialExpressionVectorParameter {
    /* 0x0158 */ uint8_t MaskChannel;
    /* 0x0160 */ FExpressionInput Input;
};

// Size: 0x168
class UMaterialExpressionClamp : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ FExpressionInput Min;
    /* 0x0120 */ FExpressionInput Max;
    /* 0x0158 */ uint8_t ClampMode;
    /* 0x015c */ float MinDefault;
    /* 0x0160 */ float MaxDefault;
};

// Size: 0xe8
class UMaterialExpressionClearCoatNormalCustomOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xb0
class UMaterialExpressionCloudSampleAttribute : public UMaterialExpression {
};

// Size: 0xd8
class UMaterialExpressionCollectionParameter : public UMaterialExpression {
    /* 0x00b0 */ UMaterialParameterCollection* Collection;
    /* 0x00b8 */ FName ParameterName;
    /* 0x00c4 */ FGuid ParameterId;
};

// Size: 0xe0
class UMaterialExpressionComment : public UMaterialExpression {
    /* 0x00b0 */ int32_t SizeX;
    /* 0x00b4 */ int32_t SizeY;
    /* 0x00b8 */ FString text;
    /* 0x00c8 */ FLinearColor CommentColor;
    /* 0x00d8 */ int32_t FontSize;
};

// Size: 0xf0
class UMaterialExpressionComponentMask : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ bool R;
    /* 0x00e8 */ bool G;
    /* 0x00e8 */ bool B;
    /* 0x00e8 */ bool A;
};

// Size: 0xb8
class UMaterialExpressionConstant : public UMaterialExpression {
    /* 0x00b0 */ float R;
};

// Size: 0xb8
class UMaterialExpressionConstant2Vector : public UMaterialExpression {
    /* 0x00b0 */ float R;
    /* 0x00b4 */ float G;
};

// Size: 0xc0
class UMaterialExpressionConstant3Vector : public UMaterialExpression {
    /* 0x00b0 */ FLinearColor Constant;
};

// Size: 0xc0
class UMaterialExpressionConstant4Vector : public UMaterialExpression {
    /* 0x00b0 */ FLinearColor Constant;
};

// Size: 0xf0
class UMaterialExpressionConstantBiasScale : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ float Bias;
    /* 0x00ec */ float Scale;
};

// Size: 0xf0
class UMaterialExpressionCosine : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ float Period;
};

// Size: 0x120
class UMaterialExpressionCrossProduct : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
};

// Size: 0x138
class UMaterialExpressionCurveAtlasRowParameter : public UMaterialExpressionScalarParameter {
    /* 0x00f0 */ UCurveLinearColor* Curve;
    /* 0x00f8 */ UCurveLinearColorAtlas* Atlas;
    /* 0x0100 */ FExpressionInput InputTime;
};

// Size: 0x118
class UMaterialExpressionCustom : public UMaterialExpression {
    /* 0x00b0 */ FString Code;
    /* 0x00c0 */ uint8_t OutputType;
    /* 0x00c8 */ FString Description;
    /* 0x00d8 */ TArray<FCustomInput> Inputs;
    /* 0x00e8 */ TArray<FCustomOutput> AdditionalOutputs;
    /* 0x00f8 */ TArray<FCustomDefine> AdditionalDefines;
    /* 0x0108 */ TArray<FString> IncludeFilePaths;
};

// Size: 0xb0
class UMaterialExpressionCustomOutput : public UMaterialExpression {
};

// Size: 0xe8
class UMaterialExpressionDDX : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Value;
};

// Size: 0xe8
class UMaterialExpressionDDY : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Value;
};

// Size: 0xb0
class UMaterialExpressionDecalDerivative : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionDecalLifetimeOpacity : public UMaterialExpression {
};

// Size: 0xf0
class UMaterialExpressionDecalMipmapLevel : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput TextureSize;
    /* 0x00e8 */ float ConstWidth;
    /* 0x00ec */ float ConstHeight;
};

// Size: 0xb0
class UMaterialExpressionDeltaTime : public UMaterialExpression {
};

// Size: 0x128
class UMaterialExpressionDepthFade : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput InOpacity;
    /* 0x00e8 */ FExpressionInput FadeDistance;
    /* 0x0120 */ float OpacityDefault;
    /* 0x0124 */ float FadeDistanceDefault;
};

// Size: 0xf0
class UMaterialExpressionDepthOfFieldFunction : public UMaterialExpression {
    /* 0x00b0 */ uint8_t FunctionValue;
    /* 0x00b8 */ FExpressionInput Depth;
};

// Size: 0xe8
class UMaterialExpressionDeriveNormalZ : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput InXY;
};

// Size: 0x130
class UMaterialExpressionDesaturation : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ FExpressionInput Fraction;
    /* 0x0120 */ FLinearColor LuminanceFactors;
};

// Size: 0x120
class UMaterialExpressionDistance : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
};

// Size: 0xb0
class UMaterialExpressionDistanceCullFade : public UMaterialExpression {
};

// Size: 0xe8
class UMaterialExpressionDistanceFieldGradient : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Position;
};

// Size: 0x120
class UMaterialExpressionDistanceFieldsRenderingSwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput No;
    /* 0x00e8 */ FExpressionInput Yes;
};

// Size: 0xe8
class UMaterialExpressionDistanceToNearestSurface : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Position;
};

// Size: 0x128
class UMaterialExpressionDivide : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ float ConstA;
    /* 0x0124 */ float ConstB;
};

// Size: 0x120
class UMaterialExpressionDotProduct : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
};

// Size: 0xd8
class UMaterialExpressionDynamicParameter : public UMaterialExpression {
    /* 0x00b0 */ TArray<FString> ParamNames;
    /* 0x00c0 */ FLinearColor DefaultValue;
    /* 0x00d0 */ uint32_t ParameterIndex;
};

// Size: 0xb0
class UMaterialExpressionEyeAdaptation : public UMaterialExpression {
};

// Size: 0x1c8
class UMaterialExpressionFeatureLevelSwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Default;
    /* 0x00e8 */ FExpressionInput Inputs[4];
};

// Size: 0xe8
class UMaterialExpressionFloor : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0x120
class UMaterialExpressionFmod : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
};

// Size: 0xc0
class UMaterialExpressionFontSample : public UMaterialExpression {
    /* 0x00b0 */ UFont* Font;
    /* 0x00b8 */ int32_t FontTexturePage;
};

// Size: 0xf0
class UMaterialExpressionFontSampleParameter : public UMaterialExpressionFontSample {
    /* 0x00c0 */ FName ParameterName;
    /* 0x00cc */ FGuid ExpressionGUID;
    /* 0x00dc */ FName Group;
    /* 0x00e8 */ int32_t SortPriority;
};

// Size: 0xe8
class UMaterialExpressionFrac : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0x168
class UMaterialExpressionFresnel : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput ExponentIn;
    /* 0x00e8 */ float Exponent;
    /* 0x00f0 */ FExpressionInput BaseReflectFractionIn;
    /* 0x0128 */ float BaseReflectFraction;
    /* 0x0130 */ FExpressionInput Normal;
};

// Size: 0x180
class UMaterialExpressionFunctionInput : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Preview;
    /* 0x00e8 */ FName InputName;
    /* 0x00f8 */ FString Description;
    /* 0x0108 */ FGuid ID;
    /* 0x0118 */ uint8_t InputType;
    /* 0x0120 */ FVector4 PreviewValue;
    /* 0x0130 */ bool bUsePreviewValueAsDefault;
    /* 0x0134 */ int32_t SortPriority;
    /* 0x0138 */ bool bCompilingFunctionPreview;
};

// Size: 0x128
class UMaterialExpressionFunctionOutput : public UMaterialExpression {
    /* 0x00b0 */ FName OutputName;
    /* 0x00c0 */ FString Description;
    /* 0x00d0 */ int32_t SortPriority;
    /* 0x00d8 */ FExpressionInput A;
    /* 0x0110 */ bool bLastPreviewed;
    /* 0x0114 */ FGuid ID;
};

// Size: 0x158
class UMaterialExpressionGIReplace : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Default;
    /* 0x00e8 */ FExpressionInput StaticIndirect;
    /* 0x0120 */ FExpressionInput DynamicIndirect;
};

// Size: 0x110
class UMaterialExpressionGetMaterialAttributes : public UMaterialExpression {
    /* 0x00b0 */ FMaterialAttributesInput MaterialAttributes;
    /* 0x00f0 */ TArray<FGuid> AttributeGetTypes;
};

// Size: 0xb8
class UMaterialExpressionHairAttributes : public UMaterialExpression {
    /* 0x00b0 */ bool bUseTangentSpace;
};

// Size: 0x158
class UMaterialExpressionHairColor : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Melanin;
    /* 0x00e8 */ FExpressionInput Redness;
    /* 0x0120 */ FExpressionInput DyeColor;
};

// Size: 0x1d8
class UMaterialExpressionIf : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ FExpressionInput AGreaterThanB;
    /* 0x0158 */ FExpressionInput AEqualsB;
    /* 0x0190 */ FExpressionInput ALessThanB;
    /* 0x01c8 */ float EqualsThreshold;
    /* 0x01cc */ float ConstB;
    /* 0x01d0 */ float ConstAEqualsB;
};

// Size: 0x168
class UMaterialExpressionInverseLinearInterpolate : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ FExpressionInput Value;
    /* 0x0158 */ float ConstA;
    /* 0x015c */ float ConstB;
    /* 0x0160 */ float ConstValue;
    /* 0x0164 */ bool bClampResult;
};

// Size: 0xb0
class UMaterialExpressionLightVector : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionLightmapUVs : public UMaterialExpression {
};

// Size: 0x120
class UMaterialExpressionLightmassReplace : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Realtime;
    /* 0x00e8 */ FExpressionInput Lightmass;
};

// Size: 0x168
class UMaterialExpressionLinearInterpolate : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ FExpressionInput Alpha;
    /* 0x0158 */ float ConstA;
    /* 0x015c */ float ConstB;
    /* 0x0160 */ float ConstAlpha;
};

// Size: 0xe8
class UMaterialExpressionLogarithm10 : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput X;
};

// Size: 0xe8
class UMaterialExpressionLogarithm2 : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput X;
};

// Size: 0x6d0
class UMaterialExpressionMakeMaterialAttributes : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput BaseColor;
    /* 0x00e8 */ FExpressionInput Metallic;
    /* 0x0120 */ FExpressionInput Specular;
    /* 0x0158 */ FExpressionInput Roughness;
    /* 0x0190 */ FExpressionInput Anisotropy;
    /* 0x01c8 */ FExpressionInput EmissiveColor;
    /* 0x0200 */ FExpressionInput Opacity;
    /* 0x0238 */ FExpressionInput OpacityMask;
    /* 0x0270 */ FExpressionInput Normal;
    /* 0x02a8 */ FExpressionInput Tangent;
    /* 0x02e0 */ FExpressionInput WorldPositionOffset;
    /* 0x0318 */ FExpressionInput WorldDisplacement;
    /* 0x0350 */ FExpressionInput TessellationMultiplier;
    /* 0x0388 */ FExpressionInput SubsurfaceColor;
    /* 0x03c0 */ FExpressionInput ClearCoat;
    /* 0x03f8 */ FExpressionInput ClearCoatRoughness;
    /* 0x0430 */ FExpressionInput AmbientOcclusion;
    /* 0x0468 */ FExpressionInput Refraction;
    /* 0x04a0 */ FExpressionInput CustomizedUVs[8];
    /* 0x0660 */ FExpressionInput PixelDepthOffset;
    /* 0x0698 */ FExpressionInput ShadingModel;
};

// Size: 0xe8
class UMaterialExpressionMapARPassthroughCameraUV : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Coordinates;
};

// Size: 0x1e8
class UMaterialExpressionMaterialAttributeLayers : public UMaterialExpression {
    /* 0x00b0 */ FName ParameterName;
    /* 0x00bc */ FGuid ExpressionGUID;
    /* 0x00d0 */ FMaterialAttributesInput Input;
    /* 0x0110 */ FMaterialLayersFunctions DefaultLayers;
    /* 0x01b0 */ TArray<UMaterialExpressionMaterialFunctionCall*> LayerCallers;
    /* 0x01c0 */ int32_t NumActiveLayerCallers;
    /* 0x01c8 */ TArray<UMaterialExpressionMaterialFunctionCall*> BlendCallers;
    /* 0x01d8 */ int32_t NumActiveBlendCallers;
    /* 0x01dc */ bool bIsLayerGraphBuilt;
};

// Size: 0xf8
class UMaterialExpressionMaterialFunctionCall : public UMaterialExpression {
    /* 0x00b0 */ UMaterialFunctionInterface* MaterialFunction;
    /* 0x00b8 */ TArray<FFunctionExpressionInput> FunctionInputs;
    /* 0x00c8 */ TArray<FFunctionExpressionOutput> FunctionOutputs;
    /* 0x00d8 */ FMaterialParameterInfo FunctionParameterInfo;

    bool SetMaterialFunction(UMaterialFunctionInterface* NewMaterialFunction);
};

// Size: 0x128
class UMaterialExpressionMaterialLayerOutput : public UMaterialExpressionFunctionOutput {
};

// Size: 0x120
class UMaterialExpressionMaterialProxyReplace : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Realtime;
    /* 0x00e8 */ FExpressionInput MaterialProxy;
};

// Size: 0x128
class UMaterialExpressionMax : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ float ConstA;
    /* 0x0124 */ float ConstB;
};

// Size: 0x128
class UMaterialExpressionMin : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ float ConstA;
    /* 0x0124 */ float ConstB;
};

// Size: 0x128
class UMaterialExpressionMultiply : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ float ConstA;
    /* 0x0124 */ float ConstB;
};

// Size: 0xb0
class UMaterialExpressionNamedRerouteBase : public UMaterialExpressionRerouteBase {
};

// Size: 0x118
class UMaterialExpressionNamedRerouteDeclaration : public UMaterialExpressionNamedRerouteBase {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ FName Name;
    /* 0x00f4 */ FLinearColor NodeColor;
    /* 0x0104 */ FGuid VariableGuid;
};

// Size: 0xc8
class UMaterialExpressionNamedRerouteUsage : public UMaterialExpressionNamedRerouteBase {
    /* 0x00b0 */ UMaterialExpressionNamedRerouteDeclaration* Declaration;
    /* 0x00b8 */ FGuid DeclarationGuid;
};

// Size: 0x148
class UMaterialExpressionNoise : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Position;
    /* 0x00e8 */ FExpressionInput FilterWidth;
    /* 0x0120 */ float Scale;
    /* 0x0124 */ int32_t Quality;
    /* 0x0128 */ uint8_t NoiseFunction;
    /* 0x012c */ bool bTurbulence;
    /* 0x0130 */ int32_t Levels;
    /* 0x0134 */ float OutputMin;
    /* 0x0138 */ float OutputMax;
    /* 0x013c */ float LevelScale;
    /* 0x0140 */ bool bTiling;
    /* 0x0144 */ uint32_t RepeatSize;
};

// Size: 0xe8
class UMaterialExpressionNormalize : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput VectorInput;
};

// Size: 0xb0
class UMaterialExpressionObjectBounds : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionObjectOrientation : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionObjectPositionWS : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionObjectRadius : public UMaterialExpression {
};

// Size: 0xe8
class UMaterialExpressionOneMinus : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0x168
class UMaterialExpressionPanner : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Coordinate;
    /* 0x00e8 */ FExpressionInput Time;
    /* 0x0120 */ FExpressionInput Speed;
    /* 0x0158 */ float SpeedX;
    /* 0x015c */ float SpeedY;
    /* 0x0160 */ uint32_t ConstCoordinate;
    /* 0x0164 */ bool bFractionalPart;
};

// Size: 0xe0
class UMaterialExpressionParameter : public UMaterialExpression {
    /* 0x00b0 */ FName ParameterName;
    /* 0x00bc */ FGuid ExpressionGUID;
    /* 0x00cc */ FName Group;
    /* 0x00d8 */ int32_t SortPriority;
};

// Size: 0xb0
class UMaterialExpressionParticleColor : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticleDirection : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticleMacroUV : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticleMotionBlurFade : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticlePositionWS : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticleRadius : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticleRandom : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticleRelativeTime : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticleSize : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionParticleSpeed : public UMaterialExpression {
};

// Size: 0x220
class UMaterialExpressionParticleSubUV : public UMaterialExpressionTextureSample {
    /* 0x0218 */ bool bBlend;
};

// Size: 0xb0
class UMaterialExpressionParticleSubUVProperties : public UMaterialExpression {
};

// Size: 0xf0
class UMaterialExpressionPerInstanceCustomData : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput DefaultValue;
    /* 0x00e8 */ float ConstDefaultValue;
    /* 0x00ec */ uint32_t DataIndex;
};

// Size: 0xb0
class UMaterialExpressionPerInstanceFadeAmount : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionPerInstanceRandom : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionPixelDepth : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionPixelNormalWS : public UMaterialExpression {
};

// Size: 0x128
class UMaterialExpressionPower : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Base;
    /* 0x00e8 */ FExpressionInput Exponent;
    /* 0x0120 */ float ConstExponent;
};

// Size: 0xc0
class UMaterialExpressionPreSkinnedLocalBounds : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionPreSkinnedNormal : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionPreSkinnedPosition : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionPrecomputedAOMask : public UMaterialExpression {
};

// Size: 0x120
class UMaterialExpressionPreviousFrameSwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput CurrentFrame;
    /* 0x00e8 */ FExpressionInput PreviousFrame;
};

// Size: 0x1c8
class UMaterialExpressionQualitySwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Default;
    /* 0x00e8 */ FExpressionInput Inputs[4];
};

// Size: 0x120
class UMaterialExpressionRayTracingQualitySwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Normal;
    /* 0x00e8 */ FExpressionInput RayTraced;
};

// Size: 0x120
class UMaterialExpressionReflectionCapturePassSwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Default;
    /* 0x00e8 */ FExpressionInput Reflection;
};

// Size: 0xf0
class UMaterialExpressionReflectionVectorWS : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput CustomWorldNormal;
    /* 0x00e8 */ bool bNormalizeCustomWorldNormal;
};

// Size: 0xe8
class UMaterialExpressionReroute : public UMaterialExpressionRerouteBase {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xb0
class UMaterialExpressionRerouteBase : public UMaterialExpression {
};

// Size: 0x198
class UMaterialExpressionRotateAboutAxis : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput NormalizedRotationAxis;
    /* 0x00e8 */ FExpressionInput RotationAngle;
    /* 0x0120 */ FExpressionInput PivotPoint;
    /* 0x0158 */ FExpressionInput Position;
    /* 0x0190 */ float Period;
};

// Size: 0x130
class UMaterialExpressionRotator : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Coordinate;
    /* 0x00e8 */ FExpressionInput Time;
    /* 0x0120 */ float CenterX;
    /* 0x0124 */ float CenterY;
    /* 0x0128 */ float Speed;
    /* 0x012c */ uint32_t ConstCoordinate;
};

// Size: 0xe8
class UMaterialExpressionRound : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0x238
class UMaterialExpressionRuntimeVirtualTextureOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ FExpressionInput BaseColor;
    /* 0x00e8 */ FExpressionInput Specular;
    /* 0x0120 */ FExpressionInput Roughness;
    /* 0x0158 */ FExpressionInput Normal;
    /* 0x0190 */ FExpressionInput WorldHeight;
    /* 0x01c8 */ FExpressionInput Opacity;
    /* 0x0200 */ FExpressionInput mask;
};

// Size: 0x120
class UMaterialExpressionRuntimeVirtualTextureReplace : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Default;
    /* 0x00e8 */ FExpressionInput VirtualTextureOutput;
};

// Size: 0x168
class UMaterialExpressionRuntimeVirtualTextureSample : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Coordinates;
    /* 0x00e8 */ FExpressionInput WorldPosition;
    /* 0x0120 */ FExpressionInput MipValue;
    /* 0x0158 */ URuntimeVirtualTexture* VirtualTexture;
    /* 0x0160 */ ERuntimeVirtualTextureMaterialType MaterialType;
    /* 0x0161 */ bool bSinglePhysicalSpace;
    /* 0x0162 */ bool bAdaptive;
    /* 0x0163 */ uint8_t MipValueMode;
    /* 0x0164 */ uint8_t TextureAddressMode;
};

// Size: 0x198
class UMaterialExpressionRuntimeVirtualTextureSampleParameter : public UMaterialExpressionRuntimeVirtualTextureSample {
    /* 0x0168 */ FName ParameterName;
    /* 0x0174 */ FGuid ExpressionGUID;
    /* 0x0184 */ FName Group;
    /* 0x0190 */ int32_t SortPriority;
};

// Size: 0xf0
class UMaterialExpressionSamplePhysicsIntegerField : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput WorldPosition;
    /* 0x00e8 */ uint8_t FieldTarget;
};

// Size: 0xf0
class UMaterialExpressionSamplePhysicsScalarField : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput WorldPosition;
    /* 0x00e8 */ uint8_t FieldTarget;
};

// Size: 0xf0
class UMaterialExpressionSamplePhysicsVectorField : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput WorldPosition;
    /* 0x00e8 */ uint8_t FieldTarget;
};

// Size: 0xe8
class UMaterialExpressionSaturate : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xf0
class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter {
    /* 0x00e0 */ float DefaultValue;
    /* 0x00e4 */ bool bUseCustomPrimitiveData;
    /* 0x00e5 */ uint8_t PrimitiveDataIndex;
    /* 0x00e8 */ float SliderMin;
    /* 0x00ec */ float SliderMax;
};

// Size: 0x130
class UMaterialExpressionSceneColor : public UMaterialExpression {
    /* 0x00b0 */ uint8_t InputMode;
    /* 0x00b8 */ FExpressionInput Input;
    /* 0x00f0 */ FExpressionInput OffsetFraction;
    /* 0x0128 */ FVector2D ConstInput;
};

// Size: 0x130
class UMaterialExpressionSceneDepth : public UMaterialExpression {
    /* 0x00b0 */ uint8_t InputMode;
    /* 0x00b8 */ FExpressionInput Input;
    /* 0x00f0 */ FExpressionInput Coordinates;
    /* 0x0128 */ FVector2D ConstInput;
};

// Size: 0x100
class UMaterialExpressionSceneDepthWithoutWater : public UMaterialExpression {
    /* 0x00b0 */ uint8_t InputMode;
    /* 0x00b8 */ FExpressionInput Input;
    /* 0x00f0 */ FVector2D ConstInput;
    /* 0x00f8 */ float FallbackDepth;
};

// Size: 0xb0
class UMaterialExpressionSceneTexelSize : public UMaterialExpression {
};

// Size: 0xf0
class UMaterialExpressionSceneTexture : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Coordinates;
    /* 0x00e8 */ uint8_t SceneTextureId;
    /* 0x00e9 */ bool bFiltered;
};

// Size: 0xb0
class UMaterialExpressionScreenPosition : public UMaterialExpression {
};

// Size: 0xe0
class UMaterialExpressionSetMaterialAttributes : public UMaterialExpression {
    /* 0x00b0 */ TArray<FExpressionInput> Inputs;
    /* 0x00c0 */ TArray<FGuid> AttributeSetTypes;
};

// Size: 0x120
class UMaterialExpressionShaderStageSwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput PixelShader;
    /* 0x00e8 */ FExpressionInput VertexShader;
};

// Size: 0xb8
class UMaterialExpressionShadingModel : public UMaterialExpression {
    /* 0x00b0 */ uint8_t ShadingModel;
};

// Size: 0x190
class UMaterialExpressionShadingPathSwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Default;
    /* 0x00e8 */ FExpressionInput Inputs[3];
};

// Size: 0x120
class UMaterialExpressionShadowReplace : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Default;
    /* 0x00e8 */ FExpressionInput Shadow;
};

// Size: 0xe8
class UMaterialExpressionSign : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xf0
class UMaterialExpressionSine : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ float Period;
};

// Size: 0x190
class UMaterialExpressionSingleLayerWaterMaterialOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ FExpressionInput ScatteringCoefficients;
    /* 0x00e8 */ FExpressionInput AbsorptionCoefficients;
    /* 0x0120 */ FExpressionInput PhaseG;
    /* 0x0158 */ FExpressionInput ColorScaleBehindWater;
};

// Size: 0xb0
class UMaterialExpressionSkinningVertexOffsets : public UMaterialExpression {
};

// Size: 0xe8
class UMaterialExpressionSkyAtmosphereAerialPerspective : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput WorldPosition;
};

// Size: 0xb0
class UMaterialExpressionSkyAtmosphereDistantLightScatteredLuminance : public UMaterialExpression {
};

// Size: 0xb8
class UMaterialExpressionSkyAtmosphereLightDirection : public UMaterialExpression {
    /* 0x00b0 */ int32_t LightIndex;
};

// Size: 0xb8
class UMaterialExpressionSkyAtmosphereLightDiskLuminance : public UMaterialExpression {
    /* 0x00b0 */ int32_t LightIndex;
};

// Size: 0xf0
class UMaterialExpressionSkyAtmosphereLightIlluminance : public UMaterialExpression {
    /* 0x00b0 */ int32_t LightIndex;
    /* 0x00b8 */ FExpressionInput WorldPosition;
};

// Size: 0xb0
class UMaterialExpressionSkyAtmosphereViewLuminance : public UMaterialExpression {
};

// Size: 0x168
class UMaterialExpressionSmoothStep : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Min;
    /* 0x00e8 */ FExpressionInput Max;
    /* 0x0120 */ FExpressionInput Value;
    /* 0x0158 */ float ConstMin;
    /* 0x015c */ float ConstMax;
    /* 0x0160 */ float ConstValue;
};

// Size: 0x168
class UMaterialExpressionSobol : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Cell;
    /* 0x00e8 */ FExpressionInput index;
    /* 0x0120 */ FExpressionInput Seed;
    /* 0x0158 */ uint32_t ConstIndex;
    /* 0x015c */ FVector2D ConstSeed;
};

// Size: 0x1a0
class UMaterialExpressionSpeedTree : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput GeometryInput;
    /* 0x00e8 */ FExpressionInput WindInput;
    /* 0x0120 */ FExpressionInput LODInput;
    /* 0x0158 */ FExpressionInput ExtraBendWS;
    /* 0x0190 */ uint8_t GeometryType;
    /* 0x0191 */ uint8_t WindType;
    /* 0x0192 */ uint8_t LODType;
    /* 0x0194 */ float BillboardThreshold;
    /* 0x0198 */ bool bAccurateWindVelocities;
};

// Size: 0x198
class UMaterialExpressionSphereMask : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ FExpressionInput Radius;
    /* 0x0158 */ FExpressionInput Hardness;
    /* 0x0190 */ float AttenuationRadius;
    /* 0x0194 */ float HardnessPercent;
};

// Size: 0xf0
class UMaterialExpressionSphericalParticleOpacity : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Density;
    /* 0x00e8 */ float ConstantDensity;
};

// Size: 0xe8
class UMaterialExpressionSquareRoot : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xb8
class UMaterialExpressionStaticBool : public UMaterialExpression {
    /* 0x00b0 */ bool Value;
};

// Size: 0xe8
class UMaterialExpressionStaticBoolParameter : public UMaterialExpressionParameter {
    /* 0x00e0 */ bool DefaultValue;
};

// Size: 0x120
class UMaterialExpressionStaticComponentMaskParameter : public UMaterialExpressionParameter {
    /* 0x00e0 */ FExpressionInput Input;
    /* 0x0118 */ bool DefaultR;
    /* 0x0118 */ bool DefaultG;
    /* 0x0118 */ bool DefaultB;
    /* 0x0118 */ bool DefaultA;
};

// Size: 0x160
class UMaterialExpressionStaticSwitch : public UMaterialExpression {
    /* 0x00b0 */ bool DefaultValue;
    /* 0x00b8 */ FExpressionInput A;
    /* 0x00f0 */ FExpressionInput B;
    /* 0x0128 */ FExpressionInput Value;
};

// Size: 0x158
class UMaterialExpressionStaticSwitchParameter : public UMaterialExpressionStaticBoolParameter {
    /* 0x00e8 */ FExpressionInput A;
    /* 0x0120 */ FExpressionInput B;
};

// Size: 0x128
class UMaterialExpressionStep : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Y;
    /* 0x00e8 */ FExpressionInput X;
    /* 0x0120 */ float ConstY;
    /* 0x0124 */ float ConstX;
};

// Size: 0x128
class UMaterialExpressionSubtract : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput A;
    /* 0x00e8 */ FExpressionInput B;
    /* 0x0120 */ float ConstA;
    /* 0x0124 */ float ConstB;
};

// Size: 0xf0
class UMaterialExpressionTangent : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ float Period;
};

// Size: 0xe8
class UMaterialExpressionTangentOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0x130
class UMaterialExpressionTemporalSobol : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput index;
    /* 0x00e8 */ FExpressionInput Seed;
    /* 0x0120 */ uint32_t ConstIndex;
    /* 0x0124 */ FVector2D ConstSeed;
};

// Size: 0xc0
class UMaterialExpressionTextureBase : public UMaterialExpression {
    /* 0x00b0 */ UTexture* Texture;
    /* 0x00b8 */ uint8_t SamplerType;
    /* 0x00b9 */ bool IsDefaultMeshpaintTexture;
};

// Size: 0xc0
class UMaterialExpressionTextureCoordinate : public UMaterialExpression {
    /* 0x00b0 */ int32_t CoordinateIndex;
    /* 0x00b4 */ float UTiling;
    /* 0x00b8 */ float VTiling;
    /* 0x00bc */ bool UnMirrorU;
    /* 0x00bc */ bool UnMirrorV;
};

// Size: 0xc0
class UMaterialExpressionTextureObject : public UMaterialExpressionTextureBase {
};

// Size: 0x2a8
class UMaterialExpressionTextureObjectParameter : public UMaterialExpressionTextureSampleParameter {
};

// Size: 0xf0
class UMaterialExpressionTextureProperty : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput TextureObject;
    /* 0x00e8 */ uint8_t Property;
};

// Size: 0x218
class UMaterialExpressionTextureSample : public UMaterialExpressionTextureBase {
    /* 0x00c0 */ FExpressionInput Coordinates;
    /* 0x00f8 */ FExpressionInput TextureObject;
    /* 0x0130 */ FExpressionInput MipValue;
    /* 0x0168 */ FExpressionInput CoordinatesDX;
    /* 0x01a0 */ FExpressionInput CoordinatesDY;
    /* 0x01d8 */ FExpressionInput AutomaticViewMipBiasValue;
    /* 0x0210 */ uint8_t MipValueMode;
    /* 0x0211 */ uint8_t SamplerSource;
    /* 0x0212 */ bool AutomaticViewMipBias;
    /* 0x0213 */ uint8_t ConstCoordinate;
    /* 0x0214 */ int32_t ConstMipValue;
};

// Size: 0x2a8
class UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample {
    /* 0x0218 */ FName ParameterName;
    /* 0x0224 */ FGuid ExpressionGUID;
    /* 0x0234 */ FName Group;
    /* 0x0240 */ int32_t SortPriority;
    /* 0x0248 */ FParameterChannelNames ChannelNames;
};

// Size: 0x2a8
class UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter {
};

// Size: 0x2a8
class UMaterialExpressionTextureSampleParameter2DArray : public UMaterialExpressionTextureSampleParameter {
};

// Size: 0x2a8
class UMaterialExpressionTextureSampleParameterCube : public UMaterialExpressionTextureSampleParameter {
};

// Size: 0x2b0
class UMaterialExpressionTextureSampleParameterSubUV : public UMaterialExpressionTextureSampleParameter2D {
    /* 0x02a8 */ bool bBlend;
};

// Size: 0x2a8
class UMaterialExpressionTextureSampleParameterVolume : public UMaterialExpressionTextureSampleParameter {
};

// Size: 0xe8
class UMaterialExpressionThinTranslucentMaterialOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ FExpressionInput TransmittanceColor;
};

// Size: 0xb8
class UMaterialExpressionTime : public UMaterialExpression {
    /* 0x00b0 */ bool bIgnorePause;
    /* 0x00b0 */ bool bOverride_Period;
    /* 0x00b4 */ float Period;
};

// Size: 0xf0
class UMaterialExpressionTransform : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ uint8_t TransformSourceType;
    /* 0x00e9 */ uint8_t TransformType;
};

// Size: 0xf0
class UMaterialExpressionTransformPosition : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
    /* 0x00e8 */ uint8_t TransformSourceType;
    /* 0x00e9 */ uint8_t TransformType;
};

// Size: 0xe8
class UMaterialExpressionTruncate : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xb0
class UMaterialExpressionTwoSidedSign : public UMaterialExpression {
};

// Size: 0xf8
class UMaterialExpressionVectorNoise : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Position;
    /* 0x00e8 */ uint8_t NoiseFunction;
    /* 0x00ec */ int32_t Quality;
    /* 0x00f0 */ bool bTiling;
    /* 0x00f4 */ uint32_t TileSize;
};

// Size: 0x158
class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter {
    /* 0x00e0 */ FLinearColor DefaultValue;
    /* 0x00f0 */ bool bUseCustomPrimitiveData;
    /* 0x00f1 */ uint8_t PrimitiveDataIndex;
    /* 0x00f8 */ FParameterChannelNames ChannelNames;
};

// Size: 0xb0
class UMaterialExpressionVertexColor : public UMaterialExpression {
};

// Size: 0x118
class UMaterialExpressionVertexInterpolator : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ FExpressionInput Input;
};

// Size: 0xb0
class UMaterialExpressionVertexNormalWS : public UMaterialExpression {
};

// Size: 0xb0
class UMaterialExpressionVertexTangentWS : public UMaterialExpression {
};

// Size: 0xb8
class UMaterialExpressionViewProperty : public UMaterialExpression {
    /* 0x00b0 */ uint8_t Property;
};

// Size: 0xb0
class UMaterialExpressionViewSize : public UMaterialExpression {
};

// Size: 0x120
class UMaterialExpressionVirtualTextureFeatureSwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput No;
    /* 0x00e8 */ FExpressionInput Yes;
};

// Size: 0xb0
class UMaterialExpressionVolumetricAdvancedMaterialInput : public UMaterialExpression {
};

// Size: 0x260
class UMaterialExpressionVolumetricAdvancedMaterialOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ FExpressionInput PhaseG;
    /* 0x00e8 */ FExpressionInput PhaseG2;
    /* 0x0120 */ FExpressionInput PhaseBlend;
    /* 0x0158 */ FExpressionInput MultiScatteringContribution;
    /* 0x0190 */ FExpressionInput MultiScatteringOcclusion;
    /* 0x01c8 */ FExpressionInput MultiScatteringEccentricity;
    /* 0x0200 */ FExpressionInput ConservativeDensity;
    /* 0x0238 */ float ConstPhaseG;
    /* 0x023c */ float ConstPhaseG2;
    /* 0x0240 */ float ConstPhaseBlend;
    /* 0x0244 */ bool PerSamplePhaseEvaluation;
    /* 0x0248 */ uint32_t MultiScatteringApproximationOctaveCount;
    /* 0x024c */ float ConstMultiScatteringContribution;
    /* 0x0250 */ float ConstMultiScatteringOcclusion;
    /* 0x0254 */ float ConstMultiScatteringEccentricity;
    /* 0x0258 */ bool bGroundContribution;
    /* 0x0259 */ bool bGrayScaleMaterial;
    /* 0x025a */ bool bRayMarchVolumeShadow;
};

// Size: 0xb8
class UMaterialExpressionWorldPosition : public UMaterialExpression {
    /* 0x00b0 */ uint8_t WorldPositionShaderOffset;
};

// Size: 0xd8
class UMaterialFunction : public UMaterialFunctionInterface {
    /* 0x0058 */ UMaterialFunction* ParentFunction;
    /* 0x0060 */ FString Description;
    /* 0x0070 */ TArray<UMaterialExpression*> FunctionExpressions;
    /* 0x0080 */ bool bExposeToLibrary;
    /* 0x0080 */ bool bPrefixParameterNames;
    /* 0x0088 */ TArray<FString> LibraryCategories;
    /* 0x0098 */ TArray<FText> LibraryCategoriesText;
    /* 0x00a8 */ TArray<UMaterialExpressionComment*> FunctionEditorComments;
    /* 0x00b8 */ UMaterial* PreviewMaterial;
    /* 0x00c0 */ TArray<UMaterialExpressionMaterialFunctionCall*> DependentFunctionExpressionCandidates;
    /* 0x00d0 */ bool bReentrantFlag;
};

// Size: 0x18
struct FMaterialFunctionInfo {
    /* 0x0000 */ FGuid StateId;
    /* 0x0010 */ UMaterialFunctionInterface* Function;
};

// Size: 0xe0
class UMaterialFunctionInstance : public UMaterialFunctionInterface {
    /* 0x0058 */ UMaterialFunctionInterface* Parent;
    /* 0x0060 */ UMaterialFunctionInterface* Base;
    /* 0x0068 */ TArray<FScalarParameterValue> ScalarParameterValues;
    /* 0x0078 */ TArray<FVectorParameterValue> VectorParameterValues;
    /* 0x0088 */ TArray<FTextureParameterValue> TextureParameterValues;
    /* 0x0098 */ TArray<FFontParameterValue> FontParameterValues;
    /* 0x00a8 */ TArray<FStaticSwitchParameter> StaticSwitchParameterValues;
    /* 0x00b8 */ TArray<FStaticComponentMaskParameter> StaticComponentMaskParameterValues;
    /* 0x00c8 */ TArray<FRuntimeVirtualTextureParameterValue> RuntimeVirtualTextureParameterValues;
    /* 0x00d8 */ UMaterialInstanceConstant* PreviewMaterial;
};

// Size: 0x58
class UMaterialFunctionInterface : public UObject {
    /* 0x0030 */ FGuid StateId;
    /* 0x0040 */ EMaterialFunctionUsage MaterialFunctionUsage;
    /* 0x0044 */ uint32_t CombinedInputTypes;
    /* 0x0048 */ uint32_t CombinedOutputTypes;
    /* 0x0050 */ UThumbnailInfo* ThumbnailInfo;
};

// Size: 0xd8
class UMaterialFunctionMaterialLayer : public UMaterialFunction {
};

// Size: 0xd8
class UMaterialFunctionMaterialLayerBlend : public UMaterialFunction {
};

// Size: 0xe0
class UMaterialFunctionMaterialLayerBlendInstance : public UMaterialFunctionInstance {
};

// Size: 0xe0
class UMaterialFunctionMaterialLayerInstance : public UMaterialFunctionInstance {
};

// Size: 0x5a8
class UMaterialInstance : public UMaterialInterface {
    /* 0x0190 */ UPhysicalMaterial* PhysMaterial;
    /* 0x0198 */ UPhysicalMaterial* PhysicalMaterialMap[8];
    /* 0x01d8 */ UMaterialInterface* Parent;
    /* 0x01e0 */ bool bHasStaticPermutationResource;
    /* 0x01e0 */ bool bOverrideSubsurfaceProfile;
    /* 0x01e8 */ TArray<FScalarParameterValue> ScalarParameterValues;
    /* 0x01f8 */ TArray<FVectorParameterValue> VectorParameterValues;
    /* 0x0208 */ TArray<FTextureParameterValue> TextureParameterValues;
    /* 0x0218 */ TArray<FRuntimeVirtualTextureParameterValue> RuntimeVirtualTextureParameterValues;
    /* 0x0228 */ TArray<FFontParameterValue> FontParameterValues;
    /* 0x0238 */ bool bOverrideBaseProperties;
    /* 0x023c */ FMaterialInstanceBasePropertyOverrides BasePropertyOverrides;
    /* 0x0250 */ TArray<FGuid> ReferencedTextureGuids;
    /* 0x0260 */ FStaticParameterSet StaticParameters;
    /* 0x02a0 */ FMaterialCachedParameters CachedLayerParameters;
    /* 0x04d0 */ TArray<UObject*> CachedReferencedTextures;
};

// Size: 0x310
class AMaterialInstanceActor : public AActor {
    /* 0x02f8 */ TArray<AActor*> TargetActors;
};

// Size: 0x8
struct FMaterialInstanceBasePropertyOverrides {
    /* 0x0000 */ bool bOverride_OpacityMaskClipValue;
    /* 0x0000 */ bool bOverride_BlendMode;
    /* 0x0000 */ bool bOverride_ShadingModel;
    /* 0x0000 */ bool bOverride_DitheredLODTransition;
    /* 0x0000 */ bool bOverride_CastDynamicShadowAsMasked;
    /* 0x0000 */ bool bOverride_TwoSided;
    /* 0x0000 */ bool TwoSided;
    /* 0x0000 */ bool DitheredLODTransition;
    /* 0x0001 */ bool bCastDynamicShadowAsMasked;
    /* 0x0002 */ uint8_t BlendMode;
    /* 0x0003 */ uint8_t ShadingModel;
    /* 0x0004 */ float OpacityMaskClipValue;
};

// Size: 0x5c0
class UMaterialInstanceConstant : public UMaterialInstance {
    /* 0x05a8 */ FGuid ParameterStateId;
    /* 0x05b8 */ UPhysicalMaterialMask* PhysMaterialMask;

    float K2_GetScalarParameterValue(FName ParameterName);
    UTexture* K2_GetTextureParameterValue(FName ParameterName);
    FLinearColor K2_GetVectorParameterValue(FName ParameterName);
};

// Size: 0x5f8
class UMaterialInstanceDynamic : public UMaterialInstance {

    void CopyInterpParameters(UMaterialInstance* Source);
    void CopyParameterOverrides(UMaterialInstance* MaterialInstance);
    void K2_CopyMaterialInstanceParameters(UMaterialInterface* Source, bool bQuickParametersOnly);
    float K2_GetScalarParameterValue(FName ParameterName);
    float K2_GetScalarParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    UTexture* K2_GetTextureParameterValue(FName ParameterName);
    UTexture* K2_GetTextureParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    FLinearColor K2_GetVectorParameterValue(FName ParameterName);
    FLinearColor K2_GetVectorParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    void K2_InterpolateMaterialInstanceParams(UMaterialInstance* SourceA, UMaterialInstance* SourceB, float Alpha);
    void SetScalarParameterValue(FName ParameterName, float Value);
    void SetScalarParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, float Value);
    void SetTextureParameterValue(FName ParameterName, UTexture* Value);
    void SetTextureParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, UTexture* Value);
    void SetVectorParameterValue(FName ParameterName, FLinearColor Value);
    void SetVectorParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, FLinearColor Value);
};

// Size: 0x190
class UMaterialInterface : public UObject {
    /* 0x0040 */ USubsurfaceProfile* SubsurfaceProfile;
    /* 0x0058 */ FLightmassMaterialInterfaceSettings LightmassSettings;
    /* 0x0068 */ bool bTextureStreamingDataSorted;
    /* 0x006c */ int32_t TextureStreamingDataVersion;
    /* 0x0070 */ TArray<FMaterialTextureInfo> TextureStreamingData;
    /* 0x0080 */ TArray<UAssetUserData*> AssetUserData;
    /* 0x0098 */ TArray<FMaterialTextureInfo> TextureStreamingDataMissingEntries;
    /* 0x00a8 */ FSoftObjectPath PreviewMesh;
    /* 0x00c8 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x00d0 */ TMap<FString, bool> LayerParameterExpansion;
    /* 0x0120 */ TMap<FString, bool> ParameterOverviewExpansion;
    /* 0x0170 */ UAssetImportData* AssetImportData;
    /* 0x0178 */ FGuid LightingGuid;

    UMaterial* GetBaseMaterial();
    FMaterialParameterInfo GetParameterInfo(uint8_t Association, FName ParameterName, UMaterialFunctionInterface* LayerFunction) const;
    UPhysicalMaterial* GetPhysicalMaterial() const;
    UPhysicalMaterial* GetPhysicalMaterialFromMap(int32_t index) const;
    UPhysicalMaterialMask* GetPhysicalMaterialMask() const;
    void SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, int32_t CinematicTextureGroups, bool bFastResponse);
};

// Size: 0xa0
struct FMaterialLayersFunctions {
    /* 0x0000 */ TArray<UMaterialFunctionInterface*> Layers;
    /* 0x0010 */ TArray<UMaterialFunctionInterface*> Blends;
    /* 0x0020 */ TArray<bool> LayerStates;
    /* 0x0030 */ TArray<FText> LayerNames;
    /* 0x0040 */ TArray<bool> RestrictToLayerRelatives;
    /* 0x0050 */ TArray<bool> RestrictToBlendRelatives;
    /* 0x0060 */ TArray<FGuid> LayerGuids;
    /* 0x0070 */ TArray<EMaterialLayerLinkState> LayerLinkStates;
    /* 0x0080 */ TArray<FGuid> DeletedParentLayerGuids;
    /* 0x0090 */ FString KeyString;
};

// Size: 0x78
class UMaterialParameterCollection : public UObject {
    /* 0x0030 */ FGuid StateId;
    /* 0x0040 */ TArray<FCollectionScalarParameter> ScalarParameters;
    /* 0x0050 */ TArray<FCollectionVectorParameter> VectorParameters;
};

// Size: 0x18
struct FMaterialParameterCollectionInfo {
    /* 0x0000 */ FGuid StateId;
    /* 0x0010 */ UMaterialParameterCollection* ParameterCollection;
};

// Size: 0x128
class UMaterialParameterCollectionInstance : public UObject {
    /* 0x0038 */ UMaterialParameterCollection* Collection;
};

// Size: 0x14
struct FMaterialParameterInfo {
    /* 0x0000 */ FName Name;
    /* 0x000c */ uint8_t Association;
    /* 0x0010 */ int32_t index;
};

// Size: 0x88
struct FMaterialProxySettings {
    /* 0x0000 */ FIntPoint TextureSize;
    /* 0x0008 */ float GutterSpace;
    /* 0x000c */ float MetallicConstant;
    /* 0x0010 */ float RoughnessConstant;
    /* 0x0014 */ float AnisotropyConstant;
    /* 0x0018 */ float SpecularConstant;
    /* 0x001c */ float OpacityConstant;
    /* 0x0020 */ float OpacityMaskConstant;
    /* 0x0024 */ float AmbientOcclusionConstant;
    /* 0x0028 */ uint8_t TextureSizingType;
    /* 0x0029 */ uint8_t MaterialMergeType;
    /* 0x002a */ uint8_t BlendMode;
    /* 0x002b */ bool bAllowTwoSidedMaterial;
    /* 0x002b */ bool bNormalMap;
    /* 0x002b */ bool bTangentMap;
    /* 0x002b */ bool bMetallicMap;
    /* 0x002b */ bool bRoughnessMap;
    /* 0x002b */ bool bAnisotropyMap;
    /* 0x002b */ bool bSpecularMap;
    /* 0x002b */ bool bEmissiveMap;
    /* 0x002c */ bool bOpacityMap;
    /* 0x002c */ bool bOpacityMaskMap;
    /* 0x002c */ bool bAmbientOcclusionMap;
    /* 0x0030 */ FIntPoint DiffuseTextureSize;
    /* 0x0038 */ FIntPoint NormalTextureSize;
    /* 0x0040 */ FIntPoint TangentTextureSize;
    /* 0x0048 */ FIntPoint MetallicTextureSize;
    /* 0x0050 */ FIntPoint RoughnessTextureSize;
    /* 0x0058 */ FIntPoint AnisotropyTextureSize;
    /* 0x0060 */ FIntPoint SpecularTextureSize;
    /* 0x0068 */ FIntPoint EmissiveTextureSize;
    /* 0x0070 */ FIntPoint OpacityTextureSize;
    /* 0x0078 */ FIntPoint OpacityMaskTextureSize;
    /* 0x0080 */ FIntPoint AmbientOcclusionTextureSize;
};

// Size: 0x18
struct FMaterialRemapIndex {
    /* 0x0000 */ uint32_t ImportVersionKey;
    /* 0x0008 */ TArray<int32_t> MaterialRemap;
};

// Size: 0x2
struct FMaterialShadingModelField {
    /* 0x0000 */ uint16_t ShadingModelField;
};

// Size: 0x28
struct FMaterialSpriteElement {
    /* 0x0000 */ UMaterialInterface* Material;
    /* 0x0008 */ UCurveFloat* DistanceToOpacityCurve;
    /* 0x0010 */ bool bSizeIsInScreenSpace;
    /* 0x0014 */ float BaseSizeX;
    /* 0x0018 */ float BaseSizeY;
    /* 0x0020 */ UCurveFloat* DistanceToSizeCurve;
};

// Size: 0x40
struct FMaterialTextureInfo {
    /* 0x0000 */ float SamplingScale;
    /* 0x0004 */ int32_t UVChannelIndex;
    /* 0x0008 */ FName TextureName;
    /* 0x0018 */ FSoftObjectPath TextureReference;
    /* 0x0038 */ int32_t TextureIndex;
};

// Size: 0x450
class AMatineeActor : public AActor {
    /* 0x02f8 */ UInterpData* MatineeData;
    /* 0x0300 */ FName MatineeControllerName;
    /* 0x030c */ float PlayRate;
    /* 0x0310 */ bool bPlayOnLevelLoad;
    /* 0x0310 */ bool bForceStartPos;
    /* 0x0314 */ float ForceStartPosition;
    /* 0x0318 */ bool bLooping;
    /* 0x0318 */ bool bRewindOnPlay;
    /* 0x0318 */ bool bNoResetOnRewind;
    /* 0x0318 */ bool bRewindIfAlreadyPlaying;
    /* 0x0318 */ bool bDisableRadioFilter;
    /* 0x0318 */ bool bClientSideOnly;
    /* 0x0318 */ bool bSkipUpdateIfNotVisible;
    /* 0x0318 */ bool bIsSkippable;
    /* 0x031c */ int32_t PreferredSplitScreenNum;
    /* 0x0320 */ bool bDisableMovementInput;
    /* 0x0320 */ bool bDisableLookAtInput;
    /* 0x0320 */ bool bHidePlayer;
    /* 0x0320 */ bool bHideHud;
    /* 0x0328 */ TArray<FInterpGroupActorInfo> GroupActorInfos;
    /* 0x0338 */ bool bShouldShowGore;
    /* 0x0340 */ TArray<UInterpGroupInst*> GroupInst;
    /* 0x0350 */ TArray<FCameraCutInfo> CameraCuts;
    /* 0x0360 */ UBillboardComponent* SpriteComponent;
    /* 0x0368 */ bool bIsBeingEdited;
    /* 0x0368 */ bool bIsScrubbing;
    /* 0x0368 */ bool bIsPlaying;
    /* 0x0368 */ bool bReversePlayback;
    /* 0x0368 */ bool bPaused;
    /* 0x0368 */ bool bPendingStop;
    /* 0x036c */ float InterpPosition;
    /* 0x0374 */ uint8_t ReplicationForceIsPlaying;
    /* 0x0378 */ FMulticastInlineDelegate OnPlay;
    /* 0x0388 */ FMulticastInlineDelegate OnStop;
    /* 0x0398 */ FMulticastInlineDelegate OnPause;

    void ChangePlaybackDirection();
    void EnableGroupByName(FString GroupName, bool bEnable);
    void Pause();
    void Play();
    void Reverse();
    void SetLoopingState(bool bNewLooping);
    void SetPosition(float NewPosition, bool bJump);
    void Stop();
};

// Size: 0x458
class AMatineeActorCameraAnim : public AMatineeActor {
    /* 0x0450 */ UCameraAnim* CameraAnim;
};

// Size: 0x30
class IMatineeAnimInterface : public UInterface {
};

// Size: 0x30
class IMatineeInterface : public UInterface {
};

// Size: 0x38
struct FMemberReference {
    /* 0x0000 */ UObject* MemberParent;
    /* 0x0008 */ FString MemberScope;
    /* 0x0018 */ FName MemberName;
    /* 0x0024 */ FGuid MemberGuid;
    /* 0x0034 */ bool bSelfContext;
    /* 0x0035 */ bool bWasDeprecated;
};

// Size: 0x30
struct FMeshBuildSettings {
    /* 0x0000 */ bool bUseMikkTSpace;
    /* 0x0000 */ bool bRecomputeNormals;
    /* 0x0000 */ bool bRecomputeTangents;
    /* 0x0000 */ bool bComputeWeightedNormals;
    /* 0x0000 */ bool bRemoveDegenerates;
    /* 0x0000 */ bool bBuildAdjacencyBuffer;
    /* 0x0000 */ bool bBuildReversedIndexBuffer;
    /* 0x0000 */ bool bUseHighPrecisionTangentBasis;
    /* 0x0001 */ bool bUseFullPrecisionUVs;
    /* 0x0001 */ bool bGenerateLightmapUVs;
    /* 0x0001 */ bool bGenerateDistanceFieldAsIfTwoSided;
    /* 0x0001 */ bool bSupportFaceRemap;
    /* 0x0004 */ int32_t MinLightmapResolution;
    /* 0x0008 */ int32_t SrcLightmapIndex;
    /* 0x000c */ int32_t DstLightmapIndex;
    /* 0x0010 */ float BuildScale;
    /* 0x0014 */ FVector BuildScale3D;
    /* 0x0020 */ float DistanceFieldResolutionScale;
    /* 0x0024 */ float DistanceFieldBias;
    /* 0x0028 */ UStaticMesh* DistanceFieldReplacementMesh;
};

// Size: 0x500
class UMeshComponent : public UPrimitiveComponent {
    /* 0x04d8 */ TArray<UMaterialInterface*> OverrideMaterials;
    /* 0x04f8 */ bool bEnableMaterialParameterCaching;

    int32_t GetMaterialIndex(FName MaterialSlotName) const;
    TArray<FName> GetMaterialSlotNames() const;
    TArray<UMaterialInterface*> GetMaterials() const;
    bool IsMaterialSlotNameValid(FName MaterialSlotName) const;
    void PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, int32_t CinematicTextureGroups);
    void SetScalarParameterValueOnMaterials(const FName ParameterName, const float ParameterValue);
    void SetVectorParameterValueOnMaterials(const FName ParameterName, const FVector ParameterValue);
};

// Size: 0x18
struct FMeshInstancingSettings {
    /* 0x0000 */ UClass* ActorClassToUse;
    /* 0x0008 */ int32_t InstanceReplacementThreshold;
    /* 0x000c */ EMeshInstancingReplacementMethod MeshReplacementMethod;
    /* 0x000d */ bool bSkipMeshesWithVertexColors;
    /* 0x000e */ bool bUseHLODVolumes;
    /* 0x0010 */ UClass* ISMComponentToUse;
};

// Size: 0x338
class AMeshMergeCullingVolume : public AVolume {
};

// Size: 0xac
struct FMeshMergingSettings {
    /* 0x0000 */ int32_t TargetLightMapResolution;
    /* 0x0004 */ EUVOutput OutputUVs[8];
    /* 0x000c */ FMaterialProxySettings MaterialSettings;
    /* 0x0094 */ int32_t GutterSize;
    /* 0x0098 */ int32_t SpecificLOD;
    /* 0x009c */ EMeshLODSelectionType LODSelectionType;
    /* 0x009d */ bool bGenerateLightMapUV;
    /* 0x009d */ bool bComputedLightMapResolution;
    /* 0x009d */ bool bPivotPointAtZero;
    /* 0x009d */ bool bMergePhysicsData;
    /* 0x009d */ bool bMergeMaterials;
    /* 0x009d */ bool bCreateMergedMaterial;
    /* 0x009d */ bool bBakeVertexDataToMesh;
    /* 0x009d */ bool bUseVertexDataForBakingMaterial;
    /* 0x009e */ bool bUseTextureBinning;
    /* 0x009e */ bool bReuseMeshLightmapUVs;
    /* 0x009e */ bool bMergeEquivalentMaterials;
    /* 0x009e */ bool bUseLandscapeCulling;
    /* 0x009e */ bool bIncludeImposters;
    /* 0x009e */ bool bAllowDistanceField;
    /* 0x009e */ bool bImportVertexColors;
    /* 0x009e */ bool bCalculateCorrectLODModel;
    /* 0x009f */ bool bExportNormalMap;
    /* 0x009f */ bool bExportMetallicMap;
    /* 0x009f */ bool bExportRoughnessMap;
    /* 0x009f */ bool bExportSpecularMap;
    /* 0x00a0 */ int32_t MergedMaterialAtlasResolution;
    /* 0x00a4 */ int32_t ExportSpecificLOD;
};

// Size: 0xb4
struct FMeshProxySettings {
    /* 0x0000 */ int32_t ScreenSize;
    /* 0x0004 */ float VoxelSize;
    /* 0x0008 */ FMaterialProxySettings MaterialSettings;
    /* 0x0090 */ int32_t TextureWidth;
    /* 0x0094 */ int32_t TextureHeight;
    /* 0x0098 */ bool bExportNormalMap;
    /* 0x0098 */ bool bExportMetallicMap;
    /* 0x0098 */ bool bExportRoughnessMap;
    /* 0x0098 */ bool bExportSpecularMap;
    /* 0x0098 */ bool bBakeVertexData;
    /* 0x009c */ float MergeDistance;
    /* 0x00a0 */ FColor UnresolvedGeometryColor;
    /* 0x00a4 */ float MaxRayCastDist;
    /* 0x00a8 */ float HardAngleThreshold;
    /* 0x00ac */ int32_t LightMapResolution;
    /* 0x00b0 */ uint8_t NormalCalculationMethod;
    /* 0x00b1 */ uint8_t LandscapeCullingPrecision;
    /* 0x00b2 */ bool bCalculateCorrectLODModel;
    /* 0x00b2 */ bool bOverrideVoxelSize;
    /* 0x00b2 */ bool bOverrideTransferDistance;
    /* 0x00b2 */ bool bUseHardAngleThreshold;
    /* 0x00b2 */ bool bComputeLightMapResolution;
    /* 0x00b2 */ bool bRecalculateNormals;
    /* 0x00b2 */ bool bUseLandscapeCulling;
    /* 0x00b2 */ bool bAllowAdjacency;
    /* 0x00b3 */ bool bAllowDistanceField;
    /* 0x00b3 */ bool bReuseMeshLightmapUVs;
    /* 0x00b3 */ bool bCreateCollision;
    /* 0x00b3 */ bool bAllowVertexColors;
    /* 0x00b3 */ bool bGenerateLightmapUVs;
};

// Size: 0x24
struct FMeshReductionSettings {
    /* 0x0000 */ float PercentTriangles;
    /* 0x0004 */ float PercentVertices;
    /* 0x0008 */ float MaxDeviation;
    /* 0x000c */ float PixelError;
    /* 0x0010 */ float WeldingThreshold;
    /* 0x0014 */ float HardAngleThreshold;
    /* 0x0018 */ int32_t BaseLODModel;
    /* 0x001c */ uint8_t SilhouetteImportance;
    /* 0x001d */ uint8_t TextureImportance;
    /* 0x001e */ uint8_t ShadingImportance;
    /* 0x001f */ bool bRecalculateNormals;
    /* 0x001f */ bool bGenerateUniqueLightmapUVs;
    /* 0x001f */ bool bKeepSymmetry;
    /* 0x001f */ bool bVisibilityAided;
    /* 0x001f */ bool bCullOccluded;
    /* 0x0020 */ EStaticMeshReductionTerimationCriterion TerminationCriterion;
    /* 0x0021 */ uint8_t VisibilityAggressiveness;
    /* 0x0022 */ uint8_t VertexColorImportance;
};

// Size: 0x8
struct FMeshSectionInfo {
    /* 0x0000 */ int32_t MaterialIndex;
    /* 0x0004 */ bool bEnableCollision;
    /* 0x0005 */ bool bCastShadow;
    /* 0x0006 */ bool bVisibleInRayTracing;
    /* 0x0007 */ bool bForceOpaque;
};

// Size: 0x50
struct FMeshSectionInfoMap {
    /* 0x0000 */ TMap<uint32_t, FMeshSectionInfo> Map;
};

// Size: 0x70
class UMeshSimplificationSettings : public UDeveloperSettings {
    /* 0x0060 */ FName MeshReductionModuleName;
};

// Size: 0x14
struct FMeshUVChannelInfo {
    /* 0x0000 */ bool bInitialized;
    /* 0x0001 */ bool bOverrideDensities;
    /* 0x0004 */ float LocalUVDensities[4];
};

// Size: 0x30
class UMeshVertexPainterKismetLibrary : public UBlueprintFunctionLibrary {

    static void PaintVerticesLerpAlongAxis(UStaticMeshComponent* StaticMeshComponent, const FLinearColor& StartColor, const FLinearColor& EndColor, EVertexPaintAxis Axis, bool bConvertToSRGB);
    static void PaintVerticesSingleColor(UStaticMeshComponent* StaticMeshComponent, const FLinearColor& FillColor, bool bConvertToSRGB);
    static void RemovePaintedVertices(UStaticMeshComponent* StaticMeshComponent);
};

// Size: 0x70
class UMicroTransactionBase : public UPlatformInterfaceBase {
    /* 0x0040 */ TArray<FPurchaseInfo> AvailableProducts;
    /* 0x0050 */ FString LastError;
    /* 0x0060 */ FString LastErrorSolution;
};

// Size: 0x620
struct FMinimalViewInfo {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FRotator Rotation;
    /* 0x0018 */ float FOV;
    /* 0x001c */ float DesiredFOV;
    /* 0x0020 */ float OrthoWidth;
    /* 0x0024 */ float OrthoNearClipPlane;
    /* 0x0028 */ float OrthoFarClipPlane;
    /* 0x002c */ float AspectRatio;
    /* 0x0030 */ bool bConstrainAspectRatio;
    /* 0x0030 */ bool bUseFieldOfViewForLOD;
    /* 0x0034 */ uint8_t ProjectionMode;
    /* 0x0038 */ float PostProcessBlendWeight;
    /* 0x0040 */ FPostProcessSettings PostProcessSettings;
    /* 0x05d0 */ FVector2D OffCenterProjectionOffset;
};

// Size: 0x318
class UModel : public UObject {
};

// Size: 0x520
class UModelComponent : public UPrimitiveComponent {
    /* 0x04f0 */ UBodySetup* ModelBodySetup;
};

enum class ModulationParamMode {
    MPM_Normal = 0,
    MPM_Abs = 1,
    MPM_Direct = 2,
    MPM_MAX = 3,
};

// Size: 0x24
struct FModulatorContinuousParams {
    /* 0x0000 */ FName ParameterName;
    /* 0x000c */ float Default;
    /* 0x0010 */ float MinInput;
    /* 0x0014 */ float MaxInput;
    /* 0x0018 */ float MinOutput;
    /* 0x001c */ float MaxOutput;
    /* 0x0020 */ uint8_t ParamMode;
};

// Size: 0x48
class UMorphTarget : public UObject {
    /* 0x0030 */ USkeletalMesh* BaseSkelMesh;
};

// Size: 0x100
class UMovementComponent : public UActorComponent {
    /* 0x00c0 */ USceneComponent* UpdatedComponent;
    /* 0x00c8 */ UPrimitiveComponent* UpdatedPrimitive;
    /* 0x00d4 */ FVector Velocity;
    /* 0x00e0 */ FVector PlaneConstraintNormal;
    /* 0x00ec */ FVector PlaneConstraintOrigin;
    /* 0x00f8 */ bool bUpdateOnlyIfRendered;
    /* 0x00f8 */ bool bAutoUpdateTickRegistration;
    /* 0x00f8 */ bool bTickBeforeOwner;
    /* 0x00f8 */ bool bAutoRegisterUpdatedComponent;
    /* 0x00f8 */ bool bConstrainToPlane;
    /* 0x00f8 */ bool bSnapToPlaneAtStart;
    /* 0x00f8 */ bool bAutoRegisterPhysicsVolumeUpdates;
    /* 0x00f8 */ bool bComponentShouldUpdatePhysicsVolume;
    /* 0x00fc */ EPlaneConstraintAxisSetting PlaneConstraintAxisSetting;

    FVector ConstrainDirectionToPlane(FVector Direction) const;
    FVector ConstrainLocationToPlane(FVector Location) const;
    FVector ConstrainNormalToPlane(FVector Normal) const;
    float GetGravityZ() const;
    float GetMaxSpeed() const;
    APhysicsVolume* GetPhysicsVolume() const;
    EPlaneConstraintAxisSetting GetPlaneConstraintAxisSetting() const;
    FVector GetPlaneConstraintNormal() const;
    FVector GetPlaneConstraintOrigin() const;
    bool IsExceedingMaxSpeed(float MaxSpeed) const;
    float K2_GetMaxSpeedModifier() const;
    float K2_GetModifiedMaxSpeed() const;
    bool K2_MoveUpdatedComponent(FVector Delta, FRotator NewRotation, FHitResult& OutHit, bool bSweep, bool bTeleport);
    void PhysicsVolumeChanged(APhysicsVolume* NewVolume);
    void SetPlaneConstraintAxisSetting(EPlaneConstraintAxisSetting NewAxisSetting);
    void SetPlaneConstraintEnabled(bool bEnabled);
    void SetPlaneConstraintFromVectors(FVector Forward, FVector Up);
    void SetPlaneConstraintNormal(FVector PlaneNormal);
    void SetPlaneConstraintOrigin(FVector PlaneOrigin);
    void SetUpdatedComponent(USceneComponent* NewUpdatedComponent);
    void SnapUpdatedComponentToPlane();
    void StopMovementImmediately();
};

// Size: 0x1
struct FMovementProperties {
    /* 0x0000 */ bool bCanCrouch;
    /* 0x0000 */ bool bCanJump;
    /* 0x0000 */ bool bCanWalk;
    /* 0x0000 */ bool bCanSwim;
    /* 0x0000 */ bool bCanFly;
};

// Size: 0x18
struct FMulticastRecordOptions {
    /* 0x0000 */ FString FuncPathName;
    /* 0x0010 */ bool bServerSkip;
    /* 0x0011 */ bool bClientSkip;
};

// Size: 0x78
struct FNameCurve : public FIndexedCurve {
    /* 0x0068 */ TArray<FNameCurveKey> Keys;
};

// Size: 0x10
struct FNameCurveKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ FName Value;
};

// Size: 0x18
struct FNameMapping {
    /* 0x0000 */ FName NodeName;
    /* 0x000c */ FName BoneName;
};

// Size: 0x10
struct FNamedColor {
    /* 0x0000 */ FColor Value;
    /* 0x0004 */ FName Name;
};

// Size: 0x10
struct FNamedCurveValue {
    /* 0x0000 */ FName Name;
    /* 0x000c */ float Value;
};

// Size: 0x18
struct FNamedEmitterMaterial {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ UMaterialInterface* Material;
};

// Size: 0x10
struct FNamedFloat {
    /* 0x0000 */ float Value;
    /* 0x0004 */ FName Name;
};

// Size: 0x10
struct FNamedNetDriver {
    /* 0x0000 */ UNetDriver* NetDriver;
};

// Size: 0x40
struct FNamedTransform {
    /* 0x0000 */ FTransform Value;
    /* 0x0030 */ FName Name;
};

// Size: 0x18
struct FNamedVector {
    /* 0x0000 */ FVector Value;
    /* 0x000c */ FName Name;
};

// Size: 0x30
class INavAgentInterface : public UInterface {
};

// Size: 0x38
struct FNavAgentProperties : public FMovementProperties {
    /* 0x0004 */ float AgentRadius;
    /* 0x0008 */ float AgentHeight;
    /* 0x000c */ float AgentStepHeight;
    /* 0x0010 */ float NavWalkingSearchHeightScale;
    /* 0x0018 */ FSoftClassPath PreferredNavData;
};

// Size: 0x4
struct FNavAgentSelector {
    /* 0x0000 */ bool bSupportsAgent0;
    /* 0x0000 */ bool bSupportsAgent1;
    /* 0x0000 */ bool bSupportsAgent2;
    /* 0x0000 */ bool bSupportsAgent3;
    /* 0x0000 */ bool bSupportsAgent4;
    /* 0x0000 */ bool bSupportsAgent5;
    /* 0x0000 */ bool bSupportsAgent6;
    /* 0x0000 */ bool bSupportsAgent7;
    /* 0x0001 */ bool bSupportsAgent8;
    /* 0x0001 */ bool bSupportsAgent9;
    /* 0x0001 */ bool bSupportsAgent10;
    /* 0x0001 */ bool bSupportsAgent11;
    /* 0x0001 */ bool bSupportsAgent12;
    /* 0x0001 */ bool bSupportsAgent13;
    /* 0x0001 */ bool bSupportsAgent14;
    /* 0x0001 */ bool bSupportsAgent15;
};

// Size: 0x38
class UNavAreaBase : public UObject {
};

// Size: 0x3c
struct FNavAvoidanceData {
};

// Size: 0x4
struct FNavAvoidanceMask {
    /* 0x0000 */ bool bGroup0;
    /* 0x0000 */ bool bGroup1;
    /* 0x0000 */ bool bGroup2;
    /* 0x0000 */ bool bGroup3;
    /* 0x0000 */ bool bGroup4;
    /* 0x0000 */ bool bGroup5;
    /* 0x0000 */ bool bGroup6;
    /* 0x0000 */ bool bGroup7;
    /* 0x0001 */ bool bGroup8;
    /* 0x0001 */ bool bGroup9;
    /* 0x0001 */ bool bGroup10;
    /* 0x0001 */ bool bGroup11;
    /* 0x0001 */ bool bGroup12;
    /* 0x0001 */ bool bGroup13;
    /* 0x0001 */ bool bGroup14;
    /* 0x0001 */ bool bGroup15;
    /* 0x0002 */ bool bGroup16;
    /* 0x0002 */ bool bGroup17;
    /* 0x0002 */ bool bGroup18;
    /* 0x0002 */ bool bGroup19;
    /* 0x0002 */ bool bGroup20;
    /* 0x0002 */ bool bGroup21;
    /* 0x0002 */ bool bGroup22;
    /* 0x0002 */ bool bGroup23;
    /* 0x0003 */ bool bGroup24;
    /* 0x0003 */ bool bGroup25;
    /* 0x0003 */ bool bGroup26;
    /* 0x0003 */ bool bGroup27;
    /* 0x0003 */ bool bGroup28;
    /* 0x0003 */ bool bGroup29;
    /* 0x0003 */ bool bGroup30;
    /* 0x0003 */ bool bGroup31;
};

// Size: 0x98
class UNavCollisionBase : public UObject {
    /* 0x0030 */ bool bIsDynamicObstacle;
};

// Size: 0xb0
struct FNavDataConfig : public FNavAgentProperties {
    /* 0x0038 */ FName Name;
    /* 0x0044 */ FColor Color;
    /* 0x0048 */ FVector DefaultQueryExtent;
    /* 0x0058 */ UClass* NavigationDataClass;
    /* 0x0080 */ TSoftClassPtr<AActor> NavDataClass;
};

// Size: 0x30
class INavEdgeProviderInterface : public UInterface {
};

// Size: 0x58
class UNavLinkDefinition : public UObject {
    /* 0x0030 */ TArray<FNavigationLink> Links;
    /* 0x0040 */ TArray<FNavigationSegmentLink> SegmentLinks;
};

// Size: 0x148
class UNavMovementComponent : public UMovementComponent {
    /* 0x0100 */ FNavAgentProperties NavAgentProps;
    /* 0x0138 */ float FixedPathBrakingDistance;
    /* 0x013c */ bool bUpdateNavAgentWithOwnersCollision;
    /* 0x013c */ bool bUseAccelerationForPaths;
    /* 0x013c */ bool bUseFixedBrakingDistanceForPaths;
    /* 0x013d */ FMovementProperties MovementState;
    /* 0x0140 */ UObject* PathFollowingComp;

    bool IsCrouching() const;
    bool IsFalling() const;
    bool IsFlying() const;
    bool IsMovingOnGround() const;
    bool IsSwimming() const;
    void StopActiveMovement();
    void StopMovementKeepPathing();
};

// Size: 0x30
class INavPathObserverInterface : public UInterface {
};

// Size: 0x30
class INavRelevantInterface : public UInterface {
};

// Size: 0x40
class UNavigationDataChunk : public UObject {
    /* 0x0030 */ FName NavigationDataName;
};

// Size: 0x30
class INavigationDataInterface : public UInterface {
};

// Size: 0x60
struct FNavigationLink : public FNavigationLinkBase {
    /* 0x0048 */ FVector Left;
    /* 0x0054 */ FVector Right;
};

// Size: 0x48
struct FNavigationLinkBase {
    /* 0x0000 */ float LeftProjectHeight;
    /* 0x0004 */ float MaxFallDownLength;
    /* 0x000c */ float SnapRadius;
    /* 0x0010 */ float SnapHeight;
    /* 0x0014 */ FNavAgentSelector SupportedAgents;
    /* 0x0018 */ bool bSupportsAgent0;
    /* 0x0018 */ bool bSupportsAgent1;
    /* 0x0018 */ bool bSupportsAgent2;
    /* 0x0018 */ bool bSupportsAgent3;
    /* 0x0018 */ bool bSupportsAgent4;
    /* 0x0018 */ bool bSupportsAgent5;
    /* 0x0018 */ bool bSupportsAgent6;
    /* 0x0018 */ bool bSupportsAgent7;
    /* 0x0019 */ bool bSupportsAgent8;
    /* 0x0019 */ bool bSupportsAgent9;
    /* 0x0019 */ bool bSupportsAgent10;
    /* 0x0019 */ bool bSupportsAgent11;
    /* 0x0019 */ bool bSupportsAgent12;
    /* 0x0019 */ bool bSupportsAgent13;
    /* 0x0019 */ bool bSupportsAgent14;
    /* 0x0019 */ bool bSupportsAgent15;
    /* 0x0020 */ FString Description;
    /* 0x0030 */ uint8_t Direction;
    /* 0x0031 */ bool bUseSnapHeight;
    /* 0x0031 */ bool bSnapToCheapestArea;
    /* 0x0031 */ bool bCustomFlag0;
    /* 0x0031 */ bool bCustomFlag1;
    /* 0x0031 */ bool bCustomFlag2;
    /* 0x0031 */ bool bCustomFlag3;
    /* 0x0031 */ bool bCustomFlag4;
    /* 0x0031 */ bool bCustomFlag5;
    /* 0x0032 */ bool bCustomFlag6;
    /* 0x0032 */ bool bCustomFlag7;
    /* 0x0038 */ UClass* AreaClass;
};

// Size: 0x320
class ANavigationObjectBase : public AActor {
    /* 0x0300 */ UCapsuleComponent* CapsuleComponent;
    /* 0x0308 */ UBillboardComponent* GoodSprite;
    /* 0x0310 */ UBillboardComponent* BadSprite;
    /* 0x0318 */ bool bIsPIEPlayerStart;
};

// Size: 0x78
struct FNavigationSegmentLink : public FNavigationLinkBase {
    /* 0x0048 */ FVector LeftStart;
    /* 0x0054 */ FVector LeftEnd;
    /* 0x0060 */ FVector RightStart;
    /* 0x006c */ FVector RightEnd;
};

// Size: 0x30
class UNavigationSystemBase : public UObject {
};

// Size: 0x68
class UNavigationSystemConfig : public UObject {
    /* 0x0030 */ FSoftClassPath NavigationSystemClass;
    /* 0x0050 */ FNavAgentSelector SupportedAgentsMask;
    /* 0x0054 */ FName DefaultAgentName;
    /* 0x0060 */ bool bIsOverriden;
};

// Size: 0x1c38
class UNetConnection : public UPlayer {
    /* 0x0050 */ TArray<UChildConnection*> Children;
    /* 0x0060 */ UNetDriver* Driver;
    /* 0x0068 */ UClass* PackageMapClass;
    /* 0x0070 */ UPackageMap* PackageMap;
    /* 0x0078 */ TArray<UChannel*> OpenChannels;
    /* 0x0088 */ TArray<AActor*> SentTemporaries;
    /* 0x0098 */ AActor* ViewTarget;
    /* 0x00a0 */ AActor* OwningActor;
    /* 0x00a8 */ int32_t MaxPacket;
    /* 0x00ac */ bool InternalAck;
    /* 0x0168 */ FUniqueNetIdRepl PlayerId;
    /* 0x01d8 */ double LastReceiveTime;
    /* 0x1580 */ TArray<UChannel*> ChannelsToTick;
};

// Size: 0x7c8
class UNetDriver : public UObject {
    /* 0x0038 */ FString NetConnectionClassName;
    /* 0x0048 */ FString ReplicationDriverClassName;
    /* 0x0058 */ int32_t MaxDownloadSize;
    /* 0x005c */ bool bClampListenServerTickRate;
    /* 0x0060 */ int32_t NetServerMaxTickRate;
    /* 0x0064 */ int32_t MaxNetTickRate;
    /* 0x0068 */ int32_t MaxInternetClientRate;
    /* 0x006c */ int32_t MaxClientRate;
    /* 0x0070 */ float ServerTravelPause;
    /* 0x0074 */ float SpawnPrioritySeconds;
    /* 0x0078 */ float RelevantTimeout;
    /* 0x007c */ float KeepAliveTime;
    /* 0x0080 */ float InitialConnectTimeout;
    /* 0x0084 */ float ConnectionTimeout;
    /* 0x0088 */ float TimeoutMultiplierForUnoptimizedBuilds;
    /* 0x008c */ bool bNoTimeouts;
    /* 0x008d */ bool bNeverApplyNetworkEmulationSettings;
    /* 0x0090 */ UNetConnection* ServerConnection;
    /* 0x0098 */ TArray<UNetConnection*> ClientConnections;
    /* 0x0108 */ int32_t RecentlyDisconnectedTrackingTime;
    /* 0x0148 */ UWorld* World;
    /* 0x0150 */ UPackage* WorldPackage;
    /* 0x0178 */ UClass* NetConnectionClass;
    /* 0x0180 */ UClass* ReplicationDriverClass;
    /* 0x0198 */ FName NetDriverName;
    /* 0x01a8 */ TArray<FChannelDefinition> ChannelDefinitions;
    /* 0x01b8 */ TMap<FName, FChannelDefinition> ChannelDefinitionMap;
    /* 0x0208 */ TArray<UChannel*> ActorChannelPool;
    /* 0x0220 */ float Time;
    /* 0x0768 */ UReplicationDriver* ReplicationDriver;
};

// Size: 0x24
struct FNetDriverDefinition {
    /* 0x0000 */ FName DefName;
    /* 0x000c */ FName DriverClassName;
    /* 0x0018 */ FName DriverClassNameFallback;
};

// Size: 0x30
class UNetPushModelHelpers : public UBlueprintFunctionLibrary {

    static void MarkPropertyDirty(UObject* Object, FName PropertyName);
    static void MarkPropertyDirtyFromRepIndex(UObject* Object, int32_t RepIndex, FName PropertyName);
};

// Size: 0x30
struct FNetViewer {
    /* 0x0000 */ UNetConnection* Connection;
    /* 0x0008 */ AActor* InViewer;
    /* 0x0010 */ AActor* ViewTarget;
    /* 0x0018 */ FVector ViewLocation;
    /* 0x0024 */ FVector ViewDir;
};

// Size: 0x20
struct FNetworkEmulationProfileDescription {
    /* 0x0000 */ FString ProfileName;
    /* 0x0010 */ FString Tooltip;
};

// Size: 0x30
class INetworkPredictionInterface : public UInterface {
};

// Size: 0x80
class UNetworkSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bVerifyPeer;
    /* 0x0060 */ bool bEnableMultiplayerWorldOriginRebasing;
    /* 0x0064 */ int32_t MaxRepArraySize;
    /* 0x0068 */ int32_t MaxRepArrayMemory;
    /* 0x0070 */ TArray<FNetworkEmulationProfileDescription> NetworkEmulationProfiles;
};

// Size: 0x70
struct FNode {
    /* 0x0000 */ FName Name;
    /* 0x000c */ FName ParentName;
    /* 0x0020 */ FTransform Transform;
    /* 0x0050 */ FString DisplayName;
    /* 0x0060 */ bool bAdvanced;
};

// Size: 0x40
struct FNodeItem {
    /* 0x0000 */ FName ParentName;
    /* 0x0010 */ FTransform Transform;
};

// Size: 0x180
class UNodeMappingContainer : public UObject {
    /* 0x0030 */ TMap<FName, FNodeItem> SourceItems;
    /* 0x0080 */ TMap<FName, FNodeItem> TargetItems;
    /* 0x00d0 */ TMap<FName, FName> SourceToTarget;
    /* 0x0120 */ TSoftObjectPtr<UObject> SourceAsset;
    /* 0x0150 */ TSoftObjectPtr<UObject> TargetAsset;
};

// Size: 0x30
class INodeMappingProviderInterface : public UInterface {
};

// Size: 0x14
struct FNodeToCodeAssociation {
};

// Size: 0x318
class ANote : public AActor {
    /* 0x02f8 */ FString text;
    /* 0x0308 */ UBillboardComponent* SpriteComponent;
    /* 0x0310 */ UArrowComponent* ArrowComponent;
};

// Size: 0x68
class UNullNavSysConfig : public UNavigationSystemConfig {
};

// Size: 0xc8
class UObjectLibrary : public UObject {
    /* 0x0030 */ UClass* ObjectBaseClass;
    /* 0x0038 */ bool bHasBlueprintClasses;
    /* 0x0040 */ TArray<UObject*> Objects;
    /* 0x0050 */ TArray<TWeakObjectPtr<UObject>> WeakObjects;
    /* 0x0060 */ bool bUseWeakReferences;
    /* 0x0061 */ bool bIsFullyLoaded;
};

// Size: 0x40
class UObjectReferencer : public UObject {
    /* 0x0030 */ TArray<UObject*> ReferencedObjects;
};

// Size: 0x40
class UObjectTraceWorldSubsystem : public UWorldSubsystem {
};

// Size: 0x38
class UOnlineBlueprintCallProxyBase : public UBlueprintAsyncActionBase {
};

// Size: 0x30
class UOnlineEngineInterface : public UObject {
};

// Size: 0x30
class UOnlineSession : public UObject {
};

// Size: 0x4
struct FOrbitOptions {
    /* 0x0000 */ bool bProcessDuringSpawn;
    /* 0x0000 */ bool bProcessDuringUpdate;
    /* 0x0000 */ bool bUseEmitterTime;
};

// Size: 0x18
struct FOverlapResult {
    /* 0x0000 */ TWeakObjectPtr<AActor> Actor;
    /* 0x0008 */ TWeakObjectPtr<UPrimitiveComponent> Component;
    /* 0x0014 */ bool bBlockingHit;
};

// Size: 0x1c
struct FPOV {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FRotator Rotation;
    /* 0x0018 */ float FOV;
};

// Size: 0x38
struct FPSCPool {
    /* 0x0000 */ TArray<FPSCPoolElem> FreeElements;
};

// Size: 0x10
struct FPSCPoolElem {
    /* 0x0000 */ UParticleSystemComponent* PSC;
};

// Size: 0x410
class UPackageMapClient : public UPackageMap {
};

// Size: 0x34
struct FPacketSimulationSettings {
    /* 0x0000 */ int32_t PktLoss;
    /* 0x0004 */ int32_t PktLossMaxSize;
    /* 0x0008 */ int32_t PktLossMinSize;
    /* 0x000c */ int32_t PktOrder;
    /* 0x0010 */ int32_t PktDup;
    /* 0x0014 */ int32_t PktLag;
    /* 0x0018 */ int32_t PktLagVariance;
    /* 0x001c */ int32_t PktLagMin;
    /* 0x0020 */ int32_t PktLagMax;
    /* 0x0024 */ int32_t PktIncomingLagMin;
    /* 0x0028 */ int32_t PktIncomingLagMax;
    /* 0x002c */ int32_t PktIncomingLoss;
    /* 0x0030 */ int32_t PktJitter;
};

// Size: 0x370
class APainCausingVolume : public APhysicsVolume {
    /* 0x0348 */ bool bPainCausing;
    /* 0x034c */ float DamagePerSec;
    /* 0x0350 */ UClass* DamageType;
    /* 0x0358 */ float PainInterval;
    /* 0x035c */ bool bEntryPain;
    /* 0x035c */ bool BACKUP_bPainCausing;
    /* 0x0360 */ AController* DamageInstigator;
};

// Size: 0x20
struct FPaintedVertex {
    /* 0x0000 */ FVector Position;
    /* 0x000c */ FColor Color;
    /* 0x0010 */ FVector4 Normal;
};

// Size: 0x60
struct FParameterChannelNames {
    /* 0x0000 */ FText R;
    /* 0x0018 */ FText G;
    /* 0x0030 */ FText B;
    /* 0x0048 */ FText A;
};

// Size: 0x18
struct FParameterGroupData {
    /* 0x0000 */ FString GroupName;
    /* 0x0010 */ int32_t GroupSortPriority;
};

// Size: 0xc
struct FParticleBurst {
    /* 0x0000 */ int32_t Count;
    /* 0x0004 */ int32_t CountLow;
    /* 0x0008 */ float Time;
};

// Size: 0x18
struct FParticleCurvePair {
    /* 0x0000 */ FString CurveName;
    /* 0x0010 */ UObject* CurveObject;
};

// Size: 0x10
struct FParticleEditorPromotionSettings {
    /* 0x0000 */ FFilePath DefaultParticleAsset;
};

// Size: 0x1e8
class UParticleEmitter : public UObject {
    /* 0x0030 */ FName EmitterName;
    /* 0x003c */ int32_t SubUVDataOffset;
    /* 0x0040 */ uint8_t EmitterRenderMode;
    /* 0x0041 */ EParticleSignificanceLevel SignificanceLevel;
    /* 0x0043 */ bool bUseLegacySpawningBehavior;
    /* 0x0043 */ bool ConvertedModules;
    /* 0x0043 */ bool bIsSoloing;
    /* 0x0043 */ bool bCookedOut;
    /* 0x0043 */ bool bDisabledLODsKeepEmitterAlive;
    /* 0x0044 */ bool bDisableWhenInsignficant;
    /* 0x0044 */ bool bCollapsed;
    /* 0x0045 */ uint8_t DetailMode;
    /* 0x0048 */ FColor EmitterEditorColor;
    /* 0x0050 */ TArray<UParticleLODLevel*> LODLevels;
    /* 0x0060 */ int32_t PeakActiveParticles;
    /* 0x0064 */ int32_t InitialAllocationCount;
    /* 0x0068 */ float QualityLevelSpawnRateScale;
    /* 0x006c */ uint32_t DetailModeBitmask;
    /* 0x0070 */ FString DetailModeDisplay;
};

// Size: 0x10
struct FParticleEmitterReplayFrame {
};

// Size: 0x2f8
class AParticleEventManager : public AActor {
};

// Size: 0x30
struct FParticleEvent_GenerateInfo {
    /* 0x0000 */ uint8_t Type;
    /* 0x0004 */ int32_t Frequency;
    /* 0x0008 */ int32_t ParticleFrequency;
    /* 0x000c */ bool FirstTimeOnly;
    /* 0x000c */ bool LastTimeOnly;
    /* 0x000c */ bool UseReflectedImpactVector;
    /* 0x000c */ bool bUseOrbitOffset;
    /* 0x0010 */ FName CustomName;
    /* 0x0020 */ TArray<UParticleModuleEventSendToGame*> ParticleModuleEventsToSendToGame;
};

// Size: 0xc0
class UParticleLODLevel : public UObject {
    /* 0x0030 */ int32_t Level;
    /* 0x0034 */ bool bEnabled;
    /* 0x0038 */ UParticleModuleRequired* RequiredModule;
    /* 0x0040 */ TArray<UParticleModule*> Modules;
    /* 0x0050 */ UParticleModuleTypeDataBase* TypeDataModule;
    /* 0x0058 */ UParticleModuleSpawn* SpawnModule;
    /* 0x0060 */ UParticleModuleEventGenerator* EventGenerator;
    /* 0x0068 */ TArray<UParticleModuleSpawnBase*> SpawningModules;
    /* 0x0078 */ TArray<UParticleModule*> SpawnModules;
    /* 0x0088 */ TArray<UParticleModule*> UpdateModules;
    /* 0x0098 */ TArray<UParticleModuleOrbit*> OrbitModules;
    /* 0x00a8 */ TArray<UParticleModuleEventReceiverBase*> EventReceiverModules;
    /* 0x00b8 */ bool ConvertedModules;
    /* 0x00bc */ int32_t PeakActiveParticles;
};

// Size: 0x38
class UParticleModule : public UObject {
    /* 0x0030 */ bool bSpawnModule;
    /* 0x0030 */ bool bUpdateModule;
    /* 0x0030 */ bool bFinalUpdateModule;
    /* 0x0030 */ bool bUpdateForGPUEmitter;
    /* 0x0030 */ bool bCurvesAsColor;
    /* 0x0030 */ bool b3DDrawMode;
    /* 0x0030 */ bool bSupported3DDrawMode;
    /* 0x0030 */ bool bEnabled;
    /* 0x0031 */ bool bEditable;
    /* 0x0031 */ bool LODDuplicate;
    /* 0x0031 */ bool bSupportsRandomSeed;
    /* 0x0031 */ bool bRequiresLoopingNotification;
    /* 0x0032 */ uint8_t LODValidity;
    /* 0x0034 */ FColor ModuleEditorColor;
};

// Size: 0x90
class UParticleModuleAcceleration : public UParticleModuleAccelerationBase {
    /* 0x0040 */ FRawDistributionVector Acceleration;
    /* 0x0088 */ bool bApplyOwnerScale;
};

// Size: 0x40
class UParticleModuleAccelerationBase : public UParticleModule {
    /* 0x0038 */ bool bAlwaysInWorldSpace;
};

// Size: 0x50
class UParticleModuleAccelerationConstant : public UParticleModuleAccelerationBase {
    /* 0x0040 */ FVector Acceleration;
};

// Size: 0x78
class UParticleModuleAccelerationDrag : public UParticleModuleAccelerationBase {
    /* 0x0040 */ UDistributionFloat* DragCoefficient;
    /* 0x0048 */ FRawDistributionFloat DragCoefficientRaw;
};

// Size: 0x78
class UParticleModuleAccelerationDragScaleOverLife : public UParticleModuleAccelerationBase {
    /* 0x0040 */ UDistributionFloat* DragScale;
    /* 0x0048 */ FRawDistributionFloat DragScaleRaw;
};

// Size: 0x88
class UParticleModuleAccelerationOverLifetime : public UParticleModuleAccelerationBase {
    /* 0x0040 */ FRawDistributionVector AccelOverLife;
};

// Size: 0x38
class UParticleModuleAttractorBase : public UParticleModule {
};

// Size: 0xb0
class UParticleModuleAttractorLine : public UParticleModuleAttractorBase {
    /* 0x0038 */ FVector EndPoint0;
    /* 0x0044 */ FVector EndPoint1;
    /* 0x0050 */ FRawDistributionFloat Range;
    /* 0x0080 */ FRawDistributionFloat Strength;
};

// Size: 0xc0
class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase {
    /* 0x0038 */ FName EmitterName;
    /* 0x0048 */ FRawDistributionFloat Range;
    /* 0x0078 */ bool bStrengthByDistance;
    /* 0x0080 */ FRawDistributionFloat Strength;
    /* 0x00b0 */ bool bAffectBaseVelocity;
    /* 0x00b4 */ uint8_t SelectionMethod;
    /* 0x00b8 */ bool bRenewSource;
    /* 0x00b8 */ bool bInheritSourceVel;
    /* 0x00bc */ int32_t LastSelIndex;
};

// Size: 0xe8
class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase {
    /* 0x0038 */ FRawDistributionVector Position;
    /* 0x0080 */ FRawDistributionFloat Range;
    /* 0x00b0 */ FRawDistributionFloat Strength;
    /* 0x00e0 */ bool StrengthByDistance;
    /* 0x00e0 */ bool bAffectBaseVelocity;
    /* 0x00e0 */ bool bOverrideVelocity;
    /* 0x00e0 */ bool bUseWorldSpacePosition;
    /* 0x00e0 */ bool Positive_X;
    /* 0x00e0 */ bool Positive_Y;
    /* 0x00e0 */ bool Positive_Z;
    /* 0x00e0 */ bool Negative_X;
    /* 0x00e1 */ bool Negative_Y;
    /* 0x00e1 */ bool Negative_Z;
};

// Size: 0x80
class UParticleModuleAttractorPointGravity : public UParticleModuleAttractorBase {
    /* 0x0038 */ FVector Position;
    /* 0x0044 */ float Radius;
    /* 0x0048 */ UDistributionFloat* Strength;
    /* 0x0050 */ FRawDistributionFloat StrengthRaw;
};

// Size: 0x38
class UParticleModuleBeamBase : public UParticleModule {
};

// Size: 0x110
class UParticleModuleBeamModifier : public UParticleModuleBeamBase {
    /* 0x0038 */ uint8_t ModifierType;
    /* 0x003c */ FBeamModifierOptions PositionOptions;
    /* 0x0040 */ FRawDistributionVector Position;
    /* 0x0088 */ FBeamModifierOptions TangentOptions;
    /* 0x0090 */ FRawDistributionVector Tangent;
    /* 0x00d8 */ bool bAbsoluteTangent;
    /* 0x00dc */ FBeamModifierOptions StrengthOptions;
    /* 0x00e0 */ FRawDistributionFloat Strength;
};

// Size: 0x198
class UParticleModuleBeamNoise : public UParticleModuleBeamBase {
    /* 0x0038 */ bool bLowFreq_Enabled;
    /* 0x003c */ int32_t Frequency;
    /* 0x0040 */ int32_t Frequency_LowRange;
    /* 0x0048 */ FRawDistributionVector NoiseRange;
    /* 0x0090 */ FRawDistributionFloat NoiseRangeScale;
    /* 0x00c0 */ bool bNRScaleEmitterTime;
    /* 0x00c8 */ FRawDistributionVector NoiseSpeed;
    /* 0x0110 */ bool bSmooth;
    /* 0x0114 */ float NoiseLockRadius;
    /* 0x0118 */ bool bNoiseLock;
    /* 0x0118 */ bool bOscillate;
    /* 0x011c */ float NoiseLockTime;
    /* 0x0120 */ float NoiseTension;
    /* 0x0124 */ bool bUseNoiseTangents;
    /* 0x0128 */ FRawDistributionFloat NoiseTangentStrength;
    /* 0x0158 */ int32_t NoiseTessellation;
    /* 0x015c */ bool bTargetNoise;
    /* 0x0160 */ float FrequencyDistance;
    /* 0x0164 */ bool bApplyNoiseScale;
    /* 0x0168 */ FRawDistributionFloat NoiseScale;
};

// Size: 0x128
class UParticleModuleBeamSource : public UParticleModuleBeamBase {
    /* 0x0038 */ uint8_t SourceMethod;
    /* 0x003c */ FName SourceName;
    /* 0x0048 */ bool bSourceAbsolute;
    /* 0x0050 */ FRawDistributionVector Source;
    /* 0x0098 */ bool bLockSource;
    /* 0x009c */ uint8_t SourceTangentMethod;
    /* 0x00a0 */ FRawDistributionVector SourceTangent;
    /* 0x00e8 */ bool bLockSourceTangent;
    /* 0x00f0 */ FRawDistributionFloat SourceStrength;
    /* 0x0120 */ bool bLockSourceStength;
};

// Size: 0x128
class UParticleModuleBeamTarget : public UParticleModuleBeamBase {
    /* 0x0038 */ uint8_t TargetMethod;
    /* 0x003c */ FName TargetName;
    /* 0x0048 */ FRawDistributionVector Target;
    /* 0x0090 */ bool bTargetAbsolute;
    /* 0x0090 */ bool bLockTarget;
    /* 0x0094 */ uint8_t TargetTangentMethod;
    /* 0x0098 */ FRawDistributionVector TargetTangent;
    /* 0x00e0 */ bool bLockTargetTangent;
    /* 0x00e8 */ FRawDistributionFloat TargetStrength;
    /* 0x0118 */ bool bLockTargetStength;
    /* 0x011c */ float LockRadius;
};

// Size: 0x38
class UParticleModuleCameraBase : public UParticleModule {
};

// Size: 0x70
class UParticleModuleCameraOffset : public UParticleModuleCameraBase {
    /* 0x0038 */ FRawDistributionFloat CameraOffset;
    /* 0x0068 */ bool bSpawnTimeOnly;
    /* 0x006c */ uint8_t UpdateMethod;
};

// Size: 0x198
class UParticleModuleCollision : public UParticleModuleCollisionBase {
    /* 0x0038 */ FRawDistributionVector DampingFactor;
    /* 0x0080 */ FRawDistributionVector DampingFactorRotation;
    /* 0x00c8 */ FRawDistributionFloat MaxCollisions;
    /* 0x00f8 */ uint8_t CollisionCompletionOption;
    /* 0x0100 */ TArray<uint8_t> CollisionTypes;
    /* 0x0118 */ bool bApplyPhysics;
    /* 0x0118 */ bool bIgnoreTriggerVolumes;
    /* 0x0120 */ FRawDistributionFloat ParticleMass;
    /* 0x0150 */ float DirScalar;
    /* 0x0154 */ bool bPawnsDoNotDecrementCount;
    /* 0x0154 */ bool bOnlyVerticalNormalsDecrementCount;
    /* 0x0158 */ float VerticalFudgeFactor;
    /* 0x0160 */ FRawDistributionFloat DelayAmount;
    /* 0x0190 */ bool bDropDetail;
    /* 0x0190 */ bool bCollideOnlyIfVisible;
    /* 0x0190 */ bool bIgnoreSourceActor;
    /* 0x0194 */ float MaxCollisionDistance;
};

// Size: 0x38
class UParticleModuleCollisionBase : public UParticleModule {
};

// Size: 0xb0
class UParticleModuleCollisionGPU : public UParticleModuleCollisionBase {
    /* 0x0038 */ FRawDistributionFloat Resilience;
    /* 0x0068 */ FRawDistributionFloat ResilienceScaleOverLife;
    /* 0x0098 */ float Friction;
    /* 0x009c */ float RandomSpread;
    /* 0x00a0 */ float RandomDistribution;
    /* 0x00a4 */ float RadiusScale;
    /* 0x00a8 */ float RadiusBias;
    /* 0x00ac */ uint8_t Response;
    /* 0x00ad */ uint8_t CollisionMode;
};

// Size: 0xb8
class UParticleModuleColor : public UParticleModuleColorBase {
    /* 0x0038 */ FRawDistributionVector StartColor;
    /* 0x0080 */ FRawDistributionFloat StartAlpha;
    /* 0x00b0 */ bool bClampAlpha;
};

// Size: 0x38
class UParticleModuleColorBase : public UParticleModule {
};

// Size: 0xb8
class UParticleModuleColorOverLife : public UParticleModuleColorBase {
    /* 0x0038 */ FRawDistributionVector ColorOverLife;
    /* 0x0080 */ FRawDistributionFloat AlphaOverLife;
    /* 0x00b0 */ bool bClampAlpha;
};

// Size: 0xb8
class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase {
    /* 0x0038 */ FRawDistributionVector ColorScaleOverLife;
    /* 0x0080 */ FRawDistributionFloat AlphaScaleOverLife;
    /* 0x00b0 */ bool bEmitterTime;
};

// Size: 0xd8
class UParticleModuleColor_Seeded : public UParticleModuleColor {
    /* 0x00b8 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x38
class UParticleModuleEventBase : public UParticleModule {
};

// Size: 0x48
class UParticleModuleEventGenerator : public UParticleModuleEventBase {
    /* 0x0038 */ TArray<FParticleEvent_GenerateInfo> Events;
};

// Size: 0x48
class UParticleModuleEventReceiverBase : public UParticleModuleEventBase {
    /* 0x0038 */ uint8_t EventGeneratorType;
    /* 0x003c */ FName EventName;
};

// Size: 0x50
class UParticleModuleEventReceiverKillParticles : public UParticleModuleEventReceiverBase {
    /* 0x0048 */ bool bStopSpawning;
};

// Size: 0xe0
class UParticleModuleEventReceiverSpawn : public UParticleModuleEventReceiverBase {
    /* 0x0048 */ FRawDistributionFloat SpawnCount;
    /* 0x0078 */ bool bUseParticleTime;
    /* 0x0078 */ bool bUsePSysLocation;
    /* 0x0078 */ bool bInheritVelocity;
    /* 0x0080 */ FRawDistributionVector InheritVelocityScale;
    /* 0x00c8 */ TArray<UPhysicalMaterial*> PhysicalMaterials;
    /* 0x00d8 */ bool bBanPhysicalMaterials;
};

// Size: 0x30
class UParticleModuleEventSendToGame : public UObject {
};

// Size: 0x38
class UParticleModuleKillBase : public UParticleModule {
};

// Size: 0xd0
class UParticleModuleKillBox : public UParticleModuleKillBase {
    /* 0x0038 */ FRawDistributionVector LowerLeftCorner;
    /* 0x0080 */ FRawDistributionVector UpperRightCorner;
    /* 0x00c8 */ bool bAbsolute;
    /* 0x00c8 */ bool bKillInside;
    /* 0x00c8 */ bool bAxisAlignedAndFixedSize;
};

// Size: 0x70
class UParticleModuleKillHeight : public UParticleModuleKillBase {
    /* 0x0038 */ FRawDistributionFloat Height;
    /* 0x0068 */ bool bAbsolute;
    /* 0x0068 */ bool bFloor;
    /* 0x0068 */ bool bApplyPSysScale;
};

// Size: 0x68
class UParticleModuleLifetime : public UParticleModuleLifetimeBase {
    /* 0x0038 */ FRawDistributionFloat LifeTime;
};

// Size: 0x38
class UParticleModuleLifetimeBase : public UParticleModule {
};

// Size: 0x88
class UParticleModuleLifetime_Seeded : public UParticleModuleLifetime {
    /* 0x0068 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x128
class UParticleModuleLight : public UParticleModuleLightBase {
    /* 0x0038 */ bool bUseInverseSquaredFalloff;
    /* 0x0039 */ bool bAffectsTranslucency;
    /* 0x003a */ bool bPreviewLightRadius;
    /* 0x003c */ float SpawnFraction;
    /* 0x0040 */ FRawDistributionVector ColorScaleOverLife;
    /* 0x0088 */ FRawDistributionFloat BrightnessOverLife;
    /* 0x00b8 */ FRawDistributionFloat RadiusScale;
    /* 0x00e8 */ FRawDistributionFloat LightExponent;
    /* 0x0118 */ FLightingChannels LightingChannels;
    /* 0x011c */ float VolumetricScatteringIntensity;
    /* 0x0120 */ bool bHighQualityLights;
    /* 0x0121 */ bool bShadowCastingLights;
};

// Size: 0x38
class UParticleModuleLightBase : public UParticleModule {
};

// Size: 0x148
class UParticleModuleLight_Seeded : public UParticleModuleLight {
    /* 0x0128 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x88
class UParticleModuleLocation : public UParticleModuleLocationBase {
    /* 0x0038 */ FRawDistributionVector StartLocation;
    /* 0x0080 */ float DistributeOverNPoints;
    /* 0x0084 */ float DistributeThreshold;
};

// Size: 0x38
class UParticleModuleLocationBase : public UParticleModule {
};

// Size: 0x88
class UParticleModuleLocationBoneSocket : public UParticleModuleLocationBase {
    /* 0x0038 */ uint8_t SourceType;
    /* 0x003c */ FVector UniversalOffset;
    /* 0x0048 */ TArray<FLocationBoneSocketInfo> SourceLocations;
    /* 0x0058 */ uint8_t SelectionMethod;
    /* 0x005c */ bool bUpdatePositionEachFrame;
    /* 0x005c */ bool bOrientMeshEmitters;
    /* 0x005c */ bool bInheritBoneVelocity;
    /* 0x0060 */ float InheritVelocityScale;
    /* 0x0064 */ FName SkelMeshActorParamName;
    /* 0x0070 */ int32_t NumPreSelectedIndices;
    /* 0x0078 */ USkeletalMesh* EditorSkelMesh;
};

// Size: 0x158
class UParticleModuleLocationDirect : public UParticleModuleLocationBase {
    /* 0x0038 */ FRawDistributionVector Location;
    /* 0x0080 */ FRawDistributionVector LocationOffset;
    /* 0x00c8 */ FRawDistributionVector ScaleFactor;
    /* 0x0110 */ FRawDistributionVector Direction;
};

// Size: 0x58
class UParticleModuleLocationEmitter : public UParticleModuleLocationBase {
    /* 0x0038 */ FName EmitterName;
    /* 0x0044 */ uint8_t SelectionMethod;
    /* 0x0048 */ bool InheritSourceVelocity;
    /* 0x004c */ float InheritSourceVelocityScale;
    /* 0x0050 */ bool bInheritSourceRotation;
    /* 0x0054 */ float InheritSourceRotationScale;
};

// Size: 0x48
class UParticleModuleLocationEmitterDirect : public UParticleModuleLocationBase {
    /* 0x0038 */ FName EmitterName;
};

// Size: 0xb8
class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase {
    /* 0x0038 */ bool Positive_X;
    /* 0x0038 */ bool Positive_Y;
    /* 0x0038 */ bool Positive_Z;
    /* 0x0038 */ bool Negative_X;
    /* 0x0038 */ bool Negative_Y;
    /* 0x0038 */ bool Negative_Z;
    /* 0x0038 */ bool SurfaceOnly;
    /* 0x0038 */ bool Velocity;
    /* 0x0040 */ FRawDistributionFloat VelocityScale;
    /* 0x0070 */ FRawDistributionVector StartLocation;
};

// Size: 0x128
class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase {
    /* 0x00b8 */ bool RadialVelocity;
    /* 0x00c0 */ FRawDistributionFloat StartRadius;
    /* 0x00f0 */ FRawDistributionFloat StartHeight;
    /* 0x0120 */ uint8_t HeightAxis;
};

// Size: 0x148
class UParticleModuleLocationPrimitiveCylinder_Seeded : public UParticleModuleLocationPrimitiveCylinder {
    /* 0x0128 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0xe8
class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase {
    /* 0x00b8 */ FRawDistributionFloat StartRadius;
};

// Size: 0x108
class UParticleModuleLocationPrimitiveSphere_Seeded : public UParticleModuleLocationPrimitiveSphere {
    /* 0x00e8 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x110
class UParticleModuleLocationPrimitiveTriangle : public UParticleModuleLocationBase {
    /* 0x0038 */ FRawDistributionVector StartOffset;
    /* 0x0080 */ FRawDistributionFloat Height;
    /* 0x00b0 */ FRawDistributionFloat Angle;
    /* 0x00e0 */ FRawDistributionFloat Thickness;
};

// Size: 0xa8
class UParticleModuleLocationSkelVertSurface : public UParticleModuleLocationBase {
    /* 0x0038 */ uint8_t SourceType;
    /* 0x003c */ FVector UniversalOffset;
    /* 0x0048 */ bool bUpdatePositionEachFrame;
    /* 0x0048 */ bool bOrientMeshEmitters;
    /* 0x0048 */ bool bInheritBoneVelocity;
    /* 0x004c */ float InheritVelocityScale;
    /* 0x0050 */ FName SkelMeshActorParamName;
    /* 0x0060 */ USkeletalMesh* EditorSkelMesh;
    /* 0x0068 */ TArray<FName> ValidAssociatedBones;
    /* 0x0078 */ bool bEnforceNormalCheck;
    /* 0x007c */ FVector NormalToCompare;
    /* 0x0088 */ float NormalCheckToleranceDegrees;
    /* 0x008c */ float NormalCheckTolerance;
    /* 0x0090 */ TArray<int32_t> ValidMaterialIndices;
    /* 0x00a0 */ bool bInheritVertexColor;
    /* 0x00a0 */ bool bInheritUV;
    /* 0x00a4 */ uint32_t InheritUVChannel;
};

// Size: 0x88
class UParticleModuleLocationWorldOffset : public UParticleModuleLocation {
};

// Size: 0xa8
class UParticleModuleLocationWorldOffset_Seeded : public UParticleModuleLocationWorldOffset {
    /* 0x0088 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0xa8
class UParticleModuleLocation_Seeded : public UParticleModuleLocation {
    /* 0x0088 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x38
class UParticleModuleMaterialBase : public UParticleModule {
};

// Size: 0x48
class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase {
    /* 0x0038 */ TArray<UMaterialInterface*> MeshMaterials;
};

// Size: 0x88
class UParticleModuleMeshRotation : public UParticleModuleRotationBase {
    /* 0x0038 */ FRawDistributionVector StartRotation;
    /* 0x0080 */ bool bInheritParent;
};

// Size: 0x80
class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase {
    /* 0x0038 */ FRawDistributionVector StartRotationRate;
};

// Size: 0x80
class UParticleModuleMeshRotationRateMultiplyLife : public UParticleModuleRotationRateBase {
    /* 0x0038 */ FRawDistributionVector LifeMultiplier;
};

// Size: 0x88
class UParticleModuleMeshRotationRateOverLife : public UParticleModuleRotationRateBase {
    /* 0x0038 */ FRawDistributionVector RotRate;
    /* 0x0080 */ bool bScaleRotRate;
};

// Size: 0xa0
class UParticleModuleMeshRotationRate_Seeded : public UParticleModuleMeshRotationRate {
    /* 0x0080 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0xa8
class UParticleModuleMeshRotation_Seeded : public UParticleModuleMeshRotation {
    /* 0x0088 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x138
class UParticleModuleOrbit : public UParticleModuleOrbitBase {
    /* 0x0040 */ uint8_t ChainMode;
    /* 0x0048 */ FRawDistributionVector OffsetAmount;
    /* 0x0090 */ FOrbitOptions OffsetOptions;
    /* 0x0098 */ FRawDistributionVector RotationAmount;
    /* 0x00e0 */ FOrbitOptions RotationOptions;
    /* 0x00e8 */ FRawDistributionVector RotationRateAmount;
    /* 0x0130 */ FOrbitOptions RotationRateOptions;
};

// Size: 0x40
class UParticleModuleOrbitBase : public UParticleModule {
    /* 0x0038 */ bool bUseEmitterTime;
};

// Size: 0x40
class UParticleModuleOrientationAxisLock : public UParticleModuleOrientationBase {
    /* 0x0038 */ uint8_t LockAxisFlags;
};

// Size: 0x38
class UParticleModuleOrientationBase : public UParticleModule {
};

// Size: 0x38
class UParticleModuleParameterBase : public UParticleModule {
};

// Size: 0x50
class UParticleModuleParameterDynamic : public UParticleModuleParameterBase {
    /* 0x0038 */ TArray<FEmitterDynamicParameter> DynamicParams;
    /* 0x0048 */ int32_t UpdateFlags;
    /* 0x004c */ bool bUsesVelocity;
};

// Size: 0x70
class UParticleModuleParameterDynamic_Seeded : public UParticleModuleParameterDynamic {
    /* 0x0050 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x40
class UParticleModulePivotOffset : public UParticleModuleLocationBase {
    /* 0x0038 */ FVector2D PivotOffset;
};

// Size: 0x148
class UParticleModuleRequired : public UParticleModule {
    /* 0x0038 */ UMaterialInterface* Material;
    /* 0x0040 */ float MinFacingCameraBlendDistance;
    /* 0x0044 */ float MaxFacingCameraBlendDistance;
    /* 0x0048 */ FVector EmitterOrigin;
    /* 0x0054 */ FRotator EmitterRotation;
    /* 0x0060 */ uint8_t ScreenAlignment;
    /* 0x0061 */ bool bUseLocalSpace;
    /* 0x0061 */ bool bKillOnDeactivate;
    /* 0x0061 */ bool bKillOnCompleted;
    /* 0x0062 */ uint8_t SortMode;
    /* 0x0063 */ bool bUseLegacyEmitterTime;
    /* 0x0063 */ bool bRemoveHMDRoll;
    /* 0x0063 */ bool bEmitterDurationUseRange;
    /* 0x0064 */ float EmitterDuration;
    /* 0x0068 */ FRawDistributionFloat SpawnRate;
    /* 0x0098 */ TArray<FParticleBurst> BurstList;
    /* 0x00a8 */ float EmitterDelay;
    /* 0x00ac */ float EmitterDelayLow;
    /* 0x00b0 */ bool bDelayFirstLoopOnly;
    /* 0x00b1 */ uint8_t InterpolationMethod;
    /* 0x00b2 */ bool bScaleUV;
    /* 0x00b2 */ bool bEmitterDelayUseRange;
    /* 0x00b3 */ uint8_t ParticleBurstMethod;
    /* 0x00b4 */ bool bOverrideSystemMacroUV;
    /* 0x00b4 */ bool bUseMaxDrawCount;
    /* 0x00b5 */ uint8_t OpacitySourceMode;
    /* 0x00b6 */ uint8_t EmitterNormalsMode;
    /* 0x00b7 */ bool bOrbitModuleAffectsVelocityAlignment;
    /* 0x00b8 */ int32_t SubImages_Horizontal;
    /* 0x00bc */ int32_t SubImages_Vertical;
    /* 0x00c0 */ float RandomImageTime;
    /* 0x00c4 */ int32_t RandomImageChanges;
    /* 0x00c8 */ FVector MacroUVPosition;
    /* 0x00d4 */ float MacroUVRadius;
    /* 0x00d8 */ EParticleUVFlipMode UVFlippingMode;
    /* 0x00d9 */ uint8_t BoundingMode;
    /* 0x00da */ bool bDurationRecalcEachLoop;
    /* 0x00dc */ FVector NormalsSphereCenter;
    /* 0x00e8 */ float AlphaThreshold;
    /* 0x00ec */ int32_t EmitterLoops;
    /* 0x00f0 */ UTexture2D* CutoutTexture;
    /* 0x00f8 */ int32_t MaxDrawCount;
    /* 0x00fc */ float EmitterDurationLow;
    /* 0x0100 */ FVector NormalsCylinderDirection;
    /* 0x0110 */ TArray<FName> NamedMaterialOverrides;
};

// Size: 0x68
class UParticleModuleRotation : public UParticleModuleRotationBase {
    /* 0x0038 */ FRawDistributionFloat StartRotation;
};

// Size: 0x38
class UParticleModuleRotationBase : public UParticleModule {
};

// Size: 0x70
class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase {
    /* 0x0038 */ FRawDistributionFloat RotationOverLife;
    /* 0x0068 */ bool Scale;
};

// Size: 0x68
class UParticleModuleRotationRate : public UParticleModuleRotationRateBase {
    /* 0x0038 */ FRawDistributionFloat StartRotationRate;
};

// Size: 0x38
class UParticleModuleRotationRateBase : public UParticleModule {
};

// Size: 0x68
class UParticleModuleRotationRateMultiplyLife : public UParticleModuleRotationRateBase {
    /* 0x0038 */ FRawDistributionFloat LifeMultiplier;
};

// Size: 0x88
class UParticleModuleRotationRate_Seeded : public UParticleModuleRotationRate {
    /* 0x0068 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x88
class UParticleModuleRotation_Seeded : public UParticleModuleRotation {
    /* 0x0068 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x80
class UParticleModuleSize : public UParticleModuleSizeBase {
    /* 0x0038 */ FRawDistributionVector StartSize;
};

// Size: 0x38
class UParticleModuleSizeBase : public UParticleModule {
};

// Size: 0x88
class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase {
    /* 0x0038 */ FRawDistributionVector LifeMultiplier;
    /* 0x0080 */ bool MultiplyX;
    /* 0x0080 */ bool MultiplyY;
    /* 0x0080 */ bool MultiplyZ;
};

// Size: 0x88
class UParticleModuleSizeScale : public UParticleModuleSizeBase {
    /* 0x0038 */ FRawDistributionVector SizeScale;
    /* 0x0080 */ bool EnableX;
    /* 0x0080 */ bool EnableY;
    /* 0x0080 */ bool EnableZ;
};

// Size: 0x48
class UParticleModuleSizeScaleBySpeed : public UParticleModuleSizeBase {
    /* 0x0038 */ FVector2D SpeedScale;
    /* 0x0040 */ FVector2D MaxScale;
};

// Size: 0xa0
class UParticleModuleSize_Seeded : public UParticleModuleSize {
    /* 0x0080 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x80
class UParticleModuleSourceMovement : public UParticleModuleLocationBase {
    /* 0x0038 */ FRawDistributionVector SourceMovementScale;
};

// Size: 0xf0
class UParticleModuleSpawn : public UParticleModuleSpawnBase {
    /* 0x0040 */ FRawDistributionFloat Rate;
    /* 0x0070 */ FRawDistributionFloat RateScale;
    /* 0x00a0 */ uint8_t ParticleBurstMethod;
    /* 0x00a8 */ TArray<FParticleBurst> BurstList;
    /* 0x00b8 */ FRawDistributionFloat BurstScale;
    /* 0x00e8 */ bool bApplyGlobalSpawnRateScale;
};

// Size: 0x40
class UParticleModuleSpawnBase : public UParticleModule {
    /* 0x0038 */ bool bProcessSpawnRate;
    /* 0x0038 */ bool bProcessBurstList;
};

// Size: 0x80
class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase {
    /* 0x0040 */ float UnitScalar;
    /* 0x0044 */ float MovementTolerance;
    /* 0x0048 */ FRawDistributionFloat SpawnPerUnit;
    /* 0x0078 */ float MaxFrameDistance;
    /* 0x007c */ bool bIgnoreSpawnRateWhenMoving;
    /* 0x007c */ bool bIgnoreMovementAlongX;
    /* 0x007c */ bool bIgnoreMovementAlongY;
    /* 0x007c */ bool bIgnoreMovementAlongZ;
};

// Size: 0x78
class UParticleModuleSubUV : public UParticleModuleSubUVBase {
    /* 0x0038 */ USubUVAnimation* Animation;
    /* 0x0040 */ FRawDistributionFloat SubImageIndex;
    /* 0x0070 */ bool bUseRealTime;
};

// Size: 0x38
class UParticleModuleSubUVBase : public UParticleModule {
};

// Size: 0xb8
class UParticleModuleSubUVMovie : public UParticleModuleSubUV {
    /* 0x0078 */ bool bUseEmitterTime;
    /* 0x0080 */ FRawDistributionFloat FrameRate;
    /* 0x00b0 */ int32_t StartingFrame;
};

// Size: 0x38
class UParticleModuleTrailBase : public UParticleModule {
};

// Size: 0x98
class UParticleModuleTrailSource : public UParticleModuleTrailBase {
    /* 0x0038 */ uint8_t SourceMethod;
    /* 0x003c */ FName SourceName;
    /* 0x0048 */ FRawDistributionFloat SourceStrength;
    /* 0x0078 */ bool bLockSourceStength;
    /* 0x007c */ int32_t SourceOffsetCount;
    /* 0x0080 */ TArray<FVector> SourceOffsetDefaults;
    /* 0x0090 */ uint8_t SelectionMethod;
    /* 0x0094 */ bool bInheritRotation;
};

// Size: 0x50
class UParticleModuleTypeDataAnimTrail : public UParticleModuleTypeDataBase {
    /* 0x0038 */ bool bDeadTrailsOnDeactivate;
    /* 0x0038 */ bool bEnablePreviousTangentRecalculation;
    /* 0x0038 */ bool bTangentRecalculationEveryFrame;
    /* 0x003c */ float TilingDistance;
    /* 0x0040 */ float DistanceTessellationStepSize;
    /* 0x0044 */ float TangentTessellationStepSize;
    /* 0x0048 */ float WidthTessellationStepSize;
};

// Size: 0x38
class UParticleModuleTypeDataBase : public UParticleModule {
};

// Size: 0x158
class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase {
    /* 0x0038 */ uint8_t BeamMethod;
    /* 0x003c */ int32_t TextureTile;
    /* 0x0040 */ float TextureTileDistance;
    /* 0x0044 */ int32_t Sheets;
    /* 0x0048 */ int32_t MaxBeamCount;
    /* 0x004c */ float Speed;
    /* 0x0050 */ int32_t InterpolationPoints;
    /* 0x0054 */ bool bAlwaysOn;
    /* 0x0058 */ int32_t UpVectorStepSize;
    /* 0x005c */ FName BranchParentName;
    /* 0x0068 */ FRawDistributionFloat Distance;
    /* 0x0098 */ uint8_t TaperMethod;
    /* 0x00a0 */ FRawDistributionFloat TaperFactor;
    /* 0x00d0 */ FRawDistributionFloat TaperScale;
    /* 0x0100 */ bool RenderGeometry;
    /* 0x0100 */ bool RenderDirectLine;
    /* 0x0100 */ bool RenderLines;
    /* 0x0100 */ bool RenderTessellation;
};

// Size: 0x430
class UParticleModuleTypeDataGpu : public UParticleModuleTypeDataBase {
    /* 0x0040 */ FGPUSpriteEmitterInfo EmitterInfo;
    /* 0x02c0 */ FGPUSpriteResourceData ResourceData;
    /* 0x0420 */ float CameraMotionBlurAmount;
    /* 0x0424 */ bool bClearExistingParticlesOnInit;
};

// Size: 0xa0
class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase {
    /* 0x0038 */ UStaticMesh* Mesh;
    /* 0x0048 */ float LODSizeScale;
    /* 0x004c */ bool bUseStaticMeshLODs;
    /* 0x004c */ bool CastShadows;
    /* 0x004c */ bool DoCollisions;
    /* 0x004d */ uint8_t MeshAlignment;
    /* 0x004e */ bool bOverrideMaterial;
    /* 0x004e */ bool bOverrideDefaultMotionBlurSettings;
    /* 0x004e */ bool bEnableMotionBlur;
    /* 0x0050 */ FRawDistributionVector RollPitchYawRange;
    /* 0x0098 */ uint8_t AxisLockOption;
    /* 0x0099 */ bool bCameraFacing;
    /* 0x009a */ uint8_t CameraFacingUpAxisOption;
    /* 0x009b */ uint8_t CameraFacingOption;
    /* 0x009c */ bool bApplyParticleRotationAsSpin;
    /* 0x009c */ bool bFaceCameraDirectionRatherThanPosition;
    /* 0x009c */ bool bCollisionsConsiderPartilceSize;
};

// Size: 0x68
class UParticleModuleTypeDataRibbon : public UParticleModuleTypeDataBase {
    /* 0x0038 */ int32_t MaxTessellationBetweenParticles;
    /* 0x003c */ int32_t SheetsPerTrail;
    /* 0x0040 */ int32_t MaxTrailCount;
    /* 0x0044 */ int32_t MaxParticleInTrailCount;
    /* 0x0048 */ bool bDeadTrailsOnDeactivate;
    /* 0x0048 */ bool bDeadTrailsOnSourceLoss;
    /* 0x0048 */ bool bClipSourceSegement;
    /* 0x0048 */ bool bEnablePreviousTangentRecalculation;
    /* 0x0048 */ bool bTangentRecalculationEveryFrame;
    /* 0x0048 */ bool bSpawnInitialParticle;
    /* 0x004c */ uint8_t RenderAxis;
    /* 0x0050 */ float TangentSpawningScalar;
    /* 0x0054 */ bool bRenderGeometry;
    /* 0x0054 */ bool bRenderSpawnPoints;
    /* 0x0054 */ bool bRenderTangents;
    /* 0x0054 */ bool bRenderTessellation;
    /* 0x0058 */ float TilingDistance;
    /* 0x005c */ float DistanceTessellationStepSize;
    /* 0x0060 */ bool bEnableTangentDiffInterpScale;
    /* 0x0064 */ float TangentTessellationScalar;
};

// Size: 0x38
class UParticleModuleVectorFieldBase : public UParticleModule {
};

// Size: 0x48
class UParticleModuleVectorFieldGlobal : public UParticleModuleVectorFieldBase {
    /* 0x0038 */ bool bOverrideGlobalVectorFieldTightness;
    /* 0x003c */ float GlobalVectorFieldScale;
    /* 0x0040 */ float GlobalVectorFieldTightness;
};

// Size: 0x70
class UParticleModuleVectorFieldLocal : public UParticleModuleVectorFieldBase {
    /* 0x0038 */ UVectorField* VectorField;
    /* 0x0040 */ FVector RelativeTranslation;
    /* 0x004c */ FRotator RelativeRotation;
    /* 0x0058 */ FVector RelativeScale3D;
    /* 0x0064 */ float Intensity;
    /* 0x0068 */ float Tightness;
    /* 0x006c */ bool bIgnoreComponentTransform;
    /* 0x006c */ bool bTileX;
    /* 0x006c */ bool bTileY;
    /* 0x006c */ bool bTileZ;
    /* 0x006c */ bool bUseFixDT;
};

// Size: 0x50
class UParticleModuleVectorFieldRotation : public UParticleModuleVectorFieldBase {
    /* 0x0038 */ FVector MinInitialRotation;
    /* 0x0044 */ FVector MaxInitialRotation;
};

// Size: 0x48
class UParticleModuleVectorFieldRotationRate : public UParticleModuleVectorFieldBase {
    /* 0x0038 */ FVector RotationRate;
};

// Size: 0x70
class UParticleModuleVectorFieldScale : public UParticleModuleVectorFieldBase {
    /* 0x0038 */ UDistributionFloat* VectorFieldScale;
    /* 0x0040 */ FRawDistributionFloat VectorFieldScaleRaw;
};

// Size: 0x70
class UParticleModuleVectorFieldScaleOverLife : public UParticleModuleVectorFieldBase {
    /* 0x0038 */ UDistributionFloat* VectorFieldScaleOverLife;
    /* 0x0040 */ FRawDistributionFloat VectorFieldScaleOverLifeRaw;
};

// Size: 0xb8
class UParticleModuleVelocity : public UParticleModuleVelocityBase {
    /* 0x0040 */ FRawDistributionVector StartVelocity;
    /* 0x0088 */ FRawDistributionFloat StartVelocityRadial;
};

// Size: 0x40
class UParticleModuleVelocityBase : public UParticleModule {
    /* 0x0038 */ bool bInWorldSpace;
    /* 0x0038 */ bool bApplyOwnerScale;
};

// Size: 0xb0
class UParticleModuleVelocityCone : public UParticleModuleVelocityBase {
    /* 0x0040 */ FRawDistributionFloat Angle;
    /* 0x0070 */ FRawDistributionFloat Velocity;
    /* 0x00a0 */ FVector Direction;
};

// Size: 0x88
class UParticleModuleVelocityInheritParent : public UParticleModuleVelocityBase {
    /* 0x0040 */ FRawDistributionVector Scale;
};

// Size: 0x90
class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase {
    /* 0x0040 */ FRawDistributionVector VelOverLife;
    /* 0x0088 */ bool Absolute;
};

// Size: 0xd8
class UParticleModuleVelocity_Seeded : public UParticleModuleVelocity {
    /* 0x00b8 */ FParticleRandomSeedInfo RandomSeedInfo;
};

// Size: 0x20
struct FParticleRandomSeedInfo {
    /* 0x0000 */ FName ParameterName;
    /* 0x000c */ bool bGetSeedFromInstance;
    /* 0x000c */ bool bInstanceSeedIsIndex;
    /* 0x000c */ bool bResetSeedOnEmitterLooping;
    /* 0x000c */ bool bRandomlySelectSeedArray;
    /* 0x0010 */ TArray<int32_t> RandomSeeds;
};

enum class ParticleReplayState {
    PRS_Disabled = 0,
    PRS_Capturing = 1,
    PRS_Replaying = 2,
    PRS_MAX = 3,
};

// Size: 0xc
struct FParticleReplayTrackKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ float Duration;
    /* 0x0008 */ int32_t ClipIDNumber;
};

// Size: 0x1e8
class UParticleSpriteEmitter : public UParticleEmitter {
};

// Size: 0x90
struct FParticleSysParam {
    /* 0x0000 */ FName Name;
    /* 0x000c */ uint8_t ParamType;
    /* 0x0010 */ float Scalar;
    /* 0x0014 */ float Scalar_Low;
    /* 0x0018 */ FVector Vector;
    /* 0x0024 */ FVector Vector_Low;
    /* 0x0030 */ FColor Color;
    /* 0x0038 */ AActor* Actor;
    /* 0x0040 */ UMaterialInterface* Material;
};

// Size: 0x188
class UParticleSystem : public UFXSystemAsset {
    /* 0x0040 */ float UpdateTime_FPS;
    /* 0x0044 */ float UpdateTime_Delta;
    /* 0x0048 */ float WarmupTime;
    /* 0x004c */ float WarmupTickRate;
    /* 0x0050 */ TArray<UParticleEmitter*> Emitters;
    /* 0x0060 */ UParticleSystemComponent* PreviewComponent;
    /* 0x0068 */ FRotator ThumbnailAngle;
    /* 0x0074 */ float ThumbnailDistance;
    /* 0x0078 */ float ThumbnailWarmup;
    /* 0x0080 */ UInterpCurveEdSetup* CurveEdSetup;
    /* 0x0088 */ float LODDistanceCheckTime;
    /* 0x008c */ float MacroUVRadius;
    /* 0x0090 */ TArray<float> LODDistances;
    /* 0x00a0 */ int32_t EditorLODSetting;
    /* 0x00a8 */ TArray<FParticleSystemLOD> LODSettings;
    /* 0x00b8 */ FBox FixedRelativeBoundingBox;
    /* 0x00d4 */ float SecondsBeforeInactive;
    /* 0x00d8 */ FString FloorMesh;
    /* 0x00e8 */ FVector FloorPosition;
    /* 0x00f4 */ FRotator FloorRotation;
    /* 0x0100 */ float FloorScale;
    /* 0x0104 */ FVector FloorScale3D;
    /* 0x0110 */ FColor BackgroundColor;
    /* 0x0114 */ float Delay;
    /* 0x0118 */ float DelayLow;
    /* 0x011c */ bool bOrientZAxisTowardCamera;
    /* 0x011c */ bool bUseFixedRelativeBoundingBox;
    /* 0x011c */ bool bShouldResetPeakCounts;
    /* 0x011c */ bool bHasPhysics;
    /* 0x011c */ bool bUseRealtimeThumbnail;
    /* 0x011c */ bool ThumbnailImageOutOfDate;
    /* 0x0120 */ UTexture2D* ThumbnailImage;
    /* 0x0128 */ bool bUseDelayRange;
    /* 0x0128 */ bool bAllowManagedTicking;
    /* 0x0128 */ bool bAutoDeactivate;
    /* 0x0128 */ bool bRegenerateLODDuplicate;
    /* 0x0129 */ uint8_t SystemUpdateMode;
    /* 0x012a */ uint8_t LODMethod;
    /* 0x012b */ EParticleSystemInsignificanceReaction InsignificantReaction;
    /* 0x012c */ uint8_t OcclusionBoundsMethod;
    /* 0x012e */ EParticleSignificanceLevel MaxSignificanceLevel;
    /* 0x0130 */ uint32_t MinTimeBetweenTicks;
    /* 0x0134 */ float InsignificanceDelay;
    /* 0x0138 */ FVector MacroUVPosition;
    /* 0x0144 */ FBox CustomOcclusionBounds;
    /* 0x0160 */ TArray<FLODSoloTrack> SoloTracking;
    /* 0x0170 */ TArray<FNamedEmitterMaterial> NamedMaterialSlots;

    bool ContainsEmitterType(UClass* TypeData);
};

// Size: 0x750
class UParticleSystemComponent : public UFXSystemComponent {
    /* 0x04e0 */ UParticleSystem* Template;
    /* 0x04e8 */ TArray<UMaterialInterface*> EmitterMaterials;
    /* 0x04f8 */ TArray<USkeletalMeshComponent*> SkelMeshComponents;
    /* 0x0509 */ bool bResetOnDetach;
    /* 0x0509 */ bool bUpdateOnDedicatedServer;
    /* 0x0509 */ bool bAllowRecycling;
    /* 0x0509 */ bool bAutoManageAttachment;
    /* 0x0509 */ bool bAutoAttachWeldSimulatedBodies;
    /* 0x050a */ bool bWarmingUp;
    /* 0x050a */ bool bOverrideLODMethod;
    /* 0x050a */ bool bSkipUpdateDynamicDataDuringTick;
    /* 0x0515 */ uint8_t LODMethod;
    /* 0x0516 */ EParticleSignificanceLevel RequiredSignificance;
    /* 0x0518 */ TArray<FParticleSysParam> InstanceParameters;
    /* 0x0528 */ FMulticastInlineDelegate OnParticleSpawn;
    /* 0x0538 */ FMulticastInlineDelegate OnParticleBurst;
    /* 0x0548 */ FMulticastInlineDelegate OnParticleDeath;
    /* 0x0558 */ FMulticastInlineDelegate OnParticleCollide;
    /* 0x0568 */ bool bOldPositionValid;
    /* 0x056c */ FVector OldPosition;
    /* 0x0578 */ FVector PartSysVelocity;
    /* 0x0584 */ float WarmupTime;
    /* 0x0588 */ float WarmupTickRate;
    /* 0x0590 */ float SecondsBeforeInactive;
    /* 0x0598 */ float MaxTimeBeforeForceUpdateTransform;
    /* 0x059c */ int32_t EditorLODLevel;
    /* 0x05a0 */ int32_t EditorDetailMode;
    /* 0x05c0 */ TArray<UParticleSystemReplay*> ReplayClips;
    /* 0x05d8 */ float CustomTimeDilation;
    /* 0x0630 */ TWeakObjectPtr<USceneComponent> AutoAttachParent;
    /* 0x0638 */ FName AutoAttachSocketName;
    /* 0x0644 */ uint8_t AutoAttachLocationType;
    /* 0x0645 */ EAttachmentRule AutoAttachLocationRule;
    /* 0x0646 */ EAttachmentRule AutoAttachRotationRule;
    /* 0x0647 */ EAttachmentRule AutoAttachScaleRule;
    /* 0x0678 */ FMulticastInlineDelegate OnSystemFinished;

    void BeginTrails(FName InFirstSocketName, FName InSecondSocketName, uint8_t InWidthMode, float InWidth);
    UMaterialInstanceDynamic* CreateNamedDynamicMaterialInstance(FName InName, UMaterialInterface* SourceMaterial);
    void EndTrails();
    void GenerateParticleEvent(const FName InEventName, const float InEmitterTime, const FVector InLocation, const FVector InDirection, const FVector InVelocity);
    bool GetBeamEndPoint(int32_t EmitterIndex, FVector& OutEndPoint) const;
    bool GetBeamSourcePoint(int32_t EmitterIndex, int32_t SourceIndex, FVector& OutSourcePoint) const;
    bool GetBeamSourceStrength(int32_t EmitterIndex, int32_t SourceIndex, float& OutSourceStrength) const;
    bool GetBeamSourceTangent(int32_t EmitterIndex, int32_t SourceIndex, FVector& OutTangentPoint) const;
    bool GetBeamTargetPoint(int32_t EmitterIndex, int32_t TargetIndex, FVector& OutTargetPoint) const;
    bool GetBeamTargetStrength(int32_t EmitterIndex, int32_t TargetIndex, float& OutTargetStrength) const;
    bool GetBeamTargetTangent(int32_t EmitterIndex, int32_t TargetIndex, FVector& OutTangentPoint) const;
    UMaterialInterface* GetNamedMaterial(FName InName) const;
    int32_t GetNumActiveParticles() const;
    void SetAutoAttachParams(USceneComponent* Parent, FName SocketName, uint8_t LocationType);
    void SetBeamEndPoint(int32_t EmitterIndex, FVector NewEndPoint);
    void SetBeamSourcePoint(int32_t EmitterIndex, FVector NewSourcePoint, int32_t SourceIndex);
    void SetBeamSourceStrength(int32_t EmitterIndex, float NewSourceStrength, int32_t SourceIndex);
    void SetBeamSourceTangent(int32_t EmitterIndex, FVector NewTangentPoint, int32_t SourceIndex);
    void SetBeamTargetPoint(int32_t EmitterIndex, FVector NewTargetPoint, int32_t TargetIndex);
    void SetBeamTargetStrength(int32_t EmitterIndex, float NewTargetStrength, int32_t TargetIndex);
    void SetBeamTargetTangent(int32_t EmitterIndex, FVector NewTangentPoint, int32_t TargetIndex);
    void SetMaterialParameter(FName ParameterName, UMaterialInterface* Param);
    void SetTemplate(UParticleSystem* NewTemplate);
    void SetTrailSourceData(FName InFirstSocketName, FName InSecondSocketName, uint8_t InWidthMode, float InWidth);
};

// Size: 0x1
struct FParticleSystemLOD {
};

enum class ParticleSystemLODMethod {
    PARTICLESYSTEMLODMETHOD_Automatic = 0,
    PARTICLESYSTEMLODMETHOD_DirectSet = 1,
    PARTICLESYSTEMLODMETHOD_ActivateAutomatic = 2,
    PARTICLESYSTEMLODMETHOD_MAX = 3,
};

// Size: 0x48
class UParticleSystemReplay : public UObject {
    /* 0x0030 */ int32_t ClipIDNumber;
};

// Size: 0x10
struct FParticleSystemReplayFrame {
};

// Size: 0x30
struct FParticleSystemWorldManagerTickFunction : public FTickFunction {
};

// Size: 0x10
struct FPassiveSoundMixModifier {
    /* 0x0000 */ USoundMix* SoundMix;
    /* 0x0008 */ float MinVolumeThreshold;
    /* 0x000c */ float MaxVolumeThreshold;
};

// Size: 0x30
class IPathFollowingAgentInterface : public UInterface {
};

// Size: 0x358
class APawn : public AActor {
    /* 0x0300 */ bool bUseControllerRotationPitch;
    /* 0x0300 */ bool bUseControllerRotationYaw;
    /* 0x0300 */ bool bUseControllerRotationRoll;
    /* 0x0300 */ bool bCanAffectNavigationGeneration;
    /* 0x0304 */ float BaseEyeHeight;
    /* 0x0308 */ uint8_t AutoPossessPlayer;
    /* 0x0309 */ EAutoPossessAI AutoPossessAI;
    /* 0x030a */ uint8_t RemoteViewPitch;
    /* 0x0310 */ UClass* AIControllerClass;
    /* 0x0318 */ APlayerState* PlayerState;
    /* 0x0328 */ AController* LastHitBy;
    /* 0x0330 */ AController* Controller;
    /* 0x033c */ FVector ControlInputVector;
    /* 0x0348 */ FVector LastControlInputVector;

    void AddControllerPitchInput(float Val);
    void AddControllerRollInput(float Val);
    void AddControllerYawInput(float Val);
    void AddMovementInput(FVector WorldDirection, float ScaleValue, bool bForce);
    FVector ConsumeMovementInputVector();
    void DetachFromControllerPendingDestroy();
    FRotator GetBaseAimRotation() const;
    FRotator GetControlRotation() const;
    AController* GetController() const;
    FVector GetLastMovementInputVector() const;
    static AActor* GetMovementBaseActor(const APawn* Pawn);
    UPawnMovementComponent* GetMovementComponent() const;
    FVector GetNavAgentLocation() const;
    FVector GetPendingMovementInputVector() const;
    bool IsBotControlled() const;
    bool IsControlled() const;
    bool IsLocallyControlled() const;
    bool IsMoveInputIgnored() const;
    bool IsPawnControlled() const;
    bool IsPlayerControlled() const;
    FVector K2_GetMovementInputVector() const;
    void LaunchPawn(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);
    void OnRep_Controller();
    void OnRep_PlayerState();
    void PawnMakeNoise(float Loudness, FVector NoiseLocation, bool bUseNoiseMakerLocation, AActor* NoiseMaker);
    void ReceivePossessed(AController* NewController);
    void ReceiveUnpossessed(AController* OldController);
    void SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate);
    void SpawnDefaultController();
};

// Size: 0x150
class UPawnMovementComponent : public UNavMovementComponent {
    /* 0x0148 */ APawn* PawnOwner;

    void AddInputVector(FVector WorldVector, bool bForce);
    FVector ConsumeInputVector();
    FVector GetLastInputVector() const;
    APawn* GetPawnOwner() const;
    FVector GetPendingInputVector() const;
    bool IsMoveInputIgnored() const;
    FVector K2_GetInputVector() const;
};

// Size: 0xe8
class UPawnNoiseEmitterComponent : public UActorComponent {
    /* 0x00c0 */ bool bAIPerceptionSystemCompatibilityMode;
    /* 0x00c4 */ FVector LastRemoteNoisePosition;
    /* 0x00d0 */ float NoiseLifetime;
    /* 0x00d4 */ float LastRemoteNoiseVolume;
    /* 0x00d8 */ float LastRemoteNoiseTime;
    /* 0x00dc */ float LastLocalNoiseVolume;
    /* 0x00e0 */ float LastLocalNoiseTime;

    void MakeNoise(AActor* NoiseMaker, float Loudness, const FVector& NoiseLocation);
};

// Size: 0xc8
class UPendingNetGame : public UObject {
    /* 0x0038 */ UNetDriver* NetDriver;
    /* 0x0040 */ UDemoNetDriver* DemoNetDriver;
};

// Size: 0x8
struct FPerBoneBlendWeight {
    /* 0x0000 */ int32_t SourceIndex;
    /* 0x0004 */ float BlendWeight;
};

// Size: 0x10
struct FPerBoneBlendWeights {
    /* 0x0000 */ TArray<FPerBoneBlendWeight> BoneBlendWeights;
};

// Size: 0x18
struct FPerBoneInterpolation {
    /* 0x0000 */ FBoneReference BoneReference;
    /* 0x0014 */ float InterpolationSpeedPerSec;
};

// Size: 0x58
struct FPerPlatformBool {
    /* 0x0000 */ bool Default;
    /* 0x0008 */ TMap<FName, bool> PerPlatform;
};

// Size: 0x58
struct FPerPlatformFloat {
    /* 0x0000 */ float Default;
    /* 0x0008 */ TMap<FName, float> PerPlatform;
};

// Size: 0x58
struct FPerPlatformInt {
    /* 0x0000 */ int32_t Default;
    /* 0x0008 */ TMap<FName, int32_t> PerPlatform;
};

// Size: 0x100
class UPhysicalAnimationComponent : public UActorComponent {
    /* 0x00c0 */ float StrengthMultiplyer;
    /* 0x00c8 */ USkeletalMeshComponent* SkeletalMeshComponent;

    void ApplyPhysicalAnimationProfileBelow(FName BodyName, FName ProfileName, bool bIncludeSelf, bool bClearNotFound);
    void ApplyPhysicalAnimationSettings(FName BodyName, const FPhysicalAnimationData& PhysicalAnimationData);
    void ApplyPhysicalAnimationSettingsBelow(FName BodyName, const FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf);
    FTransform GetBodyTargetTransform(FName BodyName) const;
    void SetSkeletalMeshComponent(USkeletalMeshComponent* InSkeletalMeshComponent);
    void SetStrengthMultiplyer(float InStrengthMultiplyer);
};

// Size: 0x28
struct FPhysicalAnimationData {
    /* 0x0000 */ FName BodyName;
    /* 0x000c */ bool bIsLocalSimulation;
    /* 0x0010 */ float OrientationStrength;
    /* 0x0014 */ float AngularVelocityStrength;
    /* 0x0018 */ float PositionStrength;
    /* 0x001c */ float VelocityStrength;
    /* 0x0020 */ float MaxLinearForce;
    /* 0x0024 */ float MaxAngularForce;
};

// Size: 0x34
struct FPhysicalAnimationProfile {
    /* 0x0000 */ FName ProfileName;
    /* 0x000c */ FPhysicalAnimationData PhysicalAnimationData;
};

// Size: 0x48
class UPhysicalMaterialMask : public UObject {
    /* 0x0030 */ UAssetImportData* AssetImportData;
    /* 0x0038 */ UTexture* MaskTexture;
    /* 0x0040 */ int32_t UVChannelIndex;
    /* 0x0044 */ uint8_t AddressX;
    /* 0x0045 */ uint8_t AddressY;
};

// Size: 0x10
struct FPhysicalSurfaceName {
    /* 0x0000 */ uint8_t Type;
    /* 0x0004 */ FName Name;
};

// Size: 0x1d0
class UPhysicsAsset : public UObject {
    /* 0x0038 */ USkeletalMesh* DefaultSkelMesh;
    /* 0x0040 */ TSoftObjectPtr<USkeletalMesh> PreviewSkeletalMesh;
    /* 0x0070 */ TArray<FName> PhysicalAnimationProfiles;
    /* 0x0080 */ TArray<FName> ConstraintProfiles;
    /* 0x0090 */ FName CurrentPhysicalAnimationProfileName;
    /* 0x009c */ FName CurrentConstraintProfileName;
    /* 0x00a8 */ TArray<int32_t> BoundsBodies;
    /* 0x00b8 */ TArray<USkeletalBodySetup*> SkeletalBodySetups;
    /* 0x00c8 */ TArray<UPhysicsConstraintTemplate*> ConstraintSetup;
    /* 0x00d8 */ FSolverIterations SolverIterations;
    /* 0x00f4 */ EPhysicsAssetSolverType SolverType;
    /* 0x00f5 */ bool bNotForDedicatedServer;
    /* 0x0198 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x01c0 */ TArray<UBodySetup*> BodySetup;
};

// Size: 0x48
class UPhysicsCollisionHandler : public UObject {
    /* 0x0030 */ float ImpactThreshold;
    /* 0x0034 */ float ImpactReFireDelay;
    /* 0x0038 */ USoundBase* DefaultImpactSound;
    /* 0x0040 */ float LastImpactSoundTime;
};

// Size: 0x318
class APhysicsConstraintActor : public ARigidBodyBase {
    /* 0x02f8 */ UPhysicsConstraintComponent* ConstraintComp;
    /* 0x0300 */ AActor* ConstraintActor1;
    /* 0x0308 */ AActor* ConstraintActor2;
    /* 0x0310 */ bool bDisableCollision;
};

// Size: 0x520
class UPhysicsConstraintComponent : public USceneComponent {
    /* 0x0228 */ AActor* ConstraintActor1;
    /* 0x0230 */ FConstrainComponentPropName ComponentName1;
    /* 0x0240 */ AActor* ConstraintActor2;
    /* 0x0248 */ FConstrainComponentPropName ComponentName2;
    /* 0x0268 */ UPhysicsConstraintTemplate* ConstraintSetup;
    /* 0x0270 */ FMulticastInlineDelegate OnConstraintBroken;
    /* 0x0280 */ FConstraintInstance ConstraintInstance;

    void BreakConstraint();
    void GetConstraintForce(FVector& OutLinearForce, FVector& OutAngularForce);
    float GetCurrentSwing1() const;
    float GetCurrentSwing2() const;
    float GetCurrentTwist() const;
    bool IsBroken();
    void SetAngularBreakable(bool bAngularBreakable, float AngularBreakThreshold);
    void SetAngularDriveMode(uint8_t DriveMode);
    void SetAngularDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit);
    void SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
    void SetAngularOrientationTarget(const FRotator& InPosTarget);
    void SetAngularPlasticity(bool bAngularPlasticity, float AngularPlasticityThreshold);
    void SetAngularSwing1Limit(uint8_t MotionType, float Swing1LimitAngle);
    void SetAngularSwing2Limit(uint8_t MotionType, float Swing2LimitAngle);
    void SetAngularTwistLimit(uint8_t ConstraintType, float TwistLimitAngle);
    void SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
    void SetAngularVelocityDriveSLERP(bool bEnableSLERP);
    void SetAngularVelocityDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive);
    void SetAngularVelocityTarget(const FVector& InVelTarget);
    void SetConstrainedComponents(UPrimitiveComponent* Component1, FName BoneName1, UPrimitiveComponent* Component2, FName BoneName2);
    void SetConstraintReferenceFrame(uint8_t Frame, const FTransform& RefFrame);
    void SetConstraintReferenceOrientation(uint8_t Frame, const FVector& PriAxis, const FVector& SecAxis);
    void SetConstraintReferencePosition(uint8_t Frame, const FVector& RefPosition);
    void SetDisableCollision(bool bDisableCollision);
    void SetLinearBreakable(bool bLinearBreakable, float LinearBreakThreshold);
    void SetLinearDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit);
    void SetLinearPlasticity(bool bLinearPlasticity, float LinearPlasticityThreshold);
    void SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
    void SetLinearPositionTarget(const FVector& InPosTarget);
    void SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
    void SetLinearVelocityTarget(const FVector& InVelTarget);
    void SetLinearXLimit(uint8_t ConstraintType, float LimitSize);
    void SetLinearYLimit(uint8_t ConstraintType, float LimitSize);
    void SetLinearZLimit(uint8_t ConstraintType, float LimitSize);
    void SetOrientationDriveSLERP(bool bEnableSLERP);
    void SetOrientationDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive);
};

// Size: 0x120
struct FPhysicsConstraintProfileHandle {
    /* 0x0000 */ FConstraintProfileProperties ProfileProperties;
    /* 0x0114 */ FName ProfileName;
};

// Size: 0x4c0
class UPhysicsConstraintTemplate : public UObject {
    /* 0x0030 */ FConstraintInstance DefaultInstance;
    /* 0x02d0 */ TArray<FPhysicsConstraintProfileHandle> ProfileHandles;
    /* 0x02e0 */ FConstraintProfileProperties DefaultProfile;
    /* 0x03f4 */ FName JointName;
    /* 0x0400 */ FName ConstraintBone1;
    /* 0x040c */ FName ConstraintBone2;
    /* 0x0418 */ FVector Pos1;
    /* 0x0424 */ FVector PriAxis1;
    /* 0x0430 */ FVector SecAxis1;
    /* 0x043c */ FVector Pos2;
    /* 0x0448 */ FVector PriAxis2;
    /* 0x0454 */ FVector SecAxis2;
    /* 0x0460 */ bool bEnableProjection;
    /* 0x0464 */ float ProjectionLinearTolerance;
    /* 0x0468 */ float ProjectionAngularTolerance;
    /* 0x046c */ uint8_t LinearXMotion;
    /* 0x046d */ uint8_t LinearYMotion;
    /* 0x046e */ uint8_t LinearZMotion;
    /* 0x0470 */ float LinearLimitSize;
    /* 0x0474 */ bool bLinearLimitSoft;
    /* 0x0478 */ float LinearLimitStiffness;
    /* 0x047c */ float LinearLimitDamping;
    /* 0x0480 */ bool bLinearBreakable;
    /* 0x0484 */ float LinearBreakThreshold;
    /* 0x0488 */ uint8_t AngularSwing1Motion;
    /* 0x0489 */ uint8_t AngularSwing2Motion;
    /* 0x048a */ uint8_t AngularTwistMotion;
    /* 0x048c */ bool bSwingLimitSoft;
    /* 0x048c */ bool bTwistLimitSoft;
    /* 0x0490 */ float Swing1LimitAngle;
    /* 0x0494 */ float Swing2LimitAngle;
    /* 0x0498 */ float TwistLimitAngle;
    /* 0x049c */ float SwingLimitStiffness;
    /* 0x04a0 */ float SwingLimitDamping;
    /* 0x04a4 */ float TwistLimitStiffness;
    /* 0x04a8 */ float TwistLimitDamping;
    /* 0x04ac */ bool bAngularBreakable;
    /* 0x04b0 */ float AngularBreakThreshold;
};

// Size: 0x2a0
class UPhysicsFieldComponent : public USceneComponent {
};

// Size: 0x170
class UPhysicsHandleComponent : public UActorComponent {
    /* 0x00c0 */ UPrimitiveComponent* GrabbedComponent;
    /* 0x00d4 */ bool bSoftAngularConstraint;
    /* 0x00d4 */ bool bSoftLinearConstraint;
    /* 0x00d4 */ bool bInterpolateTarget;
    /* 0x00d8 */ float LinearDamping;
    /* 0x00dc */ float LinearStiffness;
    /* 0x00e0 */ float AngularDamping;
    /* 0x00e4 */ float AngularStiffness;
    /* 0x0150 */ float InterpolationSpeed;

    UPrimitiveComponent* GetGrabbedComponent() const;
    void GetTargetLocationAndRotation(FVector& TargetLocation, FRotator& TargetRotation) const;
    void GrabComponent(UPrimitiveComponent* Component, FName InBoneName, FVector GrabLocation, bool bConstrainRotation);
    void GrabComponentAtLocation(UPrimitiveComponent* Component, FName InBoneName, FVector GrabLocation);
    void GrabComponentAtLocationWithRotation(UPrimitiveComponent* Component, FName InBoneName, FVector Location, FRotator Rotation);
    void ReleaseComponent();
    void SetAngularDamping(float NewAngularDamping);
    void SetAngularStiffness(float NewAngularStiffness);
    void SetInterpolationSpeed(float NewInterpolationSpeed);
    void SetLinearDamping(float NewLinearDamping);
    void SetLinearStiffness(float NewLinearStiffness);
    void SetTargetLocation(FVector NewLocation);
    void SetTargetLocationAndRotation(FVector NewLocation, FRotator NewRotation);
    void SetTargetRotation(FRotator NewRotation);
};

// Size: 0x1c8
class UPhysicsSettings : public UPhysicsSettingsCore {
    /* 0x0108 */ FRigidBodyErrorCorrection PhysicErrorCorrection;
    /* 0x013c */ uint8_t LockedAxis;
    /* 0x013d */ uint8_t DefaultDegreesOfFreedom;
    /* 0x013e */ bool bSuppressFaceRemapTable;
    /* 0x013f */ bool bSupportUVFromHitResults;
    /* 0x0140 */ bool bDisableActiveActors;
    /* 0x0141 */ bool bDisableKinematicStaticPairs;
    /* 0x0142 */ bool bDisableKinematicKinematicPairs;
    /* 0x0143 */ bool bDisableCCD;
    /* 0x0144 */ bool bEnableEnhancedDeterminism;
    /* 0x0148 */ float AnimPhysicsMinDeltaTime;
    /* 0x014c */ bool bSimulateAnimPhysicsAfterReset;
    /* 0x0150 */ float MaxPhysicsDeltaTime;
    /* 0x0154 */ bool bSubstepping;
    /* 0x0155 */ bool bSubsteppingAsync;
    /* 0x0158 */ float MaxSubstepDeltaTime;
    /* 0x015c */ int32_t MaxSubsteps;
    /* 0x0160 */ float SyncSceneSmoothingFactor;
    /* 0x0164 */ float InitialAverageFrameRate;
    /* 0x0168 */ int32_t PhysXTreeRebuildRate;
    /* 0x0170 */ TArray<FPhysicalSurfaceName> PhysicalSurfaces;
    /* 0x0180 */ FBroadphaseSettings DefaultBroadphaseSettings;
    /* 0x01c0 */ float MinDeltaVelocityForHitEvents;
    /* 0x01c4 */ FChaosPhysicsSettings ChaosSettings;
};

// Size: 0x250
class UPhysicsSpringComponent : public USceneComponent {
    /* 0x0228 */ float SpringStiffness;
    /* 0x022c */ float SpringDamping;
    /* 0x0230 */ float SpringLengthAtRest;
    /* 0x0234 */ float SpringRadius;
    /* 0x0238 */ uint8_t SpringChannel;
    /* 0x0239 */ bool bIgnoreSelf;
    /* 0x023c */ float SpringCompression;

    float GetNormalizedCompressionScalar() const;
    FVector GetSpringCurrentEndPoint() const;
    FVector GetSpringDirection() const;
    FVector GetSpringRestingPoint() const;
};

// Size: 0x308
class APhysicsThruster : public ARigidBodyBase {
    /* 0x02f8 */ UPhysicsThrusterComponent* ThrusterComponent;
    /* 0x0300 */ UArrowComponent* ArrowComponent;
};

// Size: 0x230
class UPhysicsThrusterComponent : public USceneComponent {
    /* 0x0228 */ float ThrustStrength;
};

// Size: 0x348
class APhysicsVolume : public AVolume {
    /* 0x0338 */ float TerminalVelocity;
    /* 0x033c */ int32_t Priority;
    /* 0x0340 */ float FluidFriction;
    /* 0x0344 */ bool bWaterVolume;
    /* 0x0344 */ bool bPhysicsOnContact;
};

// Size: 0x320
class APlanarReflection : public ASceneCapture {
    /* 0x0308 */ UPlanarReflectionComponent* PlanarReflectionComponent;
    /* 0x0310 */ UBillboardComponent* SpriteComponent;
    /* 0x0318 */ bool bShowPreviewPlane;

    void OnInterpToggle(bool bEnable);
};

// Size: 0x3f0
class UPlanarReflectionComponent : public USceneCaptureComponent {
    /* 0x0300 */ UBoxComponent* PreviewBox;
    /* 0x0308 */ float NormalDistortionStrength;
    /* 0x030c */ float PrefilterRoughness;
    /* 0x0310 */ float PrefilterRoughnessDistance;
    /* 0x0314 */ int32_t ScreenPercentage;
    /* 0x0318 */ float ExtraFOV;
    /* 0x031c */ float DistanceFromPlaneFadeStart;
    /* 0x0320 */ float DistanceFromPlaneFadeEnd;
    /* 0x0324 */ float DistanceFromPlaneFadeoutStart;
    /* 0x0328 */ float DistanceFromPlaneFadeoutEnd;
    /* 0x032c */ float AngleFromPlaneFadeStart;
    /* 0x0330 */ float AngleFromPlaneFadeEnd;
    /* 0x0334 */ bool bShowPreviewPlane;
    /* 0x0335 */ bool bRenderSceneTwoSided;
    /* 0x0338 */ UMaterial* CaptureMaterial;
};

// Size: 0x310
class APlaneReflectionCapture : public AReflectionCapture {
};

// Size: 0x2c0
class UPlaneReflectionCaptureComponent : public UReflectionCaptureComponent {
    /* 0x02a0 */ float InfluenceRadiusScale;
    /* 0x02a8 */ UDrawSphereComponent* PreviewInfluenceRadius;
    /* 0x02b0 */ UBoxComponent* PreviewCaptureBox;
};

// Size: 0xe0
class UPlatformEventsComponent : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate PlatformChangedToLaptopModeDelegate;
    /* 0x00d0 */ FMulticastInlineDelegate PlatformChangedToTabletModeDelegate;

    bool IsInLaptopMode();
    bool IsInTabletMode();
    void PlatformEventDelegate__DelegateSignature();
    bool SupportsConvertibleLaptops();
};

// Size: 0x288
class UPlatformGameInstance : public UGameInstance {
    /* 0x01b8 */ FMulticastInlineDelegate ApplicationWillDeactivateDelegate;
    /* 0x01c8 */ FMulticastInlineDelegate ApplicationHasReactivatedDelegate;
    /* 0x01d8 */ FMulticastInlineDelegate ApplicationWillEnterBackgroundDelegate;
    /* 0x01e8 */ FMulticastInlineDelegate ApplicationHasEnteredForegroundDelegate;
    /* 0x01f8 */ FMulticastInlineDelegate ApplicationWillTerminateDelegate;
    /* 0x0208 */ FMulticastInlineDelegate ApplicationShouldUnloadResourcesDelegate;
    /* 0x0218 */ FMulticastInlineDelegate ApplicationReceivedStartupArgumentsDelegate;
    /* 0x0228 */ FMulticastInlineDelegate ApplicationRegisteredForRemoteNotificationsDelegate;
    /* 0x0238 */ FMulticastInlineDelegate ApplicationRegisteredForUserNotificationsDelegate;
    /* 0x0248 */ FMulticastInlineDelegate ApplicationFailedToRegisterForRemoteNotificationsDelegate;
    /* 0x0258 */ FMulticastInlineDelegate ApplicationReceivedRemoteNotificationDelegate;
    /* 0x0268 */ FMulticastInlineDelegate ApplicationReceivedLocalNotificationDelegate;
    /* 0x0278 */ FMulticastInlineDelegate ApplicationReceivedScreenOrientationChangedNotificationDelegate;

    void PlatformDelegate__DelegateSignature();
    void PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature(FString inString);
    void PlatformReceivedLocalNotificationDelegate__DelegateSignature(FString inString, int32_t inInt, uint8_t inAppState);
    void PlatformReceivedRemoteNotificationDelegate__DelegateSignature(FString inString, uint8_t inAppState);
    void PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature(const TArray<uint8_t>& inArray);
    void PlatformRegisteredForUserNotificationsDelegate__DelegateSignature(int32_t inInt);
    void PlatformScreenOrientationChangedDelegate__DelegateSignature(uint8_t inScreenOrientation);
    void PlatformStartupArgumentsDelegate__DelegateSignature(const TArray<FString>& StartupArguments);
};

// Size: 0x40
class UPlatformInterfaceBase : public UObject {
    /* 0x0030 */ TArray<FDelegateArray> AllDelegates;
};

// Size: 0x30
struct FPlatformInterfaceData {
    /* 0x0000 */ FName DataName;
    /* 0x000c */ uint8_t Type;
    /* 0x0010 */ int32_t IntValue;
    /* 0x0014 */ float FloatValue;
    /* 0x0018 */ FString StringValue;
    /* 0x0028 */ UObject* ObjectValue;
};

// Size: 0x38
struct FPlatformInterfaceDelegateResult {
    /* 0x0000 */ bool bSuccessful;
    /* 0x0008 */ FPlatformInterfaceData Data;
};

// Size: 0xb8
class UPlatformInterfaceWebResponse : public UObject {
    /* 0x0030 */ FString OriginalURL;
    /* 0x0040 */ int32_t ResponseCode;
    /* 0x0044 */ int32_t Tag;
    /* 0x0048 */ FString StringResponse;
    /* 0x0058 */ TArray<uint8_t> BinaryResponse;

    void GetHeader(int32_t HeaderIndex, FString& Header, FString& Value);
    FString GetHeaderValue(FString HeaderName);
    int32_t GetNumHeaders();
};

// Size: 0x50
class UPlayer : public UObject {
    /* 0x0038 */ APlayerController* PlayerController;
    /* 0x0040 */ int32_t CurrentNetSpeed;
    /* 0x0044 */ int32_t ConfiguredInternetSpeed;
    /* 0x0048 */ int32_t ConfiguredLanSpeed;
};

// Size: 0x2a10
class APlayerCameraManager : public AActor {
    /* 0x02f8 */ APlayerController* PCOwner;
    /* 0x0300 */ USceneComponent* TransformComponent;
    /* 0x0314 */ float DefaultFOV;
    /* 0x031c */ float DefaultOrthoWidth;
    /* 0x0324 */ float DefaultAspectRatio;
    /* 0x0370 */ FCameraCacheEntry CameraCache;
    /* 0x09a0 */ FCameraCacheEntry LastFrameCameraCache;
    /* 0x0fd0 */ FTViewTarget ViewTarget;
    /* 0x1610 */ FTViewTarget PendingViewTarget;
    /* 0x1c80 */ FCameraCacheEntry CameraCachePrivate;
    /* 0x22b0 */ FCameraCacheEntry LastFrameCameraCachePrivate;
    /* 0x28e0 */ TArray<UCameraModifier*> ModifierList;
    /* 0x28f0 */ TArray<UClass*> DefaultModifiers;
    /* 0x2900 */ float FreeCamDistance;
    /* 0x2904 */ FVector FreeCamOffset;
    /* 0x2910 */ FVector ViewTargetOffset;
    /* 0x2920 */ FMulticastInlineDelegate OnAudioFadeChangeEvent;
    /* 0x2940 */ TArray<AEmitterCameraLensEffectBase*> CameraLensEffects;
    /* 0x2950 */ UCameraModifier_CameraShake* CachedCameraShakeMod;
    /* 0x2958 */ UCameraAnimInst* AnimInstPool[8];
    /* 0x2998 */ TArray<FPostProcessSettings> PostProcessBlendCache;
    /* 0x29b8 */ TArray<UCameraAnimInst*> ActiveAnims;
    /* 0x29c8 */ TArray<UCameraAnimInst*> FreeAnims;
    /* 0x29d8 */ ACameraActor* AnimCameraActor;
    /* 0x29e0 */ bool bIsOrthographic;
    /* 0x29e0 */ bool bDefaultConstrainAspectRatio;
    /* 0x29e0 */ bool bClientSimulatingViewTarget;
    /* 0x29e0 */ bool bUseClientSideCameraUpdates;
    /* 0x29e1 */ bool bGameCameraCutThisFrame;
    /* 0x29e4 */ float ViewPitchMin;
    /* 0x29e8 */ float ViewPitchMax;
    /* 0x29ec */ float ViewYawMin;
    /* 0x29f0 */ float ViewYawMax;
    /* 0x29f4 */ float ViewRollMin;
    /* 0x29f8 */ float ViewRollMax;
    /* 0x2a00 */ float ServerUpdateCameraTimeout;

    AEmitterCameraLensEffectBase* AddCameraLensEffect(UClass* LensEffectEmitterClass);
    UCameraModifier* AddNewCameraModifier(UClass* ModifierClass);
    bool BlueprintUpdateCamera(AActor* CameraTarget, FVector& NewCameraLocation, FRotator& NewCameraRotation, float& NewCameraFOV);
    void ClearCameraLensEffects();
    UCameraModifier* FindCameraModifierByClass(UClass* ModifierClass);
    FVector GetCameraLocation() const;
    FRotator GetCameraRotation() const;
    float GetFOVAngle() const;
    APlayerController* GetOwningPlayerController() const;
    void OnPhotographyMultiPartCaptureEnd();
    void OnPhotographyMultiPartCaptureStart();
    void OnPhotographySessionEnd();
    void OnPhotographySessionStart();
    void PhotographyCameraModify(const FVector NewCameraLocation, const FVector PreviousCameraLocation, const FVector OriginalCameraLocation, FVector& ResultCameraLocation);
    UCameraAnimInst* PlayCameraAnim(UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void RemoveCameraLensEffect(AEmitterCameraLensEffectBase* Emitter);
    bool RemoveCameraModifier(UCameraModifier* ModifierToRemove);
    void SetGameCameraCutThisFrame();
    void SetManualCameraFade(float InFadeAmount, FLinearColor Color, bool bInFadeAudio);
    void StartCameraFade(float FromAlpha, float ToAlpha, float Duration, FLinearColor Color, bool bShouldFadeAudio, bool bHoldWhenFinished);
    UCameraShakeBase* StartCameraShake(UClass* ShakeClass, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    UCameraShakeBase* StartCameraShakeFromSource(UClass* ShakeClass, UCameraShakeSourceComponent* SourceComponent, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void StopAllCameraAnims(bool bImmediate);
    void StopAllCameraShakes(bool bImmediately);
    void StopAllCameraShakesFromSource(UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void StopAllInstancesOfCameraAnim(UCameraAnim* Anim, bool bImmediate);
    void StopAllInstancesOfCameraShake(UClass* Shake, bool bImmediately);
    void StopAllInstancesOfCameraShakeFromSource(UClass* Shake, UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void StopCameraAnimInst(UCameraAnimInst* AnimInst, bool bImmediate);
    void StopCameraFade();
    void StopCameraShake(UCameraShakeBase* ShakeInstance, bool bImmediately);
    void SwapPendingViewTargetWhenUsingClientSideCameraUpdates();
};

// Size: 0x660
class APlayerController : public AController {
    /* 0x0378 */ UPlayer* Player;
    /* 0x0380 */ APawn* AcknowledgedPawn;
    /* 0x0388 */ UInterpTrackInstDirector* ControllingDirTrackInst;
    /* 0x0390 */ AHUD* MyHUD;
    /* 0x0398 */ APlayerCameraManager* PlayerCameraManager;
    /* 0x03a0 */ UClass* PlayerCameraManagerClass;
    /* 0x03a8 */ bool bAutoManageActiveCameraTarget;
    /* 0x03ac */ FRotator TargetViewRotation;
    /* 0x03c4 */ float SmoothTargetViewRotationSpeed;
    /* 0x03d0 */ TArray<AActor*> HiddenActors;
    /* 0x03e0 */ TArray<TWeakObjectPtr<UPrimitiveComponent>> HiddenPrimitiveComponents;
    /* 0x03f4 */ float LastSpectatorStateSynchTime;
    /* 0x03f8 */ FVector LastSpectatorSyncLocation;
    /* 0x0404 */ FRotator LastSpectatorSyncRotation;
    /* 0x0410 */ int32_t ClientCap;
    /* 0x0418 */ UCheatManager* CheatManager;
    /* 0x0420 */ UClass* CheatClass;
    /* 0x0428 */ UPlayerInput* PlayerInput;
    /* 0x0430 */ TArray<FActiveForceFeedbackEffect> ActiveForceFeedbackEffects;
    /* 0x04c0 */ bool bPlayerIsWaiting;
    /* 0x04c4 */ uint8_t NetPlayerIndex;
    /* 0x0500 */ UNetConnection* PendingSwapConnection;
    /* 0x0508 */ UNetConnection* NetConnection;
    /* 0x051c */ float InputYawScale;
    /* 0x0520 */ float InputPitchScale;
    /* 0x0524 */ float InputRollScale;
    /* 0x0528 */ bool bShowMouseCursor;
    /* 0x0528 */ bool bEnableClickEvents;
    /* 0x0528 */ bool bEnableTouchEvents;
    /* 0x0528 */ bool bEnableMouseOverEvents;
    /* 0x0528 */ bool bEnableTouchOverEvents;
    /* 0x0528 */ bool bForceFeedbackEnabled;
    /* 0x052c */ float ForceFeedbackScale;
    /* 0x0530 */ TArray<FKey> ClickEventKeys;
    /* 0x0540 */ uint8_t DefaultMouseCursor;
    /* 0x0541 */ uint8_t CurrentMouseCursor;
    /* 0x0542 */ uint8_t DefaultClickTraceChannel;
    /* 0x0543 */ uint8_t CurrentClickTraceChannel;
    /* 0x0544 */ float HitResultTraceDistance;
    /* 0x0548 */ uint16_t SeamlessTravelCount;
    /* 0x054a */ uint16_t LastCompletedSeamlessTravelCount;
    /* 0x05c0 */ UInputComponent* InactiveStateInputComponent;
    /* 0x05c8 */ bool bShouldPerformFullTickWhenPaused;
    /* 0x05e0 */ UTouchInterface* CurrentTouchInterface;
    /* 0x0638 */ ASpectatorPawn* SpectatorPawn;
    /* 0x0644 */ bool bIsLocalPlayerController;
    /* 0x0648 */ FVector SpawnLocation;

    void ActivateTouchInterface(UTouchInterface* NewTouchInterface);
    void AddPitchInput(float Val);
    void AddRollInput(float Val);
    void AddYawInput(float Val);
    void Camera(FName NewMode);
    bool CanRestartPlayer();
    void ClearAudioListenerAttenuationOverride();
    void ClearAudioListenerOverride();
    void ClientAddTextureStreamingLoc(FVector InLoc, float Duration, bool bOverrideLocation);
    void ClientCancelPendingMapChange();
    void ClientCapBandwidth(int32_t Cap);
    void ClientClearCameraLensEffects();
    void ClientCommitMapChange();
    void ClientEnableNetworkVoice(bool bEnable);
    void ClientEndOnlineSession();
    void ClientFlushLevelStreaming();
    void ClientForceGarbageCollection();
    void ClientGameEnded(AActor* EndGameFocus, bool bIsWinner);
    void ClientGotoState(FName NewState);
    void ClientIgnoreLookInput(bool bIgnore);
    void ClientIgnoreMoveInput(bool bIgnore);
    void ClientMessage(FString S, FName Type, float MsgLifeTime);
    void ClientMutePlayer(FUniqueNetIdRepl PlayerId);
    void ClientPlayCameraAnim(UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, ECameraShakePlaySpace Space, FRotator CustomPlaySpace);
    void ClientPlayForceFeedback_Internal(UForceFeedbackEffect* ForceFeedbackEffect, FForceFeedbackParameters Params);
    void ClientPlaySound(USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier);
    void ClientPlaySoundAtLocation(USoundBase* Sound, FVector Location, float VolumeMultiplier, float PitchMultiplier);
    void ClientPrepareMapChange(FName LevelName, bool bFirst, bool bLast);
    void ClientPrestreamTextures(AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int32_t CinematicTextureGroups);
    void ClientReceiveLocalizedMessage(UClass* Message, int32_t SWITCH, APlayerState* RelatedPlayerState_1, APlayerState* RelatedPlayerState_2, UObject* OptionalObject);
    void ClientRepObjRef(UObject* Object);
    void ClientReset();
    void ClientRestart(APawn* NewPawn);
    void ClientRetryClientRestart(APawn* NewPawn);
    void ClientReturnToMainMenu(FString ReturnReason);
    void ClientReturnToMainMenuWithTextReason(const FText ReturnReason);
    void ClientSetBlockOnAsyncLoading();
    void ClientSetCameraFade(bool bEnableFading, FColor FadeColor, FVector2D FadeAlpha, float FadeTime, bool bFadeAudio, bool bHoldWhenFinished);
    void ClientSetCameraMode(FName NewCamMode);
    void ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD);
    void ClientSetForceMipLevelsToBeResident(UMaterialInterface* Material, float ForceDuration, int32_t CinematicTextureGroups);
    void ClientSetHUD(UClass* NewHUDClass);
    void ClientSetSpectatorWaiting(bool bWaiting);
    void ClientSetViewTarget(AActor* A, FViewTargetTransitionParams TransitionParams);
    void ClientSpawnCameraLensEffect(UClass* LensEffectEmitterClass);
    void ClientStartCameraShake(UClass* Shake, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void ClientStartCameraShakeFromSource(UClass* Shake, UCameraShakeSourceComponent* SourceComponent);
    void ClientStartOnlineSession();
    void ClientStopCameraAnim(UCameraAnim* AnimToStop);
    void ClientStopCameraShake(UClass* Shake, bool bImmediately);
    void ClientStopCameraShakesFromSource(UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void ClientStopForceFeedback(UForceFeedbackEffect* ForceFeedbackEffect, FName Tag);
    void ClientTeamMessage(APlayerState* SenderPlayerState, FString S, FName Type, float MsgLifeTime);
    void ClientTravel(FString URL, uint8_t TravelType, bool bSeamless, FGuid MapPackageGuid);
    void ClientTravelInternal(FString URL, uint8_t TravelType, bool bSeamless, FGuid MapPackageGuid);
    void ClientUnmutePlayer(FUniqueNetIdRepl PlayerId);
    void ClientUpdateLevelStreamingStatus(FName PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int32_t LODIndex);
    void ClientUpdateMultipleLevelsStreamingStatus(const TArray<FUpdateLevelStreamingLevelStatus> LevelStatuses);
    void ClientVoiceHandshakeComplete();
    void ClientWasKicked(const FText KickReason);
    void ConsoleKey(FKey Key);
    bool DeprojectMousePositionToWorld(FVector& WorldLocation, FVector& WorldDirection) const;
    bool DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, FVector& WorldLocation, FVector& WorldDirection) const;
    void EnableCheats();
    void FOV(float NewFOV);
    FVector GetFocalLocation() const;
    AHUD* GetHUD() const;
    bool GetHitResultUnderCursor(uint8_t TraceChannel, bool bTraceComplex, FHitResult& HitResult) const;
    bool GetHitResultUnderCursorByChannel(uint8_t TraceChannel, bool bTraceComplex, FHitResult& HitResult) const;
    bool GetHitResultUnderCursorForObjects(const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, FHitResult& HitResult) const;
    bool GetHitResultUnderFinger(uint8_t FingerIndex, uint8_t TraceChannel, bool bTraceComplex, FHitResult& HitResult) const;
    bool GetHitResultUnderFingerByChannel(uint8_t FingerIndex, uint8_t TraceChannel, bool bTraceComplex, FHitResult& HitResult) const;
    bool GetHitResultUnderFingerForObjects(uint8_t FingerIndex, const TArray<uint8_t>& ObjectTypes, bool bTraceComplex, FHitResult& HitResult) const;
    float GetInputAnalogKeyState(FKey Key) const;
    void GetInputAnalogStickState(uint8_t WhichStick, float& StickX, float& StickY) const;
    float GetInputKeyTimeDown(FKey Key) const;
    void GetInputMotionState(FVector& Tilt, FVector& RotationRate, FVector& Gravity, FVector& Acceleration) const;
    void GetInputMouseDelta(float& DeltaX, float& DeltaY) const;
    void GetInputTouchState(uint8_t FingerIndex, float& LocationX, float& LocationY, bool& bIsCurrentlyPressed) const;
    FVector GetInputVectorKeyState(FKey Key) const;
    bool GetMousePosition(float& LocationX, float& LocationY) const;
    ASpectatorPawn* GetSpectatorPawn() const;
    void GetViewportSize(int32_t& SizeX, int32_t& SizeY) const;
    bool IsInputKeyDown(FKey Key) const;
    void K2_ClientPlayForceFeedback(UForceFeedbackEffect* ForceFeedbackEffect, FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused);
    void LocalTravel(FString URL);
    void OnServerStartedVisualLogger(bool bIsLogging);
    void Pause();
    void PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, uint8_t Action, FLatentActionInfo LatentInfo);
    void PlayHapticEffect(UHapticFeedbackEffect_Base* HapticEffect, EControllerHand hand, float Scale, bool bLoop);
    bool ProjectWorldLocationToScreen(FVector WorldLocation, FVector2D& ScreenLocation, bool bPlayerViewportRelative) const;
    void ResetControllerLightColor();
    void RestartLevel();
    void SendToConsole(FString Command);
    void ServerAcknowledgePossession(APawn* P);
    void ServerCamera(FName NewMode);
    void ServerChangeName(FString S);
    void ServerCheckClientPossession();
    void ServerCheckClientPossessionReliable();
    void ServerExec(FString Msg);
    void ServerExecRPC(FString Msg);
    void ServerMutePlayer(FUniqueNetIdRepl PlayerId);
    void ServerNotifyLoadedWorld(FName WorldPackageName);
    void ServerPause();
    void ServerRestartPlayer();
    void ServerSetSpectatorLocation(FVector NewLoc, FRotator NewRot);
    void ServerSetSpectatorWaiting(bool bWaiting);
    void ServerShortTimeout();
    void ServerToggleAILogging();
    void ServerUnmutePlayer(FUniqueNetIdRepl PlayerId);
    void ServerUpdateCamera(FVector_NetQuantize CamLoc, int32_t CamPitchAndYaw);
    void ServerUpdateLevelVisibility(const FUpdateLevelVisibilityLevelInfo LevelVisibility);
    void ServerUpdateMultipleLevelsVisibility(const TArray<FUpdateLevelVisibilityLevelInfo> LevelVisibilities);
    void ServerVerifyViewTarget();
    void ServerViewNextPlayer();
    void ServerViewPrevPlayer();
    void ServerViewSelf(FViewTargetTransitionParams TransitionParams);
    void SetAudioListenerAttenuationOverride(USceneComponent* AttachToComponent, FVector AttenuationLocationOVerride);
    void SetAudioListenerOverride(USceneComponent* AttachToComponent, FVector Location, FRotator Rotation);
    void SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
    void SetControllerLightColor(FColor Color);
    void SetDisableHaptics(bool bNewDisabled);
    void SetHapticsByValue(const float Frequency, const float Amplitude, EControllerHand hand);
    void SetMouseCursorWidget(uint8_t Cursor, UUserWidget* CursorWidget);
    void SetMouseLocation(const int32_t X, const int32_t Y);
    void SetName(FString S);
    void SetViewTargetWithBlend(AActor* NewViewTarget, float BlendTime, uint8_t BlendFunc, float BlendExp, bool bLockOutgoing);
    void SetVirtualJoystickVisibility(bool bVisible);
    void StartFire(uint8_t FireModeNum);
    void StopHapticEffect(EControllerHand hand);
    void SwitchLevel(FString URL);
    void TestServerLevelVisibilityChange(const FName PackageName, const FName Filename);
    void ToggleSpeaking(bool bInSpeaking);
    bool WasInputKeyJustPressed(FKey Key) const;
    bool WasInputKeyJustReleased(FKey Key) const;
};

// Size: 0x3b0
class UPlayerInput : public UObject {
    /* 0x0128 */ TArray<FKeyBind> DebugExecBindings;
    /* 0x0168 */ TArray<FName> InvertedAxis;

    void ClearSmoothing();
    void InvertAxis(const FName AxisName);
    void InvertAxisKey(const FKey AxisKey);
    void SetBind(FName BindName, FString Command);
    void SetMouseSensitivity(const float Sensitivity);
};

// Size: 0x38
struct FPlayerMuteList {
    /* 0x0030 */ bool bHasVoiceHandshakeCompleted;
    /* 0x0034 */ int32_t VoiceChannelIdx;
};

// Size: 0x338
class APlayerStart : public ANavigationObjectBase {
    /* 0x0320 */ FName PlayerStartTag;
    /* 0x0330 */ UArrowComponent* ArrowComponent;
};

// Size: 0x338
class APlayerStartPIE : public APlayerStart {
};

// Size: 0x408
class APlayerState : public AInfo {
    /* 0x0300 */ float Score;
    /* 0x0304 */ int32_t PlayerId;
    /* 0x0308 */ uint8_t Ping;
    /* 0x030a */ bool bShouldUpdateReplicatedPing;
    /* 0x030a */ bool bIsSpectator;
    /* 0x030a */ bool bOnlySpectator;
    /* 0x030a */ bool bIsABot;
    /* 0x030a */ bool bIsInactive;
    /* 0x030a */ bool bFromPreviousLevel;
    /* 0x030c */ int32_t StartTime;
    /* 0x0310 */ UClass* EngineMessageClass;
    /* 0x0320 */ FString SavedNetworkAddress;
    /* 0x0330 */ FUniqueNetIdRepl UniqueId;
    /* 0x0368 */ APawn* PawnPrivate;
    /* 0x03e8 */ FString PlayerNamePrivate;

    FString GetPlayerName() const;
    bool IsOnlyASpectator() const;
    void OnRep_PlayerId();
    void OnRep_PlayerName();
    void OnRep_Score();
    void OnRep_UniqueId();
    void OnRep_bIsInactive();
    void ReceiveCopyProperties(APlayerState* NewPlayerState);
    void ReceiveOverrideWith(APlayerState* OldPlayerState);
};

// Size: 0xa8
class UPluginCommandlet : public UCommandlet {
};

// Size: 0x20
struct FPluginRedirect {
    /* 0x0000 */ FString OldPluginName;
    /* 0x0010 */ FString NewPluginName;
};

// Size: 0xb0
struct FPointDamageEvent : public FDamageEvent {
    /* 0x0010 */ float Damage;
    /* 0x0014 */ FVector_NetQuantizeNormal ShotDirection;
    /* 0x0020 */ FHitResult HitInfo;
};

// Size: 0x310
class APointLight : public ALight {
    /* 0x0308 */ UPointLightComponent* PointLightComponent;

    void SetLightFalloffExponent(float NewLightFalloffExponent);
    void SetRadius(float NewRadius);
};

// Size: 0x3b0
class UPointLightComponent : public ULocalLightComponent {
    /* 0x0390 */ bool bUseInverseSquaredFalloff;
    /* 0x0394 */ float LightFalloffExponent;
    /* 0x0398 */ float SourceRadius;
    /* 0x039c */ float SoftSourceRadius;
    /* 0x03a0 */ float SourceLength;

    void SetLightFalloffExponent(float NewLightFalloffExponent);
    void SetSoftSourceRadius(float bNewValue);
    void SetSourceLength(float NewValue);
    void SetSourceRadius(float bNewValue);
};

// Size: 0x10
struct FPointerToUberGraphFrame {
};

// Size: 0x40
class UPolys : public UObject {
};

// Size: 0x10
struct FPooledCameraShakes {
    /* 0x0000 */ TArray<UCameraShakeBase*> PooledShakes;
};

// Size: 0x1f0
class UPoseAsset : public UAnimationAsset {
    /* 0x00e8 */ FPoseDataContainer PoseContainer;
    /* 0x0178 */ bool bAdditivePose;
    /* 0x017c */ int32_t BasePoseIndex;
    /* 0x0180 */ FName RetargetSource;
    /* 0x0190 */ TSoftObjectPtr<USkeletalMesh> RetargetSourceAsset;
    /* 0x01c0 */ TArray<FTransform> RetargetSourceAssetReferencePose;
    /* 0x01d0 */ UAnimSequence* SourceAnimation;
};

// Size: 0x90
struct FPoseData {
    /* 0x0000 */ TArray<FTransform> SourceLocalSpacePose;
    /* 0x0010 */ TArray<float> SourceCurveData;
    /* 0x0020 */ TArray<FTransform> LocalSpacePose;
    /* 0x0030 */ TMap<int32_t, int32_t> TrackToBufferIndex;
    /* 0x0080 */ TArray<float> CurveData;
};

// Size: 0x90
struct FPoseDataContainer {
    /* 0x0000 */ TArray<FSmartName> PoseNames;
    /* 0x0010 */ TArray<FName> Tracks;
    /* 0x0020 */ TMap<FName, int32_t> TrackMap;
    /* 0x0070 */ TArray<FPoseData> Poses;
    /* 0x0080 */ TArray<FAnimCurveBase> Curves;
};

// Size: 0x18
struct FPoseLink : public FPoseLinkBase {
};

// Size: 0x18
struct FPoseLinkBase {
    /* 0x0000 */ int32_t LinkID;
    /* 0x0004 */ int32_t SourceLinkID;
};

// Size: 0x40
struct FPoseSnapshot {
    /* 0x0000 */ TArray<FTransform> LocalTransforms;
    /* 0x0010 */ TArray<FName> BoneNames;
    /* 0x0020 */ FName SkeletalMeshName;
    /* 0x002c */ FName SnapshotName;
    /* 0x0038 */ bool bIsValid;
};

// Size: 0x40
class UPoseWatch : public UObject {
    /* 0x0030 */ UEdGraphNode* Node;
    /* 0x0038 */ FColor PoseWatchColour;
};

// Size: 0x8c0
class UPoseableMeshComponent : public USkinnedMeshComponent {

    void CopyPoseFromSkeletalComponent(USkeletalMeshComponent* InComponentToCopy);
    FVector GetBoneLocationByName(FName BoneName, uint8_t BoneSpace);
    FRotator GetBoneRotationByName(FName BoneName, uint8_t BoneSpace);
    FVector GetBoneScaleByName(FName BoneName, uint8_t BoneSpace);
    FTransform GetBoneTransformByName(FName BoneName, uint8_t BoneSpace);
    void ResetBoneTransformByName(FName BoneName);
    void SetBoneLocationByName(FName BoneName, FVector InLocation, uint8_t BoneSpace);
    void SetBoneRotationByName(FName BoneName, FRotator InRotation, uint8_t BoneSpace);
    void SetBoneScaleByName(FName BoneName, FVector InScale3D, uint8_t BoneSpace);
    void SetBoneTransformByName(FName BoneName, const FTransform& InTransform, uint8_t BoneSpace);
};

// Size: 0x7d0
class UPostProcessComponent : public USceneComponent {
    /* 0x0230 */ FPostProcessSettings Settings;
    /* 0x07c0 */ float Priority;
    /* 0x07c4 */ float BlendRadius;
    /* 0x07c8 */ float BlendWeight;
    /* 0x07cc */ bool bEnabled;
    /* 0x07cc */ bool bUnbound;

    void AddOrUpdateBlendable(TScriptInterface<IBlendableInterface> InBlendableObject, float InWeight);
};

// Size: 0x590
struct FPostProcessSettings {
    /* 0x0000 */ bool bOverride_TemperatureType;
    /* 0x0000 */ bool bOverride_WhiteTemp;
    /* 0x0000 */ bool bOverride_WhiteTint;
    /* 0x0000 */ bool bOverride_ColorSaturation;
    /* 0x0000 */ bool bOverride_ColorContrast;
    /* 0x0000 */ bool bOverride_ColorGamma;
    /* 0x0000 */ bool bOverride_ColorGain;
    /* 0x0000 */ bool bOverride_ColorOffset;
    /* 0x0001 */ bool bOverride_ColorSaturationShadows;
    /* 0x0001 */ bool bOverride_ColorContrastShadows;
    /* 0x0001 */ bool bOverride_ColorGammaShadows;
    /* 0x0001 */ bool bOverride_ColorGainShadows;
    /* 0x0001 */ bool bOverride_ColorOffsetShadows;
    /* 0x0001 */ bool bOverride_ColorSaturationMidtones;
    /* 0x0001 */ bool bOverride_ColorContrastMidtones;
    /* 0x0001 */ bool bOverride_ColorGammaMidtones;
    /* 0x0002 */ bool bOverride_ColorGainMidtones;
    /* 0x0002 */ bool bOverride_ColorOffsetMidtones;
    /* 0x0002 */ bool bOverride_ColorSaturationHighlights;
    /* 0x0002 */ bool bOverride_ColorContrastHighlights;
    /* 0x0002 */ bool bOverride_ColorGammaHighlights;
    /* 0x0002 */ bool bOverride_ColorGainHighlights;
    /* 0x0002 */ bool bOverride_ColorOffsetHighlights;
    /* 0x0002 */ bool bOverride_ColorCorrectionShadowsMax;
    /* 0x0003 */ bool bOverride_ColorCorrectionHighlightsMin;
    /* 0x0003 */ bool bOverride_BlueCorrection;
    /* 0x0003 */ bool bOverride_ExpandGamut;
    /* 0x0003 */ bool bOverride_ToneCurveAmount;
    /* 0x0003 */ bool bOverride_FilmWhitePoint;
    /* 0x0003 */ bool bOverride_FilmSaturation;
    /* 0x0003 */ bool bOverride_FilmChannelMixerRed;
    /* 0x0003 */ bool bOverride_FilmChannelMixerGreen;
    /* 0x0004 */ bool bOverride_FilmChannelMixerBlue;
    /* 0x0004 */ bool bOverride_FilmContrast;
    /* 0x0004 */ bool bOverride_FilmDynamicRange;
    /* 0x0004 */ bool bOverride_FilmHealAmount;
    /* 0x0004 */ bool bOverride_FilmToeAmount;
    /* 0x0004 */ bool bOverride_FilmShadowTint;
    /* 0x0004 */ bool bOverride_FilmShadowTintBlend;
    /* 0x0004 */ bool bOverride_FilmShadowTintAmount;
    /* 0x0005 */ bool bOverride_FilmSlope;
    /* 0x0005 */ bool bOverride_FilmToe;
    /* 0x0005 */ bool bOverride_FilmShoulder;
    /* 0x0005 */ bool bOverride_FilmBlackClip;
    /* 0x0005 */ bool bOverride_FilmWhiteClip;
    /* 0x0005 */ bool bOverride_SceneColorTint;
    /* 0x0005 */ bool bOverride_SceneFringeIntensity;
    /* 0x0005 */ bool bOverride_ChromaticAberrationStartOffset;
    /* 0x0006 */ bool bOverride_AmbientCubemapTint;
    /* 0x0006 */ bool bOverride_AmbientCubemapIntensity;
    /* 0x0006 */ bool bOverride_BloomMethod;
    /* 0x0006 */ bool bOverride_BloomIntensity;
    /* 0x0006 */ bool bOverride_BloomThreshold;
    /* 0x0006 */ bool bOverride_Bloom1Tint;
    /* 0x0006 */ bool bOverride_Bloom1Size;
    /* 0x0006 */ bool bOverride_Bloom2Size;
    /* 0x0007 */ bool bOverride_Bloom2Tint;
    /* 0x0007 */ bool bOverride_Bloom3Tint;
    /* 0x0007 */ bool bOverride_Bloom3Size;
    /* 0x0007 */ bool bOverride_Bloom4Tint;
    /* 0x0007 */ bool bOverride_Bloom4Size;
    /* 0x0007 */ bool bOverride_Bloom5Tint;
    /* 0x0007 */ bool bOverride_Bloom5Size;
    /* 0x0007 */ bool bOverride_Bloom6Tint;
    /* 0x0008 */ bool bOverride_Bloom6Size;
    /* 0x0008 */ bool bOverride_BloomSizeScale;
    /* 0x0008 */ bool bOverride_BloomConvolutionTexture;
    /* 0x0008 */ bool bOverride_BloomConvolutionSize;
    /* 0x0008 */ bool bOverride_BloomConvolutionCenterUV;
    /* 0x0008 */ bool bOverride_BloomConvolutionPreFilter;
    /* 0x0008 */ bool bOverride_BloomConvolutionPreFilterMin;
    /* 0x0008 */ bool bOverride_BloomConvolutionPreFilterMax;
    /* 0x0009 */ bool bOverride_BloomConvolutionPreFilterMult;
    /* 0x0009 */ bool bOverride_BloomConvolutionBufferScale;
    /* 0x0009 */ bool bOverride_BloomDirtMaskIntensity;
    /* 0x0009 */ bool bOverride_BloomDirtMaskTint;
    /* 0x0009 */ bool bOverride_BloomDirtMask;
    /* 0x0009 */ bool bOverride_CameraShutterSpeed;
    /* 0x0009 */ bool bOverride_CameraISO;
    /* 0x0009 */ bool bOverride_AutoExposureMethod;
    /* 0x000a */ bool bOverride_AutoExposureLowPercent;
    /* 0x000a */ bool bOverride_AutoExposureHighPercent;
    /* 0x000a */ bool bOverride_AutoExposureMinBrightness;
    /* 0x000a */ bool bOverride_AutoExposureMaxBrightness;
    /* 0x000a */ bool bOverride_AutoExposureCalibrationConstant;
    /* 0x000a */ bool bOverride_AutoExposureSpeedUp;
    /* 0x000a */ bool bOverride_AutoExposureSpeedDown;
    /* 0x000a */ bool bOverride_AutoExposureBias;
    /* 0x000b */ bool bOverride_AutoExposureBiasCurve;
    /* 0x000b */ bool bOverride_AutoExposureMeterMask;
    /* 0x000b */ bool bOverride_AutoExposureApplyPhysicalCameraExposure;
    /* 0x000b */ bool bOverride_HistogramLogMin;
    /* 0x000b */ bool bOverride_HistogramLogMax;
    /* 0x000b */ bool bOverride_LensFlareIntensity;
    /* 0x000b */ bool bOverride_LensFlareTint;
    /* 0x000b */ bool bOverride_LensFlareTints;
    /* 0x000c */ bool bOverride_LensFlareBokehSize;
    /* 0x000c */ bool bOverride_LensFlareBokehShape;
    /* 0x000c */ bool bOverride_LensFlareThreshold;
    /* 0x000c */ bool bOverride_VignetteIntensity;
    /* 0x000c */ bool bOverride_GrainIntensity;
    /* 0x000c */ bool bOverride_GrainJitter;
    /* 0x000c */ bool bOverride_AmbientOcclusionIntensity;
    /* 0x000c */ bool bOverride_AmbientOcclusionStaticFraction;
    /* 0x000d */ bool bOverride_AmbientOcclusionRadius;
    /* 0x000d */ bool bOverride_AmbientOcclusionFadeDistance;
    /* 0x000d */ bool bOverride_AmbientOcclusionFadeRadius;
    /* 0x000d */ bool bOverride_AmbientOcclusionDistance;
    /* 0x000d */ bool bOverride_AmbientOcclusionRadiusInWS;
    /* 0x000d */ bool bOverride_AmbientOcclusionPower;
    /* 0x000d */ bool bOverride_AmbientOcclusionBias;
    /* 0x000d */ bool bOverride_AmbientOcclusionQuality;
    /* 0x000e */ bool bOverride_AmbientOcclusionMipBlend;
    /* 0x000e */ bool bOverride_AmbientOcclusionMipScale;
    /* 0x000e */ bool bOverride_AmbientOcclusionMipThreshold;
    /* 0x000e */ bool bOverride_AmbientOcclusionTemporalBlendWeight;
    /* 0x0010 */ bool bOverride_RayTracingAO;
    /* 0x0010 */ bool bOverride_RayTracingAOSamplesPerPixel;
    /* 0x0010 */ bool bOverride_RayTracingAOIntensity;
    /* 0x0010 */ bool bOverride_RayTracingAORadius;
    /* 0x0014 */ bool bOverride_LPVIntensity;
    /* 0x0014 */ bool bOverride_LPVDirectionalOcclusionIntensity;
    /* 0x0014 */ bool bOverride_LPVDirectionalOcclusionRadius;
    /* 0x0014 */ bool bOverride_LPVDiffuseOcclusionExponent;
    /* 0x0014 */ bool bOverride_LPVSpecularOcclusionExponent;
    /* 0x0014 */ bool bOverride_LPVDiffuseOcclusionIntensity;
    /* 0x0014 */ bool bOverride_LPVSpecularOcclusionIntensity;
    /* 0x0014 */ bool bOverride_LPVSize;
    /* 0x0015 */ bool bOverride_LPVSecondaryOcclusionIntensity;
    /* 0x0015 */ bool bOverride_LPVSecondaryBounceIntensity;
    /* 0x0015 */ bool bOverride_LPVGeometryVolumeBias;
    /* 0x0015 */ bool bOverride_LPVVplInjectionBias;
    /* 0x0015 */ bool bOverride_LPVEmissiveInjectionIntensity;
    /* 0x0015 */ bool bOverride_LPVFadeRange;
    /* 0x0015 */ bool bOverride_LPVDirectionalOcclusionFadeRange;
    /* 0x0015 */ bool bOverride_IndirectLightingColor;
    /* 0x0016 */ bool bOverride_IndirectLightingIntensity;
    /* 0x0016 */ bool bOverride_ColorGradingIntensity;
    /* 0x0016 */ bool bOverride_ColorGradingLUT;
    /* 0x0016 */ bool bOverride_DepthOfFieldFocalDistance;
    /* 0x0016 */ bool bOverride_DepthOfFieldFstop;
    /* 0x0016 */ bool bOverride_DepthOfFieldMinFstop;
    /* 0x0016 */ bool bOverride_DepthOfFieldBladeCount;
    /* 0x0016 */ bool bOverride_DepthOfFieldSensorWidth;
    /* 0x0017 */ bool bOverride_DepthOfFieldDepthBlurRadius;
    /* 0x0017 */ bool bOverride_DepthOfFieldDepthBlurAmount;
    /* 0x0017 */ bool bOverride_DepthOfFieldFocalRegion;
    /* 0x0017 */ bool bOverride_DepthOfFieldNearTransitionRegion;
    /* 0x0017 */ bool bOverride_DepthOfFieldFarTransitionRegion;
    /* 0x0017 */ bool bOverride_DepthOfFieldScale;
    /* 0x0017 */ bool bOverride_DepthOfFieldNearBlurSize;
    /* 0x0017 */ bool bOverride_DepthOfFieldFarBlurSize;
    /* 0x0018 */ bool bOverride_MobileHQGaussian;
    /* 0x0018 */ bool bOverride_DepthOfFieldOcclusion;
    /* 0x0018 */ bool bOverride_DepthOfFieldSkyFocusDistance;
    /* 0x0018 */ bool bOverride_DepthOfFieldVignetteSize;
    /* 0x0018 */ bool bOverride_MotionBlurAmount;
    /* 0x0018 */ bool bOverride_MotionBlurMax;
    /* 0x0018 */ bool bOverride_MotionBlurTargetFPS;
    /* 0x0018 */ bool bOverride_MotionBlurPerObjectSize;
    /* 0x0019 */ bool bOverride_ScreenPercentage;
    /* 0x0019 */ bool bOverride_ScreenSpaceReflectionIntensity;
    /* 0x0019 */ bool bOverride_ScreenSpaceReflectionQuality;
    /* 0x0019 */ bool bOverride_ScreenSpaceReflectionMaxRoughness;
    /* 0x0019 */ bool bOverride_ScreenSpaceReflectionRoughnessScale;
    /* 0x001c */ bool bOverride_ReflectionsType;
    /* 0x001c */ bool bOverride_RayTracingReflectionsMaxRoughness;
    /* 0x001c */ bool bOverride_RayTracingReflectionsMaxBounces;
    /* 0x001c */ bool bOverride_RayTracingReflectionsSamplesPerPixel;
    /* 0x001c */ bool bOverride_RayTracingReflectionsShadows;
    /* 0x001c */ bool bOverride_RayTracingReflectionsTranslucency;
    /* 0x001c */ bool bOverride_TranslucencyType;
    /* 0x001c */ bool bOverride_RayTracingTranslucencyMaxRoughness;
    /* 0x001d */ bool bOverride_RayTracingTranslucencyRefractionRays;
    /* 0x001d */ bool bOverride_RayTracingTranslucencySamplesPerPixel;
    /* 0x001d */ bool bOverride_RayTracingTranslucencyShadows;
    /* 0x001d */ bool bOverride_RayTracingTranslucencyRefraction;
    /* 0x001d */ bool bOverride_RayTracingGI;
    /* 0x001d */ bool bOverride_RayTracingGIMaxBounces;
    /* 0x001d */ bool bOverride_RayTracingGISamplesPerPixel;
    /* 0x001d */ bool bOverride_PathTracingMaxBounces;
    /* 0x001e */ bool bOverride_PathTracingSamplesPerPixel;
    /* 0x001e */ bool bOverride_PathTracingFilterWidth;
    /* 0x001e */ bool bOverride_PathTracingEnableEmissive;
    /* 0x001e */ bool bOverride_PathTracingMaxPathExposure;
    /* 0x001e */ bool bOverride_PathTracingEnableDenoiser;
    /* 0x0020 */ bool bMobileHQGaussian;
    /* 0x0021 */ uint8_t BloomMethod;
    /* 0x0022 */ uint8_t AutoExposureMethod;
    /* 0x0023 */ uint8_t DepthOfFieldMethod;
    /* 0x0024 */ uint8_t TemperatureType;
    /* 0x0028 */ float WhiteTemp;
    /* 0x002c */ float WhiteTint;
    /* 0x0030 */ FVector4 ColorSaturation;
    /* 0x0040 */ FVector4 ColorContrast;
    /* 0x0050 */ FVector4 ColorGamma;
    /* 0x0060 */ FVector4 ColorGain;
    /* 0x0070 */ FVector4 ColorOffset;
    /* 0x0080 */ FVector4 ColorSaturationShadows;
    /* 0x0090 */ FVector4 ColorContrastShadows;
    /* 0x00a0 */ FVector4 ColorGammaShadows;
    /* 0x00b0 */ FVector4 ColorGainShadows;
    /* 0x00c0 */ FVector4 ColorOffsetShadows;
    /* 0x00d0 */ FVector4 ColorSaturationMidtones;
    /* 0x00e0 */ FVector4 ColorContrastMidtones;
    /* 0x00f0 */ FVector4 ColorGammaMidtones;
    /* 0x0100 */ FVector4 ColorGainMidtones;
    /* 0x0110 */ FVector4 ColorOffsetMidtones;
    /* 0x0120 */ FVector4 ColorSaturationHighlights;
    /* 0x0130 */ FVector4 ColorContrastHighlights;
    /* 0x0140 */ FVector4 ColorGammaHighlights;
    /* 0x0150 */ FVector4 ColorGainHighlights;
    /* 0x0160 */ FVector4 ColorOffsetHighlights;
    /* 0x0170 */ float ColorCorrectionHighlightsMin;
    /* 0x0174 */ float ColorCorrectionShadowsMax;
    /* 0x0178 */ float BlueCorrection;
    /* 0x017c */ float ExpandGamut;
    /* 0x0180 */ float ToneCurveAmount;
    /* 0x0184 */ float FilmSlope;
    /* 0x0188 */ float FilmToe;
    /* 0x018c */ float FilmShoulder;
    /* 0x0190 */ float FilmBlackClip;
    /* 0x0194 */ float FilmWhiteClip;
    /* 0x0198 */ FLinearColor FilmWhitePoint;
    /* 0x01a8 */ FLinearColor FilmShadowTint;
    /* 0x01b8 */ float FilmShadowTintBlend;
    /* 0x01bc */ float FilmShadowTintAmount;
    /* 0x01c0 */ float FilmSaturation;
    /* 0x01c4 */ FLinearColor FilmChannelMixerRed;
    /* 0x01d4 */ FLinearColor FilmChannelMixerGreen;
    /* 0x01e4 */ FLinearColor FilmChannelMixerBlue;
    /* 0x01f4 */ float FilmContrast;
    /* 0x01f8 */ float FilmToeAmount;
    /* 0x01fc */ float FilmHealAmount;
    /* 0x0200 */ float FilmDynamicRange;
    /* 0x0204 */ FLinearColor SceneColorTint;
    /* 0x0214 */ float SceneFringeIntensity;
    /* 0x0218 */ float ChromaticAberrationStartOffset;
    /* 0x021c */ float BloomIntensity;
    /* 0x0220 */ float BloomThreshold;
    /* 0x0224 */ float BloomSizeScale;
    /* 0x0228 */ float Bloom1Size;
    /* 0x022c */ float Bloom2Size;
    /* 0x0230 */ float Bloom3Size;
    /* 0x0234 */ float Bloom4Size;
    /* 0x0238 */ float Bloom5Size;
    /* 0x023c */ float Bloom6Size;
    /* 0x0240 */ FLinearColor Bloom1Tint;
    /* 0x0250 */ FLinearColor Bloom2Tint;
    /* 0x0260 */ FLinearColor Bloom3Tint;
    /* 0x0270 */ FLinearColor Bloom4Tint;
    /* 0x0280 */ FLinearColor Bloom5Tint;
    /* 0x0290 */ FLinearColor Bloom6Tint;
    /* 0x02a0 */ float BloomConvolutionSize;
    /* 0x02a8 */ UTexture2D* BloomConvolutionTexture;
    /* 0x02b0 */ FVector2D BloomConvolutionCenterUV;
    /* 0x02b8 */ FVector BloomConvolutionPreFilter;
    /* 0x02c4 */ float BloomConvolutionPreFilterMin;
    /* 0x02c8 */ float BloomConvolutionPreFilterMax;
    /* 0x02cc */ float BloomConvolutionPreFilterMult;
    /* 0x02d0 */ float BloomConvolutionBufferScale;
    /* 0x02d8 */ UTexture* BloomDirtMask;
    /* 0x02e0 */ float BloomDirtMaskIntensity;
    /* 0x02e4 */ FLinearColor BloomDirtMaskTint;
    /* 0x02f4 */ FLinearColor AmbientCubemapTint;
    /* 0x0304 */ float AmbientCubemapIntensity;
    /* 0x0308 */ UTextureCube* AmbientCubemap;
    /* 0x0310 */ float CameraShutterSpeed;
    /* 0x0314 */ float CameraISO;
    /* 0x0318 */ float DepthOfFieldFstop;
    /* 0x031c */ float DepthOfFieldMinFstop;
    /* 0x0320 */ int32_t DepthOfFieldBladeCount;
    /* 0x0324 */ float AutoExposureBias;
    /* 0x0328 */ float AutoExposureBiasBackup;
    /* 0x032c */ bool bOverride_AutoExposureBiasBackup;
    /* 0x0330 */ bool AutoExposureApplyPhysicalCameraExposure;
    /* 0x0338 */ UCurveFloat* AutoExposureBiasCurve;
    /* 0x0340 */ UTexture* AutoExposureMeterMask;
    /* 0x0348 */ float AutoExposureLowPercent;
    /* 0x034c */ float AutoExposureHighPercent;
    /* 0x0350 */ float AutoExposureMinBrightness;
    /* 0x0354 */ float AutoExposureMaxBrightness;
    /* 0x0358 */ float AutoExposureSpeedUp;
    /* 0x035c */ float AutoExposureSpeedDown;
    /* 0x0360 */ float HistogramLogMin;
    /* 0x0364 */ float HistogramLogMax;
    /* 0x0368 */ float AutoExposureCalibrationConstant;
    /* 0x036c */ float LensFlareIntensity;
    /* 0x0370 */ FLinearColor LensFlareTint;
    /* 0x0380 */ float LensFlareBokehSize;
    /* 0x0384 */ float LensFlareThreshold;
    /* 0x0388 */ UTexture* LensFlareBokehShape;
    /* 0x0390 */ FLinearColor LensFlareTints[8];
    /* 0x0410 */ float VignetteIntensity;
    /* 0x0414 */ float GrainJitter;
    /* 0x0418 */ float GrainIntensity;
    /* 0x041c */ float AmbientOcclusionIntensity;
    /* 0x0420 */ float AmbientOcclusionStaticFraction;
    /* 0x0424 */ float AmbientOcclusionRadius;
    /* 0x0428 */ bool AmbientOcclusionRadiusInWS;
    /* 0x042c */ float AmbientOcclusionFadeDistance;
    /* 0x0430 */ float AmbientOcclusionFadeRadius;
    /* 0x0434 */ float AmbientOcclusionDistance;
    /* 0x0438 */ float AmbientOcclusionPower;
    /* 0x043c */ float AmbientOcclusionBias;
    /* 0x0440 */ float AmbientOcclusionQuality;
    /* 0x0444 */ float AmbientOcclusionMipBlend;
    /* 0x0448 */ float AmbientOcclusionMipScale;
    /* 0x044c */ float AmbientOcclusionMipThreshold;
    /* 0x0450 */ float AmbientOcclusionTemporalBlendWeight;
    /* 0x0454 */ bool RayTracingAO;
    /* 0x0458 */ int32_t RayTracingAOSamplesPerPixel;
    /* 0x045c */ float RayTracingAOIntensity;
    /* 0x0460 */ float RayTracingAORadius;
    /* 0x0464 */ FLinearColor IndirectLightingColor;
    /* 0x0474 */ float IndirectLightingIntensity;
    /* 0x0478 */ bool RayTracingGI;
    /* 0x047c */ ERayTracingGlobalIlluminationType RayTracingGIType;
    /* 0x0480 */ int32_t RayTracingGIMaxBounces;
    /* 0x0484 */ int32_t RayTracingGISamplesPerPixel;
    /* 0x0488 */ float ColorGradingIntensity;
    /* 0x0490 */ UTexture* ColorGradingLUT;
    /* 0x0498 */ float DepthOfFieldSensorWidth;
    /* 0x049c */ float DepthOfFieldFocalDistance;
    /* 0x04a0 */ float DepthOfFieldDepthBlurAmount;
    /* 0x04a4 */ float DepthOfFieldDepthBlurRadius;
    /* 0x04a8 */ float DepthOfFieldFocalRegion;
    /* 0x04ac */ float DepthOfFieldNearTransitionRegion;
    /* 0x04b0 */ float DepthOfFieldFarTransitionRegion;
    /* 0x04b4 */ float DepthOfFieldScale;
    /* 0x04b8 */ float DepthOfFieldNearBlurSize;
    /* 0x04bc */ float DepthOfFieldFarBlurSize;
    /* 0x04c0 */ float DepthOfFieldOcclusion;
    /* 0x04c4 */ float DepthOfFieldSkyFocusDistance;
    /* 0x04c8 */ float DepthOfFieldVignetteSize;
    /* 0x04cc */ float MotionBlurAmount;
    /* 0x04d0 */ float MotionBlurMax;
    /* 0x04d4 */ int32_t MotionBlurTargetFPS;
    /* 0x04d8 */ float MotionBlurPerObjectSize;
    /* 0x04dc */ float LPVIntensity;
    /* 0x04e0 */ float LPVVplInjectionBias;
    /* 0x04e4 */ float LPVSize;
    /* 0x04e8 */ float LPVSecondaryOcclusionIntensity;
    /* 0x04ec */ float LPVSecondaryBounceIntensity;
    /* 0x04f0 */ float LPVGeometryVolumeBias;
    /* 0x04f4 */ float LPVEmissiveInjectionIntensity;
    /* 0x04f8 */ float LPVDirectionalOcclusionIntensity;
    /* 0x04fc */ float LPVDirectionalOcclusionRadius;
    /* 0x0500 */ float LPVDiffuseOcclusionExponent;
    /* 0x0504 */ float LPVSpecularOcclusionExponent;
    /* 0x0508 */ float LPVDiffuseOcclusionIntensity;
    /* 0x050c */ float LPVSpecularOcclusionIntensity;
    /* 0x0510 */ EReflectionsType ReflectionsType;
    /* 0x0514 */ float ScreenSpaceReflectionIntensity;
    /* 0x0518 */ float ScreenSpaceReflectionQuality;
    /* 0x051c */ float ScreenSpaceReflectionMaxRoughness;
    /* 0x0520 */ float RayTracingReflectionsMaxRoughness;
    /* 0x0524 */ int32_t RayTracingReflectionsMaxBounces;
    /* 0x0528 */ int32_t RayTracingReflectionsSamplesPerPixel;
    /* 0x052c */ EReflectedAndRefractedRayTracedShadows RayTracingReflectionsShadows;
    /* 0x052d */ bool RayTracingReflectionsTranslucency;
    /* 0x052e */ ETranslucencyType TranslucencyType;
    /* 0x0530 */ float RayTracingTranslucencyMaxRoughness;
    /* 0x0534 */ int32_t RayTracingTranslucencyRefractionRays;
    /* 0x0538 */ int32_t RayTracingTranslucencySamplesPerPixel;
    /* 0x053c */ EReflectedAndRefractedRayTracedShadows RayTracingTranslucencyShadows;
    /* 0x053d */ bool RayTracingTranslucencyRefraction;
    /* 0x0540 */ int32_t PathTracingMaxBounces;
    /* 0x0544 */ int32_t PathTracingSamplesPerPixel;
    /* 0x0548 */ float PathTracingFilterWidth;
    /* 0x054c */ bool PathTracingEnableEmissive;
    /* 0x0550 */ float PathTracingMaxPathExposure;
    /* 0x0554 */ bool PathTracingEnableDenoiser;
    /* 0x0558 */ float LPVFadeRange;
    /* 0x055c */ float LPVDirectionalOcclusionFadeRange;
    /* 0x0560 */ float ScreenPercentage;
    /* 0x0568 */ FWeightedBlendables WeightedBlendables;
    /* 0x0578 */ TArray<UObject*> Blendables;
};

// Size: 0x8e0
class APostProcessVolume : public AVolume {
    /* 0x0340 */ FPostProcessSettings Settings;
    /* 0x08d0 */ float Priority;
    /* 0x08d4 */ float BlendRadius;
    /* 0x08d8 */ float BlendWeight;
    /* 0x08dc */ bool bEnabled;
    /* 0x08dc */ bool bUnbound;

    void AddOrUpdateBlendable(TScriptInterface<IBlendableInterface> InBlendableObject, float InWeight);
};

// Size: 0x110
struct FPrecomputedLightInstanceData : public FSceneComponentInstanceData {
    /* 0x00c0 */ FTransform Transform;
    /* 0x00f0 */ FGuid LightGuid;
    /* 0x0100 */ int32_t PreviewShadowMapChannel;
};

// Size: 0x170
struct FPrecomputedSkyLightInstanceData : public FSceneComponentInstanceData {
    /* 0x00b8 */ FGuid LightGuid;
    /* 0x00c8 */ float AverageBrightness;
};

// Size: 0x368
class APrecomputedVisibilityOverrideVolume : public AVolume {
    /* 0x0338 */ TArray<AActor*> OverrideVisibleActors;
    /* 0x0348 */ TArray<AActor*> OverrideInvisibleActors;
    /* 0x0358 */ TArray<FName> OverrideInvisibleLevels;
};

// Size: 0x338
class APrecomputedVisibilityVolume : public AVolume {
};

// Size: 0x60
struct FPredictProjectilePathParams {
    /* 0x0000 */ FVector StartLocation;
    /* 0x000c */ FVector LaunchVelocity;
    /* 0x0018 */ bool bTraceWithCollision;
    /* 0x001c */ float ProjectileRadius;
    /* 0x0020 */ float MaxSimTime;
    /* 0x0024 */ bool bTraceWithChannel;
    /* 0x0025 */ uint8_t TraceChannel;
    /* 0x0028 */ TArray<uint8_t> ObjectTypes;
    /* 0x0038 */ TArray<AActor*> ActorsToIgnore;
    /* 0x0048 */ float SimFrequency;
    /* 0x004c */ float OverrideGravityZ;
    /* 0x0050 */ uint8_t DrawDebugType;
    /* 0x0054 */ float DrawDebugTime;
    /* 0x0058 */ bool bTraceComplex;
};

// Size: 0x1c
struct FPredictProjectilePathPointData {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FVector Velocity;
    /* 0x0018 */ float Time;
};

// Size: 0xc0
struct FPredictProjectilePathResult {
    /* 0x0000 */ TArray<FPredictProjectilePathPointData> PathData;
    /* 0x0010 */ FPredictProjectilePathPointData LastTraceDestination;
    /* 0x002c */ FHitResult HitResult;
};

// Size: 0x10
struct FPreviewAssetAttachContainer {
    /* 0x0000 */ TArray<FPreviewAttachedObjectPair> AttachedObjects;
};

// Size: 0x48
struct FPreviewAttachedObjectPair {
    /* 0x0000 */ TSoftObjectPtr<UObject> AttachedObject;
    /* 0x0030 */ UObject* Object;
    /* 0x0038 */ FName AttachedTo;
};

// Size: 0x30
class IPreviewCollectionInterface : public UInterface {
};

// Size: 0x58
class UPreviewMeshCollection : public UDataAsset {
    /* 0x0040 */ USkeleton* Skeleton;
    /* 0x0048 */ TArray<FPreviewMeshCollectionEntry> SkeletalMeshes;
};

// Size: 0x30
struct FPreviewMeshCollectionEntry {
    /* 0x0000 */ TSoftObjectPtr<USkeletalMesh> SkeletalMesh;
};

// Size: 0x88
class UPrimaryAssetLabel : public UPrimaryDataAsset {
    /* 0x0048 */ FPrimaryAssetRules Rules;
    /* 0x0054 */ bool bLabelAssetsInMyDirectory;
    /* 0x0054 */ bool bIsRuntimeLabel;
    /* 0x0058 */ TArray<TSoftObjectPtr<UObject>> ExplicitAssets;
    /* 0x0068 */ TArray<TSoftClassPtr<UObject>> ExplicitBlueprints;
    /* 0x0078 */ FCollectionReference AssetCollection;
};

// Size: 0xc
struct FPrimaryAssetRules {
    /* 0x0000 */ int32_t Priority;
    /* 0x0004 */ int32_t ChunkID;
    /* 0x0008 */ bool bApplyRecursively;
    /* 0x0009 */ EPrimaryAssetCookRule CookRule;
};

// Size: 0x40
struct FPrimaryAssetRulesCustomOverride {
    /* 0x0000 */ FPrimaryAssetType PrimaryAssetType;
    /* 0x0010 */ FDirectoryPath FilterDirectory;
    /* 0x0020 */ FString FilterString;
    /* 0x0030 */ FPrimaryAssetRules Rules;
};

// Size: 0x24
struct FPrimaryAssetRulesOverride {
    /* 0x0000 */ FPrimaryAssetId PrimaryAssetId;
    /* 0x0018 */ FPrimaryAssetRules Rules;
};

// Size: 0x98
struct FPrimaryAssetTypeInfo {
    /* 0x0000 */ FName PrimaryAssetType;
    /* 0x0010 */ TSoftClassPtr<UObject> AssetBaseClass;
    /* 0x0040 */ UClass* AssetBaseClassLoaded;
    /* 0x0048 */ bool bHasBlueprintClasses;
    /* 0x0049 */ bool bIsEditorOnly;
    /* 0x0050 */ TArray<FDirectoryPath> Directories;
    /* 0x0060 */ TArray<FSoftObjectPath> SpecificAssets;
    /* 0x0070 */ FPrimaryAssetRules Rules;
    /* 0x0080 */ TArray<FString> AssetScanPaths;
    /* 0x0090 */ bool bIsDynamicAsset;
    /* 0x0094 */ int32_t NumberOfAssets;
};

// Size: 0x48
class UPrimaryDataAsset : public UDataAsset {
    /* 0x0038 */ FAssetBundleData AssetBundleData;
};

// Size: 0x4e0
class UPrimitiveComponent : public USceneComponent {
    /* 0x0230 */ float MinDrawDistance;
    /* 0x0234 */ float LDMaxDrawDistance;
    /* 0x0238 */ float CachedMaxDrawDistance;
    /* 0x023c */ uint8_t DepthPriorityGroup;
    /* 0x023d */ uint8_t ViewOwnerDepthPriorityGroup;
    /* 0x023e */ uint8_t IndirectLightingCacheQuality;
    /* 0x023f */ ELightmapType LightmapType;
    /* 0x0240 */ TArray<int32_t> ExcludeForSpecificHLODLevels;
    /* 0x0250 */ bool bEnableAutoLODGeneration;
    /* 0x0250 */ bool bUseMaxLODAsImposter;
    /* 0x0250 */ bool bBatchImpostersAsInstances;
    /* 0x0250 */ bool bNeverDistanceCull;
    /* 0x0251 */ bool bAlwaysCreatePhysicsState;
    /* 0x0251 */ bool bGenerateOverlapEvents;
    /* 0x0251 */ bool bMultiBodyOverlap;
    /* 0x0251 */ bool bTraceComplexOnMove;
    /* 0x0251 */ bool bReturnMaterialOnMove;
    /* 0x0251 */ bool bUseViewOwnerDepthPriorityGroup;
    /* 0x0251 */ bool bAllowCullDistanceVolume;
    /* 0x0251 */ bool bHasMotionBlurVelocityMeshes;
    /* 0x0252 */ bool bVisibleInReflectionCaptures;
    /* 0x0252 */ bool bVisibleInRealTimeSkyCaptures;
    /* 0x0252 */ bool bVisibleInRayTracing;
    /* 0x0252 */ bool bRenderInMainPass;
    /* 0x0252 */ bool bRenderInDepthPass;
    /* 0x0252 */ bool bReceivesDecals;
    /* 0x0252 */ bool bOwnerNoSee;
    /* 0x0252 */ bool bOnlyOwnerSee;
    /* 0x0253 */ bool bTreatAsBackgroundForOcclusion;
    /* 0x0253 */ bool bUseAsOccluder;
    /* 0x0253 */ bool bSelectable;
    /* 0x0253 */ bool bForceMipStreaming;
    /* 0x0253 */ bool bHasPerInstanceHitProxies;
    /* 0x0253 */ bool CastShadow;
    /* 0x0253 */ bool bAffectDynamicIndirectLighting;
    /* 0x0253 */ bool bAffectDistanceFieldLighting;
    /* 0x0254 */ bool bCastDynamicShadow;
    /* 0x0254 */ bool bCastStaticShadow;
    /* 0x0254 */ bool bCastVolumetricTranslucentShadow;
    /* 0x0254 */ bool bCastContactShadow;
    /* 0x0254 */ bool bSelfShadowOnly;
    /* 0x0254 */ bool bCastFarShadow;
    /* 0x0254 */ bool bCastInsetShadow;
    /* 0x0254 */ bool bCastCinematicShadow;
    /* 0x0255 */ bool bCastHiddenShadow;
    /* 0x0255 */ bool bCastShadowAsTwoSided;
    /* 0x0255 */ bool bLightAsIfStatic;
    /* 0x0255 */ bool bLightAttachmentsAsGroup;
    /* 0x0255 */ bool bExcludeFromLightAttachmentGroup;
    /* 0x0255 */ bool bReceiveMobileCSMShadows;
    /* 0x0255 */ bool bSingleSampleShadowFromStationaryLights;
    /* 0x0255 */ bool bIgnoreRadialImpulse;
    /* 0x0256 */ bool bIgnoreRadialForce;
    /* 0x0256 */ bool bApplyImpulseOnDamage;
    /* 0x0256 */ bool bReplicatePhysicsToAutonomousProxy;
    /* 0x0256 */ bool bFillCollisionUnderneathForNavmesh;
    /* 0x0256 */ bool AlwaysLoadOnClient;
    /* 0x0256 */ bool AlwaysLoadOnServer;
    /* 0x0256 */ bool bUseEditorCompositing;
    /* 0x0256 */ bool bRenderCustomDepth;
    /* 0x0257 */ bool bVisibleInSceneCaptureOnly;
    /* 0x0257 */ bool bHiddenInSceneCapture;
    /* 0x0258 */ uint8_t bHasCustomNavigableGeometry;
    /* 0x0259 */ uint8_t HitProxyPriority;
    /* 0x025a */ uint8_t CanBeCharacterBase;
    /* 0x025c */ uint8_t CanCharacterStepUpOn;
    /* 0x025d */ FLightingChannels LightingChannels;
    /* 0x025e */ ERendererStencilMask CustomDepthStencilWriteMask;
    /* 0x0260 */ int32_t CustomDepthStencilValue;
    /* 0x0268 */ FCustomPrimitiveData CustomPrimitiveData;
    /* 0x0278 */ FCustomPrimitiveData CustomPrimitiveDataInternal;
    /* 0x0290 */ int32_t TranslucencySortPriority;
    /* 0x0294 */ float TranslucencySortDistanceOffset;
    /* 0x0298 */ int32_t VisibilityId;
    /* 0x02a0 */ TArray<URuntimeVirtualTexture*> RuntimeVirtualTextures;
    /* 0x02b0 */ int8_t VirtualTextureLodBias;
    /* 0x02b1 */ int8_t VirtualTextureCullMips;
    /* 0x02b2 */ int8_t VirtualTextureMinCoverage;
    /* 0x02b3 */ ERuntimeVirtualTextureMainPassType VirtualTextureRenderPassType;
    /* 0x02b8 */ float LpvBiasMultiplier;
    /* 0x02c4 */ float BoundsScale;
    /* 0x02d8 */ TArray<AActor*> MoveIgnoreActors;
    /* 0x02e8 */ TArray<UPrimitiveComponent*> MoveIgnoreComponents;
    /* 0x0318 */ FBodyInstance BodyInstance;
    /* 0x04a8 */ FMulticastSparseDelegate OnComponentHit;
    /* 0x04a9 */ FMulticastSparseDelegate OnComponentBeginOverlap;
    /* 0x04aa */ FMulticastSparseDelegate OnComponentEndOverlap;
    /* 0x04ab */ FMulticastSparseDelegate OnComponentWake;
    /* 0x04ac */ FMulticastSparseDelegate OnComponentSleep;
    /* 0x04ae */ FMulticastSparseDelegate OnBeginCursorOver;
    /* 0x04af */ FMulticastSparseDelegate OnEndCursorOver;
    /* 0x04b0 */ FMulticastSparseDelegate OnClicked;
    /* 0x04b1 */ FMulticastSparseDelegate OnReleased;
    /* 0x04b2 */ FMulticastSparseDelegate OnInputTouchBegin;
    /* 0x04b3 */ FMulticastSparseDelegate OnInputTouchEnd;
    /* 0x04b4 */ FMulticastSparseDelegate OnInputTouchEnter;
    /* 0x04b5 */ FMulticastSparseDelegate OnInputTouchLeave;
    /* 0x04d0 */ UPrimitiveComponent* LODParentPrimitive;

    void AddAngularImpulse(FVector Impulse, FName BoneName, bool bVelChange);
    void AddAngularImpulseInDegrees(FVector Impulse, FName BoneName, bool bVelChange);
    void AddAngularImpulseInRadians(FVector Impulse, FName BoneName, bool bVelChange);
    void AddForce(FVector Force, FName BoneName, bool bAccelChange);
    void AddForceAtLocation(FVector Force, FVector Location, FName BoneName);
    void AddForceAtLocationLocal(FVector Force, FVector Location, FName BoneName);
    void AddImpulse(FVector Impulse, FName BoneName, bool bVelChange);
    void AddImpulseAtLocation(FVector Impulse, FVector Location, FName BoneName);
    void AddRadialForce(FVector Origin, float Radius, float Strength, uint8_t Falloff, bool bAccelChange);
    void AddRadialImpulse(FVector Origin, float Radius, float Strength, uint8_t Falloff, bool bVelChange);
    void AddTorque(FVector Torque, FName BoneName, bool bAccelChange);
    void AddTorqueInDegrees(FVector Torque, FName BoneName, bool bAccelChange);
    void AddTorqueInRadians(FVector Torque, FName BoneName, bool bAccelChange);
    bool CanCharacterStepUp(APawn* Pawn) const;
    void ClearMoveIgnoreActors();
    void ClearMoveIgnoreComponents();
    TArray<AActor*> CopyArrayOfMoveIgnoreActors();
    TArray<UPrimitiveComponent*> CopyArrayOfMoveIgnoreComponents();
    UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamic(int32_t ElementIndex);
    UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamicFromMaterial(int32_t ElementIndex, UMaterialInterface* Parent);
    UMaterialInstanceDynamic* CreateDynamicMaterialInstance(int32_t ElementIndex, UMaterialInterface* SourceMaterial, FName OptionalName);
    float GetAngularDamping() const;
    FVector GetCenterOfMass(FName BoneName) const;
    float GetClosestPointOnCollision(const FVector& Point, FVector& OutPointOnBody, FName BoneName) const;
    uint8_t GetCollisionEnabled() const;
    uint8_t GetCollisionObjectType() const;
    FName GetCollisionProfileName() const;
    uint8_t GetCollisionResponseToChannel(uint8_t Channel) const;
    bool GetGenerateOverlapEvents() const;
    FVector GetInertiaTensor(FName BoneName) const;
    float GetLinearDamping() const;
    float GetMass() const;
    float GetMassScale(FName BoneName) const;
    UMaterialInterface* GetMaterial(int32_t ElementIndex) const;
    UMaterialInterface* GetMaterialFromCollisionFaceIndex(int32_t FaceIndex, int32_t& SectionIndex) const;
    int32_t GetNumMaterials() const;
    void GetOverlappingActors(TArray<AActor*>& OverlappingActors, UClass* ClassFilter) const;
    void GetOverlappingComponents(TArray<UPrimitiveComponent*>& OutOverlappingComponents) const;
    FVector GetPhysicsAngularVelocity(FName BoneName) const;
    FVector GetPhysicsAngularVelocityInDegrees(FName BoneName) const;
    FVector GetPhysicsAngularVelocityInRadians(FName BoneName) const;
    FVector GetPhysicsLinearVelocity(FName BoneName);
    FVector GetPhysicsLinearVelocityAtPoint(FVector Point, FName BoneName);
    FWalkableSlopeOverride GetWalkableSlopeOverride() const;
    void IgnoreActorWhenMoving(AActor* Actor, bool bShouldIgnore);
    void IgnoreComponentWhenMoving(UPrimitiveComponent* Component, bool bShouldIgnore);
    bool IsAnyRigidBodyAwake();
    bool IsGravityEnabled() const;
    bool IsOverlappingActor(const AActor* Other) const;
    bool IsOverlappingComponent(const UPrimitiveComponent* OtherComp) const;
    bool K2_BoxOverlapComponent(FVector InBoxCentre, const FBox InBox, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_IsCollisionEnabled() const;
    bool K2_IsPhysicsCollisionEnabled() const;
    bool K2_IsQueryCollisionEnabled() const;
    bool K2_LineTraceComponent(FVector TraceStart, FVector TraceEnd, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_SphereOverlapComponent(FVector InSphereCentre, float InSphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_SphereTraceComponent(FVector TraceStart, FVector TraceEnd, float SphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    void PutRigidBodyToSleep(FName BoneName);
    FVector ScaleByMomentOfInertia(FVector InputVector, FName BoneName) const;
    void SetAllMassScale(float InMassScale);
    void SetAllPhysicsAngularVelocityInDegrees(const FVector& NewAngVel, bool bAddToCurrent);
    void SetAllPhysicsAngularVelocityInRadians(const FVector& NewAngVel, bool bAddToCurrent);
    void SetAllPhysicsLinearVelocity(FVector NewVel, bool bAddToCurrent);
    void SetAllUseCCD(bool InUseCCD);
    void SetAngularDamping(float InDamping);
    void SetBoundsScale(float NewBoundsScale);
    void SetCastHiddenShadow(bool NewCastHiddenShadow);
    void SetCastInsetShadow(bool bInCastInsetShadow);
    void SetCastShadow(bool NewCastShadow);
    void SetCenterOfMass(FVector CenterOfMassOffset, FName BoneName);
    void SetCollisionEnabled(uint8_t NewType);
    void SetCollisionObjectType(uint8_t Channel);
    void SetCollisionProfileName(FName InCollisionProfileName, bool bUpdateOverlaps);
    void SetCollisionResponseToAllChannels(uint8_t NewResponse);
    void SetCollisionResponseToChannel(uint8_t Channel, uint8_t NewResponse);
    void SetConstraintMode(uint8_t ConstraintMode);
    void SetCullDistance(float NewCullDistance);
    void SetCustomDepthStencilValue(int32_t Value);
    void SetCustomDepthStencilWriteMask(ERendererStencilMask WriteMaskBit);
    void SetCustomPrimitiveDataFloat(int32_t DataIndex, float Value);
    void SetCustomPrimitiveDataVector2(int32_t DataIndex, FVector2D Value);
    void SetCustomPrimitiveDataVector3(int32_t DataIndex, FVector Value);
    void SetCustomPrimitiveDataVector4(int32_t DataIndex, FVector4 Value);
    void SetDefaultCustomPrimitiveDataFloat(int32_t DataIndex, float Value);
    void SetDefaultCustomPrimitiveDataVector2(int32_t DataIndex, FVector2D Value);
    void SetDefaultCustomPrimitiveDataVector3(int32_t DataIndex, FVector Value);
    void SetDefaultCustomPrimitiveDataVector4(int32_t DataIndex, FVector4 Value);
    void SetEnableGravity(bool bGravityEnabled);
    void SetExcludeFromLightAttachmentGroup(bool bInExcludeFromLightAttachmentGroup);
    void SetGenerateOverlapEvents(bool bInGenerateOverlapEvents);
    void SetHiddenInSceneCapture(bool bValue);
    void SetLightAttachmentsAsGroup(bool bInLightAttachmentsAsGroup);
    void SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2);
    void SetLinearDamping(float InDamping);
    void SetMassOverrideInKg(FName BoneName, float MassInKg, bool bOverrideMass);
    void SetMassScale(FName BoneName, float InMassScale);
    void SetMaterial(int32_t ElementIndex, UMaterialInterface* Material);
    void SetMaterialByName(FName MaterialSlotName, UMaterialInterface* Material);
    void SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision);
    void SetOnlyOwnerSee(bool bNewOnlyOwnerSee);
    void SetOwnerNoSee(bool bNewOwnerNoSee);
    void SetPhysMaterialOverride(UPhysicalMaterial* NewPhysMaterial);
    void SetPhysicsAngularVelocity(FVector NewAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsAngularVelocityInDegrees(FVector NewAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsAngularVelocityInRadians(FVector NewAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsLinearVelocity(FVector NewVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsMaxAngularVelocity(float NewMaxAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsMaxAngularVelocityInDegrees(float NewMaxAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsMaxAngularVelocityInRadians(float NewMaxAngVel, bool bAddToCurrent, FName BoneName);
    void SetReceivesDecals(bool bNewReceivesDecals);
    void SetRenderCustomDepth(bool bValue);
    void SetRenderInMainPass(bool bValue);
    void SetSimulatePhysics(bool bSimulate);
    void SetSingleSampleShadowFromStationaryLights(bool bNewSingleSampleShadowFromStationaryLights);
    void SetTranslucencySortDistanceOffset(float NewTranslucencySortDistanceOffset);
    void SetTranslucentSortPriority(int32_t NewTranslucentSortPriority);
    void SetUseCCD(bool InUseCCD, FName BoneName);
    void SetVisibleInSceneCaptureOnly(bool bValue);
    void SetWalkableSlopeOverride(const FWalkableSlopeOverride& NewOverride);
    void WakeAllRigidBodies();
    void WakeRigidBody(FName BoneName);
    bool WasRecentlyRendered(float Tolerance) const;
};

// Size: 0x100
struct FPrimitiveComponentInstanceData : public FSceneComponentInstanceData {
    /* 0x00c0 */ FTransform ComponentTransform;
    /* 0x00f0 */ int32_t VisibilityId;
    /* 0x00f8 */ UPrimitiveComponent* LODParent;
};

// Size: 0x18
struct FPrimitiveMaterialRef {
    /* 0x0000 */ UPrimitiveComponent* Primitive;
    /* 0x0008 */ UDecalComponent* Decal;
    /* 0x0010 */ int32_t ElementIndex;
};

// Size: 0x1e0
class UProjectileMovementComponent : public UMovementComponent {
    /* 0x0100 */ float InitialSpeed;
    /* 0x0104 */ float MaxSpeed;
    /* 0x0108 */ bool bRotationFollowsVelocity;
    /* 0x0108 */ bool bRotationRemainsVertical;
    /* 0x0108 */ bool bShouldBounce;
    /* 0x0108 */ bool bInitialVelocityInLocalSpace;
    /* 0x0108 */ bool bForceSubStepping;
    /* 0x0108 */ bool bSimulationEnabled;
    /* 0x0108 */ bool bSweepCollision;
    /* 0x0108 */ bool bIsHomingProjectile;
    /* 0x0109 */ bool bBounceAngleAffectsFriction;
    /* 0x0109 */ bool bIsSliding;
    /* 0x0109 */ bool bInterpMovement;
    /* 0x0109 */ bool bInterpRotation;
    /* 0x010c */ float PreviousHitTime;
    /* 0x0110 */ FVector PreviousHitNormal;
    /* 0x011c */ float ProjectileGravityScale;
    /* 0x0120 */ float Buoyancy;
    /* 0x0124 */ float Bounciness;
    /* 0x0128 */ float Friction;
    /* 0x012c */ float BounceVelocityStopSimulatingThreshold;
    /* 0x0130 */ float MinFrictionFraction;
    /* 0x0138 */ FMulticastInlineDelegate OnProjectileBounce;
    /* 0x0148 */ FMulticastInlineDelegate OnProjectileStop;
    /* 0x0158 */ float HomingAccelerationMagnitude;
    /* 0x015c */ TWeakObjectPtr<USceneComponent> HomingTargetComponent;
    /* 0x0164 */ float MaxSimulationTimeStep;
    /* 0x0168 */ int32_t MaxSimulationIterations;
    /* 0x016c */ int32_t BounceAdditionalIterations;
    /* 0x0170 */ float InterpLocationTime;
    /* 0x0174 */ float InterpRotationTime;
    /* 0x0178 */ float InterpLocationMaxLagDistance;
    /* 0x017c */ float InterpLocationSnapToTargetDistance;

    bool IsInterpolationComplete() const;
    bool IsVelocityUnderSimulationThreshold() const;
    FVector LimitVelocity(FVector NewVelocity) const;
    void MoveInterpolationTarget(const FVector& NewLocation, const FRotator& NewRotation);
    void OnProjectileBounceDelegate__DelegateSignature(const FHitResult& ImpactResult, const FVector& ImpactVelocity);
    void OnProjectileStopDelegate__DelegateSignature(const FHitResult& ImpactResult);
    void ResetInterpolation();
    void SetInterpolatedComponent(USceneComponent* Component);
    void SetVelocityInLocalSpace(FVector NewVelocity);
    void StopSimulating(const FHitResult& HitResult);
};

// Size: 0x70
class UProxyLODMeshSimplificationSettings : public UDeveloperSettings {
    /* 0x0060 */ FName ProxyLODMeshReductionModuleName;
};

// Size: 0x40
struct FPurchaseInfo {
    /* 0x0000 */ FString Identifier;
    /* 0x0010 */ FString DisplayName;
    /* 0x0020 */ FString DisplayDescription;
    /* 0x0030 */ FString DisplayPrice;
};

// Size: 0x20
struct FQuartzClockSettings {
    /* 0x0000 */ FQuartzTimeSignature TimeSignature;
    /* 0x0018 */ bool bIgnoreLevelChange;
};

// Size: 0x8
struct FQuartzPulseOverrideStep {
    /* 0x0000 */ int32_t NumberOfPulses;
    /* 0x0004 */ EQuartzCommandQuantization PulseDuration;
};

// Size: 0xc
struct FQuartzQuantizationBoundary {
    /* 0x0000 */ EQuartzCommandQuantization Quantization;
    /* 0x0004 */ float Multiplier;
    /* 0x0008 */ EQuarztQuantizationReference CountingReferencePoint;
    /* 0x0009 */ bool bFireOnClockStart;
};

// Size: 0x18
struct FQuartzTimeSignature {
    /* 0x0000 */ int32_t NumBeats;
    /* 0x0004 */ EQuartzTimeSignatureQuantization BeatType;
    /* 0x0008 */ TArray<FQuartzPulseOverrideStep> OptionalPulseOverride;
};

// Size: 0x10
struct FQuartzTransportTimeStamp {
    /* 0x0000 */ int32_t Bars;
    /* 0x0004 */ int32_t Beat;
    /* 0x0008 */ float BeatFraction;
    /* 0x000c */ float Seconds;
};

// Size: 0x68
struct FQueuedDrawDebugItem {
    /* 0x0000 */ uint8_t ItemType;
    /* 0x0004 */ FVector StartLoc;
    /* 0x0010 */ FVector EndLoc;
    /* 0x001c */ FVector Center;
    /* 0x0028 */ FRotator Rotation;
    /* 0x0034 */ float Radius;
    /* 0x0038 */ float Size;
    /* 0x003c */ int32_t Segments;
    /* 0x0040 */ FColor Color;
    /* 0x0044 */ bool bPersistentLines;
    /* 0x0048 */ float LifeTime;
    /* 0x004c */ float Thickness;
    /* 0x0050 */ FString Message;
    /* 0x0060 */ FVector2D TextScale;
};

// Size: 0x30
class IRVOAvoidanceInterface : public UInterface {
};

// Size: 0x40
struct FRadialDamageEvent : public FDamageEvent {
    /* 0x0010 */ FRadialDamageParams Params;
    /* 0x0024 */ FVector Origin;
    /* 0x0030 */ TArray<FHitResult> ComponentHits;
};

// Size: 0x14
struct FRadialDamageParams {
    /* 0x0000 */ float BaseDamage;
    /* 0x0004 */ float MinimumDamage;
    /* 0x0008 */ float InnerRadius;
    /* 0x000c */ float OuterRadius;
    /* 0x0010 */ float DamageFalloff;
};

// Size: 0x308
class ARadialForceActor : public ARigidBodyBase {
    /* 0x02f8 */ URadialForceComponent* ForceComponent;
    /* 0x0300 */ UBillboardComponent* SpriteComponent;

    void DisableForce();
    void EnableForce();
    void FireImpulse();
    void ToggleForce();
};

// Size: 0x260
class URadialForceComponent : public USceneComponent {
    /* 0x0228 */ float Radius;
    /* 0x022c */ uint8_t Falloff;
    /* 0x0230 */ float ImpulseStrength;
    /* 0x0234 */ bool bImpulseVelChange;
    /* 0x0234 */ bool bIgnoreOwningActor;
    /* 0x0238 */ float ForceStrength;
    /* 0x023c */ float DestructibleDamage;
    /* 0x0240 */ TArray<uint8_t> ObjectTypesToAffect;

    void AddObjectTypeToAffect(uint8_t ObjectType);
    void FireImpulse();
    void RemoveObjectTypeToAffect(uint8_t ObjectType);
};

// Size: 0x30
struct FRawAnimSequenceTrack {
    /* 0x0000 */ TArray<FVector> PosKeys;
    /* 0x0010 */ TArray<FQuat> RotKeys;
    /* 0x0020 */ TArray<FVector> ScaleKeys;
};

// Size: 0x30
struct FRawCurveTracks {
    /* 0x0000 */ TArray<FFloatCurve> FloatCurves;
    /* 0x0010 */ TArray<FVectorCurve> VectorCurves;
    /* 0x0020 */ TArray<FTransformCurve> TransformCurves;
};

// Size: 0x20
struct FRawDistribution {
    /* 0x0000 */ FDistributionLookupTable Table;
};

// Size: 0x30
struct FRawDistributionFloat : public FRawDistribution {
    /* 0x0020 */ float MinValue;
    /* 0x0024 */ float MaxValue;
    /* 0x0028 */ UDistributionFloat* Distribution;
};

// Size: 0x48
struct FRawDistributionVector : public FRawDistribution {
    /* 0x0020 */ float MinValue;
    /* 0x0024 */ float MaxValue;
    /* 0x0028 */ FVector MinValueVec;
    /* 0x0034 */ FVector MaxValueVec;
    /* 0x0040 */ UDistributionVector* Distribution;
};

// Size: 0x70
struct FRealCurve : public FIndexedCurve {
    /* 0x0068 */ float DefaultValue;
    /* 0x006c */ uint8_t PreInfinityExtrap;
    /* 0x006d */ uint8_t PostInfinityExtrap;
};

// Size: 0x310
class ARectLight : public ALight {
    /* 0x0308 */ URectLightComponent* RectLightComponent;
};

// Size: 0x3b0
class URectLightComponent : public ULocalLightComponent {
    /* 0x0390 */ float SourceWidth;
    /* 0x0394 */ float SourceHeight;
    /* 0x0398 */ float BarnDoorAngle;
    /* 0x039c */ float BarnDoorLength;
    /* 0x03a0 */ UTexture* SourceTexture;

    void SetBarnDoorAngle(float NewValue);
    void SetBarnDoorLength(float NewValue);
    void SetSourceHeight(float NewValue);
    void SetSourceTexture(UTexture* bNewValue);
    void SetSourceWidth(float bNewValue);
};

// Size: 0x18
struct FRedirector {
    /* 0x0000 */ FName OldName;
    /* 0x000c */ FName NewName;
};

// Size: 0x50
struct FReferencePose {
    /* 0x0000 */ FName PoseName;
    /* 0x0010 */ TArray<FTransform> ReferencePose;
    /* 0x0020 */ TSoftObjectPtr<USkeletalMesh> SourceReferenceMesh;
};

// Size: 0x310
class AReflectionCapture : public AActor {
    /* 0x02f8 */ UReflectionCaptureComponent* CaptureComponent;
    /* 0x0300 */ UBillboardComponent* SpriteComponent;
    /* 0x0308 */ UBillboardComponent* CaptureOffsetComponent;
};

// Size: 0x2a0
class UReflectionCaptureComponent : public USceneComponent {
    /* 0x0228 */ UBillboardComponent* CaptureOffsetComponent;
    /* 0x0230 */ EReflectionSourceType ReflectionSourceType;
    /* 0x0231 */ EMobileReflectionCompression MobileReflectionCompression;
    /* 0x0238 */ UTextureCube* Cubemap;
    /* 0x0240 */ float SourceCubemapAngle;
    /* 0x0244 */ float Brightness;
    /* 0x0248 */ bool bModifyMaxValueRGBM;
    /* 0x024c */ float MaxValueRGBM;
    /* 0x0250 */ FVector CaptureOffset;
    /* 0x025c */ FGuid MapBuildDataId;
    /* 0x0280 */ UTextureCube* CachedEncodedHDRCubemap;
};

// Size: 0x68
class URendererOverrideSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bSupportAllShaderPermutations;
    /* 0x0060 */ bool bForceRecomputeTangents;
};

// Size: 0x290
class URendererSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bMobileDisableVertexFog;
    /* 0x0064 */ int32_t MaxMobileCascades;
    /* 0x0068 */ uint8_t MobileMSAASampleCount;
    /* 0x006c */ bool bMobileAllowDitheredLODTransition;
    /* 0x006c */ bool bMobileAllowSoftwareOcclusionCulling;
    /* 0x006c */ bool bMobileVirtualTextures;
    /* 0x006c */ bool bDiscardUnusedQualityLevels;
    /* 0x006c */ bool bOcclusionCulling;
    /* 0x0070 */ float MinScreenRadiusForLights;
    /* 0x0074 */ float MinScreenRadiusForEarlyZPass;
    /* 0x0078 */ float MinScreenRadiusForCSMdepth;
    /* 0x007c */ bool bPrecomputedVisibilityWarning;
    /* 0x007c */ bool bTextureStreaming;
    /* 0x007c */ bool bUseDXT5NormalMaps;
    /* 0x007c */ bool bVirtualTextures;
    /* 0x007c */ bool bVirtualTextureEnableAutoImport;
    /* 0x007c */ bool bVirtualTexturedLightmaps;
    /* 0x0080 */ uint32_t VirtualTextureTileSize;
    /* 0x0084 */ uint32_t VirtualTextureTileBorderSize;
    /* 0x0088 */ uint32_t VirtualTextureFeedbackFactor;
    /* 0x008c */ bool bVirtualTextureEnableCompressZlib;
    /* 0x008c */ bool bVirtualTextureEnableCompressCrunch;
    /* 0x008c */ bool bClearCoatEnableSecondNormal;
    /* 0x0090 */ int32_t ReflectionCaptureResolution;
    /* 0x0094 */ bool bReflectionCaptureCompression;
    /* 0x0094 */ bool ReflectionEnvironmentLightmapMixBasedOnRoughness;
    /* 0x0094 */ bool bForwardShading;
    /* 0x0094 */ bool bVertexFoggingForOpaque;
    /* 0x0094 */ bool bAllowStaticLighting;
    /* 0x0094 */ bool bUseNormalMapsForStaticLighting;
    /* 0x0094 */ bool bGenerateMeshDistanceFields;
    /* 0x0094 */ bool bEightBitMeshDistanceFields;
    /* 0x0095 */ bool bGenerateLandscapeGIData;
    /* 0x0095 */ bool bCompressMeshDistanceFields;
    /* 0x0098 */ float TessellationAdaptivePixelsPerTriangle;
    /* 0x009c */ bool bSeparateTranslucency;
    /* 0x00a0 */ uint8_t TranslucentSortPolicy;
    /* 0x00a4 */ FVector TranslucentSortAxis;
    /* 0x00b0 */ uint8_t HMDFixedFoveationLevel;
    /* 0x00b1 */ uint8_t CustomDepthStencil;
    /* 0x00b4 */ bool bCustomDepthTaaJitter;
    /* 0x00b8 */ uint8_t bEnableAlphaChannelInPostProcessing;
    /* 0x00bc */ bool bDefaultFeatureBloom;
    /* 0x00bc */ bool bDefaultFeatureAmbientOcclusion;
    /* 0x00bc */ bool bDefaultFeatureAmbientOcclusionStaticFraction;
    /* 0x00bc */ bool bDefaultFeatureAutoExposure;
    /* 0x00c0 */ uint8_t DefaultFeatureAutoExposure;
    /* 0x00c4 */ float DefaultFeatureAutoExposureBias;
    /* 0x00c8 */ bool bExtendDefaultLuminanceRangeInAutoExposureSettings;
    /* 0x00c8 */ bool bUsePreExposure;
    /* 0x00c8 */ bool bEnablePreExposureOnlyInTheEditor;
    /* 0x00c8 */ bool bDefaultFeatureMotionBlur;
    /* 0x00c8 */ bool bDefaultFeatureLensFlare;
    /* 0x00c8 */ bool bTemporalUpsampling;
    /* 0x00c8 */ bool bSSGI;
    /* 0x00cc */ uint8_t DefaultFeatureAntiAliasing;
    /* 0x00cd */ ELightUnits DefaultLightUnits;
    /* 0x00ce */ uint8_t DefaultBackBufferPixelFormat;
    /* 0x00d0 */ bool bRenderUnbuiltPreviewShadowsInGame;
    /* 0x00d0 */ bool bStencilForLODDither;
    /* 0x00d4 */ uint8_t EarlyZPass;
    /* 0x00d8 */ bool bEarlyZPassOnlyMaterialMasking;
    /* 0x00d8 */ bool bDBuffer;
    /* 0x00dc */ uint8_t ClearSceneMethod;
    /* 0x00e0 */ bool bBasePassOutputsVelocity;
    /* 0x00e0 */ bool bVertexDeformationOutputsVelocity;
    /* 0x00e0 */ bool bSelectiveBasePassOutputs;
    /* 0x00e0 */ bool bDefaultParticleCutouts;
    /* 0x00e4 */ int32_t GPUSimulationTextureSizeX;
    /* 0x00e8 */ int32_t GPUSimulationTextureSizeY;
    /* 0x00ec */ bool bGlobalClipPlane;
    /* 0x00f0 */ uint8_t GBufferFormat;
    /* 0x00f4 */ bool bUseGPUMorphTargets;
    /* 0x00f4 */ bool bNvidiaAftermathEnabled;
    /* 0x00f4 */ bool bMultiView;
    /* 0x00f4 */ bool bMobilePostProcessing;
    /* 0x00f4 */ bool bMobileMultiView;
    /* 0x00f4 */ bool bMobileUseHWsRGBEncoding;
    /* 0x00f4 */ bool bRoundRobinOcclusion;
    /* 0x00f4 */ bool bODSCapture;
    /* 0x00f5 */ bool bMeshStreaming;
    /* 0x00f8 */ float WireframeCullThreshold;
    /* 0x00fc */ bool bEnableRayTracing;
    /* 0x00fc */ bool bEnableRayTracingTextureLOD;
    /* 0x00fc */ bool bSupportStationarySkylight;
    /* 0x00fc */ bool bSupportLowQualityLightmaps;
    /* 0x00fc */ bool bSupportPointLightWholeSceneShadows;
    /* 0x00fc */ bool bSupportAtmosphericFog;
    /* 0x00fc */ bool bSupportSkyAtmosphere;
    /* 0x00fc */ bool bSupportSkyAtmosphereAffectsHeightFog;
    /* 0x00fd */ bool bSupportSkinCacheShaders;
    /* 0x0100 */ ESkinCacheDefaultBehavior DefaultSkinCacheBehavior;
    /* 0x0104 */ float SkinCacheSceneMemoryLimitInMB;
    /* 0x0108 */ bool bMobileEnableStaticAndCSMShadowReceivers;
    /* 0x0108 */ bool bMobileEnableMovableLightCSMShaderCulling;
    /* 0x0108 */ bool bMobileAllowDistanceFieldShadows;
    /* 0x0108 */ bool bMobileAllowMovableDirectionalLights;
    /* 0x010c */ uint32_t MobileNumDynamicPointLights;
    /* 0x0110 */ bool bMobileDynamicPointLightsUseStaticBranch;
    /* 0x0110 */ bool bMobileAllowMovableSpotlights;
    /* 0x0110 */ bool bMobileAllowMovableSpotlightShadows;
    /* 0x0110 */ bool bSupport16BitBoneIndex;
    /* 0x0110 */ bool bGPUSkinLimit2BoneInfluences;
    /* 0x0110 */ bool bSupportDepthOnlyIndexBuffers;
    /* 0x0110 */ bool bSupportReversedIndexBuffers;
    /* 0x0110 */ bool bLPV;
    /* 0x0111 */ bool bMobileAmbientOcclusion;
    /* 0x0111 */ bool bUseUnlimitedBoneInfluences;
    /* 0x0114 */ int32_t UnlimitedBonInfluencesThreshold;
    /* 0x0118 */ FPerPlatformInt MaxSkinBones;
    /* 0x0170 */ uint8_t MobilePlanarReflectionMode;
    /* 0x0174 */ bool bMobileSupportsGen4TAA;
    /* 0x0178 */ FPerPlatformBool bStreamSkeletalMeshLODs;
    /* 0x01d0 */ FPerPlatformBool bDiscardSkeletalMeshOptionalLODs;
    /* 0x0228 */ FSoftObjectPath VisualizeCalibrationColorMaterialPath;
    /* 0x0248 */ FSoftObjectPath VisualizeCalibrationCustomMaterialPath;
    /* 0x0268 */ FSoftObjectPath VisualizeCalibrationGrayscaleMaterialPath;
};

// Size: 0x40
struct FRepAttachment {
    /* 0x0000 */ AActor* AttachParent;
    /* 0x0008 */ FVector_NetQuantize100 LocationOffset;
    /* 0x0014 */ FVector_NetQuantize100 RelativeScale3D;
    /* 0x0020 */ FRotator RotationOffset;
    /* 0x002c */ FName AttachSocket;
    /* 0x0038 */ USceneComponent* AttachComponent;
};

// Size: 0x34
struct FRepMovement {
    /* 0x0000 */ FVector LinearVelocity;
    /* 0x000c */ FVector AngularVelocity;
    /* 0x0018 */ FVector Location;
    /* 0x0024 */ FRotator Rotation;
    /* 0x0030 */ bool bSimulatedPhysicSleep;
    /* 0x0030 */ bool bRepPhysics;
    /* 0x0031 */ EVectorQuantization LocationQuantizationLevel;
    /* 0x0032 */ EVectorQuantization VelocityQuantizationLevel;
    /* 0x0033 */ ERotatorQuantization RotationQuantizationLevel;
};

// Size: 0x98
struct FRepRootMotionMontage {
    /* 0x0000 */ bool bIsActive;
    /* 0x0008 */ UAnimMontage* AnimMontage;
    /* 0x0010 */ float Position;
    /* 0x0014 */ FVector_NetQuantize100 Location;
    /* 0x0020 */ FRotator Rotation;
    /* 0x0030 */ UPrimitiveComponent* MovementBase;
    /* 0x0038 */ FName MovementBaseBoneName;
    /* 0x0044 */ bool bRelativePosition;
    /* 0x0045 */ bool bRelativeRotation;
    /* 0x0048 */ FRootMotionSourceGroup AuthoritativeRootMotion;
    /* 0x0080 */ FVector_NetQuantize10 Acceleration;
    /* 0x008c */ FVector_NetQuantize10 LinearVelocity;
};

// Size: 0x2438
class UReplayNetConnection : public UNetConnection {
};

// Size: 0x48
class UReplaySubsystem : public UGameInstanceSubsystem {
    /* 0x0038 */ bool bLoadDefaultMapOnStop;
};

// Size: 0x40
struct FReplicatedStaticActorDestructionInfo {
    /* 0x0038 */ UClass* ObjClass;
};

// Size: 0x30
class UReplicationConnectionDriver : public UObject {
};

// Size: 0x30
class UReplicationDriver : public UObject {
};

// Size: 0x38
class UReporterBase : public UObject {
};

// Size: 0xb0
class UReporterGraph : public UReporterBase {
};

// Size: 0x10
struct FResponseChannel {
    /* 0x0000 */ FName Channel;
    /* 0x000c */ uint8_t Response;
};

// Size: 0x70
class UReverbEffect : public UObject {
    /* 0x0030 */ bool bBypassEarlyReflections;
    /* 0x0034 */ float ReflectionsDelay;
    /* 0x0038 */ float GainHF;
    /* 0x003c */ float ReflectionsGain;
    /* 0x0040 */ bool bBypassLateReflections;
    /* 0x0044 */ float LateDelay;
    /* 0x0048 */ float DecayTime;
    /* 0x004c */ float Density;
    /* 0x0050 */ float Diffusion;
    /* 0x0054 */ float AirAbsorptionGainHF;
    /* 0x0058 */ float DecayHFRatio;
    /* 0x005c */ float LateGain;
    /* 0x0060 */ float Gain;
    /* 0x0064 */ float RoomRolloffFactor;
    /* 0x0068 */ bool bChanged;
};

enum class ReverbPreset {
    REVERB_Default = 0,
    REVERB_Bathroom = 1,
    REVERB_StoneRoom = 2,
    REVERB_Auditorium = 3,
    REVERB_ConcertHall = 4,
    REVERB_Cave = 5,
    REVERB_Hallway = 6,
    REVERB_StoneCorridor = 7,
    REVERB_Alley = 8,
    REVERB_Forest = 9,
    REVERB_City = 10,
    REVERB_Mountains = 11,
    REVERB_Quarry = 12,
    REVERB_Plain = 13,
    REVERB_ParkingLot = 14,
    REVERB_SewerPipe = 15,
    REVERB_Underwater = 16,
    REVERB_SmallRoom = 17,
    REVERB_MediumRoom = 18,
    REVERB_LargeRoom = 19,
    REVERB_MediumHall = 20,
    REVERB_LargeHall = 21,
    REVERB_Plate = 22,
    REVERB_MAX = 23,
};

// Size: 0x20
struct FReverbSettings {
    /* 0x0000 */ bool bApplyReverb;
    /* 0x0001 */ uint8_t ReverbType;
    /* 0x0008 */ UReverbEffect* ReverbEffect;
    /* 0x0010 */ USoundEffectSubmixPreset* ReverbPluginEffect;
    /* 0x0018 */ float Volume;
    /* 0x001c */ float FadeTime;
};

// Size: 0x80
struct FRichCurve : public FRealCurve {
    /* 0x0070 */ TArray<FRichCurveKey> Keys;
};

// Size: 0x1c
struct FRichCurveKey {
    /* 0x0000 */ uint8_t InterpMode;
    /* 0x0001 */ uint8_t TangentMode;
    /* 0x0002 */ uint8_t TangentWeightMode;
    /* 0x0004 */ float Time;
    /* 0x0008 */ float Value;
    /* 0x000c */ float ArriveTangent;
    /* 0x0010 */ float ArriveTangentWeight;
    /* 0x0014 */ float LeaveTangent;
    /* 0x0018 */ float LeaveTangentWeight;
};

// Size: 0x160
class URig : public UObject {
    /* 0x0038 */ TArray<FTransformBase> TransformBases;
    /* 0x0048 */ TArray<FNode> Nodes;
};

// Size: 0x18
struct FRigConfiguration {
    /* 0x0000 */ URig* Rig;
    /* 0x0008 */ TArray<FNameMapping> BoneMappingTable;
};

// Size: 0x14
struct FRigTransformConstraint {
    /* 0x0000 */ uint8_t TranformType;
    /* 0x0004 */ FName ParentSpace;
    /* 0x0010 */ float Weight;
};

// Size: 0x2f8
class ARigidBodyBase : public AActor {
};

// Size: 0x30
struct FRigidBodyContactInfo {
    /* 0x0000 */ FVector ContactPosition;
    /* 0x000c */ FVector ContactNormal;
    /* 0x0018 */ float ContactPenetration;
    /* 0x0020 */ UPhysicalMaterial* PhysMaterial[2];
};

// Size: 0x34
struct FRigidBodyErrorCorrection {
    /* 0x0000 */ float PingExtrapolation;
    /* 0x0004 */ float PingLimit;
    /* 0x0008 */ float ErrorPerLinearDifference;
    /* 0x000c */ float ErrorPerAngularDifference;
    /* 0x0010 */ float MaxRestoredStateError;
    /* 0x0014 */ float MaxLinearHardSnapDistance;
    /* 0x0018 */ float PositionLerp;
    /* 0x001c */ float AngleLerp;
    /* 0x0020 */ float LinearVelocityCoefficient;
    /* 0x0024 */ float AngularVelocityCoefficient;
    /* 0x0028 */ float ErrorAccumulationSeconds;
    /* 0x002c */ float ErrorAccumulationDistanceSq;
    /* 0x0030 */ float ErrorAccumulationSimilarity;
};

// Size: 0x40
struct FRigidBodyState {
    /* 0x0000 */ FVector_NetQuantize100 Position;
    /* 0x0010 */ FQuat Quaternion;
    /* 0x0020 */ FVector_NetQuantize100 LinVel;
    /* 0x002c */ FVector_NetQuantize100 AngVel;
    /* 0x0038 */ uint8_t Flags;
};

// Size: 0xb8
struct FRollbackNetStartupActorInfo {
    /* 0x0010 */ UObject* Archetype;
    /* 0x0040 */ ULevel* Level;
    /* 0x00a8 */ TArray<UObject*> ObjReferences;
};

// Size: 0x10
struct FRootMotionExtractionStep {
    /* 0x0000 */ UAnimSequence* AnimSequence;
    /* 0x0008 */ float StartPosition;
    /* 0x000c */ float EndPosition;
};

// Size: 0x14
struct FRootMotionFinishVelocitySettings {
    /* 0x0000 */ ERootMotionFinishVelocityMode Mode;
    /* 0x0004 */ FVector SetVelocity;
    /* 0x0010 */ float ClampVelocity;
};

// Size: 0x40
struct FRootMotionMovementParams {
    /* 0x0000 */ bool bHasRootMotion;
    /* 0x0004 */ float BlendWeight;
    /* 0x0010 */ FTransform RootMotionTransform;
};

// Size: 0xa0
struct FRootMotionSource {
    /* 0x0010 */ uint16_t Priority;
    /* 0x0012 */ uint16_t LocalID;
    /* 0x0014 */ ERootMotionAccumulateMode AccumulateMode;
    /* 0x0018 */ FName InstanceName;
    /* 0x0024 */ float StartTime;
    /* 0x0028 */ float CurrentTime;
    /* 0x002c */ float PreviousTime;
    /* 0x0030 */ float Duration;
    /* 0x0034 */ FRootMotionSourceStatus Status;
    /* 0x0035 */ FRootMotionSourceSettings Settings;
    /* 0x0036 */ bool bInLocalSpace;
    /* 0x0040 */ FRootMotionMovementParams RootMotionParams;
    /* 0x0080 */ FRootMotionFinishVelocitySettings FinishVelocityParams;
};

// Size: 0x38
struct FRootMotionSourceGroup {
    /* 0x0028 */ bool bHasAdditiveSources;
    /* 0x0028 */ bool bHasOverrideSources;
    /* 0x0028 */ bool bHasOverrideSourcesWithIgnoreZAccumulate;
    /* 0x0028 */ bool bIsAdditiveVelocityApplied;
    /* 0x0029 */ FRootMotionSourceSettings LastAccumulatedSettings;
    /* 0x002c */ FVector_NetQuantize10 LastPreAdditiveVelocity;
};

// Size: 0x1
struct FRootMotionSourceSettings {
    /* 0x0000 */ uint8_t Flags;
};

// Size: 0x1
struct FRootMotionSourceStatus {
    /* 0x0000 */ uint8_t Flags;
};

// Size: 0xb0
struct FRootMotionSource_ConstantForce : public FRootMotionSource {
    /* 0x0098 */ FVector Force;
    /* 0x00a8 */ UCurveFloat* StrengthOverTime;
};

// Size: 0xd0
struct FRootMotionSource_JumpForce : public FRootMotionSource {
    /* 0x0098 */ FRotator Rotation;
    /* 0x00a4 */ float Distance;
    /* 0x00a8 */ float Height;
    /* 0x00ac */ bool bDisableTimeout;
    /* 0x00b0 */ UCurveVector* PathOffsetCurve;
    /* 0x00b8 */ UCurveFloat* TimeMappingCurve;
};

// Size: 0xd0
struct FRootMotionSource_MoveToDynamicForce : public FRootMotionSource {
    /* 0x0098 */ FVector StartLocation;
    /* 0x00a4 */ FVector InitialTargetLocation;
    /* 0x00b0 */ FVector TargetLocation;
    /* 0x00bc */ bool bRestrictSpeedToExpected;
    /* 0x00c0 */ UCurveVector* PathOffsetCurve;
    /* 0x00c8 */ UCurveFloat* TimeMappingCurve;
};

// Size: 0xc0
struct FRootMotionSource_MoveToForce : public FRootMotionSource {
    /* 0x0098 */ FVector StartLocation;
    /* 0x00a4 */ FVector TargetLocation;
    /* 0x00b0 */ bool bRestrictSpeedToExpected;
    /* 0x00b8 */ UCurveVector* PathOffsetCurve;
};

// Size: 0xe0
struct FRootMotionSource_RadialForce : public FRootMotionSource {
    /* 0x0098 */ FVector Location;
    /* 0x00a8 */ AActor* LocationActor;
    /* 0x00b0 */ float Radius;
    /* 0x00b4 */ float Strength;
    /* 0x00b8 */ bool bIsPush;
    /* 0x00b9 */ bool bNoZForce;
    /* 0x00c0 */ UCurveFloat* StrengthDistanceFalloff;
    /* 0x00c8 */ UCurveFloat* StrengthOverTime;
    /* 0x00d0 */ bool bUseFixedWorldDirection;
    /* 0x00d4 */ FRotator FixedWorldDirection;
};

// Size: 0x120
class URotatingMovementComponent : public UMovementComponent {
    /* 0x0100 */ FRotator RotationRate;
    /* 0x010c */ FVector PivotTranslation;
    /* 0x0118 */ bool bRotationInLocalSpace;
};

// Size: 0x20
struct FRotationTrack {
    /* 0x0000 */ TArray<FQuat> RotKeys;
    /* 0x0010 */ TArray<float> Times;
};

// Size: 0x208
struct FRuntimeCurveLinearColor {
    /* 0x0000 */ FRichCurve ColorCurves[4];
    /* 0x0200 */ UCurveLinearColor* ExternalCurve;
};

// Size: 0x88
struct FRuntimeFloatCurve {
    /* 0x0000 */ FRichCurve EditorCurveData;
    /* 0x0080 */ UCurveFloat* ExternalCurve;
};

// Size: 0x40
class URuntimeOptionsBase : public UObject {
};

// Size: 0xa0
class URuntimeVirtualTexture : public UObject {
    /* 0x0030 */ int32_t TileCount;
    /* 0x0034 */ int32_t TileSize;
    /* 0x0038 */ int32_t TileBorderSize;
    /* 0x003c */ ERuntimeVirtualTextureMaterialType MaterialType;
    /* 0x003d */ bool bCompressTextures;
    /* 0x003e */ bool bClearTextures;
    /* 0x003f */ bool bSinglePhysicalSpace;
    /* 0x0040 */ bool bPrivateSpace;
    /* 0x0041 */ bool bAdaptive;
    /* 0x0042 */ bool bContinuousUpdate;
    /* 0x0044 */ int32_t RemoveLowMips;
    /* 0x0048 */ uint8_t LODGroup;
    /* 0x004c */ int32_t Size;
    /* 0x0050 */ URuntimeVirtualTextureStreamingProxy* StreamingTexture;

    int32_t GetPageTableSize() const;
    int32_t GetSize() const;
    int32_t GetTileBorderSize() const;
    int32_t GetTileCount() const;
    int32_t GetTileSize() const;
};

// Size: 0x2b0
class URuntimeVirtualTextureComponent : public USceneComponent {
    /* 0x0228 */ TSoftObjectPtr<AActor> BoundsAlignActor;
    /* 0x0258 */ bool bSetBoundsButton;
    /* 0x0259 */ bool bSnapBoundsToLandscape;
    /* 0x0260 */ URuntimeVirtualTexture* VirtualTexture;
    /* 0x0268 */ bool bEnableScalability;
    /* 0x026c */ uint32_t ScalabilityGroup;
    /* 0x0270 */ bool bHidePrimitives;
    /* 0x0278 */ UVirtualTextureBuilder* StreamingTexture;
    /* 0x0280 */ int32_t StreamLowMips;
    /* 0x0284 */ bool bBuildStreamingMipsButton;
    /* 0x0285 */ bool bEnableCompressCrunch;
    /* 0x0286 */ bool bUseStreamingLowMipsInEditor;
    /* 0x0287 */ bool bBuildDebugStreamingMips;

    void Invalidate(const FBoxSphereBounds& WorldBounds);
};

// Size: 0x30
struct FRuntimeVirtualTextureParameterValue {
    /* 0x0000 */ FMaterialParameterInfo ParameterInfo;
    /* 0x0018 */ URuntimeVirtualTexture* ParameterValue;
    /* 0x0020 */ FGuid ExpressionGUID;
};

// Size: 0x410
class URuntimeVirtualTextureStreamingProxy : public UTexture2D {
};

// Size: 0x308
class ARuntimeVirtualTextureVolume : public AActor {
    /* 0x02f8 */ URuntimeVirtualTextureComponent* VirtualTextureComponent;
    /* 0x0300 */ UBoxComponent* Box;
};

// Size: 0x138
class USCS_Node : public UObject {
    /* 0x0030 */ UClass* ComponentClass;
    /* 0x0038 */ UActorComponent* ComponentTemplate;
    /* 0x0040 */ FBlueprintCookedComponentInstancingData CookedComponentInstancingData;
    /* 0x0090 */ FText CategoryName;
    /* 0x00a8 */ FName AttachToName;
    /* 0x00b4 */ FName ParentComponentOrVariableName;
    /* 0x00c0 */ FName ParentComponentOwnerClassName;
    /* 0x00cc */ bool bIsParentComponentNative;
    /* 0x00d0 */ TArray<USCS_Node*> ChildNodes;
    /* 0x00e0 */ TArray<FBPVariableMetaDataEntry> MetaDataArray;
    /* 0x00f0 */ FGuid VariableGuid;
    /* 0x0100 */ bool bIsNative;
    /* 0x0104 */ FName NativeComponentName;
    /* 0x0110 */ bool bVariableNameAutoGenerated;
    /* 0x011c */ FName InternalVariableName;
};

// Size: 0x30
class USaveGame : public UObject {
};

// Size: 0x40
struct FScalarMaterialInput : public Fmaterialinput {
    /* 0x0038 */ bool UseConstant;
    /* 0x003c */ float Constant;
};

// Size: 0x68
struct FScalarParameterAtlasInstanceData {
    /* 0x0000 */ bool bIsUsedAsAtlasPosition;
    /* 0x0008 */ TSoftObjectPtr<UCurveLinearColor> Curve;
    /* 0x0038 */ TSoftObjectPtr<UCurveLinearColorAtlas> Atlas;
};

// Size: 0xa0
struct FScalarParameterValue {
    /* 0x0000 */ FName ParameterName;
    /* 0x0010 */ FScalarParameterAtlasInstanceData AtlasData;
    /* 0x0078 */ FMaterialParameterInfo ParameterInfo;
    /* 0x008c */ float ParameterValue;
    /* 0x0090 */ FGuid ExpressionGUID;
};

// Size: 0x20
struct FScaleTrack {
    /* 0x0000 */ TArray<FVector> ScaleKeys;
    /* 0x0010 */ TArray<float> Times;
};

// Size: 0x30
class UScene : public UObject {
};

// Size: 0x308
class ASceneCapture : public AActor {
    /* 0x02f8 */ UStaticMeshComponent* MeshComp;
    /* 0x0300 */ USceneComponent* SceneComponent;
};

// Size: 0x310
class ASceneCapture2D : public ASceneCapture {
    /* 0x0308 */ USceneCaptureComponent2D* CaptureComponent2D;

    void OnInterpToggle(bool bEnable);
};

// Size: 0x300
class USceneCaptureComponent : public USceneComponent {
    /* 0x0228 */ ESceneCapturePrimitiveRenderMode PrimitiveRenderMode;
    /* 0x0229 */ uint8_t CaptureSource;
    /* 0x022a */ bool bCaptureEveryFrame;
    /* 0x022a */ bool bCaptureOnMovement;
    /* 0x022b */ bool bAlwaysPersistRenderingState;
    /* 0x0230 */ TArray<TWeakObjectPtr<UPrimitiveComponent>> HiddenComponents;
    /* 0x0240 */ TArray<AActor*> HiddenActors;
    /* 0x0250 */ TArray<TWeakObjectPtr<UPrimitiveComponent>> ShowOnlyComponents;
    /* 0x0260 */ TArray<AActor*> ShowOnlyActors;
    /* 0x0270 */ float LODDistanceFactor;
    /* 0x0274 */ float MaxViewDistanceOverride;
    /* 0x0278 */ int32_t CaptureSortPriority;
    /* 0x027c */ bool bUseRayTracingIfEnabled;
    /* 0x0280 */ TArray<FEngineShowFlagsSetting> ShowFlagSettings;
    /* 0x02d0 */ FString ProfilingEventName;
    /* 0x02f0 */ UStaticMesh* CaptureMesh;

    void ClearHiddenComponents();
    void ClearShowOnlyComponents();
    void HideActorComponents(AActor* InActor, const bool bIncludeFromChildActors);
    void HideComponent(UPrimitiveComponent* InComponent);
    void RemoveShowOnlyActorComponents(AActor* InActor, const bool bIncludeFromChildActors);
    void RemoveShowOnlyComponent(UPrimitiveComponent* InComponent);
    void SetCaptureSortPriority(int32_t NewCaptureSortPriority);
    void ShowOnlyActorComponents(AActor* InActor, const bool bIncludeFromChildActors);
    void ShowOnlyComponent(UPrimitiveComponent* InComponent);
};

// Size: 0x940
class USceneCaptureComponent2D : public USceneCaptureComponent {
    /* 0x0300 */ uint8_t ProjectionType;
    /* 0x0304 */ float FOVAngle;
    /* 0x0308 */ float OrthoWidth;
    /* 0x0310 */ UTextureRenderTarget2D* TextureTarget;
    /* 0x0318 */ uint8_t CompositeMode;
    /* 0x0320 */ FPostProcessSettings PostProcessSettings;
    /* 0x08b0 */ float PostProcessBlendWeight;
    /* 0x08b4 */ bool bOverride_CustomNearClippingPlane;
    /* 0x08b8 */ float CustomNearClippingPlane;
    /* 0x08bc */ bool bUseCustomProjectionMatrix;
    /* 0x08c0 */ FMatrix CustomProjectionMatrix;
    /* 0x0900 */ bool bEnableClipPlane;
    /* 0x0904 */ FVector ClipPlaneBase;
    /* 0x0910 */ FVector ClipPlaneNormal;
    /* 0x091c */ bool bCameraCutThisFrame;
    /* 0x091c */ bool bConsiderUnrenderedOpaquePixelAsFullyTranslucent;
    /* 0x0920 */ bool bDisableFlipCopyGLES;

    void AddOrUpdateBlendable(TScriptInterface<IBlendableInterface> InBlendableObject, float InWeight);
    void CaptureScene();
    void RemoveBlendable(TScriptInterface<IBlendableInterface> InBlendableObject);
};

// Size: 0x340
class USceneCaptureComponentCube : public USceneCaptureComponent {
    /* 0x0300 */ UTextureRenderTargetCube* TextureTarget;
    /* 0x0308 */ bool bCaptureRotation;
    /* 0x0310 */ UTextureRenderTargetCube* TextureTargetLeft;
    /* 0x0318 */ UTextureRenderTargetCube* TextureTargetRight;
    /* 0x0320 */ UTextureRenderTarget2D* TextureTargetODS;
    /* 0x0328 */ float IPD;

    void CaptureScene();
};

// Size: 0x310
class ASceneCaptureCube : public ASceneCapture {
    /* 0x0308 */ USceneCaptureComponentCube* CaptureComponentCube;

    void OnInterpToggle(bool bEnable);
};

// Size: 0x230
class USceneComponent : public UActorComponent {
    /* 0x00c8 */ TWeakObjectPtr<APhysicsVolume> PhysicsVolume;
    /* 0x00d0 */ USceneComponent* AttachParent;
    /* 0x00d8 */ FName AttachSocketName;
    /* 0x00e8 */ TArray<USceneComponent*> AttachChildren;
    /* 0x00f8 */ TArray<USceneComponent*> ClientAttachedChildren;
    /* 0x013c */ FVector RelativeLocation;
    /* 0x0148 */ FRotator RelativeRotation;
    /* 0x0154 */ FVector RelativeScale3D;
    /* 0x0160 */ FVector ComponentVelocity;
    /* 0x016c */ bool bComponentToWorldUpdated;
    /* 0x016c */ bool bAbsoluteLocation;
    /* 0x016c */ bool bAbsoluteRotation;
    /* 0x016c */ bool bAbsoluteScale;
    /* 0x016c */ bool bVisible;
    /* 0x016c */ bool bShouldBeAttached;
    /* 0x016c */ bool bShouldSnapLocationWhenAttached;
    /* 0x016d */ bool bShouldSnapRotationWhenAttached;
    /* 0x016d */ bool bShouldUpdatePhysicsVolume;
    /* 0x016d */ bool bHiddenInGame;
    /* 0x016d */ bool bBoundsChangeTriggersStreamingDataRebuild;
    /* 0x016d */ bool bUseAttachParentBound;
    /* 0x016e */ bool bVisualizeComponent;
    /* 0x016f */ uint8_t Mobility;
    /* 0x0170 */ uint8_t DetailMode;
    /* 0x0171 */ FMulticastSparseDelegate PhysicsVolumeChangedDelegate;

    void DetachFromParent(bool bMaintainWorldPosition, bool bCallModify);
    bool DoesSocketExist(FName InSocketName) const;
    TArray<FName> GetAllSocketNames() const;
    USceneComponent* GetAttachParent() const;
    FName GetAttachSocketName() const;
    USceneComponent* GetChildComponent(int32_t ChildIndex) const;
    void GetChildrenComponents(bool bIncludeAllDescendants, TArray<USceneComponent*>& Children) const;
    FVector GetComponentVelocity() const;
    FVector GetForwardVector() const;
    int32_t GetNumChildrenComponents() const;
    void GetParentComponents(TArray<USceneComponent*>& Parents) const;
    APhysicsVolume* GetPhysicsVolume() const;
    FTransform GetRelativeTransform() const;
    FVector GetRightVector() const;
    bool GetShouldUpdatePhysicsVolume() const;
    FVector GetSocketLocation(FName InSocketName) const;
    FQuat GetSocketQuaternion(FName InSocketName) const;
    FRotator GetSocketRotation(FName InSocketName) const;
    FTransform GetSocketTransform(FName InSocketName, uint8_t TransformSpace) const;
    FVector GetUpVector() const;
    bool IsAnySimulatingPhysics() const;
    bool IsSimulatingPhysics(FName BoneName) const;
    bool IsVisible() const;
    void K2_AddLocalOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddLocalRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddLocalTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddRelativeLocation(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddRelativeRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldTransformKeepScale(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_AttachTo(USceneComponent* InParent, FName InSocketName, uint8_t AttachType, bool bWeldSimulatedBodies);
    bool K2_AttachToComponent(USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    void K2_DetachFromComponent(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule, bool bCallModify);
    FVector K2_GetComponentLocation() const;
    FRotator K2_GetComponentRotation() const;
    FVector K2_GetComponentScale() const;
    FTransform K2_GetComponentToWorld() const;
    void K2_SetRelativeLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeRotation(FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldRotation(FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void OnRep_AttachChildren();
    void OnRep_AttachParent();
    void OnRep_AttachSocketName();
    void OnRep_Transform();
    void OnRep_Visibility(bool OldValue);
    void ResetRelativeTransform();
    void SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale);
    void SetHiddenInGame(bool NewHidden, bool bPropagateToChildren);
    void SetMobility(uint8_t NewMobility);
    void SetRelativeScale3D(FVector NewScale3D);
    void SetShouldUpdatePhysicsVolume(bool bInShouldUpdatePhysicsVolume);
    void SetVisibility(bool bNewVisibility, bool bPropagateToChildren);
    void SetWorldScale3D(FVector NewScale);
    bool SnapTo(USceneComponent* InParent, FName InSocketName);
    void ToggleVisibility(bool bPropagateToChildren);
};

// Size: 0xb8
struct FSceneComponentInstanceData : public FActorComponentInstanceData {
    /* 0x0068 */ TMap<USceneComponent*, FTransform> AttachedInstanceComponents;
};

// Size: 0x60
struct FSceneViewExtensionIsActiveFunctor {
};

// Size: 0x30
struct FScreenMessageString {
    /* 0x0000 */ uint64_t Key;
    /* 0x0008 */ FString ScreenMessage;
    /* 0x0018 */ FColor DisplayColor;
    /* 0x001c */ float TimeToDisplay;
    /* 0x0020 */ float CurrentTimeDisplayed;
    /* 0x0024 */ FVector2D TextScale;
};

// Size: 0x40
class UScriptViewportClient : public UObject {
};

// Size: 0xa8
class USelection : public UObject {
};

// Size: 0x3c8
class AServerStatReplicator : public AInfo {
    /* 0x0300 */ bool bUpdateStatNet;
    /* 0x0301 */ bool bOverwriteClientStats;
    /* 0x0304 */ uint32_t Channels;
    /* 0x0308 */ uint32_t InRate;
    /* 0x030c */ uint32_t OutRate;
    /* 0x0314 */ uint32_t MaxPacketOverhead;
    /* 0x0318 */ uint32_t InRateClientMax;
    /* 0x031c */ uint32_t InRateClientMin;
    /* 0x0320 */ uint32_t InRateClientAvg;
    /* 0x0324 */ uint32_t InPacketsClientMax;
    /* 0x0328 */ uint32_t InPacketsClientMin;
    /* 0x032c */ uint32_t InPacketsClientAvg;
    /* 0x0330 */ uint32_t OutRateClientMax;
    /* 0x0334 */ uint32_t OutRateClientMin;
    /* 0x0338 */ uint32_t OutRateClientAvg;
    /* 0x033c */ uint32_t OutPacketsClientMax;
    /* 0x0340 */ uint32_t OutPacketsClientMin;
    /* 0x0344 */ uint32_t OutPacketsClientAvg;
    /* 0x0348 */ uint32_t NetNumClients;
    /* 0x034c */ uint32_t InPackets;
    /* 0x0350 */ uint32_t OutPackets;
    /* 0x0354 */ uint32_t InBunches;
    /* 0x0358 */ uint32_t OutBunches;
    /* 0x035c */ uint32_t OutLoss;
    /* 0x0360 */ uint32_t InLoss;
    /* 0x0364 */ uint32_t VoiceBytesSent;
    /* 0x0368 */ uint32_t VoiceBytesRecv;
    /* 0x036c */ uint32_t VoicePacketsSent;
    /* 0x0370 */ uint32_t VoicePacketsRecv;
    /* 0x0374 */ uint32_t PercentInVoice;
    /* 0x0378 */ uint32_t PercentOutVoice;
    /* 0x037c */ uint32_t NumActorChannels;
    /* 0x0380 */ uint32_t NumConsideredActors;
    /* 0x0384 */ uint32_t PrioritizedActors;
    /* 0x0388 */ uint32_t NumRelevantActors;
    /* 0x038c */ uint32_t NumRelevantDeletedActors;
    /* 0x0390 */ uint32_t NumReplicatedActorAttempts;
    /* 0x0394 */ uint32_t NumReplicatedActors;
    /* 0x0398 */ uint32_t NumActors;
    /* 0x039c */ uint32_t NumNetActors;
    /* 0x03a0 */ uint32_t NumDormantActors;
    /* 0x03a4 */ uint32_t NumInitiallyDormantActors;
    /* 0x03a8 */ uint32_t NumNetGUIDsAckd;
    /* 0x03ac */ uint32_t NumNetGUIDsPending;
    /* 0x03b0 */ uint32_t NumNetGUIDsUnAckd;
    /* 0x03b4 */ uint32_t ObjPathBytes;
    /* 0x03b8 */ uint32_t NetGUIDOutRate;
    /* 0x03bc */ uint32_t NetGUIDInRate;
    /* 0x03c0 */ uint32_t NetSaturated;
};

// Size: 0x38
struct FShadingModelMaterialInput : public Fmaterialinput {
};

// Size: 0x420
class UShadowMapTexture2D : public UTexture2D {
    /* 0x0410 */ uint8_t ShadowmapFlags;
};

// Size: 0x4f0
class UShapeComponent : public UPrimitiveComponent {
    /* 0x04d8 */ UBodySetup* ShapeBodySetup;
    /* 0x04e0 */ UClass* AreaClass;
    /* 0x04e8 */ FColor ShapeColor;
    /* 0x04ec */ bool bDrawOnlyIfSelected;
    /* 0x04ec */ bool bShouldCollideWhenPlacing;
    /* 0x04ec */ bool bDynamicObstacle;
};

// Size: 0xd0
class USimpleConstructionScript : public UObject {
    /* 0x0030 */ TArray<USCS_Node*> RootNodes;
    /* 0x0040 */ TArray<USCS_Node*> AllNodes;
    /* 0x0050 */ USCS_Node* DefaultSceneRootNode;
    /* 0x0058 */ USCS_Node* RootNode;
    /* 0x0060 */ TArray<USCS_Node*> ActorComponentNodes;
};

// Size: 0x88
struct FSimpleCurve : public FRealCurve {
    /* 0x0070 */ uint8_t InterpMode;
    /* 0x0078 */ TArray<FSimpleCurveKey> Keys;
};

// Size: 0x8
struct FSimpleCurveKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ float Value;
};

// Size: 0x28
struct FSimpleMemberReference {
    /* 0x0000 */ UObject* MemberParent;
    /* 0x0008 */ FName MemberName;
    /* 0x0014 */ FGuid MemberGuid;
};

// Size: 0x1c38
class USimulatedClientNetConnection : public UNetConnection {
};

// Size: 0xa0
struct FSimulatedRootMotionReplicatedMove {
    /* 0x0000 */ float Time;
    /* 0x0008 */ FRepRootMotionMontage RootMotion;
};

// Size: 0x18
struct FSingleAnimationPlayData {
    /* 0x0000 */ UAnimationAsset* AnimToPlay;
    /* 0x0008 */ bool bSavedLooping;
    /* 0x0008 */ bool bSavedPlaying;
    /* 0x000c */ float SavedPosition;
    /* 0x0010 */ float SavedPlayRate;
};

// Size: 0x48
struct FSkelMeshComponentLODInfo {
    /* 0x0000 */ TArray<bool> HiddenMaterials;
};

// Size: 0x3c
struct FSkelMeshSkinWeightInfo {
    /* 0x0000 */ int32_t Bones[12];
    /* 0x0030 */ uint8_t Weights[12];
};

// Size: 0x348
class USkeletalBodySetup : public UBodySetup {
    /* 0x0300 */ FPhysicalAnimationProfile CurrentPhysicalAnimationProfile;
    /* 0x0334 */ bool bSkipScaleFromAnimation;
    /* 0x0338 */ TArray<FPhysicalAnimationProfile> PhysicalAnimationData;
};

// Size: 0x38
struct FSkeletalMaterial {
    /* 0x0000 */ UMaterialInterface* MaterialInterface;
    /* 0x0008 */ FName MaterialSlotName;
    /* 0x0014 */ bool bEnableShadowCasting;
    /* 0x0015 */ bool bRecomputeTangent;
    /* 0x0018 */ FName ImportedMaterialSlotName;
    /* 0x0024 */ FMeshUVChannelInfo UVChannelData;
};

// Size: 0x668
class USkeletalMesh : public UStreamableRenderAsset {
    /* 0x0098 */ USkeletalMeshEditorData* MeshEditorDataObject;
    /* 0x00a0 */ USkeleton* Skeleton;
    /* 0x00a8 */ FBoxSphereBounds ImportedBounds;
    /* 0x00c4 */ FBoxSphereBounds ExtendedBounds;
    /* 0x00e0 */ FVector PositiveBoundsExtension;
    /* 0x00ec */ FVector NegativeBoundsExtension;
    /* 0x00f8 */ TArray<FSkeletalMaterial> Materials;
    /* 0x0108 */ TArray<FBoneMirrorInfo> SkelMirrorTable;
    /* 0x0118 */ TArray<FSkeletalMeshLODInfo> LODInfo;
    /* 0x0128 */ FPerPlatformInt MinLOD;
    /* 0x0180 */ FPerPlatformBool DisableBelowMinLodStripping;
    /* 0x01d8 */ bool bOverrideLODStreamingSettings;
    /* 0x01e0 */ FPerPlatformBool bSupportLODStreaming;
    /* 0x0238 */ FPerPlatformInt MaxNumStreamedLODs;
    /* 0x0290 */ FPerPlatformInt MaxNumOptionalLODs;
    /* 0x02e8 */ USkeletalMeshLODSettings* LODSettings;
    /* 0x02f0 */ TSoftObjectPtr<UObject> DefaultAnimatingRig;
    /* 0x0320 */ uint8_t SkelMirrorAxis;
    /* 0x0321 */ uint8_t SkelMirrorFlipAxis;
    /* 0x0322 */ bool bUseFullPrecisionUVs;
    /* 0x0322 */ bool bUseHighPrecisionTangentBasis;
    /* 0x0322 */ bool bHasBeenSimplified;
    /* 0x0322 */ bool bHasVertexColors;
    /* 0x0322 */ bool bEnablePerPolyCollision;
    /* 0x0324 */ FGuid VertexColorGuid;
    /* 0x0338 */ UBodySetup* BodySetup;
    /* 0x0340 */ UPhysicsAsset* PhysicsAsset;
    /* 0x0348 */ UPhysicsAsset* ShadowPhysicsAsset;
    /* 0x0350 */ TArray<UNodeMappingContainer*> NodeMappingData;
    /* 0x0360 */ UAssetImportData* AssetImportData;
    /* 0x0368 */ FString SourceFilePath;
    /* 0x0378 */ FString SourceFileTimestamp;
    /* 0x0388 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x0390 */ bool bHasCustomDefaultEditorCamera;
    /* 0x0394 */ FVector DefaultEditorCameraLocation;
    /* 0x03a0 */ FRotator DefaultEditorCameraRotation;
    /* 0x03ac */ FVector DefaultEditorCameraLookAt;
    /* 0x03b8 */ float DefaultEditorCameraOrthoZoom;
    /* 0x03c0 */ FPreviewAssetAttachContainer PreviewAttachedAssetContainer;
    /* 0x03d4 */ bool bSupportRayTracing;
    /* 0x03d8 */ TArray<UMorphTarget*> MorphTargets;
    /* 0x0560 */ float FloorOffset;
    /* 0x0568 */ TArray<FTransform> RetargetBasePose;
    /* 0x0578 */ TArray<FClothingAssetData_Legacy> ClothingAssets;
    /* 0x0588 */ UClass* PostProcessAnimBlueprint;
    /* 0x0590 */ TArray<UClothingAssetBase*> MeshClothingAssets;
    /* 0x05a0 */ FSkeletalMeshSamplingInfo SamplingInfo;
    /* 0x05d0 */ TArray<UAssetUserData*> AssetUserData;
    /* 0x05f8 */ TArray<USkeletalMeshSocket*> Sockets;
    /* 0x0658 */ TArray<FSkinWeightProfileInfo> SkinWeightProfiles;

    USkeletalMeshSocket* FindSocket(FName InSocketName) const;
    USkeletalMeshSocket* FindSocketAndIndex(FName InSocketName, int32_t& OutIndex) const;
    USkeletalMeshSocket* FindSocketInfo(FName InSocketName, FTransform& OutTransform, int32_t& OutBoneIndex, int32_t& OutIndex) const;
    FBoxSphereBounds GetBounds() const;
    TSoftObjectPtr<UObject> GetDefaultAnimatingRig() const;
    FBoxSphereBounds GetImportedBounds() const;
    USkeletalMeshLODSettings* GetLODSettings() const;
    TArray<FSkeletalMaterial> GetMaterials() const;
    TArray<UClothingAssetBase*> GetMeshClothingAssets() const;
    TArray<UMorphTarget*> GetMorphTargets() const;
    UNodeMappingContainer* GetNodeMappingContainer(UBlueprint* SourceAsset) const;
    TArray<UNodeMappingContainer*> GetNodeMappingData() const;
    UPhysicsAsset* GetPhysicsAsset() const;
    UPhysicsAsset* GetShadowPhysicsAsset() const;
    USkeleton* GetSkeleton() const;
    USkeletalMeshSocket* GetSocketByIndex(int32_t index) const;
    bool IsSectionUsingCloth(int32_t InSectionIndex, bool bCheckCorrespondingSections) const;
    TArray<FString> K2_GetAllMorphTargetNames() const;
    int32_t NumSockets() const;
    void SetDefaultAnimatingRig(TSoftObjectPtr<UObject> InAnimatingRig);
    void SetLODSettings(USkeletalMeshLODSettings* InLODSettings);
    void SetMaterials(const TArray<FSkeletalMaterial>& InMaterials);
    void SetMeshClothingAssets(const TArray<UClothingAssetBase*>& InMeshClothingAssets);
    void SetMorphTargets(const TArray<UMorphTarget*>& InMorphTargets);
};

// Size: 0x380
class ASkeletalMeshActor : public AActor {
    /* 0x0300 */ bool bShouldDoAnimNotifies;
    /* 0x0300 */ bool bWakeOnLevelStart;
    /* 0x0308 */ USkeletalMeshComponent* SkeletalMeshComponent;
    /* 0x0310 */ USkeletalMesh* ReplicatedMesh;
    /* 0x0318 */ UPhysicsAsset* ReplicatedPhysAsset;
    /* 0x0320 */ UMaterialInterface* ReplicatedMaterial0;
    /* 0x0328 */ UMaterialInterface* ReplicatedMaterial1;

    void OnRep_ReplicatedMaterial0();
    void OnRep_ReplicatedMaterial1();
    void OnRep_ReplicatedMesh();
    void OnRep_ReplicatedPhysAsset();
};

// Size: 0x14
struct FSkeletalMeshBuildSettings {
    /* 0x0000 */ bool bRecomputeNormals;
    /* 0x0000 */ bool bRecomputeTangents;
    /* 0x0000 */ bool bUseMikkTSpace;
    /* 0x0000 */ bool bComputeWeightedNormals;
    /* 0x0000 */ bool bRemoveDegenerates;
    /* 0x0000 */ bool bUseHighPrecisionTangentBasis;
    /* 0x0000 */ bool bUseFullPrecisionUVs;
    /* 0x0000 */ bool bBuildAdjacencyBuffer;
    /* 0x0004 */ float ThresholdPosition;
    /* 0x0008 */ float ThresholdTangentNormal;
    /* 0x000c */ float ThresholdUV;
    /* 0x0010 */ float MorphThresholdPosition;
};

// Size: 0x60
struct FSkeletalMeshClothBuildParams {
    /* 0x0000 */ TWeakObjectPtr<UClothingAssetBase> TargetAsset;
    /* 0x0008 */ int32_t TargetLod;
    /* 0x000c */ bool bRemapParameters;
    /* 0x0010 */ FString AssetName;
    /* 0x0020 */ int32_t LODIndex;
    /* 0x0024 */ int32_t SourceSection;
    /* 0x0028 */ bool bRemoveFromMesh;
    /* 0x0030 */ TSoftObjectPtr<UPhysicsAsset> PhysicsAsset;
};

// Size: 0x1030
class USkeletalMeshComponent : public USkinnedMeshComponent {
    /* 0x0760 */ UAnimBlueprint* AnimationBlueprint;
    /* 0x0768 */ UAnimBlueprintGeneratedClass* AnimBlueprintGeneratedClass;
    /* 0x0770 */ UClass* AnimClass;
    /* 0x0778 */ UAnimInstance* AnimScriptInstance;
    /* 0x0780 */ TArray<UAnimInstance*> SubInstances;
    /* 0x0790 */ UAnimInstance* PostProcessAnimInstance;
    /* 0x0798 */ FSingleAnimationPlayData AnimationData;
    /* 0x07c0 */ FVector RootBoneTranslation;
    /* 0x07cc */ FVector LineCheckBoundsScale;
    /* 0x0808 */ TArray<UAnimInstance*> LinkedInstances;
    /* 0x0818 */ TArray<FTransform> CachedBoneSpaceTransforms;
    /* 0x0828 */ TArray<FTransform> CachedComponentSpaceTransforms;
    /* 0x0988 */ float GlobalAnimRateScale;
    /* 0x098c */ uint8_t KinematicBonesUpdateType;
    /* 0x098d */ uint8_t PhysicsTransformUpdateMode;
    /* 0x098f */ uint8_t AnimationMode;
    /* 0x0991 */ bool bDisablePostProcessBlueprint;
    /* 0x0991 */ bool bUpdateOverlapsOnAnimationFinalize;
    /* 0x0991 */ bool bHasValidBodies;
    /* 0x0991 */ bool bBlendPhysics;
    /* 0x0991 */ bool bEnablePhysicsOnDedicatedServer;
    /* 0x0991 */ bool bUpdateJointsFromAnimation;
    /* 0x0992 */ bool bDisableClothSimulation;
    /* 0x0998 */ bool bDisableRigidBodyAnimNode;
    /* 0x0998 */ bool bAllowAnimCurveEvaluation;
    /* 0x0998 */ bool bDisableAnimCurves;
    /* 0x0998 */ bool bCollideWithEnvironment;
    /* 0x0999 */ bool bCollideWithAttachedChildren;
    /* 0x0999 */ bool bLocalSpaceSimulation;
    /* 0x0999 */ bool bResetAfterTeleport;
    /* 0x0999 */ bool bDeferKinematicBoneUpdate;
    /* 0x0999 */ bool bNoSkeletonUpdate;
    /* 0x0999 */ bool bPauseAnims;
    /* 0x0999 */ bool bUseRefPoseOnInitAnim;
    /* 0x099a */ bool bEnablePerPolyCollision;
    /* 0x099a */ bool bForceRefpose;
    /* 0x099a */ bool bOnlyAllowAutonomousTickPose;
    /* 0x099a */ bool bIsAutonomousTickPose;
    /* 0x099a */ bool bOldForceRefPose;
    /* 0x099a */ bool bShowPrePhysBones;
    /* 0x099a */ bool bRequiredBonesUpToDate;
    /* 0x099a */ bool bAnimTreeInitialised;
    /* 0x099b */ bool bIncludeComponentLocationIntoBounds;
    /* 0x099b */ bool bEnableLineCheckWithBounds;
    /* 0x099b */ bool bPropagateCurvesToSlaves;
    /* 0x099b */ bool bSkipKinematicUpdateWhenInterpolating;
    /* 0x099b */ bool bSkipBoundsUpdateWhenInterpolating;
    /* 0x099b */ bool bUpdateAnimationInEditor;
    /* 0x099b */ bool bUpdateClothInEditor;
    /* 0x099c */ bool bNeedsQueuedAnimEventsDispatched;
    /* 0x099e */ uint16_t CachedAnimCurveUidVersion;
    /* 0x09a0 */ float ClothBlendWeight;
    /* 0x09a4 */ bool bWaitForParallelClothTask;
    /* 0x09a8 */ TArray<FName> DisallowedAnimCurves;
    /* 0x09b8 */ UBodySetup* BodySetup;
    /* 0x09c8 */ FMulticastInlineDelegate OnConstraintBroken;
    /* 0x09d8 */ UClass* ClothingSimulationFactory;
    /* 0x0aa8 */ float TeleportDistanceThreshold;
    /* 0x0aac */ float TeleportRotationThreshold;
    /* 0x0ab8 */ uint32_t LastPoseTickFrame;
    /* 0x0b10 */ UClothingSimulationInteractor* ClothingInteractor;
    /* 0x0be0 */ FMulticastInlineDelegate OnAnimInitialized;
    /* 0x0e48 */ UAnimSequence* SequenceToPlay;
    /* 0x0e50 */ UAnimationAsset* AnimToPlay;
    /* 0x0e58 */ bool bDefaultLooping;
    /* 0x0e58 */ bool bDefaultPlaying;
    /* 0x0e5c */ float DefaultPosition;
    /* 0x0e60 */ float DefaultPlayRate;

    void AccumulateAllBodiesBelowPhysicsBlendWeight(const FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType);
    void AddForceToAllBodiesBelow(FVector Force, FName BoneName, bool bAccelChange, bool bIncludeSelf);
    void AddImpulseToAllBodiesBelow(FVector Impulse, FName BoneName, bool bVelChange, bool bIncludeSelf);
    void AllowAnimCurveEvaluation(FName NameOfCurve, bool bAllow);
    void BindClothToMasterPoseComponent();
    void BreakConstraint(FVector Impulse, FVector HitLocation, FName InBoneName);
    void ClearMorphTargets();
    FName FindConstraintBoneName(int32_t ConstraintIndex);
    void ForceClothNextUpdateTeleport();
    void ForceClothNextUpdateTeleportAndReset();
    bool GetAllowRigidBodyAnimNode() const;
    bool GetAllowedAnimCurveEvaluate() const;
    UClass* GetAnimClass();
    UAnimInstance* GetAnimInstance() const;
    uint8_t GetAnimationMode() const;
    float GetBoneMass(FName BoneName, bool bScaleMass) const;
    float GetClothMaxDistanceScale() const;
    UClothingSimulationInteractor* GetClothingSimulationInteractor() const;
    void GetCurrentJointAngles(FName InBoneName, float& Swing1Angle, float& TwistAngle, float& Swing2Angle);
    bool GetDisableAnimCurves() const;
    bool GetDisablePostProcessBlueprint() const;
    bool GetFloatAttribute(const FName& BoneName, const FName& AttributeName, float DefaultValue, float& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetFloatAttribute_Ref(const FName& BoneName, const FName& AttributeName, float& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetIntegerAttribute(const FName& BoneName, const FName& AttributeName, int32_t DefaultValue, int32_t& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetIntegerAttribute_Ref(const FName& BoneName, const FName& AttributeName, int32_t& OutValue, ECustomBoneAttributeLookup LookupType);
    UAnimInstance* GetLinkedAnimGraphInstanceByTag(FName InTag) const;
    void GetLinkedAnimGraphInstancesByTag(FName InTag, TArray<UAnimInstance*>& OutLinkedInstances) const;
    UAnimInstance* GetLinkedAnimLayerInstanceByClass(UClass* InClass) const;
    UAnimInstance* GetLinkedAnimLayerInstanceByGroup(FName InGroup) const;
    float GetMorphTarget(FName MorphTargetName) const;
    float GetPlayRate() const;
    float GetPosition() const;
    UAnimInstance* GetPostProcessInstance() const;
    FVector GetSkeletalCenterOfMass() const;
    bool GetStringAttribute(const FName& BoneName, const FName& AttributeName, FString DefaultValue, FString& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetStringAttribute_Ref(const FName& BoneName, const FName& AttributeName, FString& OutValue, ECustomBoneAttributeLookup LookupType);
    float GetTeleportDistanceThreshold() const;
    float GetTeleportRotationThreshold() const;
    bool HasValidAnimationInstance() const;
    bool IsBodyGravityEnabled(FName BoneName);
    bool IsClothingSimulationSuspended() const;
    bool IsPlaying() const;
    bool K2_GetClosestPointOnPhysicsAsset(const FVector& WorldPosition, FVector& ClosestWorldPosition, FVector& Normal, FName& BoneName, float& Distance) const;
    void LinkAnimClassLayers(UClass* InClass);
    void LinkAnimGraphByTag(FName InTag, UClass* InClass);
    void OverrideAnimationData(UAnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate);
    void Play(bool bLooping);
    void PlayAnimation(UAnimationAsset* NewAnimToPlay, bool bLooping);
    void ResetAllBodiesSimulatePhysics();
    void ResetAllowedAnimCurveEvaluation();
    void ResetAnimInstanceDynamics(ETeleportType InTeleportType);
    void ResetClothTeleportMode();
    void ResumeClothingSimulation();
    void SetAllBodiesBelowPhysicsBlendWeight(const FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf);
    void SetAllBodiesBelowSimulatePhysics(const FName& InBoneName, bool bNewSimulate, bool bIncludeSelf);
    void SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType);
    void SetAllBodiesSimulatePhysics(bool bNewSimulate);
    void SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType);
    void SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType);
    void SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType);
    void SetAllowAnimCurveEvaluation(bool bInAllow);
    void SetAllowRigidBodyAnimNode(bool bInAllow, bool bReinitAnim);
    void SetAllowedAnimCurvesEvaluation(const TArray<FName>& List, bool bAllow);
    void SetAngularLimits(FName InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle);
    void SetAnimClass(UClass* NewClass);
    void SetAnimation(UAnimationAsset* NewAnimToPlay);
    void SetAnimationMode(uint8_t InAnimationMode);
    void SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, FName BoneName);
    void SetClothMaxDistanceScale(float Scale);
    void SetConstraintProfile(FName JointName, FName ProfileName, bool bDefaultIfNotFound);
    void SetConstraintProfileForAll(FName ProfileName, bool bDefaultIfNotFound);
    void SetDisableAnimCurves(bool bInDisableAnimCurves);
    void SetDisablePostProcessBlueprint(bool bInDisablePostProcess);
    void SetEnableBodyGravity(bool bEnableGravity, FName BoneName);
    void SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, FName BoneName, bool bIncludeSelf);
    void SetEnablePhysicsBlending(bool bNewBlendPhysics);
    void SetMorphTarget(FName MorphTargetName, float Value, bool bRemoveZeroWeight);
    void SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, FName BoneName, bool bIncludeSelf);
    void SetPhysicsBlendWeight(float PhysicsBlendWeight);
    void SetPlayRate(float Rate);
    void SetPosition(float InPos, bool bFireNotifies);
    void SetTeleportDistanceThreshold(float Threshold);
    void SetTeleportRotationThreshold(float Threshold);
    void SetUpdateAnimationInEditor(const bool NewUpdateState);
    void SetUpdateClothInEditor(const bool NewUpdateState);
    void SnapshotPose(FPoseSnapshot& Snapshot);
    void Stop();
    void SuspendClothingSimulation();
    void TermBodiesBelow(FName ParentBoneName);
    void ToggleDisablePostProcessBlueprint();
    void UnbindClothFromMasterPoseComponent(bool bRestoreSimulationSpace);
    void UnlinkAnimClassLayers(UClass* InClass);
};

// Size: 0x30
struct FSkeletalMeshComponentClothTickFunction : public FTickFunction {
};

// Size: 0x30
struct FSkeletalMeshComponentEndPhysicsTickFunction : public FTickFunction {
};

// Size: 0x40
class USkeletalMeshEditorData : public UObject {
};

// Size: 0x100
struct FSkeletalMeshLODGroupSettings {
    /* 0x0000 */ FPerPlatformFloat ScreenSize;
    /* 0x0058 */ float LODHysteresis;
    /* 0x005c */ EBoneFilterActionOption BoneFilterActionOption;
    /* 0x0060 */ TArray<FBoneFilter> BoneList;
    /* 0x0070 */ TArray<FName> BonesToPrioritize;
    /* 0x0080 */ float WeightOfPrioritization;
    /* 0x0088 */ UAnimSequence* BakePose;
    /* 0x0090 */ FSkeletalMeshOptimizationSettings ReductionSettings;
};

// Size: 0x178
struct FSkeletalMeshLODInfo {
    /* 0x0000 */ FPerPlatformFloat ScreenSize;
    /* 0x0058 */ float LODHysteresis;
    /* 0x0060 */ TArray<int32_t> LODMaterialMap;
    /* 0x0070 */ TArray<bool> bEnableShadowCasting;
    /* 0x0080 */ TArray<FName> RemovedBones;
    /* 0x0090 */ FSkeletalMeshBuildSettings BuildSettings;
    /* 0x00a8 */ FSkeletalMeshOptimizationSettings ReductionSettings;
    /* 0x0118 */ TArray<FBoneReference> BonesToRemove;
    /* 0x0128 */ TArray<FBoneReference> BonesToPrioritize;
    /* 0x0138 */ float WeightOfPrioritization;
    /* 0x0140 */ UAnimSequence* BakePose;
    /* 0x0148 */ UAnimSequence* BakePoseOverride;
    /* 0x0150 */ FString SourceImportFilename;
    /* 0x0160 */ ESkinCacheUsage SkinCacheUsage;
    /* 0x0161 */ bool bHasBeenSimplified;
    /* 0x0161 */ bool bHasPerLODVertexColors;
    /* 0x0161 */ bool bAllowCPUAccess;
    /* 0x0161 */ bool bSupportUniformlyDistributedSampling;
    /* 0x0161 */ bool bImportWithBaseMesh;
};

// Size: 0x208
class USkeletalMeshLODSettings : public UDataAsset {
    /* 0x0038 */ FPerPlatformInt MinLOD;
    /* 0x0090 */ FPerPlatformBool DisableBelowMinLodStripping;
    /* 0x00e8 */ bool bOverrideLODStreamingSettings;
    /* 0x00f0 */ FPerPlatformBool bSupportLODStreaming;
    /* 0x0148 */ FPerPlatformInt MaxNumStreamedLODs;
    /* 0x01a0 */ FPerPlatformInt MaxNumOptionalLODs;
    /* 0x01f8 */ TArray<FSkeletalMeshLODGroupSettings> LODGroups;
};

enum class SkeletalMeshOptimizationImportance {
    SMOI_Off = 0,
    SMOI_Lowest = 1,
    SMOI_Low = 2,
    SMOI_Normal = 3,
    SMOI_High = 4,
    SMOI_Highest = 5,
    SMOI_MAX = 6,
};

// Size: 0x70
struct FSkeletalMeshOptimizationSettings {
    /* 0x0000 */ uint8_t TerminationCriterion;
    /* 0x0004 */ float NumOfTrianglesPercentage;
    /* 0x0008 */ float NumOfVertPercentage;
    /* 0x000c */ uint32_t MaxNumOfTriangles;
    /* 0x0010 */ uint32_t MaxNumOfVerts;
    /* 0x0014 */ uint32_t MaxNumOfTrianglesPercentage;
    /* 0x0018 */ uint32_t MaxNumOfVertsPercentage;
    /* 0x001c */ float MaxDeviationPercentage;
    /* 0x0020 */ uint8_t ReductionMethod;
    /* 0x0021 */ uint8_t SilhouetteImportance;
    /* 0x0022 */ uint8_t TextureImportance;
    /* 0x0023 */ uint8_t ShadingImportance;
    /* 0x0024 */ uint8_t SkinningImportance;
    /* 0x0025 */ bool bRemapMorphTargets;
    /* 0x0025 */ bool bRecalcNormals;
    /* 0x0028 */ float WeldingThreshold;
    /* 0x002c */ float NormalsThreshold;
    /* 0x0030 */ int32_t MaxBonesPerVertex;
    /* 0x0034 */ bool bEnforceBoneBoundaries;
    /* 0x0038 */ float VolumeImportance;
    /* 0x003c */ bool bLockEdges;
    /* 0x003c */ bool bLockColorBounaries;
    /* 0x0040 */ int32_t BaseLOD;
    /* 0x0048 */ TArray<FBoneReference> BonesToRemove;
    /* 0x0058 */ UAnimSequence* BakePose;
};

enum class SkeletalMeshOptimizationType {
    SMOT_NumOfTriangles = 0,
    SMOT_MaxDeviation = 1,
    SMOT_TriangleOrDeviation = 2,
    SMOT_MAX = 3,
};

// Size: 0x20
struct FSkeletalMeshSamplingBuiltData {
    /* 0x0000 */ TArray<FSkeletalMeshSamplingLODBuiltData> WholeMeshBuiltData;
    /* 0x0010 */ TArray<FSkeletalMeshSamplingRegionBuiltData> RegionBuiltData;
};

// Size: 0x30
struct FSkeletalMeshSamplingInfo {
    /* 0x0000 */ TArray<FSkeletalMeshSamplingRegion> Regions;
    /* 0x0010 */ FSkeletalMeshSamplingBuiltData BuiltData;
};

// Size: 0x48
struct FSkeletalMeshSamplingLODBuiltData {
};

// Size: 0x38
struct FSkeletalMeshSamplingRegion {
    /* 0x0000 */ FName Name;
    /* 0x000c */ int32_t LODIndex;
    /* 0x0010 */ bool bSupportUniformlyDistributedSampling;
    /* 0x0018 */ TArray<FSkeletalMeshSamplingRegionMaterialFilter> MaterialFilters;
    /* 0x0028 */ TArray<FSkeletalMeshSamplingRegionBoneFilter> BoneFilters;
};

// Size: 0x10
struct FSkeletalMeshSamplingRegionBoneFilter {
    /* 0x0000 */ FName BoneName;
    /* 0x000c */ bool bIncludeOrExclude;
    /* 0x000c */ bool bApplyToChildren;
};

// Size: 0x78
struct FSkeletalMeshSamplingRegionBuiltData {
};

// Size: 0xc
struct FSkeletalMeshSamplingRegionMaterialFilter {
    /* 0x0000 */ FName MaterialName;
};

// Size: 0x70
class USkeletalMeshSimplificationSettings : public UDeveloperSettings {
    /* 0x0060 */ FName SkeletalMeshReductionModuleName;
};

// Size: 0x88
class USkeletalMeshSocket : public UObject {
    /* 0x0030 */ FName SocketName;
    /* 0x003c */ FName BoneName;
    /* 0x0048 */ FVector RelativeLocation;
    /* 0x0054 */ FRotator RelativeRotation;
    /* 0x0060 */ FVector RelativeScale;
    /* 0x006c */ bool bForceAlwaysAnimated;

    FVector GetSocketLocation(const USkeletalMeshComponent* SkelComp) const;
    void InitializeSocketFromLocation(const USkeletalMeshComponent* SkelComp, FVector WorldLocation, FVector WorldNormal);
};

enum class SkeletalMeshTerminationCriterion {
    SMTC_NumOfTriangles = 0,
    SMTC_NumOfVerts = 1,
    SMTC_TriangleOrVert = 2,
    SMTC_AbsNumOfTriangles = 3,
    SMTC_AbsNumOfVerts = 4,
    SMTC_AbsTriangleOrVert = 5,
    SMTC_MAX = 6,
};

// Size: 0x498
class USkeleton : public UObject {
    /* 0x0040 */ TArray<FBoneNode> BoneTree;
    /* 0x0050 */ TArray<FTransform> RefLocalPoses;
    /* 0x0178 */ FGuid VirtualBoneGuid;
    /* 0x0188 */ TArray<FVirtualBone> VirtualBones;
    /* 0x0198 */ TArray<USkeletalMeshSocket*> Sockets;
    /* 0x01f8 */ FSmartNameContainer SmartNames;
    /* 0x02c8 */ TArray<UBlendProfile*> BlendProfiles;
    /* 0x02d8 */ TArray<FAnimSlotGroup> SlotGroups;
    /* 0x0338 */ TSoftObjectPtr<USkeletalMesh> PreviewSkeletalMesh;
    /* 0x0368 */ TSoftObjectPtr<UDataAsset> AdditionalPreviewSkeletalMeshes;
    /* 0x0398 */ FRigConfiguration RigConfig;
    /* 0x03b0 */ TArray<FName> AnimationNotifies;
    /* 0x03c0 */ FPreviewAssetAttachContainer PreviewAttachedAssetContainer;
    /* 0x0488 */ TArray<UAssetUserData*> AssetUserData;
};

// Size: 0x20
struct FSkeletonToMeshLinkup {
    /* 0x0000 */ TArray<int32_t> SkeletonToMeshTable;
    /* 0x0010 */ TArray<int32_t> MeshToSkeletonTable;
};

// Size: 0x110
struct FSkinWeightProfileInfo {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ FPerPlatformBool DefaultProfile;
    /* 0x0068 */ FPerPlatformInt DefaultProfileFromLODIndex;
    /* 0x00c0 */ TMap<int32_t, FString> PerLODSourceFiles;
};

// Size: 0x30
struct FSkinWeightProfileManagerTickFunction : public FTickFunction {
};

// Size: 0x760
class USkinnedMeshComponent : public UMeshComponent {
    /* 0x0508 */ USkeletalMesh* SkeletalMesh;
    /* 0x0510 */ TWeakObjectPtr<USkinnedMeshComponent> MasterPoseComponent;
    /* 0x0518 */ TArray<ESkinCacheUsage> SkinCacheUsage;
    /* 0x0528 */ TArray<FVertexOffsetUsage> VertexOffsetUsage;
    /* 0x0608 */ FColor WireframeColor;
    /* 0x0658 */ UPhysicsAsset* PhysicsAssetOverride;
    /* 0x0660 */ int32_t ForcedLodModel;
    /* 0x0664 */ int32_t MinLodModel;
    /* 0x0670 */ float StreamingDistanceMultiplier;
    /* 0x0680 */ TArray<FSkelMeshComponentLODInfo> LODInfo;
    /* 0x06b4 */ EVisibilityBasedAnimTickOption VisibilityBasedAnimTickOption;
    /* 0x06c1 */ bool bOverrideMinLOD;
    /* 0x06c1 */ bool bUseBoundsFromMasterPoseComponent;
    /* 0x06c1 */ bool bForceWireframe;
    /* 0x06c1 */ bool bDisplayBones;
    /* 0x06c1 */ bool bDisableMorphTarget;
    /* 0x06c2 */ bool bHideSkin;
    /* 0x06c2 */ bool bPerBoneMotionBlur;
    /* 0x06c2 */ bool bComponentUseFixedSkelBounds;
    /* 0x06c2 */ bool bConsiderAllBodiesForBounds;
    /* 0x06c2 */ bool bSyncAttachParentLOD;
    /* 0x06c2 */ bool bCanHighlightSelectedSections;
    /* 0x06c2 */ bool bRecentlyRendered;
    /* 0x06c2 */ bool bCastCapsuleDirectShadow;
    /* 0x06c3 */ bool bCastCapsuleIndirectShadow;
    /* 0x06c3 */ bool bCPUSkinning;
    /* 0x06c3 */ bool bEnableUpdateRateOptimizations;
    /* 0x06c3 */ bool bDisplayDebugUpdateRateOptimizations;
    /* 0x06c3 */ bool bRenderStatic;
    /* 0x06c3 */ bool bIgnoreMasterPoseComponentLOD;
    /* 0x06c4 */ bool bCachedLocalBoundsUpToDate;
    /* 0x06c4 */ bool bForceMeshObjectUpdate;
    /* 0x06c8 */ float CapsuleIndirectShadowMinVisibility;
    /* 0x06e4 */ FBoxSphereBounds CachedWorldSpaceBounds;
    /* 0x0700 */ FMatrix CachedWorldToLocalTransform;

    bool BoneIsChildOf(FName BoneName, FName ParentBoneName) const;
    void ClearSkinWeightOverride(int32_t LODIndex);
    void ClearSkinWeightProfile();
    void ClearVertexColorOverride(int32_t LODIndex);
    FName FindClosestBone_K2(FVector TestLocation, FVector& BoneLocation, float IgnoreScale, bool bRequirePhysicsAsset) const;
    int32_t GetBoneIndex(FName BoneName) const;
    FName GetBoneName(int32_t BoneIndex) const;
    FName GetCurrentSkinWeightProfileName() const;
    FTransform GetDeltaTransformFromRefPose(FName BoneName, FName BaseName) const;
    int32_t GetForcedLOD() const;
    int32_t GetNumBones() const;
    int32_t GetNumLODs() const;
    FName GetParentBone(FName BoneName) const;
    FVector GetRefPosePosition(int32_t BoneIndex);
    FName GetSocketBoneName(FName InSocketName) const;
    bool GetTwistAndSwingAngleOfDeltaRotationFromRefPose(FName BoneName, float& OutTwistAngle, float& OutSwingAngle) const;
    int32_t GetVertexOffsetUsage(int32_t LODIndex) const;
    void HideBoneByName(FName BoneName, uint8_t PhysBodyOption);
    bool IsBoneHiddenByName(FName BoneName);
    bool IsMaterialSectionShown(int32_t MaterialID, int32_t LODIndex);
    bool IsUsingSkinWeightProfile() const;
    void SetCapsuleIndirectShadowMinVisibility(float NewValue);
    void SetCastCapsuleDirectShadow(bool bNewValue);
    void SetCastCapsuleIndirectShadow(bool bNewValue);
    void SetForcedLOD(int32_t InNewForcedLOD);
    void SetMasterPoseComponent(USkinnedMeshComponent* NewMasterBoneComponent, bool bForceUpdate);
    void SetMinLOD(int32_t InNewMinLOD);
    void SetPhysicsAsset(UPhysicsAsset* NewPhysicsAsset, bool bForceReInit);
    void SetPostSkinningOffsets(int32_t LODIndex, TArray<FVector> Offsets);
    void SetPreSkinningOffsets(int32_t LODIndex, TArray<FVector> Offsets);
    void SetRenderStatic(bool bNewValue);
    void SetSkeletalMesh(USkeletalMesh* NewMesh, bool bReinitPose);
    void SetSkinWeightOverride(int32_t LODIndex, const TArray<FSkelMeshSkinWeightInfo>& SkinWeights);
    bool SetSkinWeightProfile(FName InProfileName);
    void SetVertexColorOverride_LinearColor(int32_t LODIndex, const TArray<FLinearColor>& VertexColors);
    void SetVertexOffsetUsage(int32_t LODIndex, int32_t Usage);
    void ShowAllMaterialSections(int32_t LODIndex);
    void ShowMaterialSection(int32_t MaterialID, int32_t SectionIndex, bool bShow, int32_t LODIndex);
    void TransformFromBoneSpace(FName BoneName, FVector InPosition, FRotator InRotation, FVector& OutPosition, FRotator& OutRotation);
    void TransformToBoneSpace(FName BoneName, FVector InPosition, FRotator InRotation, FVector& OutPosition, FRotator& OutRotation) const;
    void UnHideBoneByName(FName BoneName);
    void UnloadSkinWeightProfile(FName InProfileName);
};

// Size: 0x310
class ASkyAtmosphere : public AInfo {
    /* 0x0300 */ USkyAtmosphereComponent* SkyAtmosphereComponent;
    /* 0x0308 */ UArrowComponent* ArrowComponent;
};

// Size: 0x300
class USkyAtmosphereComponent : public USceneComponent {
    /* 0x0228 */ ESkyAtmosphereTransformMode TransformMode;
    /* 0x022c */ float BottomRadius;
    /* 0x0230 */ FColor GroundAlbedo;
    /* 0x0234 */ float AtmosphereHeight;
    /* 0x0238 */ float MultiScatteringFactor;
    /* 0x023c */ float TraceSampleCountScale;
    /* 0x0240 */ float RayleighScatteringScale;
    /* 0x0244 */ FLinearColor RayleighScattering;
    /* 0x0254 */ float RayleighExponentialDistribution;
    /* 0x0258 */ float MieScatteringScale;
    /* 0x025c */ FLinearColor MieScattering;
    /* 0x026c */ float MieAbsorptionScale;
    /* 0x0270 */ FLinearColor MieAbsorption;
    /* 0x0280 */ float MieAnisotropy;
    /* 0x0284 */ float MieExponentialDistribution;
    /* 0x0288 */ float OtherAbsorptionScale;
    /* 0x028c */ FLinearColor OtherAbsorption;
    /* 0x029c */ FTentDistribution OtherTentDistribution;
    /* 0x02a8 */ FLinearColor SkyLuminanceFactor;
    /* 0x02b8 */ float AerialPespectiveViewDistanceScale;
    /* 0x02bc */ float HeightFogContribution;
    /* 0x02c0 */ float TransmittanceMinLightElevationAngle;
    /* 0x02c4 */ float AerialPerspectiveStartDepth;
    /* 0x02ec */ FGuid bStaticLightingBuiltGUID;

    FLinearColor GetAtmosphereTransmitanceOnGroundAtPlanetTop(UDirectionalLightComponent* DirectionalLight);
    void OverrideAtmosphereLightDirection(int32_t AtmosphereLightIndex, const FVector& LightDirection);
    void SetAerialPespectiveViewDistanceScale(float NewValue);
    void SetAtmosphereHeight(float NewValue);
    void SetHeightFogContribution(float NewValue);
    void SetMieAbsorption(FLinearColor NewValue);
    void SetMieAbsorptionScale(float NewValue);
    void SetMieAnisotropy(float NewValue);
    void SetMieExponentialDistribution(float NewValue);
    void SetMieScattering(FLinearColor NewValue);
    void SetMieScatteringScale(float NewValue);
    void SetMultiScatteringFactor(float NewValue);
    void SetOtherAbsorption(FLinearColor NewValue);
    void SetOtherAbsorptionScale(float NewValue);
    void SetRayleighExponentialDistribution(float NewValue);
    void SetRayleighScattering(FLinearColor NewValue);
    void SetRayleighScatteringScale(float NewValue);
    void SetSkyLuminanceFactor(FLinearColor NewValue);
};

// Size: 0x310
class ASkyLight : public AInfo {
    /* 0x0300 */ USkyLightComponent* LightComponent;
    /* 0x0308 */ bool bEnabled;

    void OnRep_bEnabled();
};

// Size: 0x460
class USkyLightComponent : public ULightComponentBase {
    /* 0x0278 */ bool bRealTimeCapture;
    /* 0x0279 */ uint8_t SourceType;
    /* 0x0280 */ UTextureCube* Cubemap;
    /* 0x0288 */ float SourceCubemapAngle;
    /* 0x028c */ int32_t CubemapResolution;
    /* 0x0290 */ float SkyDistanceThreshold;
    /* 0x0294 */ bool bCaptureEmissiveOnly;
    /* 0x0295 */ bool bLowerHemisphereIsBlack;
    /* 0x0298 */ FLinearColor LowerHemisphereColor;
    /* 0x02a8 */ float OcclusionMaxDistance;
    /* 0x02ac */ float Contrast;
    /* 0x02b0 */ float OcclusionExponent;
    /* 0x02b4 */ float MinOcclusion;
    /* 0x02b8 */ FColor OcclusionTint;
    /* 0x02bc */ bool bCloudAmbientOcclusion;
    /* 0x02c0 */ float CloudAmbientOcclusionStrength;
    /* 0x02c4 */ float CloudAmbientOcclusionExtent;
    /* 0x02c8 */ float CloudAmbientOcclusionMapResolutionScale;
    /* 0x02cc */ float CloudAmbientOcclusionApertureScale;
    /* 0x02d0 */ uint8_t OcclusionCombineMode;
    /* 0x0388 */ UTextureCube* BlendDestinationCubemap;

    void RecaptureSky();
    void SetCubemap(UTextureCube* NewCubemap);
    void SetCubemapBlend(UTextureCube* SourceCubemap, UTextureCube* DestinationCubemap, float InBlendFraction);
    void SetIndirectLightingIntensity(float NewIntensity);
    void SetIntensity(float NewIntensity);
    void SetLightColor(FLinearColor NewLightColor);
    void SetLowerHemisphereColor(const FLinearColor& InLowerHemisphereColor);
    void SetMinOcclusion(float InMinOcclusion);
    void SetOcclusionContrast(float InOcclusionContrast);
    void SetOcclusionExponent(float InOcclusionExponent);
    void SetOcclusionTint(const FColor& InTint);
    void SetVolumetricScatteringIntensity(float NewIntensity);
};

// Size: 0xd0
class USlateBrushAsset : public UObject {
    /* 0x0030 */ FSlateBrush Brush;
};

// Size: 0x30
class ISlateTextureAtlasInterface : public UInterface {
};

// Size: 0x20
struct FSlotAnimationTrack {
    /* 0x0000 */ FName SlotName;
    /* 0x0010 */ FAnimTrack AnimTrack;
};

// Size: 0xe0
struct FSlotEvaluationPose {
    /* 0x0000 */ uint8_t AdditiveType;
    /* 0x0004 */ float Weight;
};

// Size: 0x10
struct FSmartName {
    /* 0x0000 */ FName DisplayName;
};

// Size: 0xa0
struct FSmartNameContainer {
};

// Size: 0x60
struct FSmartNameMapping {
};

// Size: 0x88
class USmokeTestCommandlet : public UCommandlet {
};

// Size: 0x1c
struct FSolverIterations {
    /* 0x0000 */ float FixedTimeStep;
    /* 0x0004 */ int32_t SolverIterations;
    /* 0x0008 */ int32_t JointIterations;
    /* 0x000c */ int32_t CollisionIterations;
    /* 0x0010 */ int32_t SolverPushOutIterations;
    /* 0x0014 */ int32_t JointPushOutIterations;
    /* 0x0018 */ int32_t CollisionPushOutIterations;
};

// Size: 0x3f8
class USoundAttenuation : public UObject {
    /* 0x0030 */ FSoundAttenuationSettings Attenuation;
};

// Size: 0x30
struct FSoundAttenuationPluginSettings {
    /* 0x0000 */ TArray<USpatializationPluginSourceSettingsBase*> SpatializationPluginSettingsArray;
    /* 0x0010 */ TArray<UOcclusionPluginSourceSettingsBase*> OcclusionPluginSettingsArray;
    /* 0x0020 */ TArray<UReverbPluginSourceSettingsBase*> ReverbPluginSettingsArray;
};

// Size: 0x3c8
struct FSoundAttenuationSettings : public FBaseAttenuationSettings {
    /* 0x00b0 */ bool bAttenuate;
    /* 0x00b0 */ bool bSpatialize;
    /* 0x00b0 */ bool bAttenuateWithLPF;
    /* 0x00b0 */ bool bEnableListenerFocus;
    /* 0x00b0 */ bool bEnableFocusInterpolation;
    /* 0x00b0 */ bool bEnableOcclusion;
    /* 0x00b0 */ bool bUseComplexCollisionForOcclusion;
    /* 0x00b0 */ bool bEnableReverbSend;
    /* 0x00b1 */ bool bEnablePriorityAttenuation;
    /* 0x00b1 */ bool bApplyNormalizationToStereoSounds;
    /* 0x00b1 */ bool bEnableLogFrequencyScaling;
    /* 0x00b1 */ bool bEnableSubmixSends;
    /* 0x00b2 */ uint8_t SpatializationAlgorithm;
    /* 0x00b4 */ float BinauralRadius;
    /* 0x00b8 */ EAirAbsorptionMethod AbsorptionMethod;
    /* 0x00b9 */ uint8_t OcclusionTraceChannel;
    /* 0x00ba */ EReverbSendMethod ReverbSendMethod;
    /* 0x00bb */ EPriorityAttenuationMethod PriorityAttenuationMethod;
    /* 0x00bc */ uint8_t DistanceType;
    /* 0x00c0 */ float OmniRadius;
    /* 0x00c4 */ float StereoSpread;
    /* 0x00c8 */ USpatializationPluginSourceSettingsBase* SpatializationPluginSettings;
    /* 0x00d0 */ float RadiusMin;
    /* 0x00d4 */ float RadiusMax;
    /* 0x00d8 */ float LPFRadiusMin;
    /* 0x00dc */ float LPFRadiusMax;
    /* 0x00e0 */ FRuntimeFloatCurve CustomLowpassAirAbsorptionCurve;
    /* 0x0168 */ FRuntimeFloatCurve CustomHighpassAirAbsorptionCurve;
    /* 0x01f0 */ float LPFFrequencyAtMin;
    /* 0x01f4 */ float LPFFrequencyAtMax;
    /* 0x01f8 */ float HPFFrequencyAtMin;
    /* 0x01fc */ float HPFFrequencyAtMax;
    /* 0x0200 */ float FocusAzimuth;
    /* 0x0204 */ float NonFocusAzimuth;
    /* 0x0208 */ float FocusDistanceScale;
    /* 0x020c */ float NonFocusDistanceScale;
    /* 0x0210 */ float FocusPriorityScale;
    /* 0x0214 */ float NonFocusPriorityScale;
    /* 0x0218 */ float FocusVolumeAttenuation;
    /* 0x021c */ float NonFocusVolumeAttenuation;
    /* 0x0220 */ float FocusAttackInterpSpeed;
    /* 0x0224 */ float FocusReleaseInterpSpeed;
    /* 0x0228 */ float OcclusionLowPassFilterFrequency;
    /* 0x022c */ float OcclusionVolumeAttenuation;
    /* 0x0230 */ float OcclusionInterpolationTime;
    /* 0x0238 */ UOcclusionPluginSourceSettingsBase* OcclusionPluginSettings;
    /* 0x0240 */ UReverbPluginSourceSettingsBase* ReverbPluginSettings;
    /* 0x0248 */ float ReverbWetLevelMin;
    /* 0x024c */ float ReverbWetLevelMax;
    /* 0x0250 */ float ReverbDistanceMin;
    /* 0x0254 */ float ReverbDistanceMax;
    /* 0x0258 */ float ManualReverbSendLevel;
    /* 0x0260 */ FRuntimeFloatCurve CustomReverbSendCurve;
    /* 0x02e8 */ TArray<FAttenuationSubmixSendSettings> SubmixSendSettings;
    /* 0x02f8 */ float PriorityAttenuationMin;
    /* 0x02fc */ float PriorityAttenuationMax;
    /* 0x0300 */ float PriorityAttenuationDistanceMin;
    /* 0x0304 */ float PriorityAttenuationDistanceMax;
    /* 0x0308 */ float ManualPriorityAttenuation;
    /* 0x0310 */ FRuntimeFloatCurve CustomPriorityAttenuationCurve;
    /* 0x0398 */ FSoundAttenuationPluginSettings PluginSettings;
};

// Size: 0x188
class USoundBase : public UObject {
    /* 0x0038 */ USoundClass* SoundClassObject;
    /* 0x0040 */ bool bDebug;
    /* 0x0040 */ bool bOverrideConcurrency;
    /* 0x0040 */ bool bOutputToBusOnly;
    /* 0x0040 */ bool bEnableBusSends;
    /* 0x0040 */ bool bEnableBaseSubmix;
    /* 0x0040 */ bool bEnableSubmixSends;
    /* 0x0040 */ bool bHasDelayNode;
    /* 0x0040 */ bool bHasConcatenatorNode;
    /* 0x0041 */ bool bHasVirtualizeWhenSilent;
    /* 0x0041 */ bool bBypassVolumeScaleForPriority;
    /* 0x0042 */ EVirtualizationMode VirtualizationMode;
    /* 0x0043 */ uint8_t MaxConcurrentResolutionRule;
    /* 0x0098 */ USoundConcurrency* SoundConcurrencySettings;
    /* 0x00a0 */ TSet<USoundConcurrency*> ConcurrencySet;
    /* 0x00f0 */ FSoundConcurrencySettings ConcurrencyOverrides;
    /* 0x0118 */ int32_t MaxConcurrentPlayCount;
    /* 0x011c */ float Duration;
    /* 0x0120 */ float MaxDistance;
    /* 0x0124 */ float TotalSamples;
    /* 0x0128 */ float Priority;
    /* 0x0130 */ USoundAttenuation* AttenuationSettings;
    /* 0x0138 */ USoundSubmixBase* SoundSubmixObject;
    /* 0x0140 */ TArray<FSoundSubmixSendInfo> SoundSubmixSends;
    /* 0x0150 */ USoundEffectSourcePresetChain* SourceEffectChain;
    /* 0x0158 */ TArray<FSoundSourceBusSendInfo> BusSends;
    /* 0x0168 */ TArray<FSoundSourceBusSendInfo> PreEffectBusSends;
    /* 0x0178 */ TArray<UAssetUserData*> AssetUserData;
};

// Size: 0xd8
class USoundClass : public UObject {
    /* 0x0030 */ FSoundClassProperties Properties;
    /* 0x00a8 */ TArray<USoundClass*> ChildClasses;
    /* 0x00b8 */ TArray<FPassiveSoundMixModifier> PassiveSoundMixModifiers;
    /* 0x00c8 */ USoundClass* ParentClass;
};

// Size: 0x20
struct FSoundClassAdjuster {
    /* 0x0000 */ USoundClass* SoundClassObject;
    /* 0x0008 */ float VolumeAdjuster;
    /* 0x000c */ float PitchAdjuster;
    /* 0x0010 */ float LowPassFilterFrequency;
    /* 0x0014 */ bool bApplyToChildren;
    /* 0x0018 */ float VoiceCenterChannelVolumeAdjuster;
};

// Size: 0x8
struct FSoundClassEditorData {
};

// Size: 0x78
struct FSoundClassProperties {
    /* 0x0000 */ float Volume;
    /* 0x0004 */ float Pitch;
    /* 0x0008 */ float LowPassFilterFrequency;
    /* 0x000c */ float AttenuationDistanceScale;
    /* 0x0010 */ float LFEBleed;
    /* 0x0014 */ float VoiceCenterChannelVolume;
    /* 0x0018 */ float RadioFilterVolume;
    /* 0x001c */ float RadioFilterVolumeThreshold;
    /* 0x0020 */ bool bApplyEffects;
    /* 0x0020 */ bool bAlwaysPlay;
    /* 0x0020 */ bool bIsUISound;
    /* 0x0020 */ bool bIsMusic;
    /* 0x0020 */ bool bCenterChannelOnly;
    /* 0x0020 */ bool bApplyAmbientVolumes;
    /* 0x0020 */ bool bReverb;
    /* 0x0024 */ float Default2DReverbSendAmount;
    /* 0x0028 */ FSoundModulationDefaultSettings ModulationSettings;
    /* 0x0068 */ uint8_t OutputTarget;
    /* 0x0069 */ ESoundWaveLoadingBehavior LoadingBehavior;
    /* 0x0070 */ USoundSubmix* DefaultSubmix;
};

// Size: 0x58
class USoundConcurrency : public UObject {
    /* 0x0030 */ FSoundConcurrencySettings Concurrency;
};

// Size: 0x28
struct FSoundConcurrencySettings {
    /* 0x0000 */ int32_t MaxCount;
    /* 0x0004 */ bool bLimitToOwner;
    /* 0x0008 */ uint8_t ResolutionRule;
    /* 0x000c */ float RetriggerTime;
    /* 0x0010 */ float VolumeScale;
    /* 0x0014 */ EConcurrencyVolumeScaleMode VolumeScaleMode;
    /* 0x0018 */ float VolumeScaleAttackTime;
    /* 0x001c */ bool bVolumeScaleCanRelease;
    /* 0x0020 */ float VolumeScaleReleaseTime;
    /* 0x0024 */ float VoiceStealReleaseTime;
};

// Size: 0x5c8
class USoundCue : public USoundBase {
    /* 0x0188 */ bool bPrimeOnLoad;
    /* 0x0190 */ USoundNode* FirstNode;
    /* 0x0198 */ float VolumeMultiplier;
    /* 0x019c */ float PitchMultiplier;
    /* 0x01a0 */ FSoundAttenuationSettings AttenuationOverrides;
    /* 0x0568 */ TArray<USoundNode*> AllNodes;
    /* 0x0578 */ UEdGraph* SoundCueGraph;
    /* 0x0580 */ float SubtitlePriority;
    /* 0x0588 */ bool bOverrideAttenuation;
    /* 0x0588 */ bool bExcludeFromRandomNodeBranchCulling;
    /* 0x058c */ int32_t CookedQualityIndex;
    /* 0x0590 */ bool bHasPlayWhenSilent;
};

// Size: 0x30
struct FSoundDebugEntry {
    /* 0x0000 */ FName DebugName;
    /* 0x0010 */ FSoftObjectPath Sound;
};

// Size: 0x70
class USoundEffectPreset : public UObject {
};

// Size: 0x70
class USoundEffectSourcePreset : public USoundEffectPreset {
};

// Size: 0x48
class USoundEffectSourcePresetChain : public UObject {
    /* 0x0030 */ TArray<FSourceEffectChainEntry> Chain;
    /* 0x0040 */ bool bPlayEffectChainTails;
};

// Size: 0x70
class USoundEffectSubmixPreset : public USoundEffectPreset {
};

// Size: 0x20
struct FSoundGroup {
    /* 0x0000 */ uint8_t SoundGroup;
    /* 0x0008 */ FString DisplayName;
    /* 0x0018 */ bool bAlwaysDecompressOnLoad;
    /* 0x001c */ float DecompressedDuration;
};

// Size: 0x90
class USoundGroups : public UObject {
    /* 0x0030 */ TArray<FSoundGroup> SoundGroupProfiles;
};

// Size: 0xa0
class USoundMix : public UObject {
    /* 0x0030 */ bool bApplyEQ;
    /* 0x0034 */ float EQPriority;
    /* 0x0038 */ FAudioEQEffect EQSettings;
    /* 0x0078 */ TArray<FSoundClassAdjuster> SoundClassEffects;
    /* 0x0088 */ float InitialDelay;
    /* 0x008c */ float FadeInTime;
    /* 0x0090 */ float Duration;
    /* 0x0094 */ float FadeOutTime;
    /* 0x0098 */ bool bChanged;
};

// Size: 0x48
struct FSoundModulationDefaultRoutingSettings : public FSoundModulationDefaultSettings {
    /* 0x0040 */ EModulationRouting VolumeRouting;
    /* 0x0041 */ EModulationRouting PitchRouting;
    /* 0x0042 */ EModulationRouting HighpassRouting;
    /* 0x0043 */ EModulationRouting LowpassRouting;
};

// Size: 0x40
struct FSoundModulationDefaultSettings {
    /* 0x0000 */ FSoundModulationDestinationSettings VolumeModulationDestination;
    /* 0x0010 */ FSoundModulationDestinationSettings PitchModulationDestination;
    /* 0x0020 */ FSoundModulationDestinationSettings HighpassModulationDestination;
    /* 0x0030 */ FSoundModulationDestinationSettings LowpassModulationDestination;
};

// Size: 0x10
struct FSoundModulationDestinationSettings {
    /* 0x0000 */ float Value;
    /* 0x0004 */ bool bEnableModulation;
    /* 0x0008 */ USoundModulatorBase* Modulator;
};

// Size: 0x58
class USoundNode : public UObject {
    /* 0x0030 */ TArray<USoundNode*> ChildNodes;
    /* 0x0040 */ UEdGraphNode* GraphNode;
};

// Size: 0x58
class USoundNodeAssetReferencer : public USoundNode {
};

// Size: 0x430
class USoundNodeAttenuation : public USoundNode {
    /* 0x0058 */ USoundAttenuation* AttenuationSettings;
    /* 0x0060 */ FSoundAttenuationSettings AttenuationOverrides;
    /* 0x0428 */ bool bOverrideAttenuation;
};

// Size: 0x68
class USoundNodeBranch : public USoundNode {
    /* 0x0058 */ FName BoolParameterName;
};

// Size: 0x68
class USoundNodeConcatenator : public USoundNode {
    /* 0x0058 */ TArray<float> InputVolume;
};

// Size: 0x60
class USoundNodeDelay : public USoundNode {
    /* 0x0058 */ float DelayMin;
    /* 0x005c */ float DelayMax;
};

// Size: 0x80
class USoundNodeDialoguePlayer : public USoundNode {
    /* 0x0058 */ FDialogueWaveParameter DialogueWaveParameter;
    /* 0x0078 */ bool bLooping;
};

// Size: 0x68
class USoundNodeDistanceCrossFade : public USoundNode {
    /* 0x0058 */ TArray<FDistanceDatum> CrossFadeInput;
};

// Size: 0x68
class USoundNodeDoppler : public USoundNode {
    /* 0x0058 */ float DopplerIntensity;
    /* 0x005c */ bool bUseSmoothing;
    /* 0x0060 */ float SmoothingInterpSpeed;
};

// Size: 0x8
struct FSoundNodeEditorData {
};

// Size: 0x1a0
class USoundNodeEnveloper : public USoundNode {
    /* 0x0058 */ float LoopStart;
    /* 0x005c */ float LoopEnd;
    /* 0x0060 */ float DurationAfterLoop;
    /* 0x0064 */ int32_t LoopCount;
    /* 0x0068 */ bool bLoopIndefinitely;
    /* 0x0068 */ bool bLoop;
    /* 0x0070 */ UDistributionFloatConstantCurve* VolumeInterpCurve;
    /* 0x0078 */ UDistributionFloatConstantCurve* PitchInterpCurve;
    /* 0x0080 */ FRuntimeFloatCurve VolumeCurve;
    /* 0x0108 */ FRuntimeFloatCurve PitchCurve;
    /* 0x0190 */ float PitchMin;
    /* 0x0194 */ float PitchMax;
    /* 0x0198 */ float VolumeMin;
    /* 0x019c */ float VolumeMax;
};

// Size: 0x68
class USoundNodeGroupControl : public USoundNode {
    /* 0x0058 */ TArray<int32_t> GroupSizes;
};

// Size: 0x60
class USoundNodeLooping : public USoundNode {
    /* 0x0058 */ int32_t LoopCount;
    /* 0x005c */ bool bLoopIndefinitely;
};

// Size: 0x58
class USoundNodeMature : public USoundNode {
};

// Size: 0x68
class USoundNodeMixer : public USoundNode {
    /* 0x0058 */ TArray<float> InputVolume;
};

// Size: 0x68
class USoundNodeModulator : public USoundNode {
    /* 0x0058 */ float PitchMin;
    /* 0x005c */ float PitchMax;
    /* 0x0060 */ float VolumeMin;
    /* 0x0064 */ float VolumeMax;
};

// Size: 0xa0
class USoundNodeModulatorContinuous : public USoundNode {
    /* 0x0058 */ FModulatorContinuousParams PitchModulationParams;
    /* 0x007c */ FModulatorContinuousParams VolumeModulationParams;
};

// Size: 0x80
class USoundNodeOscillator : public USoundNode {
    /* 0x0058 */ bool bModulateVolume;
    /* 0x0058 */ bool bModulatePitch;
    /* 0x005c */ float AmplitudeMin;
    /* 0x0060 */ float AmplitudeMax;
    /* 0x0064 */ float FrequencyMin;
    /* 0x0068 */ float FrequencyMax;
    /* 0x006c */ float OffsetMin;
    /* 0x0070 */ float OffsetMax;
    /* 0x0074 */ float CenterMin;
    /* 0x0078 */ float CenterMax;
};

// Size: 0x78
class USoundNodeParamCrossFade : public USoundNodeDistanceCrossFade {
    /* 0x0068 */ FName ParamName;
};

// Size: 0x88
class USoundNodeQualityLevel : public USoundNode {
    /* 0x0058 */ int32_t CookedQualityLevelIndex;
};

// Size: 0x98
class USoundNodeRandom : public USoundNode {
    /* 0x0058 */ TArray<float> Weights;
    /* 0x0068 */ TArray<bool> HasBeenUsed;
    /* 0x0078 */ int32_t NumRandomUsed;
    /* 0x007c */ int32_t PreselectAtLevelLoad;
    /* 0x0080 */ bool bShouldExcludeFromBranchCulling;
    /* 0x0080 */ bool bSoundCueExcludedFromBranchCulling;
    /* 0x0080 */ bool bRandomizeWithoutReplacement;
    /* 0x0088 */ TArray<int32_t> PIEHiddenNodes;
};

// Size: 0x68
class USoundNodeSoundClass : public USoundNode {
    /* 0x0058 */ USoundClass* SoundClassOverride;
};

// Size: 0x68
class USoundNodeSwitch : public USoundNode {
    /* 0x0058 */ FName IntParameterName;
};

// Size: 0x68
class USoundNodeWaveParam : public USoundNode {
    /* 0x0058 */ FName WaveParameterName;
};

// Size: 0xa0
class USoundNodeWavePlayer : public USoundNodeAssetReferencer {
    /* 0x0058 */ TSoftObjectPtr<USoundWave> SoundWaveAssetPtr;
    /* 0x0088 */ USoundWave* SoundWave;
    /* 0x0098 */ bool bLooping;
};

// Size: 0x518
class USoundSourceBus : public USoundWave {
    /* 0x0500 */ ESourceBusChannels SourceBusChannels;
    /* 0x0504 */ float SourceBusDuration;
    /* 0x0508 */ UAudioBus* AudioBus;
    /* 0x0510 */ bool bAutoDeactivateWhenSilent;
};

// Size: 0xb8
struct FSoundSourceBusSendInfo {
    /* 0x0000 */ ESourceBusSendLevelControlMethod SourceBusSendLevelControlMethod;
    /* 0x0008 */ USoundSourceBus* SoundSourceBus;
    /* 0x0010 */ UAudioBus* AudioBus;
    /* 0x0018 */ float SendLevel;
    /* 0x001c */ float MinSendLevel;
    /* 0x0020 */ float MaxSendLevel;
    /* 0x0024 */ float MinSendDistance;
    /* 0x0028 */ float MaxSendDistance;
    /* 0x0030 */ FRuntimeFloatCurve CustomSendLevelCurve;
};

// Size: 0xe0
class USoundSubmix : public USoundSubmixWithParentBase {
    /* 0x0050 */ bool bMuteWhenBackgrounded;
    /* 0x0058 */ TArray<USoundEffectSubmixPreset*> SubmixEffectChain;
    /* 0x0068 */ USoundfieldEncodingSettingsBase* AmbisonicsPluginSettings;
    /* 0x0070 */ int32_t EnvelopeFollowerAttackTime;
    /* 0x0074 */ int32_t EnvelopeFollowerReleaseTime;
    /* 0x0078 */ EGainParamMode GainMode;
    /* 0x007c */ float OutputVolume;
    /* 0x0080 */ float WetLevel;
    /* 0x0084 */ float DryLevel;
    /* 0x0088 */ float OutputVolumeDB;
    /* 0x008c */ float WetLevelDB;
    /* 0x0090 */ float DryLevelDB;
    /* 0x0098 */ FSoundModulationDestinationSettings OutputVolumeModulation;
    /* 0x00a8 */ FSoundModulationDestinationSettings WetLevelModulation;
    /* 0x00b8 */ FSoundModulationDestinationSettings DryLevelModulation;
    /* 0x00c8 */ FMulticastInlineDelegate OnSubmixRecordedFileDone;

    void AddEnvelopeFollowerDelegate(const UObject* WorldContextObject, const FDelegate& OnSubmixEnvelopeBP);
    void AddSpectralAnalysisDelegate(const UObject* WorldContextObject, const TArray<FSoundSubmixSpectralAnalysisBandSettings>& InBandSettings, const FDelegate& OnSubmixSpectralAnalysisBP, float UpdateRate, float DecibelNoiseFloor, bool bDoNormalize, bool bDoAutoRange, float AutoRangeAttackTime, float AutoRangeReleaseTime);
    void RemoveSpectralAnalysisDelegate(const UObject* WorldContextObject, const FDelegate& OnSubmixSpectralAnalysisBP);
    void SetSubmixOutputVolume(const UObject* WorldContextObject, float InOutputVolume);
    void StartEnvelopeFollowing(const UObject* WorldContextObject);
    void StartRecordingOutput(const UObject* WorldContextObject, float ExpectedDuration);
    void StartSpectralAnalysis(const UObject* WorldContextObject, EFFTSize FFTSize, EFFTPeakInterpolationMethod InterpolationMethod, EFFTWindowType WindowType, float HopSize, EAudioSpectrumType SpectrumType);
    void StopEnvelopeFollowing(const UObject* WorldContextObject);
    void StopRecordingOutput(const UObject* WorldContextObject, EAudioRecordingExportType ExportType, FString Name, FString Path, USoundWave* ExistingSoundWaveToOverwrite);
    void StopSpectralAnalysis(const UObject* WorldContextObject);
};

// Size: 0x48
class USoundSubmixBase : public UObject {
    /* 0x0038 */ TArray<USoundSubmixBase*> ChildSubmixes;
};

// Size: 0xb0
struct FSoundSubmixSendInfo {
    /* 0x0000 */ ESendLevelControlMethod SendLevelControlMethod;
    /* 0x0001 */ ESubmixSendStage SendStage;
    /* 0x0008 */ USoundSubmixBase* SoundSubmix;
    /* 0x0010 */ float SendLevel;
    /* 0x0014 */ float MinSendLevel;
    /* 0x0018 */ float MaxSendLevel;
    /* 0x001c */ float MinSendDistance;
    /* 0x0020 */ float MaxSendDistance;
    /* 0x0028 */ FRuntimeFloatCurve CustomSendLevelCurve;
};

// Size: 0x10
struct FSoundSubmixSpectralAnalysisBandSettings {
    /* 0x0000 */ float BandFrequency;
    /* 0x0004 */ int32_t AttackTimeMsec;
    /* 0x0008 */ int32_t ReleaseTimeMsec;
    /* 0x000c */ float QFactor;
};

// Size: 0x50
class USoundSubmixWithParentBase : public USoundSubmixBase {
    /* 0x0048 */ USoundSubmixBase* ParentSubmix;
};

// Size: 0x18
struct FSoundTrackKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ float Volume;
    /* 0x0008 */ float Pitch;
    /* 0x0010 */ USoundBase* Sound;
};

// Size: 0x500
class USoundWave : public USoundBase {
    /* 0x0188 */ int32_t CompressionQuality;
    /* 0x018c */ int32_t StreamingPriority;
    /* 0x0190 */ ESoundwaveSampleRateSettings SampleRateQuality;
    /* 0x0192 */ uint8_t SoundGroup;
    /* 0x0193 */ bool bLooping;
    /* 0x0193 */ bool bStreaming;
    /* 0x0193 */ bool bSeekableStreaming;
    /* 0x0194 */ ESoundWaveLoadingBehavior LoadingBehavior;
    /* 0x0195 */ bool bMature;
    /* 0x0195 */ bool bManualWordWrap;
    /* 0x0196 */ bool bSingleLine;
    /* 0x0196 */ bool bVirtualizeWhenSilent;
    /* 0x0196 */ bool bIsAmbisonics;
    /* 0x01a0 */ USoundWave* OverrideSoundToUseForAnalysis;
    /* 0x01a8 */ bool TreatFileAsLoopingForAnalysis;
    /* 0x01a8 */ bool bEnableBakedFFTAnalysis;
    /* 0x01a8 */ bool bEnableAmplitudeEnvelopeAnalysis;
    /* 0x01a9 */ ESoundWaveFFTSize FFTSize;
    /* 0x01ac */ int32_t FFTAnalysisFrameSize;
    /* 0x01b0 */ int32_t FFTAnalysisAttackTime;
    /* 0x01b4 */ int32_t FFTAnalysisReleaseTime;
    /* 0x01b8 */ int32_t EnvelopeFollowerFrameSize;
    /* 0x01bc */ int32_t EnvelopeFollowerAttackTime;
    /* 0x01c0 */ int32_t EnvelopeFollowerReleaseTime;
    /* 0x01c8 */ FSoundModulationDefaultRoutingSettings ModulationSettings;
    /* 0x0210 */ TArray<float> FrequenciesToAnalyze;
    /* 0x0220 */ TArray<FSoundWaveSpectralTimeData> CookedSpectralTimeData;
    /* 0x0230 */ TArray<FSoundWaveEnvelopeTimeData> CookedEnvelopeTimeData;
    /* 0x0240 */ int32_t InitialChunkSize;
    /* 0x0288 */ FString SpokenText;
    /* 0x0298 */ float SubtitlePriority;
    /* 0x029c */ float Volume;
    /* 0x02a0 */ float Pitch;
    /* 0x02a4 */ int32_t NumChannels;
    /* 0x02a8 */ TArray<int32_t> ChannelOffsets;
    /* 0x02b8 */ TArray<int32_t> ChannelSizes;
    /* 0x02c8 */ int32_t SampleRate;
    /* 0x02d8 */ TArray<FSubtitleCue> Subtitles;
    /* 0x02e8 */ FString Comment;
    /* 0x02f8 */ FString SourceFilePath;
    /* 0x0308 */ FString SourceFileTimestamp;
    /* 0x0318 */ UAssetImportData* AssetImportData;
    /* 0x0320 */ UCurveTable* Curves;
    /* 0x0328 */ UCurveTable* InternalCurves;
};

// Size: 0x10
struct FSoundWaveEnvelopeDataPerSound {
    /* 0x0000 */ float Envelope;
    /* 0x0004 */ float PlaybackTime;
    /* 0x0008 */ USoundWave* SoundWave;
};

// Size: 0x8
struct FSoundWaveEnvelopeTimeData {
    /* 0x0000 */ float Amplitude;
    /* 0x0004 */ float TimeSec;
};

// Size: 0x550
class USoundWaveProcedural : public USoundWave {
};

// Size: 0xc
struct FSoundWaveSpectralData {
    /* 0x0000 */ float FrequencyHz;
    /* 0x0004 */ float Magnitude;
    /* 0x0008 */ float NormalizedMagnitude;
};

// Size: 0x8
struct FSoundWaveSpectralDataEntry {
    /* 0x0000 */ float Magnitude;
    /* 0x0004 */ float NormalizedMagnitude;
};

// Size: 0x20
struct FSoundWaveSpectralDataPerSound {
    /* 0x0000 */ TArray<FSoundWaveSpectralData> SpectralData;
    /* 0x0010 */ float PlaybackTime;
    /* 0x0018 */ USoundWave* SoundWave;
};

// Size: 0x18
struct FSoundWaveSpectralTimeData {
    /* 0x0000 */ TArray<FSoundWaveSpectralDataEntry> Data;
    /* 0x0010 */ float TimeSec;
};

// Size: 0x88
class USoundfieldEndpointSubmix : public USoundSubmixBase {
    /* 0x0048 */ FName SoundfieldEndpointType;
    /* 0x0058 */ UClass* EndpointSettingsClass;
    /* 0x0060 */ USoundfieldEndpointSettingsBase* EndpointSettings;
    /* 0x0068 */ UClass* EncodingSettingsClass;
    /* 0x0070 */ USoundfieldEncodingSettingsBase* EncodingSettings;
    /* 0x0078 */ TArray<USoundfieldEffectBase*> SoundfieldEffectChain;
};

// Size: 0x80
class USoundfieldSubmix : public USoundSubmixWithParentBase {
    /* 0x0050 */ FName SoundfieldEncodingFormat;
    /* 0x0060 */ USoundfieldEncodingSettingsBase* EncodingSettings;
    /* 0x0068 */ TArray<USoundfieldEffectBase*> SoundfieldEffectChain;
    /* 0x0078 */ UClass* EncodingSettingsClass;
};

// Size: 0x10
struct FSourceEffectChainEntry {
    /* 0x0000 */ USoundEffectSourcePreset* Preset;
    /* 0x0008 */ bool bBypass;
};

// Size: 0x380
class ASpectatorPawn : public ADefaultPawn {
};

// Size: 0x170
class USpectatorPawnMovement : public UFloatingPawnMovement {
    /* 0x0168 */ bool bIgnoreTimeDilation;
};

// Size: 0x500
class USphereComponent : public UShapeComponent {
    /* 0x04f0 */ float SphereRadius;

    float GetScaledSphereRadius() const;
    float GetShapeScale() const;
    float GetUnscaledSphereRadius() const;
    void SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps);
};

// Size: 0x318
class ASphereReflectionCapture : public AReflectionCapture {
    /* 0x0310 */ UDrawSphereComponent* DrawCaptureRadius;
};

// Size: 0x2b0
class USphereReflectionCaptureComponent : public UReflectionCaptureComponent {
    /* 0x02a0 */ float InfluenceRadius;
    /* 0x02a4 */ float CaptureDistanceScale;
    /* 0x02a8 */ UDrawSphereComponent* PreviewInfluenceRadius;
};

// Size: 0x610
class USplineComponent : public UPrimitiveComponent {
    /* 0x04d8 */ FSplineCurves SplineCurves;
    /* 0x0548 */ FInterpCurveVector SplineInfo;
    /* 0x0560 */ FInterpCurveQuat SplineRotInfo;
    /* 0x0578 */ FInterpCurveVector SplineScaleInfo;
    /* 0x0590 */ FInterpCurveFloat SplineReparamTable;
    /* 0x05a8 */ bool bAllowSplineEditingPerInstance;
    /* 0x05ac */ int32_t ReparamStepsPerSegment;
    /* 0x05b0 */ float Duration;
    /* 0x05b4 */ bool bStationaryEndpoints;
    /* 0x05b5 */ bool bSplineHasBeenEdited;
    /* 0x05b6 */ bool bModifiedByConstructionScript;
    /* 0x05b7 */ bool bInputSplinePointsToConstructionScript;
    /* 0x05b8 */ bool bDrawDebug;
    /* 0x05b9 */ bool bClosedLoop;
    /* 0x05ba */ bool bLoopPositionOverride;
    /* 0x05bc */ float LoopPosition;
    /* 0x05c0 */ FVector DefaultUpVector;
    /* 0x05cc */ FLinearColor EditorUnselectedSplineSegmentColor;
    /* 0x05dc */ FLinearColor EditorSelectedSplineSegmentColor;
    /* 0x05ec */ FLinearColor EditorTangentColor;
    /* 0x05fc */ bool bAllowDiscontinuousSpline;
    /* 0x05fd */ bool bShouldVisualizeScale;
    /* 0x0600 */ float ScaleVisualizationWidth;

    void AddPoint(const FSplinePoint& Point, bool bUpdateSpline);
    void AddPoints(const TArray<FSplinePoint>& Points, bool bUpdateSpline);
    void AddSplineLocalPoint(const FVector& Position);
    void AddSplinePoint(const FVector& Position, uint8_t CoordinateSpace, bool bUpdateSpline);
    void AddSplinePointAtIndex(const FVector& Position, int32_t index, uint8_t CoordinateSpace, bool bUpdateSpline);
    void AddSplineWorldPoint(const FVector& Position);
    void ClearSplinePoints(bool bUpdateSpline);
    FVector FindDirectionClosestToWorldLocation(const FVector& WorldLocation, uint8_t CoordinateSpace) const;
    float FindInputKeyClosestToWorldLocation(const FVector& WorldLocation) const;
    FVector FindLocationClosestToWorldLocation(const FVector& WorldLocation, uint8_t CoordinateSpace) const;
    FVector FindRightVectorClosestToWorldLocation(const FVector& WorldLocation, uint8_t CoordinateSpace) const;
    float FindRollClosestToWorldLocation(const FVector& WorldLocation, uint8_t CoordinateSpace) const;
    FRotator FindRotationClosestToWorldLocation(const FVector& WorldLocation, uint8_t CoordinateSpace) const;
    FVector FindScaleClosestToWorldLocation(const FVector& WorldLocation) const;
    FVector FindTangentClosestToWorldLocation(const FVector& WorldLocation, uint8_t CoordinateSpace) const;
    FTransform FindTransformClosestToWorldLocation(const FVector& WorldLocation, uint8_t CoordinateSpace, bool bUseScale) const;
    FVector FindUpVectorClosestToWorldLocation(const FVector& WorldLocation, uint8_t CoordinateSpace) const;
    FVector GetArriveTangentAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    FVector GetDefaultUpVector(uint8_t CoordinateSpace) const;
    FVector GetDirectionAtDistanceAlongSpline(float Distance, uint8_t CoordinateSpace) const;
    FVector GetDirectionAtSplineInputKey(float InKey, uint8_t CoordinateSpace) const;
    FVector GetDirectionAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    FVector GetDirectionAtTime(float Time, uint8_t CoordinateSpace, bool bUseConstantVelocity) const;
    float GetDistanceAlongSplineAtSplineInputKey(float InKey) const;
    float GetDistanceAlongSplineAtSplinePoint(int32_t PointIndex) const;
    float GetFloatPropertyAtSplineInputKey(float InKey, FName PropertyName) const;
    float GetFloatPropertyAtSplinePoint(int32_t index, FName PropertyName) const;
    float GetInputKeyAtDistanceAlongSpline(float Distance) const;
    FVector GetLeaveTangentAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    void GetLocalLocationAndTangentAtSplinePoint(int32_t PointIndex, FVector& LocalLocation, FVector& LocalTangent) const;
    void GetLocationAndTangentAtSplinePoint(int32_t PointIndex, FVector& Location, FVector& Tangent, uint8_t CoordinateSpace) const;
    FVector GetLocationAtDistanceAlongSpline(float Distance, uint8_t CoordinateSpace) const;
    FVector GetLocationAtSplineInputKey(float InKey, uint8_t CoordinateSpace) const;
    FVector GetLocationAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    FVector GetLocationAtTime(float Time, uint8_t CoordinateSpace, bool bUseConstantVelocity) const;
    int32_t GetNumberOfSplinePoints() const;
    int32_t GetNumberOfSplineSegments() const;
    FVector GetRightVectorAtDistanceAlongSpline(float Distance, uint8_t CoordinateSpace) const;
    FVector GetRightVectorAtSplineInputKey(float InKey, uint8_t CoordinateSpace) const;
    FVector GetRightVectorAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    FVector GetRightVectorAtTime(float Time, uint8_t CoordinateSpace, bool bUseConstantVelocity) const;
    float GetRollAtDistanceAlongSpline(float Distance, uint8_t CoordinateSpace) const;
    float GetRollAtSplineInputKey(float InKey, uint8_t CoordinateSpace) const;
    float GetRollAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    float GetRollAtTime(float Time, uint8_t CoordinateSpace, bool bUseConstantVelocity) const;
    FRotator GetRotationAtDistanceAlongSpline(float Distance, uint8_t CoordinateSpace) const;
    FRotator GetRotationAtSplineInputKey(float InKey, uint8_t CoordinateSpace) const;
    FRotator GetRotationAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    FRotator GetRotationAtTime(float Time, uint8_t CoordinateSpace, bool bUseConstantVelocity) const;
    FVector GetScaleAtDistanceAlongSpline(float Distance) const;
    FVector GetScaleAtSplineInputKey(float InKey) const;
    FVector GetScaleAtSplinePoint(int32_t PointIndex) const;
    FVector GetScaleAtTime(float Time, bool bUseConstantVelocity) const;
    float GetSplineLength() const;
    uint8_t GetSplinePointType(int32_t PointIndex) const;
    FVector GetTangentAtDistanceAlongSpline(float Distance, uint8_t CoordinateSpace) const;
    FVector GetTangentAtSplineInputKey(float InKey, uint8_t CoordinateSpace) const;
    FVector GetTangentAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    FVector GetTangentAtTime(float Time, uint8_t CoordinateSpace, bool bUseConstantVelocity) const;
    FTransform GetTransformAtDistanceAlongSpline(float Distance, uint8_t CoordinateSpace, bool bUseScale) const;
    FTransform GetTransformAtSplineInputKey(float InKey, uint8_t CoordinateSpace, bool bUseScale) const;
    FTransform GetTransformAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace, bool bUseScale) const;
    FTransform GetTransformAtTime(float Time, uint8_t CoordinateSpace, bool bUseConstantVelocity, bool bUseScale) const;
    FVector GetUpVectorAtDistanceAlongSpline(float Distance, uint8_t CoordinateSpace) const;
    FVector GetUpVectorAtSplineInputKey(float InKey, uint8_t CoordinateSpace) const;
    FVector GetUpVectorAtSplinePoint(int32_t PointIndex, uint8_t CoordinateSpace) const;
    FVector GetUpVectorAtTime(float Time, uint8_t CoordinateSpace, bool bUseConstantVelocity) const;
    FVector GetVectorPropertyAtSplineInputKey(float InKey, FName PropertyName) const;
    FVector GetVectorPropertyAtSplinePoint(int32_t index, FName PropertyName) const;
    FVector GetWorldDirectionAtDistanceAlongSpline(float Distance) const;
    FVector GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity) const;
    FVector GetWorldLocationAtDistanceAlongSpline(float Distance) const;
    FVector GetWorldLocationAtSplinePoint(int32_t PointIndex) const;
    FVector GetWorldLocationAtTime(float Time, bool bUseConstantVelocity) const;
    FRotator GetWorldRotationAtDistanceAlongSpline(float Distance) const;
    FRotator GetWorldRotationAtTime(float Time, bool bUseConstantVelocity) const;
    FVector GetWorldTangentAtDistanceAlongSpline(float Distance) const;
    bool IsClosedLoop() const;
    void RemoveSplinePoint(int32_t index, bool bUpdateSpline);
    void SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline);
    void SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline);
    void SetDefaultUpVector(const FVector& UpVector, uint8_t CoordinateSpace);
    void SetDrawDebug(bool bShow);
    void SetLocationAtSplinePoint(int32_t PointIndex, const FVector& InLocation, uint8_t CoordinateSpace, bool bUpdateSpline);
    void SetRotationAtSplinePoint(int32_t PointIndex, const FRotator& InRotation, uint8_t CoordinateSpace, bool bUpdateSpline);
    void SetScaleAtSplinePoint(int32_t PointIndex, const FVector& InScaleVector, bool bUpdateSpline);
    void SetSelectedSplineSegmentColor(const FLinearColor& SegmentColor);
    void SetSplineLocalPoints(const TArray<FVector>& Points);
    void SetSplinePointType(int32_t PointIndex, uint8_t Type, bool bUpdateSpline);
    void SetSplinePoints(const TArray<FVector>& Points, uint8_t CoordinateSpace, bool bUpdateSpline);
    void SetSplineWorldPoints(const TArray<FVector>& Points);
    void SetTangentAtSplinePoint(int32_t PointIndex, const FVector& InTangent, uint8_t CoordinateSpace, bool bUpdateSpline);
    void SetTangentColor(const FLinearColor& TangentColor);
    void SetTangentsAtSplinePoint(int32_t PointIndex, const FVector& InArriveTangent, const FVector& InLeaveTangent, uint8_t CoordinateSpace, bool bUpdateSpline);
    void SetUnselectedSplineSegmentColor(const FLinearColor& SegmentColor);
    void SetUpVectorAtSplinePoint(int32_t PointIndex, const FVector& InUpVector, uint8_t CoordinateSpace, bool bUpdateSpline);
    void SetWorldLocationAtSplinePoint(int32_t PointIndex, const FVector& InLocation);
    void UpdateSpline();
};

// Size: 0x70
struct FSplineCurves {
    /* 0x0000 */ FInterpCurveVector Position;
    /* 0x0018 */ FInterpCurveQuat Rotation;
    /* 0x0030 */ FInterpCurveVector Scale;
    /* 0x0048 */ FInterpCurveFloat ReparamTable;
    /* 0x0060 */ USplineMetadata* MetaData;
    /* 0x0068 */ uint32_t Version;
};

// Size: 0x1a0
struct FSplineInstanceData : public FSceneComponentInstanceData {
    /* 0x00b8 */ bool bSplineHasBeenEdited;
    /* 0x00c0 */ FSplineCurves SplineCurves;
    /* 0x0130 */ FSplineCurves SplineCurvesPreUCS;
};

// Size: 0x300
class ASplineMeshActor : public AActor {
    /* 0x02f8 */ USplineMeshComponent* SplineMeshComponent;
};

// Size: 0x660
class USplineMeshComponent : public UStaticMeshComponent {
    /* 0x05d0 */ FSplineMeshParams SplineParams;
    /* 0x0628 */ FVector SplineUpDir;
    /* 0x0634 */ float SplineBoundaryMin;
    /* 0x0638 */ FGuid CachedMeshBodySetupGuid;
    /* 0x0648 */ UBodySetup* BodySetup;
    /* 0x0650 */ float SplineBoundaryMax;
    /* 0x0654 */ bool bAllowSplineEditingPerInstance;
    /* 0x0654 */ bool bSmoothInterpRollScale;
    /* 0x0654 */ bool bMeshDirty;
    /* 0x0655 */ uint8_t ForwardAxis;
    /* 0x0658 */ float VirtualTextureMainPassMaxDrawDistance;
    /* 0x065c */ bool bSelected;

    float GetBoundaryMax() const;
    float GetBoundaryMin() const;
    FVector2D GetEndOffset() const;
    FVector GetEndPosition() const;
    float GetEndRoll() const;
    FVector2D GetEndScale() const;
    FVector GetEndTangent() const;
    uint8_t GetForwardAxis() const;
    FVector GetSplineUpDir() const;
    FVector2D GetStartOffset() const;
    FVector GetStartPosition() const;
    float GetStartRoll() const;
    FVector2D GetStartScale() const;
    FVector GetStartTangent() const;
    void SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh);
    void SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh);
    void SetEndOffset(FVector2D EndOffset, bool bUpdateMesh);
    void SetEndPosition(FVector EndPos, bool bUpdateMesh);
    void SetEndRoll(float EndRoll, bool bUpdateMesh);
    void SetEndScale(FVector2D EndScale, bool bUpdateMesh);
    void SetEndTangent(FVector EndTangent, bool bUpdateMesh);
    void SetForwardAxis(uint8_t InForwardAxis, bool bUpdateMesh);
    void SetSplineUpDir(const FVector& InSplineUpDir, bool bUpdateMesh);
    void SetStartAndEnd(FVector StartPos, FVector StartTangent, FVector EndPos, FVector EndTangent, bool bUpdateMesh);
    void SetStartOffset(FVector2D StartOffset, bool bUpdateMesh);
    void SetStartPosition(FVector StartPos, bool bUpdateMesh);
    void SetStartRoll(float StartRoll, bool bUpdateMesh);
    void SetStartScale(FVector2D StartScale, bool bUpdateMesh);
    void SetStartTangent(FVector StartTangent, bool bUpdateMesh);
    void UpdateMesh();
};

// Size: 0xe8
struct FSplineMeshInstanceData : public FSceneComponentInstanceData {
    /* 0x00b8 */ FVector StartPos;
    /* 0x00c4 */ FVector EndPos;
    /* 0x00d0 */ FVector StartTangent;
    /* 0x00dc */ FVector EndTangent;
};

// Size: 0x58
struct FSplineMeshParams {
    /* 0x0000 */ FVector StartPos;
    /* 0x000c */ FVector StartTangent;
    /* 0x0018 */ FVector2D StartScale;
    /* 0x0020 */ float StartRoll;
    /* 0x0024 */ FVector2D StartOffset;
    /* 0x002c */ FVector EndPos;
    /* 0x0038 */ FVector2D EndScale;
    /* 0x0040 */ FVector EndTangent;
    /* 0x004c */ float EndRoll;
    /* 0x0050 */ FVector2D EndOffset;
};

// Size: 0x30
class USplineMetadata : public UObject {
};

// Size: 0x44
struct FSplinePoint {
    /* 0x0000 */ float InputKey;
    /* 0x0004 */ FVector Position;
    /* 0x0010 */ FVector ArriveTangent;
    /* 0x001c */ FVector LeaveTangent;
    /* 0x0028 */ FRotator Rotation;
    /* 0x0034 */ FVector Scale;
    /* 0x0040 */ uint8_t Type;
};

// Size: 0x318
class ASpotLight : public ALight {
    /* 0x0308 */ USpotLightComponent* SpotLightComponent;
    /* 0x0310 */ UArrowComponent* ArrowComponent;

    void SetInnerConeAngle(float NewInnerConeAngle);
    void SetOuterConeAngle(float NewOuterConeAngle);
};

// Size: 0x3b0
class USpotLightComponent : public UPointLightComponent {
    /* 0x03a8 */ float InnerConeAngle;
    /* 0x03ac */ float OuterConeAngle;

    void SetInnerConeAngle(float NewInnerConeAngle);
    void SetOuterConeAngle(float NewOuterConeAngle);
};

// Size: 0x2b0
class USpringArmComponent : public USceneComponent {
    /* 0x0228 */ float TargetArmLength;
    /* 0x022c */ FVector SocketOffset;
    /* 0x0238 */ FVector TargetOffset;
    /* 0x0244 */ float ProbeSize;
    /* 0x0248 */ uint8_t ProbeChannel;
    /* 0x024c */ bool bDoCollisionTest;
    /* 0x024c */ bool bUsePawnControlRotation;
    /* 0x024c */ bool bInheritPitch;
    /* 0x024c */ bool bInheritYaw;
    /* 0x024c */ bool bInheritRoll;
    /* 0x024c */ bool bEnableCameraLag;
    /* 0x024c */ bool bEnableCameraRotationLag;
    /* 0x024c */ bool bUseCameraLagSubstepping;
    /* 0x024d */ bool bDrawDebugLagMarkers;
    /* 0x0250 */ float CameraLagSpeed;
    /* 0x0254 */ float CameraRotationLagSpeed;
    /* 0x0258 */ float CameraLagMaxTimeStep;
    /* 0x025c */ float CameraLagMaxDistance;

    FRotator GetTargetRotation() const;
    FVector GetUnfixedCameraPosition() const;
    bool IsCollisionFixApplied() const;
};

// Size: 0x40
struct FSpriteCategoryInfo {
    /* 0x0000 */ FName Category;
    /* 0x0010 */ FText DisplayName;
    /* 0x0028 */ FText Description;
};

// Size: 0x30
struct FStartPhysicsTickFunction : public FTickFunction {
};

// Size: 0x8
struct FStatColorMapEntry {
    /* 0x0000 */ float In;
    /* 0x0004 */ FColor Out;
};

// Size: 0x28
struct FStatColorMapping {
    /* 0x0000 */ FString StatName;
    /* 0x0010 */ TArray<FStatColorMapEntry> ColorMap;
    /* 0x0020 */ bool DisableBlend;
};

// Size: 0xb0
struct FStateMachineDebugData {
};

// Size: 0x10
struct FStateMachineStateDebugData {
};

// Size: 0x2c
struct FStaticComponentMaskParameter : public FStaticParameterBase {
    /* 0x0028 */ bool R;
    /* 0x0029 */ bool G;
    /* 0x002a */ bool B;
    /* 0x002b */ bool A;
};

// Size: 0x4
struct FStaticComponentMaskValue {
    /* 0x0000 */ bool R;
    /* 0x0001 */ bool G;
    /* 0x0002 */ bool B;
    /* 0x0003 */ bool A;
};

// Size: 0x38
struct FStaticMaterial {
    /* 0x0000 */ UMaterialInterface* MaterialInterface;
    /* 0x0008 */ FName MaterialSlotName;
    /* 0x0014 */ FName ImportedMaterialSlotName;
    /* 0x0020 */ FMeshUVChannelInfo UVChannelData;
};

// Size: 0xc8
struct FStaticMaterialLayersParameter : public FStaticParameterBase {
    /* 0x0028 */ FMaterialLayersFunctions Value;
};

// Size: 0x3e0
class UStaticMesh : public UStreamableRenderAsset {
    /* 0x0088 */ TArray<FStaticMeshSourceModel> SourceModels;
    /* 0x0098 */ FMeshSectionInfoMap SectionInfoMap;
    /* 0x00e8 */ FMeshSectionInfoMap OriginalSectionInfoMap;
    /* 0x0138 */ FName LODGroup;
    /* 0x0148 */ FPerPlatformInt NumStreamedLODs;
    /* 0x01a0 */ int32_t ImportVersion;
    /* 0x01a8 */ TArray<FMaterialRemapIndex> MaterialRemapIndexPerImportVersion;
    /* 0x01b8 */ int32_t LightmapUVVersion;
    /* 0x01bc */ bool bAutoComputeLODScreenSize;
    /* 0x01c0 */ TArray<UMaterialInterface*> Materials;
    /* 0x01d0 */ FPerPlatformInt MinLOD;
    /* 0x0228 */ float LpvBiasMultiplier;
    /* 0x0230 */ TArray<FStaticMaterial> StaticMaterials;
    /* 0x0240 */ float LightmapUVDensity;
    /* 0x0244 */ int32_t LightMapResolution;
    /* 0x0248 */ int32_t LightMapCoordinateIndex;
    /* 0x024c */ float DistanceFieldSelfShadowBias;
    /* 0x0250 */ UBodySetup* BodySetup;
    /* 0x0258 */ int32_t LODForCollision;
    /* 0x025c */ bool bGenerateMeshDistanceField;
    /* 0x025c */ bool bStripComplexCollisionForConsole;
    /* 0x025c */ bool bHasNavigationData;
    /* 0x025c */ bool bSupportUniformlyDistributedSampling;
    /* 0x025c */ bool bSupportPhysicalMaterialMasks;
    /* 0x025c */ bool bSupportRayTracing;
    /* 0x025c */ bool bIsBuiltAtRuntime;
    /* 0x025d */ bool bAllowCPUAccess;
    /* 0x025d */ bool bSupportGpuUniformlyDistributedSampling;
    /* 0x0270 */ UAssetImportData* AssetImportData;
    /* 0x0278 */ FString SourceFilePath;
    /* 0x0288 */ FString SourceFileTimestamp;
    /* 0x0298 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x02a0 */ FAssetEditorOrbitCameraPosition EditorCameraPosition;
    /* 0x02c8 */ bool bCustomizedCollision;
    /* 0x02cc */ int32_t LODForOccluderMesh;
    /* 0x02e0 */ TArray<UStaticMeshSocket*> Sockets;
    /* 0x0300 */ FVector PositiveBoundsExtension;
    /* 0x030c */ FVector NegativeBoundsExtension;
    /* 0x0318 */ FBoxSphereBounds ExtendedBounds;
    /* 0x0378 */ int32_t ElementToIgnoreForTexFactor;
    /* 0x0380 */ TArray<UAssetUserData*> AssetUserData;
    /* 0x0390 */ UObject* EditableMesh;
    /* 0x0398 */ UStaticMesh* ComplexCollisionMesh;
    /* 0x03a0 */ UNavCollisionBase* NavCollision;

    FName AddMaterial(UMaterialInterface* Material);
    void AddSocket(UStaticMeshSocket* Socket);
    void BuildFromStaticMeshDescriptions(const TArray<UStaticMeshDescription*>& StaticMeshDescriptions, bool bBuildSimpleCollision);
    static UStaticMeshDescription* CreateStaticMeshDescription(UObject* Outer);
    UStaticMeshSocket* FindSocket(FName InSocketName) const;
    FBox GetBoundingBox() const;
    FBoxSphereBounds GetBounds() const;
    UMaterialInterface* GetMaterial(int32_t MaterialIndex) const;
    int32_t GetMaterialIndex(FName MaterialSlotName) const;
    int32_t GetMinimumLODForPlatform(const FName& PlatformName) const;
    void GetMinimumLODForPlatforms(TMap<FName, int32_t>& PlatformMinimumLODs) const;
    int32_t GetNumLODs() const;
    int32_t GetNumSections(int32_t InLOD) const;
    TArray<FStaticMaterial> GetStaticMaterials() const;
    void RemoveSocket(UStaticMeshSocket* Socket);
    void SetMaterial(int32_t MaterialIndex, UMaterialInterface* NewMaterial);
    void SetNumSourceModels(int32_t Num);
    void SetStaticMaterials(const TArray<FStaticMaterial>& InStaticMaterials);
};

// Size: 0x308
class AStaticMeshActor : public AActor {
    /* 0x02f8 */ UStaticMeshComponent* StaticMeshComponent;
    /* 0x0300 */ bool bStaticMeshReplicateMovement;
    /* 0x0301 */ ENavDataGatheringMode NavigationGeometryGatheringMode;

    void SetMobility(uint8_t InMobility);
};

// Size: 0x5d0
class UStaticMeshComponent : public UMeshComponent {
    /* 0x0500 */ int32_t ForcedLodModel;
    /* 0x0504 */ int32_t PreviousLODLevel;
    /* 0x0508 */ int32_t MinLOD;
    /* 0x050c */ int32_t SubDivisionStepSize;
    /* 0x0510 */ UStaticMesh* StaticMesh;
    /* 0x0518 */ FColor WireframeColorOverride;
    /* 0x051c */ bool bEvaluateWorldPositionOffset;
    /* 0x0520 */ int32_t SelectedEditorSection;
    /* 0x0524 */ int32_t SelectedEditorMaterial;
    /* 0x0528 */ int32_t SectionIndexPreview;
    /* 0x052c */ int32_t MaterialIndexPreview;
    /* 0x0530 */ int32_t StaticMeshImportVersion;
    /* 0x0534 */ bool bOverrideWireframeColor;
    /* 0x0534 */ bool bOverrideMinLOD;
    /* 0x0534 */ bool bOverrideNavigationExport;
    /* 0x0534 */ bool bForceNavigationObstacle;
    /* 0x0534 */ bool bDisallowMeshPaintPerInstance;
    /* 0x0534 */ bool bIgnoreInstanceForTextureStreaming;
    /* 0x0535 */ bool bOverrideLightMapRes;
    /* 0x0535 */ bool bCastDistanceFieldIndirectShadow;
    /* 0x0535 */ bool bOverrideDistanceFieldSelfShadowBias;
    /* 0x0535 */ bool bUseSubDivisions;
    /* 0x0535 */ bool bUseDefaultCollision;
    /* 0x0535 */ bool bCustomOverrideVertexColorPerLOD;
    /* 0x0535 */ bool bDisplayVertexColors;
    /* 0x0535 */ bool bDisplayPhysicalMaterialMasks;
    /* 0x0536 */ bool bReverseCulling;
    /* 0x0538 */ int32_t OverriddenLightMapRes;
    /* 0x053c */ float DistanceFieldIndirectShadowMinVisibility;
    /* 0x0540 */ float DistanceFieldSelfShadowBias;
    /* 0x0544 */ float StreamingDistanceMultiplier;
    /* 0x0548 */ TArray<FGuid> IrrelevantLights;
    /* 0x0558 */ TArray<FStaticMeshComponentLODInfo> LODData;
    /* 0x0568 */ TArray<FStreamingTextureBuildInfo> StreamingTextureData;
    /* 0x0578 */ FString StaticMeshDerivedDataKey;
    /* 0x0588 */ TArray<uint32_t> MaterialStreamingRelativeBoxes;
    /* 0x0598 */ FLightmassPrimitiveSettings LightmassSettings;

    void GetLocalBounds(FVector& Min, FVector& Max) const;
    void OnRep_StaticMesh(UStaticMesh* OldStaticMesh);
    void SetDistanceFieldSelfShadowBias(float NewValue);
    void SetEvaluateWorldPositionOffsetInRayTracing(bool NewValue);
    void SetForcedLodModel(int32_t NewForcedLodModel);
    void SetReverseCulling(bool ReverseCulling);
    bool SetStaticMesh(UStaticMesh* NewMesh);
};

// Size: 0x150
struct FStaticMeshComponentInstanceData : public FPrimitiveComponentInstanceData {
    /* 0x0100 */ UStaticMesh* StaticMesh;
    /* 0x0108 */ TArray<FStaticMeshVertexColorLODData> VertexColorLODs;
    /* 0x0118 */ TArray<FGuid> CachedStaticLighting;
    /* 0x0128 */ TArray<FStreamingTextureBuildInfo> StreamingTextureData;
    /* 0x0138 */ TArray<uint32_t> MaterialStreamingRelativeBoxes;
};

// Size: 0x90
struct FStaticMeshComponentLODInfo {
};

// Size: 0x1c
struct FStaticMeshOptimizationSettings {
    /* 0x0000 */ uint8_t ReductionMethod;
    /* 0x0004 */ float NumOfTrianglesPercentage;
    /* 0x0008 */ float MaxDeviationPercentage;
    /* 0x000c */ float WeldingThreshold;
    /* 0x0010 */ bool bRecalcNormals;
    /* 0x0014 */ float NormalsThreshold;
    /* 0x0018 */ uint8_t SilhouetteImportance;
    /* 0x0019 */ uint8_t TextureImportance;
    /* 0x001a */ uint8_t ShadingImportance;
};

// Size: 0x98
class UStaticMeshSocket : public UObject {
    /* 0x0030 */ FName SocketName;
    /* 0x003c */ FVector RelativeLocation;
    /* 0x0048 */ FRotator RelativeRotation;
    /* 0x0054 */ FVector RelativeScale;
    /* 0x0060 */ FString Tag;
    /* 0x0070 */ UStaticMesh* PreviewStaticMesh;
    /* 0x0078 */ bool bSocketCreatedAtImport;
};

// Size: 0xe8
struct FStaticMeshSourceModel {
    /* 0x0020 */ FMeshBuildSettings BuildSettings;
    /* 0x0050 */ FMeshReductionSettings ReductionSettings;
    /* 0x0074 */ float LODDistance;
    /* 0x0078 */ FPerPlatformFloat ScreenSize;
    /* 0x00d0 */ FString SourceImportFilename;
    /* 0x00e0 */ bool bImportWithBaseMesh;
};

// Size: 0x28
struct FStaticMeshVertexColorLODData {
    /* 0x0000 */ TArray<FPaintedVertex> PaintedVertices;
    /* 0x0010 */ TArray<FColor> VertexBufferColors;
    /* 0x0020 */ uint32_t LODIndex;
};

// Size: 0x28
struct FStaticParameterBase {
    /* 0x0000 */ FMaterialParameterInfo ParameterInfo;
    /* 0x0014 */ bool bOverride;
    /* 0x0018 */ FGuid ExpressionGUID;
};

// Size: 0x40
struct FStaticParameterSet {
    /* 0x0000 */ TArray<FStaticSwitchParameter> StaticSwitchParameters;
    /* 0x0010 */ TArray<FStaticComponentMaskParameter> StaticComponentMaskParameters;
    /* 0x0020 */ TArray<FStaticTerrainLayerWeightParameter> TerrainLayerWeightParameters;
    /* 0x0030 */ TArray<FStaticMaterialLayersParameter> MaterialLayersParameters;
};

// Size: 0x2c
struct FStaticSwitchParameter : public FStaticParameterBase {
    /* 0x0028 */ bool Value;
};

// Size: 0x30
struct FStaticTerrainLayerWeightParameter : public FStaticParameterBase {
    /* 0x0028 */ int32_t WeightmapIndex;
    /* 0x002c */ bool bWeightBasedBlend;
};

// Size: 0x310
class UStereoLayerComponent : public USceneComponent {
    /* 0x0228 */ bool bLiveTexture;
    /* 0x0228 */ bool bSupportsDepth;
    /* 0x0228 */ bool bNoAlphaChannel;
    /* 0x0230 */ UTexture* Texture;
    /* 0x0238 */ UTexture* LeftTexture;
    /* 0x0240 */ bool bQuadPreserveTextureRatio;
    /* 0x0244 */ FVector2D QuadSize;
    /* 0x024c */ FBox2D UVRect;
    /* 0x0260 */ float CylinderRadius;
    /* 0x0264 */ float CylinderOverlayArc;
    /* 0x0268 */ int32_t CylinderHeight;
    /* 0x026c */ FEquirectProps EquirectProps;
    /* 0x02b4 */ uint8_t StereoLayerType;
    /* 0x02b5 */ uint8_t StereoLayerShape;
    /* 0x02b8 */ UStereoLayerShape* Shape;
    /* 0x02c0 */ int32_t Priority;

    UTexture* GetLeftTexture() const;
    int32_t GetPriority() const;
    FVector2D GetQuadSize() const;
    UTexture* GetTexture() const;
    FBox2D GetUVRect() const;
    void MarkTextureForUpdate();
    void SetEquirectProps(FEquirectProps InScaleBiases);
    void SetLeftTexture(UTexture* InTexture);
    void SetPriority(int32_t InPriority);
    void SetQuadSize(FVector2D InQuadSize);
    void SetTexture(UTexture* InTexture);
    void SetUVRect(FBox2D InUVRect);
};

// Size: 0x30
class UStereoLayerFunctionLibrary : public UBlueprintFunctionLibrary {

    static void EnableAutoLoadingSplashScreen(bool InAutoShowEnabled);
    static void HideSplashScreen();
    static void SetSplashScreen(UTexture* Texture, FVector2D Scale, FVector Offset, bool bShowLoadingMovie, bool bShowOnSet);
    static void ShowSplashScreen();
};

// Size: 0x30
class UStereoLayerShape : public UObject {
};

// Size: 0x30
class UStereoLayerShapeCubemap : public UStereoLayerShape {
};

// Size: 0x40
class UStereoLayerShapeCylinder : public UStereoLayerShape {
    /* 0x0030 */ float Radius;
    /* 0x0034 */ float OverlayArc;
    /* 0x0038 */ int32_t Height;

    void SetHeight(int32_t InHeight);
    void SetOverlayArc(float InOverlayArc);
    void SetRadius(float InRadius);
};

// Size: 0x78
class UStereoLayerShapeEquirect : public UStereoLayerShape {
    /* 0x0030 */ FBox2D LeftUVRect;
    /* 0x0044 */ FBox2D RightUVRect;
    /* 0x0058 */ FVector2D LeftScale;
    /* 0x0060 */ FVector2D RightScale;
    /* 0x0068 */ FVector2D LeftBias;
    /* 0x0070 */ FVector2D RightBias;

    void SetEquirectProps(FEquirectProps InScaleBiases);
};

// Size: 0x30
class UStereoLayerShapeQuad : public UStereoLayerShape {
};

// Size: 0x68
class UStreamableRenderAsset : public UObject {
    /* 0x0048 */ double ForceMipLevelsToBeResidentTimestamp;
    /* 0x0050 */ int32_t NumCinematicMipLevels;
    /* 0x0054 */ int32_t StreamingIndex;
    /* 0x0058 */ int32_t CachedCombinedLODBias;
    /* 0x005c */ bool NeverStream;
    /* 0x005c */ bool bGlobalForceMipLevelsToBeResident;
    /* 0x005c */ bool bHasStreamingUpdatePending;
    /* 0x005c */ bool bForceMiplevelsToBeResident;
    /* 0x005c */ bool bIgnoreStreamingMipBias;
    /* 0x005c */ bool bUseCinematicMipLevels;
};

// Size: 0x28
struct FStreamableTextureInstance {
};

// Size: 0x38
struct FStreamedAudioPlatformData {
};

// Size: 0x28
struct FStreamingLevelsToConsider {
    /* 0x0000 */ TArray<ULevelStreaming*> StreamingLevels;
};

// Size: 0x30
struct FStreamingRenderAssetPrimitiveInfo {
    /* 0x0000 */ UStreamableRenderAsset* RenderAsset;
    /* 0x0008 */ FBoxSphereBounds Bounds;
    /* 0x0024 */ float TexelFactor;
    /* 0x0028 */ uint32_t PackedRelativeBox;
    /* 0x002c */ bool bAllowInvalidTexelFactorWhenUnregistered;
};

// Size: 0x98
class UStreamingSettings : public UDeveloperSettings {
    /* 0x0060 */ bool AsyncLoadingThreadEnabled;
    /* 0x0060 */ bool WarnIfTimeLimitExceeded;
    /* 0x0064 */ float TimeLimitExceededMultiplier;
    /* 0x0068 */ float TimeLimitExceededMinTime;
    /* 0x006c */ int32_t MinBulkDataSizeForAsyncLoading;
    /* 0x0070 */ bool UseBackgroundLevelStreaming;
    /* 0x0070 */ bool AsyncLoadingUseFullTimeLimit;
    /* 0x0074 */ float AsyncLoadingTimeLimit;
    /* 0x0078 */ float PriorityAsyncLoadingExtraTime;
    /* 0x007c */ float LevelStreamingActorsUpdateTimeLimit;
    /* 0x0080 */ float PriorityLevelStreamingActorsUpdateExtraTime;
    /* 0x0084 */ int32_t LevelStreamingComponentsRegistrationGranularity;
    /* 0x0088 */ float LevelStreamingUnregisterComponentsTimeLimit;
    /* 0x008c */ int32_t LevelStreamingComponentsUnregistrationGranularity;
    /* 0x0090 */ bool FlushStreamingOnExit;
    /* 0x0090 */ bool EventDrivenLoaderEnabled;
};

// Size: 0xc
struct FStreamingTextureBuildInfo {
    /* 0x0000 */ uint32_t PackedRelativeBox;
    /* 0x0004 */ int32_t TextureLevelIndex;
    /* 0x0008 */ float TexelFactor;
};

// Size: 0x88
struct FStringCurve : public FIndexedCurve {
    /* 0x0068 */ FString DefaultValue;
    /* 0x0078 */ TArray<FStringCurveKey> Keys;
};

// Size: 0x18
struct FStringCurveKey {
    /* 0x0000 */ float Time;
    /* 0x0008 */ FString Value;
};

// Size: 0x50
class UStringTable : public UObject {
};

// Size: 0x18
struct FStructRedirect {
    /* 0x0000 */ FName OldStructName;
    /* 0x000c */ FName NewStructName;
};

// Size: 0x28
struct FSubTrackGroup {
    /* 0x0000 */ FString GroupName;
    /* 0x0010 */ TArray<int32_t> TrackIndices;
    /* 0x0020 */ bool bIsCollapsed;
    /* 0x0020 */ bool bIsSelected;
};

// Size: 0x70
class USubUVAnimation : public UObject {
    /* 0x0030 */ UTexture2D* SubUVTexture;
    /* 0x0038 */ int32_t SubImages_Horizontal;
    /* 0x003c */ int32_t SubImages_Vertical;
    /* 0x0040 */ uint8_t BoundingMode;
    /* 0x0041 */ uint8_t OpacitySourceMode;
    /* 0x0044 */ float AlphaThreshold;
};

// Size: 0xc0
class USubsurfaceProfile : public UObject {
    /* 0x0030 */ FSubsurfaceProfileStruct Settings;
};

// Size: 0x8c
struct FSubsurfaceProfileStruct {
    /* 0x0000 */ FLinearColor SurfaceAlbedo;
    /* 0x0010 */ FLinearColor MeanFreePathColor;
    /* 0x0020 */ float MeanFreePathDistance;
    /* 0x0024 */ float WorldUnitScale;
    /* 0x0028 */ bool bEnableBurley;
    /* 0x002c */ float ScatterRadius;
    /* 0x0030 */ FLinearColor SubsurfaceColor;
    /* 0x0040 */ FLinearColor FalloffColor;
    /* 0x0050 */ FLinearColor BoundaryColorBleed;
    /* 0x0060 */ float ExtinctionScale;
    /* 0x0064 */ float NormalScale;
    /* 0x0068 */ float ScatteringDistribution;
    /* 0x006c */ float IOR;
    /* 0x0070 */ float Roughness0;
    /* 0x0074 */ float Roughness1;
    /* 0x0078 */ float LobeMix;
    /* 0x007c */ FLinearColor TransmissionTintColor;
};

// Size: 0x38
class USubsystem : public UObject {
};

// Size: 0x30
class USubsystemBlueprintLibrary : public UBlueprintFunctionLibrary {

    static UEngineSubsystem* GetEngineSubsystem(UClass* Class);
    static UGameInstanceSubsystem* GetGameInstanceSubsystem(UObject* ContextObject, UClass* Class);
    static ULocalPlayerSubsystem* GetLocalPlayerSubSystemFromPlayerController(APlayerController* PlayerController, UClass* Class);
    static ULocalPlayerSubsystem* GetLocalPlayerSubsystem(UObject* ContextObject, UClass* Class);
    static UWorldSubsystem* GetWorldSubsystem(UObject* ContextObject, UClass* Class);
};

// Size: 0x20
struct FSubtitleCue {
    /* 0x0000 */ FText text;
    /* 0x0018 */ float Time;
};

// Size: 0x20
struct FSupportedSubTrackInfo {
    /* 0x0000 */ UClass* SupportedClass;
    /* 0x0008 */ FString SubTrackName;
    /* 0x0018 */ int32_t GroupIndex;
};

// Size: 0x4
struct FSwarmDebugOptions {
    /* 0x0000 */ bool bDistributionEnabled;
    /* 0x0000 */ bool bForceContentExport;
    /* 0x0000 */ bool bInitialized;
};

// Size: 0x48
class USystemTimeTimecodeProvider : public UTimecodeProvider {
    /* 0x0038 */ FFrameRate FrameRate;
    /* 0x0040 */ bool bGenerateFullFrame;
    /* 0x0041 */ bool bUseHighPerformanceClock;
};

// Size: 0x30
struct FTTEventTrack : public FTTTrackBase {
    /* 0x0018 */ FName FunctionName;
    /* 0x0028 */ UCurveFloat* CurveKeys;
};

// Size: 0x30
struct FTTFloatTrack : public FTTPropertyTrack {
    /* 0x0028 */ UCurveFloat* CurveFloat;
};

// Size: 0x30
struct FTTLinearColorTrack : public FTTPropertyTrack {
    /* 0x0028 */ UCurveLinearColor* CurveLinearColor;
};

// Size: 0x28
struct FTTPropertyTrack : public FTTTrackBase {
    /* 0x0018 */ FName PropertyName;
};

// Size: 0x18
struct FTTTrackBase {
    /* 0x0008 */ FName TrackName;
    /* 0x0014 */ bool bIsExternalCurve;
    /* 0x0015 */ bool bIsExpanded;
    /* 0x0016 */ bool bIsCurveViewSynchronized;
};

// Size: 0x8
struct FTTTrackId {
    /* 0x0000 */ int32_t TrackType;
    /* 0x0004 */ int32_t TrackIndex;
};

// Size: 0x30
struct FTTVectorTrack : public FTTPropertyTrack {
    /* 0x0028 */ UCurveVector* CurveVector;
};

// Size: 0x640
struct FTViewTarget {
    /* 0x0000 */ AActor* Target;
    /* 0x0010 */ FMinimalViewInfo POV;
    /* 0x0630 */ APlayerState* PlayerState;
};

// Size: 0x8
struct FTableRowBase {
};

// Size: 0x308
class ATargetPoint : public AActor {
    /* 0x02f8 */ UBillboardComponent* SpriteComponent;
    /* 0x0300 */ UArrowComponent* ArrowComponent;
};

// Size: 0xc
struct FTentDistribution {
    /* 0x0000 */ float TipAltitude;
    /* 0x0004 */ float TipValue;
    /* 0x0008 */ float Width;
};

// Size: 0x78
class UTextPropertyTestObject : public UObject {
    /* 0x0030 */ FText DefaultedText;
    /* 0x0048 */ FText UndefaultedText;
    /* 0x0060 */ FText TransientText;
};

// Size: 0x308
class ATextRenderActor : public AActor {
    /* 0x02f8 */ UTextRenderComponent* TextRender;
    /* 0x0300 */ UBillboardComponent* SpriteComponent;
};

// Size: 0x530
class UTextRenderComponent : public UPrimitiveComponent {
    /* 0x04d8 */ FText text;
    /* 0x04f0 */ UMaterialInterface* TextMaterial;
    /* 0x04f8 */ UFont* Font;
    /* 0x0500 */ uint8_t HorizontalAlignment;
    /* 0x0501 */ uint8_t VerticalAlignment;
    /* 0x0504 */ FColor TextRenderColor;
    /* 0x0508 */ float XScale;
    /* 0x050c */ float YScale;
    /* 0x0510 */ float WorldSize;
    /* 0x0514 */ float InvDefaultSize;
    /* 0x0518 */ float HorizSpacingAdjust;
    /* 0x051c */ float VertSpacingAdjust;
    /* 0x0520 */ bool bAlwaysRenderAsText;

    FVector GetTextLocalSize() const;
    FVector GetTextWorldSize() const;
    void K2_SetText(const FText& Value);
    void SetFont(UFont* Value);
    void SetHorizSpacingAdjust(float Value);
    void SetHorizontalAlignment(uint8_t Value);
    void SetText(FString Value);
    void SetTextMaterial(UMaterialInterface* Material);
    void SetTextRenderColor(FColor Value);
    void SetVertSpacingAdjust(float Value);
    void SetVerticalAlignment(uint8_t Value);
    void SetWorldSize(float Value);
    void SetXScale(float Value);
    void SetYScale(float Value);
};

// Size: 0x28
struct FTextSizingParameters {
    /* 0x0000 */ float DrawX;
    /* 0x0004 */ float DrawY;
    /* 0x0008 */ float DrawXL;
    /* 0x000c */ float DrawYL;
    /* 0x0010 */ FVector2D Scaling;
    /* 0x0018 */ UFont* DrawFont;
    /* 0x0020 */ FVector2D SpacingAdjust;
};

// Size: 0x3a0
class UTexture : public UStreamableRenderAsset {
    /* 0x0070 */ FTextureSource Source;
    /* 0x0168 */ FGuid LightingGuid;
    /* 0x0178 */ FString SourceFilePath;
    /* 0x0188 */ UAssetImportData* AssetImportData;
    /* 0x0190 */ float AdjustBrightness;
    /* 0x0194 */ float AdjustBrightnessCurve;
    /* 0x0198 */ float AdjustVibrance;
    /* 0x019c */ float AdjustSaturation;
    /* 0x01a0 */ float AdjustRGBCurve;
    /* 0x01a4 */ float AdjustHue;
    /* 0x01a8 */ float AdjustMinAlpha;
    /* 0x01ac */ float AdjustMaxAlpha;
    /* 0x01b0 */ bool CompressionNoAlpha;
    /* 0x01b0 */ bool CompressionNone;
    /* 0x01b0 */ bool DeferCompression;
    /* 0x01b4 */ uint8_t LossyCompressionAmount;
    /* 0x01b8 */ int32_t MaxTextureSize;
    /* 0x01bc */ uint8_t CompressionQuality;
    /* 0x01c0 */ bool bDitherMipMapAlpha;
    /* 0x01d0 */ FVector4 AlphaCoverageThresholds;
    /* 0x01e0 */ bool bPreserveBorder;
    /* 0x01e0 */ bool bFlipGreenChannel;
    /* 0x01e0 */ bool bForcePVRTC4;
    /* 0x01e4 */ uint8_t PowerOfTwoMode;
    /* 0x01e8 */ FColor PaddingColor;
    /* 0x01ec */ bool bChromaKeyTexture;
    /* 0x01f0 */ float ChromaKeyThreshold;
    /* 0x01f4 */ FColor ChromaKeyColor;
    /* 0x01f8 */ uint8_t MipGenSettings;
    /* 0x0200 */ UTexture* CompositeTexture;
    /* 0x0208 */ uint8_t CompositeTextureMode;
    /* 0x020c */ float CompositePower;
    /* 0x0210 */ TArray<FTextureFormatSettings> LayerFormatSettings;
    /* 0x0220 */ int32_t LODBias;
    /* 0x0224 */ uint8_t CompressionSettings;
    /* 0x0225 */ uint8_t Filter;
    /* 0x0226 */ ETextureMipLoadOptions MipLoadOptions;
    /* 0x0227 */ uint8_t LODGroup;
    /* 0x0228 */ FPerPlatformFloat Downscale;
    /* 0x0280 */ ETextureDownscaleOptions DownscaleOptions;
    /* 0x0281 */ bool sRGB;
    /* 0x0281 */ bool bUseLegacyGamma;
    /* 0x0281 */ bool bNoTiling;
    /* 0x0281 */ bool VirtualTextureStreaming;
    /* 0x0281 */ bool CompressionYCoCg;
    /* 0x0281 */ bool bNotOfflineProcessed;
    /* 0x0281 */ bool bAsyncResourceReleaseHasBeenStarted;
    /* 0x0288 */ TArray<UAssetUserData*> AssetUserData;
};

// Size: 0x410
class UTexture2D : public UTexture {
    /* 0x0398 */ int32_t LevelIndex;
    /* 0x039c */ int32_t FirstResourceMemMip;
    /* 0x03a0 */ bool bTemporarilyDisableStreaming;
    /* 0x03a0 */ bool bHasBeenPaintedInEditor;
    /* 0x03a1 */ uint8_t AddressX;
    /* 0x03a2 */ uint8_t AddressY;
    /* 0x03a4 */ FIntPoint ImportedSize;

    int32_t Blueprint_GetSizeX() const;
    int32_t Blueprint_GetSizeY() const;
};

// Size: 0x410
class UTexture2DArray : public UTexture {
    /* 0x03f0 */ uint8_t AddressX;
    /* 0x03f1 */ uint8_t AddressY;
    /* 0x03f2 */ uint8_t AddressZ;
    /* 0x03f8 */ TArray<UTexture2D*> SourceTextures;
};

// Size: 0x3b0
class UTexture2DDynamic : public UTexture {
    /* 0x03a0 */ uint8_t Format;
};

enum class TextureAddress {
    TA_Wrap = 0,
    TA_Clamp = 1,
    TA_Mirror = 2,
    TA_MAX = 3,
};

enum class TextureCompressionSettings {
    TC_Default = 0,
    TC_Normalmap = 1,
    TC_Masks = 2,
    TC_Grayscale = 3,
    TC_Displacementmap = 4,
    TC_VectorDisplacementmap = 5,
    TC_HDR = 6,
    TC_EditorIcon = 7,
    TC_Alpha = 8,
    TC_DistanceFieldFont = 9,
    TC_HDR_Compressed = 10,
    TC_BC7 = 11,
    TC_HalfFloat = 12,
    TC_EncodedReflectionCapture = 13,
    TC_MAX = 14,
};

// Size: 0x3f0
class UTextureCube : public UTexture {
};

enum class TextureFilter {
    TF_Nearest = 0,
    TF_Bilinear = 1,
    TF_Trilinear = 2,
    TF_Default = 3,
    TF_MAX = 4,
};

// Size: 0x2
struct FTextureFormatSettings {
    /* 0x0000 */ uint8_t CompressionSettings;
    /* 0x0001 */ bool CompressionNoAlpha;
    /* 0x0001 */ bool CompressionNone;
    /* 0x0001 */ bool CompressionYCoCg;
    /* 0x0001 */ bool sRGB;
};

enum class TextureGroup {
    TEXTUREGROUP_World = 0,
    TEXTUREGROUP_WorldNormalMap = 1,
    TEXTUREGROUP_WorldSpecular = 2,
    TEXTUREGROUP_Character = 3,
    TEXTUREGROUP_CharacterNormalMap = 4,
    TEXTUREGROUP_CharacterSpecular = 5,
    TEXTUREGROUP_Weapon = 6,
    TEXTUREGROUP_WeaponNormalMap = 7,
    TEXTUREGROUP_WeaponSpecular = 8,
    TEXTUREGROUP_Vehicle = 9,
    TEXTUREGROUP_VehicleNormalMap = 10,
    TEXTUREGROUP_VehicleSpecular = 11,
    TEXTUREGROUP_Cinematic = 12,
    TEXTUREGROUP_Effects = 13,
    TEXTUREGROUP_EffectsNotFiltered = 14,
    TEXTUREGROUP_Skybox = 15,
    TEXTUREGROUP_UI = 16,
    TEXTUREGROUP_Lightmap = 17,
    TEXTUREGROUP_RenderTarget = 18,
    TEXTUREGROUP_MobileFlattened = 19,
    TEXTUREGROUP_ProcBuilding_Face = 20,
    TEXTUREGROUP_ProcBuilding_LightMap = 21,
    TEXTUREGROUP_Shadowmap = 22,
    TEXTUREGROUP_ColorLookupTable = 23,
    TEXTUREGROUP_Terrain_Heightmap = 24,
    TEXTUREGROUP_Terrain_Weightmap = 25,
    TEXTUREGROUP_Bokeh = 26,
    TEXTUREGROUP_IESLightProfile = 27,
    TEXTUREGROUP_Pixels2D = 28,
    TEXTUREGROUP_HierarchicalLOD = 29,
    TEXTUREGROUP_Impostor = 30,
    TEXTUREGROUP_ImpostorNormalDepth = 31,
    TEXTUREGROUP_8BitData = 32,
    TEXTUREGROUP_16BitData = 33,
    TEXTUREGROUP_Project01 = 34,
    TEXTUREGROUP_Project02 = 35,
    TEXTUREGROUP_Project03 = 36,
    TEXTUREGROUP_Project04 = 37,
    TEXTUREGROUP_Project05 = 38,
    TEXTUREGROUP_Project06 = 39,
    TEXTUREGROUP_Project07 = 40,
    TEXTUREGROUP_Project08 = 41,
    TEXTUREGROUP_Project09 = 42,
    TEXTUREGROUP_Project10 = 43,
    TEXTUREGROUP_Project11 = 44,
    TEXTUREGROUP_Project12 = 45,
    TEXTUREGROUP_Project13 = 46,
    TEXTUREGROUP_Project14 = 47,
    TEXTUREGROUP_Project15 = 48,
    TEXTUREGROUP_MAX = 49,
};

// Size: 0x70
struct FTextureLODGroup {
    /* 0x0000 */ uint8_t Group;
    /* 0x000c */ int32_t LODBias;
    /* 0x0010 */ int32_t LODBias_Smaller;
    /* 0x0014 */ int32_t LODBias_Smallest;
    /* 0x001c */ int32_t NumStreamedMips;
    /* 0x0020 */ uint8_t MipGenSettings;
    /* 0x0024 */ int32_t MinLODSize;
    /* 0x0028 */ int32_t MaxLODSize;
    /* 0x002c */ int32_t MaxLODSize_Smaller;
    /* 0x0030 */ int32_t MaxLODSize_Smallest;
    /* 0x0034 */ int32_t OptionalLODBias;
    /* 0x0038 */ int32_t OptionalMaxLODSize;
    /* 0x0040 */ FName MinMagFilter;
    /* 0x004c */ FName MipFilter;
    /* 0x0058 */ ETextureMipLoadOptions MipLoadOptions;
    /* 0x0059 */ bool HighPriorityLoad;
    /* 0x005a */ bool DuplicateNonOptionalMips;
    /* 0x005c */ float Downscale;
    /* 0x0060 */ ETextureDownscaleOptions DownscaleOptions;
    /* 0x0064 */ int32_t VirtualTextureTileCountBias;
    /* 0x0068 */ int32_t VirtualTextureTileSizeBias;
    /* 0x006c */ uint8_t LossyCompressionAmount;
};

// Size: 0x40
class UTextureLODSettings : public UObject {
    /* 0x0030 */ TArray<FTextureLODGroup> TextureLODGroups;
};

// Size: 0x420
class UTextureLightProfile : public UTexture2D {
    /* 0x0410 */ float Brightness;
    /* 0x0414 */ float TextureMultiplier;
};

// Size: 0x30
class UTextureMipDataProviderFactory : public UAssetUserData {
};

enum class TextureMipGenSettings {
    TMGS_FromTextureGroup = 0,
    TMGS_SimpleAverage = 1,
    TMGS_Sharpen0 = 2,
    TMGS_Sharpen1 = 3,
    TMGS_Sharpen2 = 4,
    TMGS_Sharpen3 = 5,
    TMGS_Sharpen4 = 6,
    TMGS_Sharpen5 = 7,
    TMGS_Sharpen6 = 8,
    TMGS_Sharpen7 = 9,
    TMGS_Sharpen8 = 10,
    TMGS_Sharpen9 = 11,
    TMGS_Sharpen10 = 12,
    TMGS_NoMipmaps = 13,
    TMGS_LeaveExistingMips = 14,
    TMGS_Blur1 = 15,
    TMGS_Blur2 = 16,
    TMGS_Blur3 = 17,
    TMGS_Blur4 = 18,
    TMGS_Blur5 = 19,
    TMGS_Unfiltered = 20,
    TMGS_MAX = 21,
};

// Size: 0x38
struct FTextureParameterValue {
    /* 0x0000 */ FName ParameterName;
    /* 0x000c */ FMaterialParameterInfo ParameterInfo;
    /* 0x0020 */ UTexture* ParameterValue;
    /* 0x0028 */ FGuid ExpressionGUID;
};

// Size: 0x48
struct FTexturePlatformData {
};

// Size: 0x3a0
class UTextureRenderTarget : public UTexture {
    /* 0x0398 */ float TargetGamma;
};

// Size: 0x3d0
class UTextureRenderTarget2D : public UTextureRenderTarget {
    /* 0x03a0 */ int32_t SizeX;
    /* 0x03a4 */ int32_t SizeY;
    /* 0x03a8 */ FLinearColor ClearColor;
    /* 0x03b8 */ uint8_t AddressX;
    /* 0x03b9 */ uint8_t AddressY;
    /* 0x03ba */ bool bForceLinearGamma;
    /* 0x03ba */ bool bHDR;
    /* 0x03ba */ bool bGPUSharedFlag;
    /* 0x03bb */ uint8_t RenderTargetFormat;
    /* 0x03bc */ bool bAutoGenerateMips;
    /* 0x03bd */ uint8_t MipsSamplerFilter;
    /* 0x03be */ uint8_t MipsAddressU;
    /* 0x03bf */ uint8_t MipsAddressV;
    /* 0x03c0 */ uint8_t OverrideFormat;
};

// Size: 0x3c0
class UTextureRenderTarget2DArray : public UTextureRenderTarget {
    /* 0x03a0 */ int32_t SizeX;
    /* 0x03a4 */ int32_t SizeY;
    /* 0x03a8 */ int32_t Slices;
    /* 0x03ac */ FLinearColor ClearColor;
    /* 0x03bc */ uint8_t OverrideFormat;
    /* 0x03bd */ bool bHDR;
    /* 0x03bd */ bool bForceLinearGamma;
};

// Size: 0x3c0
class UTextureRenderTargetCube : public UTextureRenderTarget {
    /* 0x03a0 */ int32_t SizeX;
    /* 0x03a4 */ FLinearColor ClearColor;
    /* 0x03b4 */ uint8_t OverrideFormat;
    /* 0x03b5 */ bool bHDR;
    /* 0x03b5 */ bool bForceLinearGamma;
};

// Size: 0x3c0
class UTextureRenderTargetVolume : public UTextureRenderTarget {
    /* 0x03a0 */ int32_t SizeX;
    /* 0x03a4 */ int32_t SizeY;
    /* 0x03a8 */ int32_t SizeZ;
    /* 0x03ac */ FLinearColor ClearColor;
    /* 0x03bc */ uint8_t OverrideFormat;
    /* 0x03bd */ bool bHDR;
    /* 0x03bd */ bool bForceLinearGamma;
};

// Size: 0xf8
struct FTextureSource {
    /* 0x00a8 */ FGuid ID;
    /* 0x00b8 */ int32_t BaseBlockX;
    /* 0x00bc */ int32_t BaseBlockY;
    /* 0x00c0 */ int32_t SizeX;
    /* 0x00c4 */ int32_t SizeY;
    /* 0x00c8 */ int32_t NumSlices;
    /* 0x00cc */ int32_t NumMips;
    /* 0x00d0 */ int32_t NumLayers;
    /* 0x00d4 */ bool bPNGCompressed;
    /* 0x00d5 */ bool bGuidIsHash;
    /* 0x00d6 */ uint8_t Format;
    /* 0x00d8 */ TArray<uint8_t> LayerFormat;
    /* 0x00e8 */ TArray<FTextureSourceBlock> Blocks;
};

// Size: 0x18
struct FTextureSourceBlock {
    /* 0x0000 */ int32_t BlockX;
    /* 0x0004 */ int32_t BlockY;
    /* 0x0008 */ int32_t SizeX;
    /* 0x000c */ int32_t SizeY;
    /* 0x0010 */ int32_t NumSlices;
    /* 0x0014 */ int32_t NumMips;
};

// Size: 0x30
class UThumbnailInfo : public UObject {
};

// Size: 0x28
struct FTickFunction {
    /* 0x0008 */ uint8_t TickGroup;
    /* 0x0009 */ uint8_t EndTickGroup;
    /* 0x000a */ bool bTickEvenWhenPaused;
    /* 0x000a */ bool bCanEverTick;
    /* 0x000a */ bool bStartWithTickEnabled;
    /* 0x000a */ bool bAllowTickOnDedicatedServer;
    /* 0x000c */ float TickInterval;
};

// Size: 0x10
struct FTickPrerequisite {
};

// Size: 0x48
class UTickableWorldSubsystem : public UWorldSubsystem {
};

// Size: 0x28
struct FTimeStretchCurve {
    /* 0x0000 */ float SamplingRate;
    /* 0x0004 */ float CurveValueMinPrecision;
    /* 0x0008 */ TArray<FTimeStretchCurveMarker> Markers;
    /* 0x0018 */ float Sum_dT_i_by_C_i[3];
};

// Size: 0x30
struct FTimeStretchCurveInstance {
    /* 0x0000 */ bool bHasValidData;
};

// Size: 0x10
struct FTimeStretchCurveMarker {
    /* 0x0000 */ float Time[3];
    /* 0x000c */ float Alpha;
};

// Size: 0x38
class UTimecodeProvider : public UObject {
    /* 0x0030 */ float FrameDelay;

    void FetchAndUpdate();
    bool FetchTimecode(FQualifiedFrameTime& OutFrameTime);
    FQualifiedFrameTime GetDelayedQualifiedFrameTime() const;
    FTimecode GetDelayedTimecode() const;
    FFrameRate GetFrameRate() const;
    FQualifiedFrameTime GetQualifiedFrameTime() const;
    ETimecodeProviderSynchronizationState GetSynchronizationState() const;
    FTimecode GetTimecode() const;
};

// Size: 0xa8
struct FTimeline {
    /* 0x0000 */ uint8_t LengthMode;
    /* 0x0001 */ bool bLooping;
    /* 0x0001 */ bool bReversePlayback;
    /* 0x0001 */ bool bPlaying;
    /* 0x0004 */ float Length;
    /* 0x0008 */ float PlayRate;
    /* 0x000c */ float Position;
    /* 0x0010 */ TArray<FTimelineEventEntry> Events;
    /* 0x0020 */ TArray<FTimelineVectorTrack> InterpVectors;
    /* 0x0030 */ TArray<FTimelineFloatTrack> InterpFloats;
    /* 0x0040 */ TArray<FTimelineLinearColorTrack> InterpLinearColors;
    /* 0x0050 */ FDelegate TimelinePostUpdateFunc;
    /* 0x0064 */ FDelegate TimelineFinishedFunc;
    /* 0x0078 */ TWeakObjectPtr<UObject> PropertySetObject;
    /* 0x0080 */ FName DirectionPropertyName;
};

// Size: 0x170
class UTimelineComponent : public UActorComponent {
    /* 0x00c0 */ FTimeline TheTimeline;
    /* 0x0168 */ bool bIgnoreTimeDilation;

    bool GetIgnoreTimeDilation() const;
    float GetPlayRate() const;
    float GetPlaybackPosition() const;
    float GetTimelineLength() const;
    bool IsLooping() const;
    bool IsPlaying() const;
    bool IsReversing() const;
    void OnRep_Timeline();
    void Play();
    void PlayFromStart();
    void Reverse();
    void ReverseFromEnd();
    void SetFloatCurve(UCurveFloat* NewFloatCurve, FName FloatTrackName);
    void SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation);
    void SetLinearColorCurve(UCurveLinearColor* NewLinearColorCurve, FName LinearColorTrackName);
    void SetLooping(bool bNewLooping);
    void SetNewTime(float NewTime);
    void SetPlayRate(float NewRate);
    void SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate);
    void SetTimelineLength(float NewLength);
    void SetTimelineLengthMode(uint8_t NewLengthMode);
    void SetVectorCurve(UCurveVector* NewVectorCurve, FName VectorTrackName);
    void Stop();
};

// Size: 0x18
struct FTimelineEventEntry {
    /* 0x0000 */ float Time;
    /* 0x0004 */ FDelegate EventFunc;
};

// Size: 0x50
struct FTimelineFloatTrack {
    /* 0x0000 */ UCurveFloat* FloatCurve;
    /* 0x0008 */ FDelegate InterpFunc;
    /* 0x001c */ FName TrackName;
    /* 0x0028 */ FName FloatPropertyName;
};

// Size: 0x50
struct FTimelineLinearColorTrack {
    /* 0x0000 */ UCurveLinearColor* LinearColorCurve;
    /* 0x0008 */ FDelegate InterpFunc;
    /* 0x001c */ FName TrackName;
    /* 0x0028 */ FName LinearColorPropertyName;
};

// Size: 0xe0
class UTimelineTemplate : public UObject {
    /* 0x0030 */ float TimelineLength;
    /* 0x0034 */ uint8_t LengthMode;
    /* 0x0035 */ bool bAutoPlay;
    /* 0x0035 */ bool bLoop;
    /* 0x0035 */ bool bReplicated;
    /* 0x0035 */ bool bIgnoreTimeDilation;
    /* 0x0038 */ TArray<FTTEventTrack> EventTracks;
    /* 0x0048 */ TArray<FTTFloatTrack> FloatTracks;
    /* 0x0058 */ TArray<FTTVectorTrack> VectorTracks;
    /* 0x0068 */ TArray<FTTLinearColorTrack> LinearColorTracks;
    /* 0x0078 */ TArray<FBPVariableMetaDataEntry> MetaDataArray;
    /* 0x0088 */ FGuid TimelineGuid;
    /* 0x0098 */ uint8_t TimelineTickGroup;
    /* 0x009c */ FName VariableName;
    /* 0x00a8 */ FName DirectionPropertyName;
    /* 0x00b4 */ FName UpdateFunctionName;
    /* 0x00c0 */ FName FinishedFunctionName;
    /* 0x00d0 */ TArray<FTTTrackId> TrackDisplayOrder;
};

// Size: 0x50
struct FTimelineVectorTrack {
    /* 0x0000 */ UCurveVector* VectorCurve;
    /* 0x0008 */ FDelegate InterpFunc;
    /* 0x001c */ FName TrackName;
    /* 0x0028 */ FName VectorPropertyName;
};

// Size: 0x8
struct FTimerHandle {
    /* 0x0000 */ uint64_t Handle;
};

// Size: 0x40
class UTireType : public UDataAsset {
    /* 0x0038 */ float FrictionScale;
};

// Size: 0x8
struct FToggleTrackKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ uint8_t ToggleAction;
};

// Size: 0x78
struct FTouchInputControl {
    /* 0x0000 */ UTexture2D* Image1;
    /* 0x0008 */ UTexture2D* Image2;
    /* 0x0010 */ FVector2D Center;
    /* 0x0018 */ FVector2D VisualSize;
    /* 0x0020 */ FVector2D ThumbSize;
    /* 0x0028 */ FVector2D InteractionSize;
    /* 0x0030 */ FVector2D InputScale;
    /* 0x0038 */ FKey MainInputKey;
    /* 0x0058 */ FKey AltInputKey;
};

// Size: 0x60
class UTouchInterface : public UObject {
    /* 0x0030 */ TArray<FTouchInputControl> Controls;
    /* 0x0040 */ float ActiveOpacity;
    /* 0x0044 */ float InactiveOpacity;
    /* 0x0048 */ float TimeUntilDeactive;
    /* 0x004c */ float TimeUntilReset;
    /* 0x0050 */ float ActivationDelay;
    /* 0x0054 */ bool bPreventRecenter;
    /* 0x0058 */ float StartupDelay;
};

// Size: 0x4
struct FTrackToSkeletonMap {
    /* 0x0000 */ int32_t BoneTreeIndex;
};

// Size: 0x30
struct FTransformBase {
    /* 0x0000 */ FName Node;
    /* 0x0010 */ FTransformBaseConstraint Constraints[2];
};

// Size: 0x10
struct FTransformBaseConstraint {
    /* 0x0000 */ TArray<FRigTransformConstraint> TransformConstraints;
};

// Size: 0x540
struct FTransformCurve : public FAnimCurveBase {
    /* 0x0030 */ FVectorCurve TranslationCurve;
    /* 0x01e0 */ FVectorCurve RotationCurve;
    /* 0x0390 */ FVectorCurve ScaleCurve;
};

// Size: 0x20
struct FTranslationTrack {
    /* 0x0000 */ TArray<FVector> PosKeys;
    /* 0x0010 */ TArray<float> Times;
};

// Size: 0x308
class ATriggerBase : public AActor {
    /* 0x02f8 */ UShapeComponent* CollisionComponent;
    /* 0x0300 */ UBillboardComponent* SpriteComponent;
};

// Size: 0x308
class ATriggerBox : public ATriggerBase {
};

// Size: 0x308
class ATriggerCapsule : public ATriggerBase {
};

// Size: 0x308
class ATriggerSphere : public ATriggerBase {
};

// Size: 0x338
class ATriggerVolume : public AVolume {
};

// Size: 0x1c
struct FTwistConstraint : public FConstraintBaseParams {
    /* 0x0014 */ float TwistLimitDegrees;
    /* 0x0018 */ uint8_t TwistMotion;
};

// Size: 0x40
class UTwitterIntegrationBase : public UPlatformInterfaceBase {

    bool AuthorizeAccounts();
    bool CanShowTweetUI();
    FString GetAccountName(int32_t AccountIndex);
    int32_t GetNumAccounts();
    void Init();
    bool ShowTweetUI(FString InitialMessage, FString URL, FString Picture);
    bool TwitterRequest(FString URL, const TArray<FString>& ParamKeysAndValues, uint8_t RequestMethod, int32_t AccountIndex);
};

// Size: 0x68
struct FURL {
    /* 0x0000 */ FString Protocol;
    /* 0x0010 */ FString Host;
    /* 0x0020 */ int32_t Port;
    /* 0x0024 */ int32_t Valid;
    /* 0x0028 */ FString Map;
    /* 0x0038 */ FString RedirectURL;
    /* 0x0048 */ TArray<FString> Op;
    /* 0x0058 */ FString Portal;
};

// Size: 0x28
struct FUniqueNetIdRepl : public FUniqueNetIdWrapper {
    /* 0x0018 */ TArray<uint8_t> ReplicationBytes;
};

// Size: 0x14
struct FUpdateLevelStreamingLevelStatus {
    /* 0x0000 */ FName PackageName;
    /* 0x000c */ int32_t LODIndex;
    /* 0x0010 */ bool bNewShouldBeLoaded;
    /* 0x0011 */ bool bNewShouldBeVisible;
    /* 0x0012 */ bool bNewShouldBlockOnLoad;
};

// Size: 0x1c
struct FUpdateLevelVisibilityLevelInfo {
    /* 0x0000 */ FName PackageName;
    /* 0x000c */ FName Filename;
    /* 0x0018 */ bool bIsVisible;
};

// Size: 0x18
struct FUserActivity {
    /* 0x0000 */ FString ActionName;
};

// Size: 0xd8
class UUserDefinedEnum : public UEnum {
    /* 0x0068 */ uint32_t UniqueNameIndex;
    /* 0x0070 */ FText EnumDescription;
    /* 0x0088 */ TMap<FName, FText> DisplayNameMap;
};

// Size: 0x138
class UUserDefinedStruct : public UScriptStruct {
    /* 0x00d0 */ TWeakObjectPtr<UUserDefinedStruct> PrimaryStruct;
    /* 0x00d8 */ FString ErrorMessage;
    /* 0x00e8 */ UObject* EditorData;
    /* 0x00f0 */ uint8_t Status;
    /* 0x00f4 */ FGuid Guid;
};

// Size: 0x2d8
class UUserInterfaceSettings : public UDeveloperSettings {
    /* 0x0060 */ ERenderFocusRule RenderFocusRule;
    /* 0x0068 */ TMap<uint8_t, FHardwareCursorReference> HardwareCursors;
    /* 0x00b8 */ TMap<uint8_t, FSoftClassPath> SoftwareCursors;
    /* 0x0108 */ FSoftClassPath DefaultCursor;
    /* 0x0128 */ FSoftClassPath TextEditBeamCursor;
    /* 0x0148 */ FSoftClassPath CrosshairsCursor;
    /* 0x0168 */ FSoftClassPath HandCursor;
    /* 0x0188 */ FSoftClassPath GrabHandCursor;
    /* 0x01a8 */ FSoftClassPath GrabHandClosedCursor;
    /* 0x01c8 */ FSoftClassPath SlashedCircleCursor;
    /* 0x01e8 */ float ApplicationScale;
    /* 0x01ec */ EUIScalingRule UIScaleRule;
    /* 0x01f0 */ FSoftClassPath CustomScalingRuleClass;
    /* 0x0210 */ FRuntimeFloatCurve UIScaleCurve;
    /* 0x0298 */ bool bAllowHighDPIInGameMode;
    /* 0x029c */ FIntPoint DesignScreenSize;
    /* 0x02a4 */ bool bLoadWidgetsOnDedicatedServer;
    /* 0x02a8 */ TArray<UObject*> CursorClasses;
    /* 0x02b8 */ UClass* CustomScalingRuleClassInstance;
    /* 0x02c0 */ UDPICustomScalingRule* CustomScalingRule;
};

// Size: 0x30
class UVOIPStatics : public UBlueprintFunctionLibrary {

    static void SetMicThreshold(float InThreshold);
};

// Size: 0xf8
class UVOIPTalker : public UActorComponent {
    /* 0x00c0 */ FVoiceSettings Settings;

    void BPOnTalkingBegin(UAudioComponent* AudioComponent);
    void BPOnTalkingEnd();
    static UVOIPTalker* CreateTalkerForPlayer(APlayerState* OwningState);
    float GetVoiceLevel();
    void RegisterWithPlayerState(APlayerState* OwningState);
};

// Size: 0x48
struct FVector2MaterialInput : public Fmaterialinput {
    /* 0x0038 */ bool UseConstant;
    /* 0x003c */ float ConstantX;
    /* 0x0040 */ float ConstantY;
};

// Size: 0x20
struct FVector4Distribution {
    /* 0x0000 */ FDistributionLookupTable Table;
};

// Size: 0x1b0
struct FVectorCurve : public FAnimCurveBase {
    /* 0x0030 */ FRichCurve FloatCurves[3];
};

// Size: 0x20
struct FVectorDistribution {
    /* 0x0000 */ FDistributionLookupTable Table;
};

// Size: 0x50
class UVectorField : public UObject {
    /* 0x0030 */ FBox Bounds;
    /* 0x004c */ float Intensity;
};

// Size: 0x90
class UVectorFieldAnimated : public UVectorField {
    /* 0x0050 */ UTexture2D* Texture;
    /* 0x0058 */ uint8_t ConstructionOp;
    /* 0x005c */ int32_t VolumeSizeX;
    /* 0x0060 */ int32_t VolumeSizeY;
    /* 0x0064 */ int32_t VolumeSizeZ;
    /* 0x0068 */ int32_t SubImagesX;
    /* 0x006c */ int32_t SubImagesY;
    /* 0x0070 */ int32_t FrameCount;
    /* 0x0074 */ float FramesPerSecond;
    /* 0x0078 */ bool bLoop;
    /* 0x0080 */ UVectorFieldStatic* NoiseField;
    /* 0x0088 */ float NoiseScale;
    /* 0x008c */ float NoiseMax;
};

// Size: 0x500
class UVectorFieldComponent : public UPrimitiveComponent {
    /* 0x04d8 */ UVectorField* VectorField;
    /* 0x04e0 */ float Intensity;
    /* 0x04e4 */ float Tightness;
    /* 0x04e8 */ bool bPreviewVectorField;

    void SetIntensity(float NewIntensity);
};

// Size: 0x128
class UVectorFieldStatic : public UVectorField {
    /* 0x0050 */ int32_t SizeX;
    /* 0x0054 */ int32_t SizeY;
    /* 0x0058 */ int32_t SizeZ;
    /* 0x005c */ bool bAllowCPUAccess;
    /* 0x0100 */ FString SourceFilePath;
    /* 0x0110 */ UAssetImportData* AssetImportData;
};

// Size: 0x308
class AVectorFieldVolume : public AActor {
    /* 0x02f8 */ UVectorFieldComponent* VectorFieldComponent;
    /* 0x0300 */ UBillboardComponent* SpriteComponent;
};

// Size: 0x48
struct FVectorMaterialInput : public Fmaterialinput {
    /* 0x0038 */ bool UseConstant;
    /* 0x003c */ FVector Constant;
};

// Size: 0x40
struct FVectorParameterValue {
    /* 0x0000 */ FName ParameterName;
    /* 0x000c */ FMaterialParameterInfo ParameterInfo;
    /* 0x0020 */ FLinearColor ParameterValue;
    /* 0x0030 */ FGuid ExpressionGUID;
};

// Size: 0x8
struct FVectorRK4SpringInterpolator {
    /* 0x0000 */ float StiffnessConstant;
    /* 0x0004 */ float DampeningRatio;
};

// Size: 0x18
struct FVectorSpringState {
};

// Size: 0xc
struct FVector_NetQuantize : public FVector {
};

// Size: 0xc
struct FVector_NetQuantize10 : public FVector {
};

// Size: 0xc
struct FVector_NetQuantize100 : public FVector {
};

// Size: 0xc
struct FVector_NetQuantizeNormal : public FVector {
};

// Size: 0x4
struct FVertexOffsetUsage {
    /* 0x0000 */ int32_t Usage;
};

// Size: 0x30
class UViewModeUtils : public UObject {
};

// Size: 0x10
struct FViewTargetTransitionParams {
    /* 0x0000 */ float BlendTime;
    /* 0x0004 */ uint8_t BlendFunction;
    /* 0x0008 */ float BlendExp;
    /* 0x000c */ bool bLockOutgoing;
};

// Size: 0x58
class UViewportStatsSubsystem : public UWorldSubsystem {

    int32_t AddDisplayDelegate(const FDelegate& delegate);
    void AddTimedDisplay(FText text, FLinearColor Color, float Duration);
    void RemoveDisplayDelegate(const int32_t IndexToRemove);
};

// Size: 0x24
struct FVirtualBone {
    /* 0x0000 */ FName SourceBoneName;
    /* 0x000c */ FName TargetBoneName;
    /* 0x0018 */ FName VirtualBoneName;
};

// Size: 0x30
class UVirtualTexture : public UObject {
};

// Size: 0x420
class UVirtualTexture2D : public UTexture2D {
    /* 0x0410 */ FVirtualTextureBuildSettings Settings;
    /* 0x041c */ bool bContinuousUpdate;
    /* 0x041d */ bool bSinglePhysicalSpace;
};

// Size: 0xc
struct FVirtualTextureBuildSettings {
    /* 0x0000 */ int32_t TileSize;
    /* 0x0004 */ int32_t TileBorderSize;
    /* 0x0008 */ bool bEnableCompressCrunch;
    /* 0x0009 */ bool bEnableCompressZlib;
};

// Size: 0x40
class UVirtualTextureBuilder : public UObject {
    /* 0x0030 */ UVirtualTexture2D* Texture;
    /* 0x0038 */ uint64_t BuildHash;
};

// Size: 0x48
class UVirtualTexturePoolConfig : public UObject {
    /* 0x0030 */ int32_t DefaultSizeInMegabyte;
    /* 0x0038 */ TArray<FVirtualTextureSpacePoolConfig> Pools;
};

// Size: 0x28
struct FVirtualTextureSpacePoolConfig {
    /* 0x0000 */ int32_t MinTileSize;
    /* 0x0004 */ int32_t MaxTileSize;
    /* 0x0008 */ TArray<uint8_t> Formats;
    /* 0x0018 */ int32_t SizeInMegabyte;
    /* 0x001c */ bool bAllowSizeScale;
    /* 0x0020 */ uint32_t ScalabilityGroup;
};

// Size: 0x8
struct FVisibilityTrackKey {
    /* 0x0000 */ float Time;
    /* 0x0004 */ uint8_t Action;
    /* 0x0005 */ uint8_t ActiveCondition;
};

// Size: 0x30
class UVisualLoggerAutomationTests : public UObject {
};

// Size: 0x30
class IVisualLoggerDebugSnapshotInterface : public UInterface {
};

// Size: 0x30
class UVisualLoggerKismetLibrary : public UBlueprintFunctionLibrary {

    static void EnableRecording(bool bEnabled);
    static void LogBox(UObject* WorldContextObject, FBox BoxShape, FString text, FLinearColor ObjectColor, FName LogCategory, bool bAddToMessageLog);
    static void LogLocation(UObject* WorldContextObject, FVector Location, FString text, FLinearColor ObjectColor, float Radius, FName LogCategory, bool bAddToMessageLog);
    static void LogSegment(UObject* WorldContextObject, const FVector SegmentStart, const FVector SegmentEnd, FString text, FLinearColor ObjectColor, const float Thickness, FName CategoryName, bool bAddToMessageLog);
    static void LogText(UObject* WorldContextObject, FString text, FName LogCategory, bool bAddToMessageLog);
    static void RedirectVislog(UObject* SourceOwner, UObject* DestinationOwner);
};

// Size: 0x88
class UVoiceChannel : public UChannel {
};

// Size: 0x18
struct FVoiceSettings {
    /* 0x0000 */ USceneComponent* ComponentToAttachTo;
    /* 0x0008 */ USoundAttenuation* AttenuationSettings;
    /* 0x0010 */ USoundEffectSourcePresetChain* SourceEffectChain;
};

// Size: 0x338
class AVolume : public ABrush {
};

// Size: 0x410
class UVolumeTexture : public UTexture {
    /* 0x03f0 */ UTexture2D* Source2DTexture;
    /* 0x03f8 */ FGuid SourceLightingGuid;
    /* 0x0408 */ int32_t Source2DTileSizeX;
    /* 0x040c */ int32_t Source2DTileSizeY;
};

// Size: 0x308
class AVolumetricCloud : public AInfo {
    /* 0x0300 */ UVolumetricCloudComponent* VolumetricCloudComponent;
};

// Size: 0x270
class UVolumetricCloudComponent : public USceneComponent {
    /* 0x0228 */ float LayerBottomAltitude;
    /* 0x022c */ float LayerHeight;
    /* 0x0230 */ float TracingStartMaxDistance;
    /* 0x0234 */ float TracingMaxDistance;
    /* 0x0238 */ float PlanetRadius;
    /* 0x023c */ FColor GroundAlbedo;
    /* 0x0240 */ UMaterialInterface* Material;
    /* 0x0248 */ bool bUsePerSampleAtmosphericLightTransmittance;
    /* 0x024c */ float SkyLightCloudBottomOcclusion;
    /* 0x0250 */ float ViewSampleCountScale;
    /* 0x0254 */ float ReflectionSampleCountScale;
    /* 0x0258 */ float ShadowViewSampleCountScale;
    /* 0x025c */ float ShadowReflectionSampleCountScale;
    /* 0x0260 */ float ShadowTracingDistance;
    /* 0x0264 */ float StopTracingTransmittanceThreshold;

    void SetGroundAlbedo(FColor NewValue);
    void SetLayerBottomAltitude(float NewValue);
    void SetLayerHeight(float NewValue);
    void SetMaterial(UMaterialInterface* NewValue);
    void SetPlanetRadius(float NewValue);
    void SetReflectionSampleCountScale(float NewValue);
    void SetShadowReflectionSampleCountScale(float NewValue);
    void SetShadowTracingDistance(float NewValue);
    void SetShadowViewSampleCountScale(float NewValue);
    void SetSkyLightCloudBottomOcclusion(float NewValue);
    void SetStopTracingTransmittanceThreshold(float NewValue);
    void SetTracingMaxDistance(float NewValue);
    void SetTracingStartMaxDistance(float NewValue);
    void SetViewSampleCountScale(float NewValue);
    void SetbUsePerSampleAtmosphericLightTransmittance(bool NewValue);
};

// Size: 0x340
class AVolumetricLightmapDensityVolume : public AVolume {
    /* 0x0338 */ FInt32Interval AllowedMipLevelRange;
};

// Size: 0x10
struct FWalkableSlopeOverride {
    /* 0x0000 */ uint8_t WalkableSlopeBehavior;
    /* 0x0004 */ float WalkableSlopeAngle;
};

// Size: 0x10
struct FWeightedBlendable {
    /* 0x0000 */ float Weight;
    /* 0x0008 */ UObject* Object;
};

// Size: 0x10
struct FWeightedBlendables {
    /* 0x0000 */ TArray<FWeightedBlendable> Array;
};

// Size: 0x310
class AWindDirectionalSource : public AInfo {
    /* 0x0300 */ UWindDirectionalSourceComponent* Component;
    /* 0x0308 */ UArrowComponent* ArrowComponent;
};

// Size: 0x250
class UWindDirectionalSourceComponent : public USceneComponent {
    /* 0x0228 */ float Strength;
    /* 0x022c */ float Speed;
    /* 0x0230 */ float MinGustAmount;
    /* 0x0234 */ float MaxGustAmount;
    /* 0x0238 */ float Radius;
    /* 0x023c */ bool bPointWind;

    void SetMaximumGustAmount(float InNewMaxGust);
    void SetMinimumGustAmount(float InNewMinGust);
    void SetRadius(float InNewRadius);
    void SetSpeed(float InNewSpeed);
    void SetStrength(float InNewStrength);
    void SetWindType(EWindSourceType InNewType);
};

// Size: 0x8c0
class UWorld : public UObject {
    /* 0x0038 */ TArray<ULayer*> Layers;
    /* 0x0048 */ TArray<AActor*> ActiveGroupActors;
    /* 0x0058 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x0060 */ ULevel* PersistentLevel;
    /* 0x0068 */ UNetDriver* NetDriver;
    /* 0x0070 */ ULineBatchComponent* LineBatcher;
    /* 0x0078 */ ULineBatchComponent* PersistentLineBatcher;
    /* 0x0080 */ ULineBatchComponent* ForegroundLineBatcher;
    /* 0x0088 */ AGameNetworkManager* NetworkManager;
    /* 0x0090 */ UPhysicsCollisionHandler* PhysicsCollisionHandler;
    /* 0x0098 */ TArray<UObject*> ExtraReferencedObjects;
    /* 0x00a8 */ TArray<UObject*> PerModuleDataObjects;
    /* 0x00b8 */ TArray<ULevelStreaming*> StreamingLevels;
    /* 0x00c8 */ FStreamingLevelsToConsider StreamingLevelsToConsider;
    /* 0x00f0 */ FString StreamingLevelsPrefix;
    /* 0x0100 */ ULevel* CurrentLevelPendingVisibility;
    /* 0x0108 */ ULevel* CurrentLevelPendingInvisibility;
    /* 0x0110 */ UDemoNetDriver* DemoNetDriver;
    /* 0x0118 */ AParticleEventManager* MyParticleEventManager;
    /* 0x0120 */ APhysicsVolume* DefaultPhysicsVolume;
    /* 0x013e */ bool bAreConstraintsDirty;
    /* 0x0140 */ UNavigationSystemBase* NavigationSystem;
    /* 0x0148 */ AGameModeBase* AuthorityGameMode;
    /* 0x0150 */ AGameStateBase* GameState;
    /* 0x0158 */ UAISystemBase* AISystem;
    /* 0x0160 */ UAvoidanceManager* AvoidanceManager;
    /* 0x0168 */ TArray<ULevel*> Levels;
    /* 0x0178 */ TArray<FLevelCollection> LevelCollections;
    /* 0x01b8 */ ULevel* CurrentLevel;
    /* 0x01c0 */ UGameInstance* OwningGameInstance;
    /* 0x01c8 */ TArray<UMaterialParameterCollectionInstance*> ParameterCollectionInstances;
    /* 0x01d8 */ UCanvas* CanvasForRenderingToTarget;
    /* 0x01e0 */ UCanvas* CanvasForDrawMaterialToRenderTarget;
    /* 0x01f0 */ TArray<FLevelViewportInfo> EditorViews;
    /* 0x0248 */ UPhysicsFieldComponent* PhysicsField;
    /* 0x0250 */ TSet<UActorComponent*> ComponentsThatNeedPreEndOfFrameSync;
    /* 0x02a0 */ TArray<UActorComponent*> ComponentsThatNeedEndOfFrameUpdate;
    /* 0x02b0 */ TArray<UActorComponent*> ComponentsThatNeedEndOfFrameUpdate_OnGameThread;
    /* 0x0520 */ TArray<ULevel*> SelectedLevels;
    /* 0x06d8 */ UWorldComposition* WorldComposition;
    /* 0x07a0 */ FWorldPSCPool PSCPool;

    void HandleTimelineScrubbed();
    AWorldSettings* K2_GetWorldSettings();
};

// Size: 0x78
class UWorldComposition : public UObject {
    /* 0x0058 */ TArray<ULevelStreaming*> TilesStreaming;
    /* 0x0068 */ double TilesStreamingTimeThreshold;
    /* 0x0070 */ bool bLoadAllTilesDuringCinematic;
    /* 0x0071 */ bool bRebaseOriginIn3DSpace;
    /* 0x0072 */ bool bLockTilesLocation;
    /* 0x0074 */ float RebaseOriginDistance;
};

// Size: 0x290
struct FWorldContext {
    /* 0x00d8 */ FURL LastURL;
    /* 0x0140 */ FURL LastRemoteURL;
    /* 0x01a8 */ UPendingNetGame* PendingNetGame;
    /* 0x01b0 */ TArray<FFullyLoadedPackagesInfo> PackagesToFullyLoad;
    /* 0x01d0 */ TArray<ULevel*> LoadedLevelsForPendingMapChange;
    /* 0x01f8 */ TArray<UObjectReferencer*> ObjectReferencers;
    /* 0x0208 */ TArray<FLevelStreamingStatus> PendingLevelStreamingStatusUpdates;
    /* 0x0218 */ UGameViewportClient* GameViewport;
    /* 0x0220 */ UGameInstance* OwningGameInstance;
    /* 0x0228 */ TArray<FNamedNetDriver> ActiveNetDrivers;
};

// Size: 0x58
struct FWorldPSCPool {
    /* 0x0000 */ TMap<UParticleSystem*, FPSCPool> WorldParticleSystemPools;
};

// Size: 0x5d0
class AWorldSettings : public AInfo {
    /* 0x0308 */ int32_t VisibilityCellSize;
    /* 0x030c */ uint8_t VisibilityAggressiveness;
    /* 0x030d */ bool bPrecomputeVisibility;
    /* 0x030d */ bool bPlaceCellsOnlyAlongCameraTracks;
    /* 0x030d */ bool bEnableWorldBoundsChecks;
    /* 0x030d */ bool bEnableNavigationSystem;
    /* 0x030d */ bool bEnableAISystem;
    /* 0x030d */ bool bEnableWorldComposition;
    /* 0x030d */ bool bUseClientSideLevelStreamingVolumes;
    /* 0x030d */ bool bEnableWorldOriginRebasing;
    /* 0x030e */ bool bWorldGravitySet;
    /* 0x030e */ bool bGlobalGravitySet;
    /* 0x030e */ bool bMinimizeBSPSections;
    /* 0x030e */ bool bForceNoPrecomputedLighting;
    /* 0x030e */ bool bHighPriorityLoading;
    /* 0x030e */ bool bHighPriorityLoadingLocal;
    /* 0x030e */ bool bOverrideDefaultBroadphaseSettings;
    /* 0x0310 */ UNavigationSystemConfig* NavigationSystemConfig;
    /* 0x0318 */ UNavigationSystemConfig* NavigationSystemConfigOverride;
    /* 0x0320 */ float WorldToMeters;
    /* 0x0324 */ float KillZ;
    /* 0x0328 */ UClass* KillZDamageType;
    /* 0x0330 */ float WorldGravityZ;
    /* 0x0334 */ float GlobalGravityZ;
    /* 0x0338 */ UClass* DefaultPhysicsVolumeClass;
    /* 0x0340 */ UClass* PhysicsCollisionHandlerClass;
    /* 0x0348 */ UClass* DefaultGameMode;
    /* 0x0350 */ UClass* GameNetworkManagerClass;
    /* 0x0358 */ int32_t PackedLightAndShadowMapTextureSize;
    /* 0x035c */ FVector DefaultColorScale;
    /* 0x0368 */ float DefaultMaxDistanceFieldOcclusionDistance;
    /* 0x036c */ float GlobalDistanceFieldViewDistance;
    /* 0x0370 */ float DynamicIndirectShadowsSelfShadowingIntensity;
    /* 0x0374 */ FLightmassWorldInfoSettings LightmassSettings;
    /* 0x03c0 */ FReverbSettings DefaultReverbSettings;
    /* 0x03e0 */ FInteriorSettings DefaultAmbientZoneSettings;
    /* 0x0408 */ USoundMix* DefaultBaseSoundMix;
    /* 0x0410 */ bool bEnableHierarchicalLODSystem;
    /* 0x0418 */ TSoftClassPtr<UHierarchicalLODSetup> HLODSetupAsset;
    /* 0x0448 */ TSoftObjectPtr<UMaterialInterface> OverrideBaseMaterial;
    /* 0x0478 */ TArray<FHierarchicalSimplification> HierarchicalLODSetup;
    /* 0x0488 */ int32_t NumHLODLevels;
    /* 0x048c */ bool bGenerateSingleClusterForLevel;
    /* 0x0490 */ FTransform HLODBakingTransform;
    /* 0x04c0 */ UBookMark* Bookmarks[10];
    /* 0x0510 */ float TimeDilation;
    /* 0x0514 */ float MatineeTimeDilation;
    /* 0x0518 */ float DemoPlayTimeDilation;
    /* 0x051c */ float MinGlobalTimeDilation;
    /* 0x0520 */ float MaxGlobalTimeDilation;
    /* 0x0524 */ float MinUndilatedFrameTime;
    /* 0x0528 */ float MaxUndilatedFrameTime;
    /* 0x052c */ FBroadphaseSettings BroadphaseSettings;
    /* 0x0570 */ APlayerState* Pauser;
    /* 0x0578 */ TArray<FNetViewer> ReplicationViewers;
    /* 0x0588 */ TArray<UAssetUserData*> AssetUserData;
    /* 0x0598 */ APlayerState* PauserPlayerState;
    /* 0x05a0 */ int32_t MaxNumberOfBookmarks;
    /* 0x05a8 */ UClass* DefaultBookmarkClass;
    /* 0x05b0 */ TArray<UBookmarkBase*> BookmarkArray;
    /* 0x05c0 */ UClass* LastBookmarkClass;

    void OnRep_WorldGravityZ();
};

// Size: 0x38
class UWorldSubsystem : public USubsystem {
};

// Size: 0x18
struct FWrappedStringElement {
    /* 0x0000 */ FString Value;
    /* 0x0010 */ FVector2D LineExtent;
};

// Size: 0x38
struct Fmaterialinput {
    /* 0x0000 */ UMaterialExpression* Expression;
    /* 0x0008 */ int32_t OutputIndex;
    /* 0x000c */ FName InputName;
    /* 0x0018 */ int32_t mask;
    /* 0x001c */ int32_t MaskR;
    /* 0x0020 */ int32_t MaskG;
    /* 0x0024 */ int32_t MaskB;
    /* 0x0028 */ int32_t MaskA;
    /* 0x002c */ FName ExpressionName;
};

// Size: 0x20
struct FEngineServiceAuthDeny {
    /* 0x0000 */ FString UserName;
    /* 0x0010 */ FString UserToDeny;
};

// Size: 0x20
struct FEngineServiceAuthGrant {
    /* 0x0000 */ FString UserName;
    /* 0x0010 */ FString UserToGrant;
};

// Size: 0x20
struct FEngineServiceExecuteCommand {
    /* 0x0000 */ FString Command;
    /* 0x0010 */ FString UserName;
};

// Size: 0x18
struct FEngineServiceNotification {
    /* 0x0000 */ FString text;
    /* 0x0010 */ double TimeSeconds;
};

// Size: 0x1
struct FEngineServicePing {
};

// Size: 0x50
struct FEngineServicePong {
    /* 0x0000 */ FString CurrentLevel;
    /* 0x0010 */ int32_t EngineVersion;
    /* 0x0014 */ bool HasBegunPlay;
    /* 0x0018 */ FGuid InstanceId;
    /* 0x0028 */ FString InstanceType;
    /* 0x0038 */ FGuid SessionId;
    /* 0x0048 */ float WorldTimeSeconds;
};

// Size: 0x10
struct FEngineServiceTerminate {
    /* 0x0000 */ FString UserName;
};

// Size: 0x28
struct FAutoCompleteCommand {
    /* 0x0000 */ FString Command;
    /* 0x0010 */ FString Desc;
};

// Size: 0x78
class UConsoleSettings : public UObject {
    /* 0x0030 */ int32_t MaxScrollbackSize;
    /* 0x0038 */ TArray<FAutoCompleteCommand> ManualAutoCompleteList;
    /* 0x0048 */ TArray<FString> AutoCompleteMapPaths;
    /* 0x0058 */ float BackgroundOpacityPercentage;
    /* 0x005c */ bool bOrderTopToBottom;
    /* 0x005d */ bool bDisplayHelpInAutoComplete;
    /* 0x0060 */ FColor InputColor;
    /* 0x0064 */ FColor HistoryColor;
    /* 0x0068 */ FColor AutoCompleteCommandColor;
    /* 0x006c */ FColor AutoCompleteCVarColor;
    /* 0x0070 */ FColor AutoCompleteFadedColor;
};

enum class EFourPlayerSplitScreenType {
    Grid = 0,
    Vertical = 1,
    Horizontal = 2,
    EFourPlayerSplitScreenType_MAX = 3,
};

enum class ESubLevelStripMode {
    ExactClass = 0,
    IsChildOf = 1,
    ESubLevelStripMode_MAX = 2,
};

enum class EThreePlayerSplitScreenType {
    FavorTop = 0,
    FavorBottom = 1,
    Vertical = 2,
    Horizontal = 3,
    EThreePlayerSplitScreenType_MAX = 4,
};

enum class ETwoPlayerSplitScreenType {
    Horizontal = 0,
    Vertical = 1,
    ETwoPlayerSplitScreenType_MAX = 2,
};

// Size: 0x148
class UGameMapsSettings : public UObject {
    /* 0x0030 */ FSoftObjectPath EditorStartupMap;
    /* 0x0050 */ FString LocalMapOptions;
    /* 0x0060 */ FSoftObjectPath TransitionMap;
    /* 0x0080 */ bool bUseSplitscreen;
    /* 0x0081 */ uint8_t TwoPlayerSplitscreenLayout;
    /* 0x0082 */ uint8_t ThreePlayerSplitscreenLayout;
    /* 0x0083 */ EFourPlayerSplitScreenType FourPlayerSplitscreenLayout;
    /* 0x0084 */ bool bOffsetPlayerGamepadIds;
    /* 0x0088 */ FSoftClassPath GameInstanceClass;
    /* 0x00a8 */ FSoftObjectPath GameDefaultMap;
    /* 0x00c8 */ FSoftObjectPath ServerDefaultMap;
    /* 0x00e8 */ FSoftClassPath GlobalDefaultGameMode;
    /* 0x0108 */ FSoftClassPath GlobalDefaultServerGameMode;
    /* 0x0128 */ TArray<FGameModeName> GameModeMapPrefixes;
    /* 0x0138 */ TArray<FGameModeName> GameModeClassAliases;

    static UGameMapsSettings* GetGameMapsSettings();
    bool GetSkipAssigningGamepadToPlayer1() const;
    void SetSkipAssigningGamepadToPlayer1(bool bSkipFirstPlayer);
};

// Size: 0x30
struct FGameModeName {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FSoftClassPath GameMode;
};

// Size: 0x60
class UGameNetworkManagerSettings : public UObject {
    /* 0x0030 */ int32_t MinDynamicBandwidth;
    /* 0x0034 */ int32_t MaxDynamicBandwidth;
    /* 0x0038 */ int32_t TotalNetBandwidth;
    /* 0x003c */ int32_t BadPingThreshold;
    /* 0x0040 */ bool bIsStandbyCheckingEnabled;
    /* 0x0044 */ float StandbyRxCheatTime;
    /* 0x0048 */ float StandbyTxCheatTime;
    /* 0x004c */ float PercentMissingForRxStandby;
    /* 0x0050 */ float PercentMissingForTxStandby;
    /* 0x0054 */ float PercentForBadPing;
    /* 0x0058 */ float JoinInProgressStandbyWaitTime;
};

// Size: 0x40
class UGameSessionSettings : public UObject {
    /* 0x0030 */ int32_t MaxSpectators;
    /* 0x0034 */ int32_t MaxPlayers;
    /* 0x0038 */ bool bRequiresPushToTalk;
};

// Size: 0x30
class UGeneralEngineSettings : public UObject {
};

// Size: 0x118
class UGeneralProjectSettings : public UObject {
    /* 0x0030 */ FString CompanyName;
    /* 0x0040 */ FString CompanyDistinguishedName;
    /* 0x0050 */ FString CopyrightNotice;
    /* 0x0060 */ FString Description;
    /* 0x0070 */ FString Homepage;
    /* 0x0080 */ FString LicensingTerms;
    /* 0x0090 */ FString PrivacyPolicy;
    /* 0x00a0 */ FGuid ProjectID;
    /* 0x00b0 */ FString ProjectName;
    /* 0x00c0 */ FString ProjectVersion;
    /* 0x00d0 */ FString SupportContact;
    /* 0x00e0 */ FText ProjectDisplayedTitle;
    /* 0x00f8 */ FText ProjectDebugTitleInfo;
    /* 0x0110 */ bool bShouldWindowPreserveAspectRatio;
    /* 0x0111 */ bool bUseBorderlessWindow;
    /* 0x0112 */ bool bStartInVR;
    /* 0x0113 */ bool bAllowWindowResize;
    /* 0x0114 */ bool bAllowClose;
    /* 0x0115 */ bool bAllowMaximize;
    /* 0x0116 */ bool bAllowMinimize;
};

// Size: 0x48
class UHudSettings : public UObject {
    /* 0x0030 */ bool bShowHUD;
    /* 0x0038 */ TArray<FName> DebugDisplay;
};

// Size: 0x30
class UEdGraphSchema_EnvironmentQuery : public UAIGraphSchema {
};

// Size: 0x88
class UEnvironmentQueryFactory : public UFactory {
};

// Size: 0xb8
class UEnvironmentQueryGraph : public UAIGraph {
};

// Size: 0x168
class UEnvironmentQueryGraphNode : public UAIGraphNode {
};

// Size: 0x188
class UEnvironmentQueryGraphNode_Option : public UEnvironmentQueryGraphNode {
};

// Size: 0x180
class UEnvironmentQueryGraphNode_Root : public UEnvironmentQueryGraphNode {
    /* 0x0168 */ TArray<FString> DebugMessages;
    /* 0x0178 */ bool bHasDebugError;
};

// Size: 0x180
class UEnvironmentQueryGraphNode_Test : public UEnvironmentQueryGraphNode {
    /* 0x0168 */ float TestWeightPct;
    /* 0x016c */ bool bHasNamedWeight;
    /* 0x016c */ bool bTestEnabled;
};

enum class EEyeTrackerStatus {
    NotConnected = 0,
    NotTracking = 1,
    Tracking = 2,
    EEyeTrackerStatus_MAX = 3,
};

// Size: 0x30
class UEyeTrackerFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool GetGazeData(FEyeTrackerGazeData& OutGazeData);
    static bool GetStereoGazeData(FEyeTrackerStereoGazeData& OutGazeData);
    static bool IsEyeTrackerConnected();
    static bool IsStereoGazeDataAvailable();
    static void SetEyeTrackedPlayer(APlayerController* PlayerController);
};

// Size: 0x28
struct FEyeTrackerGazeData {
    /* 0x0000 */ FVector GazeOrigin;
    /* 0x000c */ FVector GazeDirection;
    /* 0x0018 */ FVector FixationPoint;
    /* 0x0024 */ float ConfidenceValue;
};

// Size: 0x40
struct FEyeTrackerStereoGazeData {
    /* 0x0000 */ FVector LeftEyeOrigin;
    /* 0x000c */ FVector LeftEyeDirection;
    /* 0x0018 */ FVector RightEyeOrigin;
    /* 0x0024 */ FVector RightEyeDirection;
    /* 0x0030 */ FVector FixationPoint;
    /* 0x003c */ float ConfidenceValue;
};

// Size: 0x910
class UAudioCurveSourceComponent : public UAudioComponent {
    /* 0x08d0 */ FName CurveSourceBindingName;
    /* 0x08dc */ float CurveSyncOffset;
};

// Size: 0x60
class UFacialAnimationBulkImporterSettings : public UObject {
    /* 0x0030 */ FDirectoryPath SourceImportPath;
    /* 0x0040 */ FDirectoryPath TargetImportPath;
    /* 0x0050 */ FString CurveNodeName;
};

// Size: 0x110
class UBoxFalloff : public UFieldNodeFloat {
    /* 0x00c0 */ float Magnitude;
    /* 0x00c4 */ float MinRange;
    /* 0x00c8 */ float MaxRange;
    /* 0x00cc */ float Default;
    /* 0x00d0 */ FTransform Transform;
    /* 0x0100 */ uint8_t Falloff;

    UBoxFalloff* SetBoxFalloff(float Magnitude, float MinRange, float MaxRange, float Default, FTransform Transform, uint8_t Falloff);
};

// Size: 0xd8
class UCullingField : public UFieldNodeBase {
    /* 0x00c0 */ UFieldNodeBase* Culling;
    /* 0x00c8 */ UFieldNodeBase* Field;
    /* 0x00d0 */ uint8_t Operation;

    UCullingField* SetCullingField(const UFieldNodeBase* Culling, const UFieldNodeBase* Field, uint8_t Operation);
};

// Size: 0xc0
class UFieldNodeBase : public UActorComponent {
};

// Size: 0xc0
class UFieldNodeFloat : public UFieldNodeBase {
};

// Size: 0xc0
class UFieldNodeInt : public UFieldNodeBase {
};

// Size: 0xc0
class UFieldNodeVector : public UFieldNodeBase {
};

// Size: 0x30
struct FFieldObjectCommands {
    /* 0x0000 */ TArray<FName> TargetNames;
    /* 0x0010 */ TArray<UFieldNodeBase*> RootNodes;
    /* 0x0020 */ TArray<UFieldSystemMetaData*> MetaDatas;
};

// Size: 0x40
class UFieldSystem : public UObject {
};

// Size: 0x300
class AFieldSystemActor : public AActor {
    /* 0x02f8 */ UFieldSystemComponent* FieldSystemComponent;
};

// Size: 0x5b0
class UFieldSystemComponent : public UPrimitiveComponent {
    /* 0x04d8 */ UFieldSystem* FieldSystem;
    /* 0x04e0 */ bool bIsWorldField;
    /* 0x04e1 */ bool bIsChaosField;
    /* 0x04e8 */ TArray<TSoftObjectPtr<AChaosSolverActor>> SupportedSolvers;
    /* 0x04f8 */ FFieldObjectCommands ConstructionCommands;
    /* 0x0528 */ FFieldObjectCommands BufferCommands;

    void AddFieldCommand(bool Enabled, uint8_t Target, UFieldSystemMetaData* MetaData, UFieldNodeBase* Field);
    void AddPersistentField(bool Enabled, uint8_t Target, UFieldSystemMetaData* MetaData, UFieldNodeBase* Field);
    void ApplyLinearForce(bool Enabled, FVector Direction, float Magnitude);
    void ApplyPhysicsField(bool Enabled, uint8_t Target, UFieldSystemMetaData* MetaData, UFieldNodeBase* Field);
    void ApplyRadialForce(bool Enabled, FVector Position, float Magnitude);
    void ApplyRadialVectorFalloffForce(bool Enabled, FVector Position, float Radius, float Magnitude);
    void ApplyStayDynamicField(bool Enabled, FVector Position, float Radius);
    void ApplyStrainField(bool Enabled, FVector Position, float Radius, float Magnitude, int32_t Iterations);
    void ApplyUniformVectorFalloffForce(bool Enabled, FVector Position, FVector Direction, float Radius, float Magnitude);
    void RemovePersistentFields();
    void ResetFieldSystem();
};

// Size: 0xc0
class UFieldSystemMetaData : public UActorComponent {
};

// Size: 0xc8
class UFieldSystemMetaDataFilter : public UFieldSystemMetaData {
    /* 0x00c0 */ uint8_t FilterType;

    UFieldSystemMetaDataFilter* SetMetaDataFilterType(uint8_t FilterType);
};

// Size: 0xc8
class UFieldSystemMetaDataIteration : public UFieldSystemMetaData {
    /* 0x00c0 */ int32_t Iterations;

    UFieldSystemMetaDataIteration* SetMetaDataIteration(int32_t Iterations);
};

// Size: 0xc8
class UFieldSystemMetaDataProcessingResolution : public UFieldSystemMetaData {
    /* 0x00c0 */ uint8_t ResolutionType;

    UFieldSystemMetaDataProcessingResolution* SetMetaDataaProcessingResolutionType(uint8_t ResolutionType);
};

// Size: 0x100
class UNoiseField : public UFieldNodeFloat {
    /* 0x00c0 */ float MinRange;
    /* 0x00c4 */ float MaxRange;
    /* 0x00d0 */ FTransform Transform;

    UNoiseField* SetNoiseField(float MinRange, float MaxRange, FTransform Transform);
};

// Size: 0xe0
class UOperatorField : public UFieldNodeBase {
    /* 0x00c0 */ float Magnitude;
    /* 0x00c8 */ UFieldNodeBase* RightField;
    /* 0x00d0 */ UFieldNodeBase* LeftField;
    /* 0x00d8 */ uint8_t Operation;

    UOperatorField* SetOperatorField(float Magnitude, const UFieldNodeBase* LeftField, const UFieldNodeBase* RightField, uint8_t Operation);
};

// Size: 0xf0
class UPlaneFalloff : public UFieldNodeFloat {
    /* 0x00c0 */ float Magnitude;
    /* 0x00c4 */ float MinRange;
    /* 0x00c8 */ float MaxRange;
    /* 0x00cc */ float Default;
    /* 0x00d0 */ float Distance;
    /* 0x00d4 */ FVector Position;
    /* 0x00e0 */ FVector Normal;
    /* 0x00ec */ uint8_t Falloff;

    UPlaneFalloff* SetPlaneFalloff(float Magnitude, float MinRange, float MaxRange, float Default, float Distance, FVector Position, FVector Normal, uint8_t Falloff);
};

// Size: 0xe8
class URadialFalloff : public UFieldNodeFloat {
    /* 0x00c0 */ float Magnitude;
    /* 0x00c4 */ float MinRange;
    /* 0x00c8 */ float MaxRange;
    /* 0x00cc */ float Default;
    /* 0x00d0 */ float Radius;
    /* 0x00d4 */ FVector Position;
    /* 0x00e0 */ uint8_t Falloff;

    URadialFalloff* SetRadialFalloff(float Magnitude, float MinRange, float MaxRange, float Default, float Radius, FVector Position, uint8_t Falloff);
};

// Size: 0xe0
class URadialIntMask : public UFieldNodeInt {
    /* 0x00c0 */ float Radius;
    /* 0x00c4 */ FVector Position;
    /* 0x00d0 */ int32_t InteriorValue;
    /* 0x00d4 */ int32_t ExteriorValue;
    /* 0x00d8 */ uint8_t SetMaskCondition;

    URadialIntMask* SetRadialIntMask(float Radius, FVector Position, int32_t InteriorValue, int32_t ExteriorValue, uint8_t SetMaskConditionIn);
};

// Size: 0xd0
class URadialVector : public UFieldNodeVector {
    /* 0x00c0 */ float Magnitude;
    /* 0x00c4 */ FVector Position;

    URadialVector* SetRadialVector(float Magnitude, FVector Position);
};

// Size: 0xc8
class URandomVector : public UFieldNodeVector {
    /* 0x00c0 */ float Magnitude;

    URandomVector* SetRandomVector(float Magnitude);
};

// Size: 0xc0
class UReturnResultsTerminal : public UFieldNodeBase {

    UReturnResultsTerminal* SetReturnResultsTerminal();
};

// Size: 0xc8
class UToFloatField : public UFieldNodeFloat {
    /* 0x00c0 */ UFieldNodeInt* IntField;

    UToFloatField* SetToFloatField(const UFieldNodeInt* IntegerField);
};

// Size: 0xc8
class UToIntegerField : public UFieldNodeInt {
    /* 0x00c0 */ UFieldNodeFloat* FloatField;

    UToIntegerField* SetToIntegerField(const UFieldNodeFloat* FloatField);
};

// Size: 0xc8
class UUniformInteger : public UFieldNodeInt {
    /* 0x00c0 */ int32_t Magnitude;

    UUniformInteger* SetUniformInteger(int32_t Magnitude);
};

// Size: 0xc8
class UUniformScalar : public UFieldNodeFloat {
    /* 0x00c0 */ float Magnitude;

    UUniformScalar* SetUniformScalar(float Magnitude);
};

// Size: 0xd0
class UUniformVector : public UFieldNodeVector {
    /* 0x00c0 */ float Magnitude;
    /* 0x00c4 */ FVector Direction;

    UUniformVector* SetUniformVector(float Magnitude, FVector Direction);
};

// Size: 0xe0
class UWaveScalar : public UFieldNodeFloat {
    /* 0x00c0 */ float Magnitude;
    /* 0x00c4 */ FVector Position;
    /* 0x00d0 */ float Wavelength;
    /* 0x00d4 */ float Period;
    /* 0x00d8 */ uint8_t Function;
    /* 0x00d9 */ uint8_t Falloff;

    UWaveScalar* SetWaveScalar(float Magnitude, FVector Position, float Wavelength, float Period, float Time, uint8_t Function, uint8_t Falloff);
};

enum class EFoliageScaling {
    Uniform = 0,
    Free = 1,
    LockXY = 2,
    LockXZ = 3,
    LockYZ = 4,
    EFoliageScaling_MAX = 5,
};

enum class ESimulationOverlap {
    CollisionOverlap = 0,
    ShadeOverlap = 1,
    None = 2,
    ESimulationOverlap_MAX = 3,
};

enum class ESimulationQuery {
    None = 0,
    CollisionOverlap = 1,
    ShadeOverlap = 2,
    AnyOverlap = 3,
    ESimulationQuery_MAX = 4,
};

enum class EVertexColorMaskChannel {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
    MAX_None = 4,
    EVertexColorMaskChannel_MAX = 5,
};

// Size: 0x7c0
class UFoliageInstancedStaticMeshComponent : public UHierarchicalInstancedStaticMeshComponent {
    /* 0x0788 */ FMulticastInlineDelegate OnInstanceTakePointDamage;
    /* 0x0798 */ FMulticastInlineDelegate OnInstanceTakeRadialDamage;
    /* 0x07a8 */ uint64_t FoliageHiddenEditorViews;
    /* 0x07b0 */ FGuid GenerationGuid;
};

// Size: 0x30
class UFoliageStatistics : public UBlueprintFunctionLibrary {

    static int32_t FoliageOverlappingBoxCount(UObject* WorldContextObject, const UStaticMesh* StaticMesh, FBox Box);
    static int32_t FoliageOverlappingSphereCount(UObject* WorldContextObject, const UStaticMesh* StaticMesh, FVector CenterPosition, float Radius);
};

// Size: 0x448
class UFoliageType : public UObject {
    /* 0x0030 */ FGuid UpdateGuid;
    /* 0x0040 */ float Density;
    /* 0x0044 */ float DensityAdjustmentFactor;
    /* 0x0048 */ float Radius;
    /* 0x004c */ bool bSingleInstanceModeOverrideRadius;
    /* 0x0050 */ float SingleInstanceModeRadius;
    /* 0x0054 */ EFoliageScaling Scaling;
    /* 0x0058 */ FFloatInterval ScaleX;
    /* 0x0060 */ FFloatInterval ScaleY;
    /* 0x0068 */ FFloatInterval ScaleZ;
    /* 0x0070 */ FFoliageVertexColorChannelMask VertexColorMaskByChannel[4];
    /* 0x00a0 */ uint8_t VertexColorMask;
    /* 0x00a4 */ float VertexColorMaskThreshold;
    /* 0x00a8 */ bool VertexColorMaskInvert;
    /* 0x00ac */ FFloatInterval ZOffset;
    /* 0x00b4 */ bool AlignToNormal;
    /* 0x00b8 */ float AlignMaxAngle;
    /* 0x00bc */ bool RandomYaw;
    /* 0x00c0 */ float RandomPitchAngle;
    /* 0x00c4 */ FFloatInterval GroundSlopeAngle;
    /* 0x00cc */ FFloatInterval Height;
    /* 0x00d8 */ TArray<FName> LandscapeLayers;
    /* 0x00e8 */ float MinimumLayerWeight;
    /* 0x00f0 */ TArray<FName> ExclusionLandscapeLayers;
    /* 0x0100 */ float MinimumExclusionLayerWeight;
    /* 0x0104 */ FName LandscapeLayer;
    /* 0x0110 */ bool CollisionWithWorld;
    /* 0x0114 */ FVector CollisionScale;
    /* 0x0120 */ FBoxSphereBounds MeshBounds;
    /* 0x013c */ FVector LowBoundOriginRadius;
    /* 0x0148 */ uint8_t Mobility;
    /* 0x014c */ FInt32Interval CullDistance;
    /* 0x0154 */ bool bEnableStaticLighting;
    /* 0x0154 */ bool CastShadow;
    /* 0x0154 */ bool bAffectDynamicIndirectLighting;
    /* 0x0154 */ bool bAffectDistanceFieldLighting;
    /* 0x0154 */ bool bCastDynamicShadow;
    /* 0x0154 */ bool bCastStaticShadow;
    /* 0x0154 */ bool bCastShadowAsTwoSided;
    /* 0x0154 */ bool bReceivesDecals;
    /* 0x0155 */ bool bOverrideLightMapRes;
    /* 0x0158 */ int32_t OverriddenLightMapRes;
    /* 0x015c */ ELightmapType LightmapType;
    /* 0x0160 */ bool bUseAsOccluder;
    /* 0x0164 */ bool bVisibleInRayTracing;
    /* 0x0164 */ bool bEvaluateWorldPositionOffset;
    /* 0x0168 */ FBodyInstance BodyInstance;
    /* 0x02f8 */ uint8_t CustomNavigableGeometry;
    /* 0x02f9 */ FLightingChannels LightingChannels;
    /* 0x02fc */ bool bRenderCustomDepth;
    /* 0x0300 */ ERendererStencilMask CustomDepthStencilWriteMask;
    /* 0x0304 */ int32_t CustomDepthStencilValue;
    /* 0x0308 */ int32_t TranslucencySortPriority;
    /* 0x0310 */ uint64_t HiddenEditorViews;
    /* 0x0318 */ bool IsSelected;
    /* 0x031c */ float CollisionRadius;
    /* 0x0320 */ float ShadeRadius;
    /* 0x0324 */ int32_t NumSteps;
    /* 0x0328 */ float InitialSeedDensity;
    /* 0x032c */ float AverageSpreadDistance;
    /* 0x0330 */ float SpreadVariance;
    /* 0x0334 */ int32_t SeedsPerStep;
    /* 0x0338 */ int32_t DistributionSeed;
    /* 0x033c */ float MaxInitialSeedOffset;
    /* 0x0340 */ bool bCanGrowInShade;
    /* 0x0341 */ bool bSpawnsInShade;
    /* 0x0344 */ float MaxInitialAge;
    /* 0x0348 */ float MaxAge;
    /* 0x034c */ float OverlapPriority;
    /* 0x0350 */ FFloatInterval ProceduralScale;
    /* 0x0358 */ FRuntimeFloatCurve ScaleCurve;
    /* 0x03e0 */ int32_t ChangeCount;
    /* 0x03e4 */ bool ReapplyDensity;
    /* 0x03e4 */ bool ReapplyRadius;
    /* 0x03e4 */ bool ReapplyAlignToNormal;
    /* 0x03e4 */ bool ReapplyRandomYaw;
    /* 0x03e4 */ bool ReapplyScaling;
    /* 0x03e4 */ bool ReapplyScaleX;
    /* 0x03e4 */ bool ReapplyScaleY;
    /* 0x03e4 */ bool ReapplyScaleZ;
    /* 0x03e5 */ bool ReapplyRandomPitchAngle;
    /* 0x03e5 */ bool ReapplyGroundSlope;
    /* 0x03e5 */ bool ReapplyHeight;
    /* 0x03e5 */ bool ReapplyLandscapeLayers;
    /* 0x03e5 */ bool ReapplyZOffset;
    /* 0x03e5 */ bool ReapplyCollisionWithWorld;
    /* 0x03e5 */ bool ReapplyVertexColorMask;
    /* 0x03e5 */ bool bEnableDensityScaling;
    /* 0x03e6 */ bool bEnableDiscardOnLoad;
    /* 0x03e8 */ TArray<URuntimeVirtualTexture*> RuntimeVirtualTextures;
    /* 0x03f8 */ int32_t VirtualTextureCullMips;
    /* 0x03fc */ ERuntimeVirtualTextureMainPassType VirtualTextureRenderPassType;
    /* 0x0400 */ float ScaleMinX;
    /* 0x0404 */ float ScaleMinY;
    /* 0x0408 */ float ScaleMinZ;
    /* 0x040c */ float ScaleMaxX;
    /* 0x0410 */ float ScaleMaxY;
    /* 0x0414 */ float ScaleMaxZ;
    /* 0x0418 */ float HeightMin;
    /* 0x041c */ float HeightMax;
    /* 0x0420 */ float ZOffsetMin;
    /* 0x0424 */ float ZOffsetMax;
    /* 0x0428 */ int32_t StartCullDistance;
    /* 0x042c */ int32_t EndCullDistance;
    /* 0x0430 */ bool UniformScale;
    /* 0x0430 */ bool LockScaleX;
    /* 0x0430 */ bool LockScaleY;
    /* 0x0430 */ bool LockScaleZ;
    /* 0x0434 */ float GroundSlope;
    /* 0x0438 */ float MinGroundSlope;
    /* 0x043c */ float MinScale;
    /* 0x0440 */ float MaxScale;
};

// Size: 0x20
struct FFoliageTypeObject {
    /* 0x0000 */ UObject* FoliageTypeObject;
    /* 0x0008 */ UFoliageType* TypeInstance;
    /* 0x0010 */ bool bIsAsset;
    /* 0x0018 */ UClass* Type;
};

// Size: 0x458
class UFoliageType_Actor : public UFoliageType {
    /* 0x0448 */ UClass* ActorClass;
    /* 0x0450 */ bool bShouldAttachToBaseComponent;
};

// Size: 0x468
class UFoliageType_InstancedStaticMesh : public UFoliageType {
    /* 0x0448 */ UStaticMesh* Mesh;
    /* 0x0450 */ TArray<UMaterialInterface*> OverrideMaterials;
    /* 0x0460 */ UClass* ComponentClass;
};

// Size: 0xc
struct FFoliageVertexColorChannelMask {
    /* 0x0000 */ bool UseMask;
    /* 0x0004 */ float MaskThreshold;
    /* 0x0008 */ bool InvertMask;
};

enum class FoliageVertexColorMask {
    FOLIAGEVERTEXCOLORMASK_Disabled = 0,
    FOLIAGEVERTEXCOLORMASK_Red = 1,
    FOLIAGEVERTEXCOLORMASK_Green = 2,
    FOLIAGEVERTEXCOLORMASK_Blue = 3,
    FOLIAGEVERTEXCOLORMASK_Alpha = 4,
    FOLIAGEVERTEXCOLORMASK_MAX = 5,
};

// Size: 0x578
class AInstancedFoliageActor : public AActor {
};

// Size: 0x368
class AInteractiveFoliageActor : public AStaticMeshActor {
    /* 0x0308 */ UCapsuleComponent* CapsuleComponent;
    /* 0x0310 */ FVector TouchingActorEntryPosition;
    /* 0x031c */ FVector FoliageVelocity;
    /* 0x0328 */ FVector FoliageForce;
    /* 0x0334 */ FVector FoliagePosition;
    /* 0x0340 */ float FoliageDamageImpulseScale;
    /* 0x0344 */ float FoliageTouchImpulseScale;
    /* 0x0348 */ float FoliageStiffness;
    /* 0x034c */ float FoliageStiffnessQuadratic;
    /* 0x0350 */ float FoliageDamping;
    /* 0x0354 */ float MaxDamageImpulse;
    /* 0x0358 */ float MaxTouchImpulse;
    /* 0x035c */ float MaxForce;
    /* 0x0360 */ float Mass;

    void CapsuleTouched(UPrimitiveComponent* OverlappedComp, AActor* Other, UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const FHitResult& OverlapInfo);
};

// Size: 0x5d0
class UInteractiveFoliageComponent : public UStaticMeshComponent {
};

// Size: 0x340
class AProceduralFoliageBlockingVolume : public AVolume {
    /* 0x0338 */ AProceduralFoliageVolume* ProceduralFoliageVolume;
};

// Size: 0xf0
class UProceduralFoliageComponent : public UActorComponent {
    /* 0x00c0 */ UProceduralFoliageSpawner* FoliageSpawner;
    /* 0x00c8 */ float TileOverlap;
    /* 0x00cc */ bool bAllowLandscape;
    /* 0x00cd */ bool bAllowBSP;
    /* 0x00ce */ bool bAllowStaticMesh;
    /* 0x00cf */ bool bAllowTranslucent;
    /* 0x00d0 */ bool bAllowFoliage;
    /* 0x00d1 */ bool bShowDebugTiles;
    /* 0x00d8 */ AVolume* SpawningVolume;
    /* 0x00e0 */ FGuid ProceduralGuid;
};

// Size: 0x50
struct FProceduralFoliageInstance {
    /* 0x0000 */ FQuat Rotation;
    /* 0x0010 */ FVector Location;
    /* 0x001c */ float Age;
    /* 0x0020 */ FVector Normal;
    /* 0x002c */ float Scale;
    /* 0x0030 */ UFoliageType* Type;
};

// Size: 0x70
class UProceduralFoliageSpawner : public UObject {
    /* 0x0030 */ int32_t RandomSeed;
    /* 0x0034 */ float TileSize;
    /* 0x0038 */ int32_t NumUniqueTiles;
    /* 0x003c */ float MinimumQuadTreeSize;
    /* 0x0048 */ TArray<FFoliageTypeObject> FoliageTypes;

    void Simulate(int32_t NumSteps);
};

// Size: 0x160
class UProceduralFoliageTile : public UObject {
    /* 0x0030 */ UProceduralFoliageSpawner* FoliageSpawner;
    /* 0x00d8 */ TArray<FProceduralFoliageInstance> InstancesArray;
};

// Size: 0x340
class AProceduralFoliageVolume : public AVolume {
    /* 0x0338 */ UProceduralFoliageComponent* ProceduralComponent;
};

// Size: 0x78
class UActorFactoryProceduralFoliage : public UActorFactoryBoxVolume {
};

// Size: 0x88
class UFoliageType_ActorFactory : public UFactory {
};

// Size: 0x88
class UFoliageType_ActorThumbnailRenderer : public UBlueprintThumbnailRenderer {
};

// Size: 0x40
class UFoliageType_ISMThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x88
class UFoliageType_InstancedStaticMeshFactory : public UFactory {
};

// Size: 0x88
class ULandscapeGrassTypeFactory : public UFactory {
};

// Size: 0x88
class UProceduralFoliageSpawnerFactory : public UFactory {
};

// Size: 0x30
class UAutoClusterFractureCommand : public UObject {
};

enum class EDynamicStateOverrideEnum {
    NoOverride = 0,
    Sleeping = 1,
    Kinematic = 2,
    Static = 3,
    EDynamicStateOverrideEnum_MAX = 4,
};

enum class EFractureAutoClusterMode {
    BoundingBox = 0,
    Proximity = 1,
    Distance = 2,
    Voronoi = 3,
    EFractureAutoClusterMode_MAX = 4,
};

enum class EFractureBrickBond {
    Stretcher = 0,
    Stack = 1,
    English = 2,
    Header = 3,
    Flemish = 4,
    EFractureBrickBond_MAX = 5,
};

enum class EFractureBrickProjection {
    X = 0,
    Y = 1,
    Z = 2,
    EFractureBrickProjection_MAX = 3,
};

enum class EInspectedAttributeEnum {
    Volume = 0,
    Level = 1,
    InitialDynamicState = 3,
    EInspectedAttributeEnum_MAX = 4,
};

enum class EOutlinerItemNameEnum {
    BoneName = 0,
    BoneIndex = 1,
    EOutlinerItemNameEnum_MAX = 2,
};

// Size: 0x40
class UFractureActionTool : public UObject {
};

// Size: 0x48
class UFractureAutoClusterSettings : public UFractureToolSettings {
    /* 0x0038 */ EFractureAutoClusterMode AutoClusterMode;
    /* 0x003c */ uint32_t SiteCount;
    /* 0x0040 */ bool bEnforceConnectivity;
};

// Size: 0x48
class UFractureBrickSettings : public UFractureToolSettings {
    /* 0x0038 */ EFractureBrickBond Bond;
    /* 0x0039 */ EFractureBrickProjection Forward;
    /* 0x003a */ EFractureBrickProjection Up;
    /* 0x003c */ float BrickLength;
    /* 0x0040 */ float BrickHeight;
    /* 0x0044 */ float BrickDepth;
};

// Size: 0x58
class UFractureClusterCutterSettings : public UFractureToolSettings {
    /* 0x0038 */ int32_t NumberClustersMin;
    /* 0x003c */ int32_t NumberClustersMax;
    /* 0x0040 */ int32_t SitesPerClusterMin;
    /* 0x0044 */ int32_t SitesPerClusterMax;
    /* 0x0048 */ float ClusterRadiusPercentageMin;
    /* 0x004c */ float ClusterRadiusPercentageMax;
    /* 0x0050 */ float ClusterRadius;
};

// Size: 0x40
class UFractureClusterMagnetSettings : public UFractureToolSettings {
    /* 0x0038 */ uint32_t Iterations;
};

// Size: 0x40
class UFractureCollisionSettings : public UFractureToolSettings {
    /* 0x0038 */ float PointSpacing;
};

// Size: 0x58
class UFractureCutterSettings : public UFractureToolSettings {
    /* 0x0038 */ int32_t RandomSeed;
    /* 0x003c */ float ChanceToFracture;
    /* 0x0040 */ bool bGroupFracture;
    /* 0x0041 */ bool bDrawSites;
    /* 0x0042 */ bool bDrawDiagram;
    /* 0x0044 */ float Grout;
    /* 0x0048 */ float Amplitude;
    /* 0x004c */ float Frequency;
    /* 0x0050 */ int32_t OctaveNumber;
    /* 0x0054 */ float SurfaceResolution;
};

// Size: 0x40
class UFractureInitialDynamicStateSettings : public UFractureToolSettings {
    /* 0x0038 */ EDynamicStateOverrideEnum InitialDynamicState;
};

// Size: 0x40
class UFractureInteractiveTool : public UFractureModalTool {
};

// Size: 0x40
class UFractureModalTool : public UFractureActionTool {
};

// Size: 0x58
class UFracturePlaneCutSettings : public UFractureToolSettings {
    /* 0x0038 */ int32_t NumberPlanarCuts;
    /* 0x003c */ TLazyObjectPtr<AActor> ReferenceActor;
};

// Size: 0x68
class UFractureRadialSettings : public UFractureToolSettings {
    /* 0x0038 */ FVector Center;
    /* 0x0044 */ FVector Normal;
    /* 0x0050 */ float Radius;
    /* 0x0054 */ int32_t AngularSteps;
    /* 0x0058 */ int32_t RadialSteps;
    /* 0x005c */ float AngleOffset;
    /* 0x0060 */ float Variability;
};

// Size: 0x38
class UFractureSettings : public UObject {
    /* 0x0030 */ float ExplodeAmount;
    /* 0x0034 */ int32_t FractureLevel;
};

// Size: 0x50
class UFractureSliceSettings : public UFractureToolSettings {
    /* 0x0038 */ int32_t SlicesX;
    /* 0x003c */ int32_t SlicesY;
    /* 0x0040 */ int32_t SlicesZ;
    /* 0x0044 */ float SliceAngleVariation;
    /* 0x0048 */ float SliceOffsetVariation;
};

// Size: 0x40
class UFractureToolAddEmbeddedGeometry : public UFractureActionTool {
};

// Size: 0x48
class UFractureToolAutoCluster : public UFractureModalTool {
    /* 0x0040 */ UFractureAutoClusterSettings* AutoClusterSettings;
};

// Size: 0x88
class UFractureToolBrick : public UFractureToolCutterBase {
    /* 0x0050 */ UFractureBrickSettings* BrickSettings;
};

// Size: 0x40
class UFractureToolCluster : public UFractureActionTool {
};

// Size: 0x98
class UFractureToolClusterCutter : public UFractureToolVoronoiCutterBase {
    /* 0x0090 */ UFractureClusterCutterSettings* ClusterSettings;
};

// Size: 0x48
class UFractureToolClusterMagnet : public UFractureModalTool {
    /* 0x0040 */ UFractureClusterMagnetSettings* ClusterMagnetSettings;
};

// Size: 0x50
class UFractureToolCutterBase : public UFractureInteractiveTool {
    /* 0x0040 */ UFractureCutterSettings* CutterSettings;
    /* 0x0048 */ UFractureCollisionSettings* CollisionSettings;
};

// Size: 0x40
class UFractureToolDeleteEmbeddedGeometry : public UFractureActionTool {
};

// Size: 0x40
class UFractureToolFlattenAll : public UFractureActionTool {
};

// Size: 0x60
class UFractureToolGenerateAsset : public UFractureActionTool {
    /* 0x0050 */ FString AssetPath;
};

// Size: 0x40
class UFractureToolMoveUp : public UFractureActionTool {
};

// Size: 0x70
class UFractureToolPlaneCut : public UFractureToolCutterBase {
    /* 0x0050 */ UFracturePlaneCutSettings* PlaneCutSettings;
};

// Size: 0x98
class UFractureToolRadial : public UFractureToolVoronoiCutterBase {
    /* 0x0090 */ UFractureRadialSettings* RadialSettings;
};

// Size: 0x60
class UFractureToolResetAsset : public UFractureToolGenerateAsset {
};

// Size: 0x40
class UFractureToolSelectAll : public UFractureActionTool {
};

// Size: 0x40
class UFractureToolSelectAllInCluster : public UFractureToolSelectAll {
};

// Size: 0x40
class UFractureToolSelectInvert : public UFractureToolSelectAll {
};

// Size: 0x40
class UFractureToolSelectNeighbors : public UFractureToolSelectAll {
};

// Size: 0x40
class UFractureToolSelectNone : public UFractureToolSelectAll {
};

// Size: 0x40
class UFractureToolSelectSiblings : public UFractureToolSelectAll {
};

// Size: 0x48
class UFractureToolSetInitialDynamicState : public UFractureModalTool {
    /* 0x0040 */ UFractureInitialDynamicStateSettings* StateSettings;
};

// Size: 0x38
class UFractureToolSettings : public UObject {
    /* 0x0030 */ UFractureModalTool* OwnerTool;
};

// Size: 0x70
class UFractureToolSlice : public UFractureToolCutterBase {
    /* 0x0050 */ UFractureSliceSettings* SliceSettings;
};

// Size: 0x40
class UFractureToolUncluster : public UFractureActionTool {
};

// Size: 0x98
class UFractureToolUniform : public UFractureToolVoronoiCutterBase {
    /* 0x0090 */ UFractureUniformSettings* UniformSettings;
};

// Size: 0x90
class UFractureToolVoronoiCutterBase : public UFractureToolCutterBase {
};

// Size: 0x40
class UFractureUniformSettings : public UFractureToolSettings {
    /* 0x0038 */ int32_t NumberVoronoiSitesMin;
    /* 0x003c */ int32_t NumberVoronoiSitesMax;
};

// Size: 0x38
class UHistogramSettings : public UObject {
    /* 0x0030 */ EInspectedAttributeEnum InspectedAttribute;
    /* 0x0031 */ bool bSorted;
};

// Size: 0x38
class UOutlinerSettings : public UObject {
    /* 0x0030 */ EOutlinerItemNameEnum ItemText;
};

// Size: 0x48
struct FAITestSpawnInfo : public FAITestSpawnInfoBase {
    /* 0x0028 */ UClass* PawnClass;
    /* 0x0030 */ UClass* ControllerClass;
    /* 0x0038 */ FGenericTeamId TeamID;
    /* 0x0040 */ UBehaviorTree* BehaviorTree;
};

// Size: 0x28
struct FAITestSpawnInfoBase {
    /* 0x0008 */ AActor* SpawnLocation;
    /* 0x0010 */ int32_t NumberToSpawn;
    /* 0x0014 */ float SpawnDelay;
    /* 0x0018 */ float PreSpawnDelay;
};

// Size: 0x30
struct FAITestSpawnSet : public FAITestSpawnSetBase {
    /* 0x0020 */ TArray<FAITestSpawnInfo> SpawnInfoContainer;
};

// Size: 0x20
struct FAITestSpawnSetBase {
    /* 0x0008 */ FName Name;
    /* 0x0014 */ bool bEnabled;
    /* 0x0018 */ AActor* FallbackSpawnLocation;
};

// Size: 0x30
class UAutomationBlueprintFunctionLibrary : public UBlueprintFunctionLibrary {

    static void AddExpectedLogError(FString ExpectedPatternString, int32_t Occurrences, bool ExactMatch);
    static bool AreAutomatedTestsRunning();
    static void AutomationWaitForLoading(UObject* WorldContextObject, FLatentActionInfo LatentInfo, FAutomationWaitForLoadingOptions Options);
    static void DisableStatGroup(UObject* WorldContextObject, FName GroupName);
    static void EnableStatGroup(UObject* WorldContextObject, FName GroupName);
    static FAutomationScreenshotOptions GetDefaultScreenshotOptionsForGameplay(EComparisonTolerance Tolerance, float Delay);
    static FAutomationScreenshotOptions GetDefaultScreenshotOptionsForRendering(EComparisonTolerance Tolerance, float Delay);
    static float GetStatCallCount(FName StatName);
    static float GetStatExcAverage(FName StatName);
    static float GetStatExcMax(FName StatName);
    static float GetStatIncAverage(FName StatName);
    static float GetStatIncMax(FName StatName);
    static void SetScalabilityQualityLevelRelativeToMax(UObject* WorldContextObject, int32_t Value);
    static void SetScalabilityQualityToEpic(UObject* WorldContextObject);
    static void SetScalabilityQualityToLow(UObject* WorldContextObject);
    static void TakeAutomationScreenshot(UObject* WorldContextObject, FLatentActionInfo LatentInfo, FString Name, FString Notes, const FAutomationScreenshotOptions& Options);
    static void TakeAutomationScreenshotAtCamera(UObject* WorldContextObject, FLatentActionInfo LatentInfo, ACameraActor* Camera, FString NameOverride, FString Notes, const FAutomationScreenshotOptions& Options);
    static void TakeAutomationScreenshotOfUI(UObject* WorldContextObject, FLatentActionInfo LatentInfo, FString Name, const FAutomationScreenshotOptions& Options);
    static UAutomationEditorTask* TakeHighResScreenshot(int32_t ResX, int32_t ResY, FString Filename, ACameraActor* Camera, bool bMaskEnabled, bool bCaptureHDR, EComparisonTolerance ComparisonTolerance, FString ComparisonNotes, float Delay);
};

// Size: 0x38
class UAutomationEditorTask : public UObject {

    bool IsTaskDone() const;
    bool IsValidTask() const;
};

// Size: 0x68
class UAutomationPerformaceHelper : public UObject {

    void BeginRecording(FString RecordName, float InGPUBudget, float InRenderThreadBudget, float InGameThreadBudget);
    void BeginRecordingBaseline(FString RecordName);
    void BeginStatsFile(FString RecordName);
    void EndRecording();
    void EndRecordingBaseline();
    void EndStatsFile();
    bool IsCurrentRecordWithinGPUBudget() const;
    bool IsCurrentRecordWithinGameThreadBudget() const;
    bool IsCurrentRecordWithinRenderThreadBudget() const;
    bool IsRecording() const;
    void OnAllTestsComplete();
    void OnBeginTests();
    void Sample(float DeltaSeconds);
    void StartCPUProfiling();
    void StopCPUProfiling();
    void Tick(float DeltaSeconds);
    void TriggerGPUTraceIfRecordFallsBelowBudget();
    void WriteLogFile(FString CaptureDir, FString CaptureExtension);
};

// Size: 0x40
struct FAutomationScreenshotOptions {
    /* 0x0000 */ FVector2D Resolution;
    /* 0x0008 */ float Delay;
    /* 0x000c */ bool bOverride_OverrideTimeTo;
    /* 0x0010 */ float OverrideTimeTo;
    /* 0x0014 */ bool bDisableNoisyRenderingFeatures;
    /* 0x0015 */ bool bDisableTonemapping;
    /* 0x0018 */ UAutomationViewSettings* ViewSettings;
    /* 0x0020 */ FName VisualizeBuffer;
    /* 0x002c */ EComparisonTolerance Tolerance;
    /* 0x002d */ FComparisonToleranceAmount ToleranceAmount;
    /* 0x0034 */ float MaximumLocalError;
    /* 0x0038 */ float MaximumGlobalError;
    /* 0x003c */ bool bIgnoreAntiAliasing;
    /* 0x003d */ bool bIgnoreColors;
};

// Size: 0x48
class UAutomationViewSettings : public UDataAsset {
    /* 0x0038 */ bool AntiAliasing;
    /* 0x0039 */ bool MotionBlur;
    /* 0x003a */ bool TemporalAA;
    /* 0x003b */ bool ScreenSpaceReflections;
    /* 0x003c */ bool ScreenSpaceAO;
    /* 0x003d */ bool DistanceFieldAO;
    /* 0x003e */ bool ContactShadows;
    /* 0x003f */ bool EyeAdaptation;
    /* 0x0040 */ bool Bloom;
};

// Size: 0x1
struct FAutomationWaitForLoadingOptions {
    /* 0x0000 */ bool WaitForReplicationToSettle;
};

// Size: 0x6
struct FComparisonToleranceAmount {
    /* 0x0000 */ uint8_t red;
    /* 0x0001 */ uint8_t green;
    /* 0x0002 */ uint8_t blue;
    /* 0x0003 */ uint8_t Alpha;
    /* 0x0004 */ uint8_t MinBrightness;
    /* 0x0005 */ uint8_t MaxBrightness;
};

enum class EComparisonMethod {
    Equal_To = 0,
    Not_Equal_To = 1,
    Greater_Than_Or_Equal_To = 2,
    Less_Than_Or_Equal_To = 3,
    Greater_Than = 4,
    Less_Than = 5,
    EComparisonMethod_MAX = 6,
};

enum class EComparisonTolerance {
    Zero = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    Custom = 4,
    EComparisonTolerance_MAX = 5,
};

enum class EFunctionalTestLogHandling {
    ProjectDefault = 0,
    OutputIsError = 1,
    OutputIgnored = 2,
    EFunctionalTestLogHandling_MAX = 3,
};

enum class EFunctionalTestResult {
    Default = 0,
    Invalid = 1,
    Error = 2,
    Running = 3,
    Failed = 4,
    Succeeded = 5,
    EFunctionalTestResult_MAX = 6,
};

enum class EWidgetTestAppearLocation {
    Viewport = 0,
    PlayerScreen = 1,
    EWidgetTestAppearLocation_MAX = 2,
};

// Size: 0x4e0
class UFuncTestRenderingComponent : public UPrimitiveComponent {
};

// Size: 0x4c0
class AFunctionalAITest : public AFunctionalAITestBase {
    /* 0x04b0 */ TArray<FAITestSpawnSet> SpawnSets;
};

// Size: 0x4b0
class AFunctionalAITestBase : public AFunctionalTest {
    /* 0x0428 */ float SpawnLocationRandomizationRange;
    /* 0x0430 */ TArray<APawn*> SpawnedPawns;
    /* 0x0440 */ TArray<FPendingDelayedSpawn> PendingDelayedSpawns;
    /* 0x0450 */ int32_t CurrentSpawnSetIndex;
    /* 0x0458 */ FString CurrentSpawnSetName;
    /* 0x0468 */ FMulticastInlineDelegate OnAISpawned;
    /* 0x0478 */ FMulticastInlineDelegate OnAllAISPawned;
    /* 0x0488 */ FVector NavMeshDebugOrigin;
    /* 0x0494 */ FVector NavMeshDebugExtent;
    /* 0x04a0 */ bool bWaitForNavMesh;
    /* 0x04a0 */ bool bDebugNavMeshOnTimeout;

    bool IsOneOfSpawnedPawns(AActor* Actor);
};

// Size: 0x428
class AFunctionalTest : public AActor {
    /* 0x02f8 */ UBillboardComponent* SpriteComponent;
    /* 0x0300 */ bool bIsEnabled;
    /* 0x0304 */ EFunctionalTestLogHandling LogErrorHandling;
    /* 0x0305 */ EFunctionalTestLogHandling LogWarningHandling;
    /* 0x0308 */ FString Author;
    /* 0x0318 */ FString Description;
    /* 0x0328 */ AActor* ObservationPoint;
    /* 0x0330 */ FRandomStream RandomNumbersStream;
    /* 0x0338 */ EFunctionalTestResult Result;
    /* 0x033c */ float PreparationTimeLimit;
    /* 0x0340 */ float TimeLimit;
    /* 0x0348 */ FText TimesUpMessage;
    /* 0x0360 */ EFunctionalTestResult TimesUpResult;
    /* 0x0368 */ FMulticastInlineDelegate OnTestPrepare;
    /* 0x0378 */ FMulticastInlineDelegate OnTestStart;
    /* 0x0388 */ FMulticastInlineDelegate OnTestFinished;
    /* 0x0398 */ TArray<AActor*> AutoDestroyActors;
    /* 0x03b8 */ UFuncTestRenderingComponent* RenderComp;
    /* 0x03c0 */ UTextRenderComponent* TestName;
    /* 0x03f8 */ bool bIsRunning;
    /* 0x0410 */ float TotalTime;

    void AddError(FString Message);
    void AddRerun(FName reason);
    void AddWarning(FString Message);
    bool AssertEqual_Bool(const bool Actual, const bool Expected, FString What, const UObject* ContextObject);
    bool AssertEqual_Float(const float Actual, const float Expected, FString What, const float Tolerance, const UObject* ContextObject);
    bool AssertEqual_Int(const int32_t Actual, const int32_t Expected, FString What, const UObject* ContextObject);
    bool AssertEqual_Name(const FName Actual, const FName Expected, FString What, const UObject* ContextObject);
    bool AssertEqual_Object(UObject* Actual, UObject* Expected, FString What, const UObject* ContextObject);
    bool AssertEqual_Rotator(const FRotator Actual, const FRotator Expected, FString What, const float Tolerance, const UObject* ContextObject);
    bool AssertEqual_String(const FString Actual, const FString Expected, FString What, const UObject* ContextObject);
    bool AssertEqual_TraceQueryResults(const UTraceQueryTestResults* Actual, const UTraceQueryTestResults* Expected, FString What, const UObject* ContextObject);
    bool AssertEqual_Transform(const FTransform& Actual, const FTransform& Expected, FString What, float Tolerance, const UObject* ContextObject);
    bool AssertEqual_Vector(const FVector Actual, const FVector Expected, FString What, const float Tolerance, const UObject* ContextObject);
    bool AssertFalse(bool Condition, FString Message, const UObject* ContextObject);
    bool AssertIsValid(UObject* Object, FString Message, const UObject* ContextObject);
    bool AssertNotEqual_Rotator(const FRotator Actual, const FRotator NotExpected, FString What, const UObject* ContextObject);
    bool AssertNotEqual_String(const FString Actual, const FString NotExpected, FString What, const UObject* ContextObject);
    bool AssertNotEqual_Transform(const FTransform& Actual, const FTransform& NotExpected, FString What, const UObject* ContextObject);
    bool AssertNotEqual_Vector(const FVector Actual, const FVector NotExpected, FString What, const UObject* ContextObject);
    bool AssertTrue(bool Condition, FString Message, const UObject* ContextObject);
    bool AssertValue_DateTime(FDateTime Actual, EComparisonMethod ShouldBe, FDateTime Expected, FString What, const UObject* ContextObject);
    bool AssertValue_Float(float Actual, EComparisonMethod ShouldBe, float Expected, FString What, const UObject* ContextObject);
    bool AssertValue_Int(int32_t Actual, EComparisonMethod ShouldBe, int32_t Expected, FString What, const UObject* ContextObject);
    TArray<AActor*> DebugGatherRelevantActors() const;
    void FinishTest(EFunctionalTestResult TestResult, FString Message);
    FName GetCurrentRerunReason() const;
    bool IsEnabled() const;
    bool IsReady();
    bool IsRunning() const;
    void LogMessage(FString Message);
    FString OnAdditionalTestFinishedMessageRequest(EFunctionalTestResult TestResult) const;
    bool OnWantsReRunCheck() const;
    void ReceivePrepareTest();
    void ReceiveStartTest();
    void RegisterAutoDestroyActor(AActor* ActorToAutoDestroy);
    void SetTimeLimit(float NewTimeLimit, EFunctionalTestResult ResultWhenTimeRunsOut);
};

// Size: 0x3a0
class AFunctionalTestGameMode : public AGameModeBase {
};

// Size: 0x300
class AFunctionalTestLevelScript : public ALevelScriptActor {
};

// Size: 0x30
class UFunctionalTestUtilityLibrary : public UBlueprintFunctionLibrary {

    static UTraceQueryTestResults* TraceChannelTestUtil(UObject* WorldContextObject, const FTraceChannelTestBatchOptions& BatchOptions, const FVector Start, const FVector End, float SphereCapsuleRadius, float CapsuleHalfHeight, FVector BoxHalfSize, const FRotator Orientation, uint8_t TraceChannel, TArray<uint8_t> ObjectTypes, FName ProfileName, bool bTraceComplex, const TArray<AActor*>& ActorsToIgnore, bool bIgnoreSelf, uint8_t DrawDebugType, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
};

// Size: 0xc8
class UFunctionalTestingManager : public UBlueprintFunctionLibrary {
    /* 0x0030 */ TArray<AFunctionalTest*> TestsLeft;
    /* 0x0040 */ TArray<AFunctionalTest*> AllTests;
    /* 0x0050 */ FMulticastInlineDelegate OnSetupTests;
    /* 0x0060 */ FMulticastInlineDelegate OnTestsComplete;
    /* 0x0070 */ FMulticastInlineDelegate OnTestsBegin;

    static bool RunAllFunctionalTests(UObject* WorldContextObject, bool bNewLog, bool bRunLooped, FString FailedTestsReproString);
};

// Size: 0x4c0
class AFunctionalUIScreenshotTest : public AScreenshotFunctionalTestBase {
    /* 0x04a0 */ UClass* WidgetClass;
    /* 0x04a8 */ UUserWidget* SpawnedWidget;
    /* 0x04b0 */ EWidgetTestAppearLocation WidgetLocation;
    /* 0x04b8 */ UTextureRenderTarget2D* ScreenshotRT;
};

// Size: 0x40
class UGroundTruthData : public UObject {
    /* 0x0030 */ bool bResetGroundTruth;
    /* 0x0038 */ UObject* ObjectData;

    bool CanModify() const;
    UObject* LoadObject();
    void SaveObject(UObject* GroundTruth);
};

// Size: 0x14
struct FPendingDelayedSpawn {
};

// Size: 0x2f8
class APhasedAutomationActorBase : public AActor {

    void OnFunctionalTestingBegin();
    void OnFunctionalTestingComplete();
};

// Size: 0x4a8
class AScreenshotFunctionalTest : public AScreenshotFunctionalTestBase {
    /* 0x04a0 */ bool bCameraCutOnScreenshotPrep;
};

// Size: 0x4a0
class AScreenshotFunctionalTestBase : public AFunctionalTest {
    /* 0x0428 */ FString Notes;
    /* 0x0438 */ UCameraComponent* ScreenshotCamera;
    /* 0x0440 */ FAutomationScreenshotOptions ScreenshotOptions;
};

// Size: 0x230
class UTestPhaseComponent : public USceneComponent {
};

// Size: 0x7
struct FTraceChannelTestBatchOptions {
    /* 0x0000 */ bool bLineTrace;
    /* 0x0001 */ bool bSphereTrace;
    /* 0x0002 */ bool bCapsuleTrace;
    /* 0x0003 */ bool bBoxTrace;
    /* 0x0004 */ bool bChannelTrace;
    /* 0x0005 */ bool bObjectsTrace;
    /* 0x0006 */ bool bProfileTrace;
};

// Size: 0x24
struct FTraceQueryTestNames {
    /* 0x0000 */ FName ComponentName;
    /* 0x000c */ FName PhysicalMaterialName;
    /* 0x0018 */ FName ActorName;
};

// Size: 0xab8
class UTraceQueryTestResults : public UObject {
    /* 0x0030 */ FTraceQueryTestResultsInner ChannelResults;
    /* 0x03b0 */ FTraceQueryTestResultsInner ObjectResults;
    /* 0x0730 */ FTraceQueryTestResultsInner ProfileResults;
    /* 0x0ab0 */ FTraceChannelTestBatchOptions BatchOptions;

    FString ToString();
};

// Size: 0x380
struct FTraceQueryTestResultsInner {
    /* 0x0000 */ FTraceQueryTestResultsInnerMost LineResults;
    /* 0x00e0 */ FTraceQueryTestResultsInnerMost SphereResults;
    /* 0x01c0 */ FTraceQueryTestResultsInnerMost CapsuleResults;
    /* 0x02a0 */ FTraceQueryTestResultsInnerMost BoxResults;
};

// Size: 0xe0
struct FTraceQueryTestResultsInnerMost {
    /* 0x0000 */ FHitResult SingleHit;
    /* 0x0090 */ FTraceQueryTestNames SingleNames;
    /* 0x00b4 */ bool bSingleResult;
    /* 0x00b8 */ TArray<FHitResult> MultiHits;
    /* 0x00c8 */ TArray<FTraceQueryTestNames> MultiNames;
    /* 0x00d8 */ bool bMultiResult;
};

// Size: 0x38
class UClassTemplate : public UObject {
    /* 0x0030 */ UClass* GeneratedBaseClass;
};

// Size: 0x88
class UClassTemplateEditorSubsystem : public UEditorSubsystem {
};

// Size: 0x130
class UDefaultTemplateProjectDefs : public UTemplateProjectDefs {
};

enum class ETemplateSetting {
    Languages = 0,
    HardwareTarget = 1,
    GraphicsPreset = 2,
    StarterContent = 3,
    XR = 4,
    Raytracing = 5,
    All = 6,
    ETemplateSetting_MAX = 7,
};

// Size: 0x20
struct FLocalizedTemplateString {
    /* 0x0000 */ FString Language;
    /* 0x0010 */ FString text;
};

// Size: 0x48
class UPluginClassTemplate : public UClassTemplate {
    /* 0x0038 */ FString PluginName;
};

// Size: 0x40
class UTemplateCategories : public UObject {
    /* 0x0030 */ TArray<FTemplateCategoryDef> Categories;
};

// Size: 0x48
struct FTemplateCategoryDef {
    /* 0x0000 */ FName Key;
    /* 0x0010 */ TArray<FLocalizedTemplateString> LocalizedDisplayNames;
    /* 0x0020 */ TArray<FLocalizedTemplateString> LocalizedDescriptions;
    /* 0x0030 */ FString Icon;
    /* 0x0040 */ bool IsMajorCategory;
};

// Size: 0x20
struct FTemplateFolderRename {
    /* 0x0000 */ FString From;
    /* 0x0010 */ FString To;
};

// Size: 0x130
class UTemplateProjectDefs : public UObject {
    /* 0x0030 */ TArray<FLocalizedTemplateString> LocalizedDisplayNames;
    /* 0x0040 */ TArray<FLocalizedTemplateString> LocalizedDescriptions;
    /* 0x0050 */ TArray<FString> FoldersToIgnore;
    /* 0x0060 */ TArray<FString> FilesToIgnore;
    /* 0x0070 */ TArray<FTemplateFolderRename> FolderRenames;
    /* 0x0080 */ TArray<FTemplateReplacement> FilenameReplacements;
    /* 0x0090 */ TArray<FTemplateReplacement> ReplacementsInFiles;
    /* 0x00a0 */ FString SortKey;
    /* 0x00b0 */ TArray<FName> Categories;
    /* 0x00c0 */ FString ClassTypes;
    /* 0x00d0 */ FString AssetTypes;
    /* 0x00e0 */ bool bAllowProjectCreation;
    /* 0x00e1 */ bool bIsEnterprise;
    /* 0x00e2 */ bool bIsBlank;
    /* 0x00e8 */ TArray<ETemplateSetting> HiddenSettings;
    /* 0x00f8 */ TArray<FString> PacksToInclude;
    /* 0x0108 */ EFeaturePackDetailLevel EditDetailLevelPreference;
    /* 0x0110 */ TArray<FFeaturePackLevelSet> SharedContentPacks;
    /* 0x0120 */ FString StarterContent;
};

// Size: 0x38
struct FTemplateReplacement {
    /* 0x0000 */ TArray<FString> Extensions;
    /* 0x0010 */ FString From;
    /* 0x0020 */ FString To;
    /* 0x0030 */ bool bCaseSensitive;
};

// Size: 0x50
class UCompositeCameraShakePattern : public UCameraShakePattern {
    /* 0x0030 */ TArray<UCameraShakePattern*> ChildPatterns;
};

// Size: 0x58
class UConstantCameraShakePattern : public USimpleCameraShakePattern {
    /* 0x0040 */ FVector LocationOffset;
    /* 0x004c */ FRotator RotationOffset;
};

// Size: 0xb0
class UDefaultCameraShakeBase : public UCameraShakeBase {
};

enum class EInitialOscillatorOffset {
    EOO_OffsetRandom = 0,
    EOO_OffsetZero = 1,
    EOO_MAX = 2,
};

enum class EInitialWaveOscillatorOffsetType {
    Random = 0,
    Zero = 1,
    EInitialWaveOscillatorOffsetType_MAX = 2,
};

enum class EOscillatorWaveform {
    SineWave = 0,
    PerlinNoise = 1,
    EOscillatorWaveform_MAX = 2,
};

// Size: 0xc
struct FFOscillator {
    /* 0x0000 */ float Amplitude;
    /* 0x0004 */ float Frequency;
    /* 0x0008 */ uint8_t InitialOffset;
    /* 0x0009 */ EOscillatorWaveform Waveform;
};

// Size: 0x1b0
class UMatineeCameraShake : public UCameraShakeBase {
    /* 0x00a8 */ float OscillationDuration;
    /* 0x00ac */ float OscillationBlendInTime;
    /* 0x00b0 */ float OscillationBlendOutTime;
    /* 0x00b4 */ FROscillator RotOscillation;
    /* 0x00d8 */ FVOscillator LocOscillation;
    /* 0x00fc */ FFOscillator FOVOscillation;
    /* 0x0108 */ float AnimPlayRate;
    /* 0x010c */ float AnimScale;
    /* 0x0110 */ float AnimBlendInTime;
    /* 0x0114 */ float AnimBlendOutTime;
    /* 0x0118 */ float RandomAnimSegmentDuration;
    /* 0x0120 */ UCameraAnim* Anim;
    /* 0x0128 */ UCameraAnimationSequence* AnimSequence;
    /* 0x0130 */ bool bRandomAnimSegment;
    /* 0x0134 */ float OscillatorTimeRemaining;
    /* 0x0138 */ UCameraAnimInst* AnimInst;
    /* 0x0180 */ USequenceCameraShakePattern* SequenceShakePattern;

    void BlueprintUpdateCameraShake(float DeltaTime, float Alpha, const FMinimalViewInfo& POV, FMinimalViewInfo& ModifiedPOV);
    bool ReceiveIsFinished() const;
    void ReceivePlayShake(float Scale);
    void ReceiveStopShake(bool bImmediately);
    static UMatineeCameraShake* StartMatineeCameraShake(APlayerCameraManager* PlayerCameraManager, UClass* ShakeClass, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    static UMatineeCameraShake* StartMatineeCameraShakeFromSource(APlayerCameraManager* PlayerCameraManager, UClass* ShakeClass, UCameraShakeSourceComponent* SourceComponent, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
};

// Size: 0x30
class UMatineeCameraShakeFunctionLibrary : public UBlueprintFunctionLibrary {

    static UMatineeCameraShake* Conv_MatineeCameraShake(UCameraShakeBase* CameraShake);
};

// Size: 0x30
class UMatineeCameraShakePattern : public UCameraShakePattern {
};

// Size: 0x30
class UMovieSceneMatineeCameraShakeEvaluator : public UMovieSceneCameraShakeEvaluator {
};

// Size: 0xc0
class UPerlinNoiseCameraShakePattern : public USimpleCameraShakePattern {
    /* 0x0040 */ float LocationAmplitudeMultiplier;
    /* 0x0044 */ float LocationFrequencyMultiplier;
    /* 0x0048 */ FPerlinNoiseShaker X;
    /* 0x0050 */ FPerlinNoiseShaker Y;
    /* 0x0058 */ FPerlinNoiseShaker Z;
    /* 0x0060 */ float RotationAmplitudeMultiplier;
    /* 0x0064 */ float RotationFrequencyMultiplier;
    /* 0x0068 */ FPerlinNoiseShaker Pitch;
    /* 0x0070 */ FPerlinNoiseShaker Yaw;
    /* 0x0078 */ FPerlinNoiseShaker Roll;
    /* 0x0080 */ FPerlinNoiseShaker FOV;
};

// Size: 0x8
struct FPerlinNoiseShaker {
    /* 0x0000 */ float Amplitude;
    /* 0x0004 */ float Frequency;
};

// Size: 0x24
struct FROscillator {
    /* 0x0000 */ FFOscillator Pitch;
    /* 0x000c */ FFOscillator Yaw;
    /* 0x0018 */ FFOscillator Roll;
};

// Size: 0x40
class USimpleCameraShakePattern : public UCameraShakePattern {
    /* 0x0030 */ float Duration;
    /* 0x0034 */ float BlendInTime;
    /* 0x0038 */ float BlendOutTime;
};

// Size: 0xb0
class UTestCameraShake : public UCameraShakeBase {
};

// Size: 0x24
struct FVOscillator {
    /* 0x0000 */ FFOscillator X;
    /* 0x000c */ FFOscillator Y;
    /* 0x0018 */ FFOscillator Z;
};

// Size: 0xc
struct FWaveOscillator {
    /* 0x0000 */ float Amplitude;
    /* 0x0004 */ float Frequency;
    /* 0x0008 */ EInitialWaveOscillatorOffsetType InitialOffsetType;
};

// Size: 0xe0
class UWaveOscillatorCameraShakePattern : public USimpleCameraShakePattern {
    /* 0x0040 */ float LocationAmplitudeMultiplier;
    /* 0x0044 */ float LocationFrequencyMultiplier;
    /* 0x0048 */ FWaveOscillator X;
    /* 0x0054 */ FWaveOscillator Y;
    /* 0x0060 */ FWaveOscillator Z;
    /* 0x006c */ float RotationAmplitudeMultiplier;
    /* 0x0070 */ float RotationFrequencyMultiplier;
    /* 0x0074 */ FWaveOscillator Pitch;
    /* 0x0080 */ FWaveOscillator Yaw;
    /* 0x008c */ FWaveOscillator Roll;
    /* 0x0098 */ FWaveOscillator FOV;
};

enum class EGameplayDebuggerOverrideMode {
    Enable = 0,
    Disable = 1,
    UseDefault = 2,
    EGameplayDebuggerOverrideMode_MAX = 3,
};

// Size: 0x30
struct FGameplayDebuggerCategoryConfig {
    /* 0x0000 */ FString CategoryName;
    /* 0x0010 */ int32_t SlotIdx;
    /* 0x0014 */ EGameplayDebuggerOverrideMode ActiveInGame;
    /* 0x0015 */ EGameplayDebuggerOverrideMode ActiveInSimulate;
    /* 0x0016 */ EGameplayDebuggerOverrideMode Hidden;
    /* 0x0018 */ bool bOverrideSlotIdx;
    /* 0x0020 */ TArray<FGameplayDebuggerInputConfig> InputHandlers;
};

// Size: 0x378
class AGameplayDebuggerCategoryReplicator : public AActor {
    /* 0x02f8 */ APlayerController* OwnerPC;
    /* 0x0300 */ bool bIsEnabled;
    /* 0x0308 */ FGameplayDebuggerNetPack ReplicatedData;
    /* 0x0320 */ FGameplayDebuggerDebugActor DebugActor;
    /* 0x0338 */ FGameplayDebuggerVisLogSync VisLogSync;
    /* 0x0348 */ UGameplayDebuggerRenderingComponent* RenderingComp;

    void ServerSendCategoryInputEvent(int32_t CategoryId, int32_t HandlerId);
    void ServerSendExtensionInputEvent(int32_t ExtensionId, int32_t HandlerId);
    void ServerSetCategoryEnabled(int32_t CategoryId, bool bEnable);
    void ServerSetDebugActor(AActor* Actor, bool bSelectInEditor);
    void ServerSetEnabled(bool bEnable);
};

// Size: 0x2c8
class UGameplayDebuggerConfig : public UObject {
    /* 0x0030 */ FKey ActivationKey;
    /* 0x0050 */ FKey CategoryRowNextKey;
    /* 0x0070 */ FKey CategoryRowPrevKey;
    /* 0x0090 */ FKey CategorySlot0;
    /* 0x00b0 */ FKey CategorySlot1;
    /* 0x00d0 */ FKey CategorySlot2;
    /* 0x00f0 */ FKey CategorySlot3;
    /* 0x0110 */ FKey CategorySlot4;
    /* 0x0130 */ FKey CategorySlot5;
    /* 0x0150 */ FKey CategorySlot6;
    /* 0x0170 */ FKey CategorySlot7;
    /* 0x0190 */ FKey CategorySlot8;
    /* 0x01b0 */ FKey CategorySlot9;
    /* 0x01d0 */ float DebugCanvasPaddingLeft;
    /* 0x01d4 */ float DebugCanvasPaddingRight;
    /* 0x01d8 */ float DebugCanvasPaddingTop;
    /* 0x01dc */ float DebugCanvasPaddingBottom;
    /* 0x01e0 */ bool bDebugCanvasEnableTextShadow;
    /* 0x01e8 */ TArray<FGameplayDebuggerCategoryConfig> Categories;
    /* 0x01f8 */ TArray<FGameplayDebuggerExtensionConfig> Extensions;
};

// Size: 0x18
struct FGameplayDebuggerDebugActor {
    /* 0x0000 */ AActor* Actor;
    /* 0x0008 */ FName ActorName;
    /* 0x0014 */ int32_t SyncCounter;
};

// Size: 0x28
struct FGameplayDebuggerExtensionConfig {
    /* 0x0000 */ FString ExtensionName;
    /* 0x0010 */ EGameplayDebuggerOverrideMode UseExtension;
    /* 0x0018 */ TArray<FGameplayDebuggerInputConfig> InputHandlers;
};

// Size: 0x38
struct FGameplayDebuggerInputConfig {
    /* 0x0000 */ FString ConfigName;
    /* 0x0010 */ FKey Key;
    /* 0x0030 */ bool bModShift;
    /* 0x0030 */ bool bModCtrl;
    /* 0x0030 */ bool bModAlt;
    /* 0x0030 */ bool bModCmd;
};

// Size: 0x140
class UGameplayDebuggerLocalController : public UObject {
    /* 0x0030 */ AGameplayDebuggerCategoryReplicator* CachedReplicator;
    /* 0x0038 */ AGameplayDebuggerPlayerManager* CachedPlayerManager;
    /* 0x0040 */ AActor* DebugActorCandidate;
};

// Size: 0x18
struct FGameplayDebuggerNetPack {
};

// Size: 0x18
struct FGameplayDebuggerPlayerData {
    /* 0x0000 */ UGameplayDebuggerLocalController* Controller;
    /* 0x0008 */ UInputComponent* InputComponent;
    /* 0x0010 */ AGameplayDebuggerCategoryReplicator* Replicator;
};

// Size: 0x320
class AGameplayDebuggerPlayerManager : public AActor {
    /* 0x02f8 */ TArray<FGameplayDebuggerPlayerData> PlayerData;
    /* 0x0308 */ TArray<AGameplayDebuggerCategoryReplicator*> PendingRegistrations;
};

// Size: 0x540
class UGameplayDebuggerRenderingComponent : public UPrimitiveComponent {
};

// Size: 0x10
struct FGameplayDebuggerVisLogSync {
    /* 0x0000 */ FString DeviceIDs;
};

// Size: 0x30
class UBlueprintGameplayTagLibrary : public UBlueprintFunctionLibrary {

    static void AddGameplayTag(FGameplayTagContainer& TagContainer, FGameplayTag Tag);
    static void AppendGameplayTagContainers(FGameplayTagContainer& InOutTagContainer, const FGameplayTagContainer& InTagContainer);
    static void BreakGameplayTagContainer(const FGameplayTagContainer& GameplayTagContainer, TArray<FGameplayTag>& GameplayTags);
    static bool DoesContainerMatchTagQuery(const FGameplayTagContainer& TagContainer, const FGameplayTagQuery& TagQuery);
    static bool DoesTagAssetInterfaceHaveTag(TScriptInterface<IGameplayTagAssetInterface> TagContainerInterface, FGameplayTag Tag);
    static bool EqualEqual_GameplayTag(FGameplayTag A, FGameplayTag B);
    static bool EqualEqual_GameplayTagContainer(const FGameplayTagContainer& A, const FGameplayTagContainer& B);
    static void GetAllActorsOfClassMatchingTagQuery(UObject* WorldContextObject, UClass* ActorClass, const FGameplayTagQuery& GameplayTagQuery, TArray<AActor*>& OutActors);
    static FString GetDebugStringFromGameplayTag(FGameplayTag GameplayTag);
    static FString GetDebugStringFromGameplayTagContainer(const FGameplayTagContainer& TagContainer);
    static int32_t GetNumGameplayTagsInContainer(const FGameplayTagContainer& TagContainer);
    static FName GetTagName(const FGameplayTag& GameplayTag);
    static bool HasAllMatchingGameplayTags(TScriptInterface<IGameplayTagAssetInterface> TagContainerInterface, const FGameplayTagContainer& OtherContainer);
    static bool HasAllTags(const FGameplayTagContainer& TagContainer, const FGameplayTagContainer& OtherContainer, bool bExactMatch);
    static bool HasAnyTags(const FGameplayTagContainer& TagContainer, const FGameplayTagContainer& OtherContainer, bool bExactMatch);
    static bool HasTag(const FGameplayTagContainer& TagContainer, FGameplayTag Tag, bool bExactMatch);
    static bool IsGameplayTagValid(FGameplayTag GameplayTag);
    static bool IsTagQueryEmpty(const FGameplayTagQuery& TagQuery);
    static FGameplayTagContainer MakeGameplayTagContainerFromArray(const TArray<FGameplayTag>& GameplayTags);
    static FGameplayTagContainer MakeGameplayTagContainerFromTag(FGameplayTag SingleTag);
    static FGameplayTagQuery MakeGameplayTagQuery(FGameplayTagQuery TagQuery);
    static FGameplayTag MakeLiteralGameplayTag(FGameplayTag Value);
    static FGameplayTagContainer MakeLiteralGameplayTagContainer(FGameplayTagContainer Value);
    static bool MatchesAnyTags(FGameplayTag TagOne, const FGameplayTagContainer& OtherContainer, bool bExactMatch);
    static bool MatchesTag(FGameplayTag TagOne, FGameplayTag TagTwo, bool bExactMatch);
    static bool NotEqual_GameplayTag(FGameplayTag A, FGameplayTag B);
    static bool NotEqual_GameplayTagContainer(const FGameplayTagContainer& A, const FGameplayTagContainer& B);
    static bool NotEqual_TagContainerTagContainer(FGameplayTagContainer A, FString B);
    static bool NotEqual_TagTag(FGameplayTag A, FString B);
    static bool RemoveGameplayTag(FGameplayTagContainer& TagContainer, FGameplayTag Tag);
};

enum class EGameplayContainerMatchType {
    Any = 0,
    All = 1,
    EGameplayContainerMatchType_MAX = 2,
};

enum class EGameplayTagMatchType {
    Explicit = 0,
    IncludeParentTags = 1,
    EGameplayTagMatchType_MAX = 2,
};

enum class EGameplayTagQueryExprType {
    Undefined = 0,
    AnyTagsMatch = 1,
    AllTagsMatch = 2,
    NoTagsMatch = 3,
    AnyExprMatch = 4,
    AllExprMatch = 5,
    NoExprMatch = 6,
    EGameplayTagQueryExprType_MAX = 7,
};

enum class EGameplayTagSelectionType {
    None = 0,
    NonRestrictedOnly = 1,
    RestrictedOnly = 2,
    All = 3,
    EGameplayTagSelectionType_MAX = 4,
};

enum class EGameplayTagSourceType {
    Native = 0,
    DefaultTagList = 1,
    TagList = 2,
    RestrictedTagList = 3,
    DataTable = 4,
    Invalid = 5,
    EGameplayTagSourceType_MAX = 6,
};

// Size: 0xa0
class UEditableGameplayTagQuery : public UObject {
    /* 0x0030 */ FString UserDescription;
    /* 0x0050 */ UEditableGameplayTagQueryExpression* RootExpression;
    /* 0x0058 */ FGameplayTagQuery TagQueryExportText_Helper;
};

// Size: 0x30
class UEditableGameplayTagQueryExpression : public UObject {
};

// Size: 0x40
class UEditableGameplayTagQueryExpression_AllExprMatch : public UEditableGameplayTagQueryExpression {
    /* 0x0030 */ TArray<UEditableGameplayTagQueryExpression*> Expressions;
};

// Size: 0x50
class UEditableGameplayTagQueryExpression_AllTagsMatch : public UEditableGameplayTagQueryExpression {
    /* 0x0030 */ FGameplayTagContainer Tags;
};

// Size: 0x40
class UEditableGameplayTagQueryExpression_AnyExprMatch : public UEditableGameplayTagQueryExpression {
    /* 0x0030 */ TArray<UEditableGameplayTagQueryExpression*> Expressions;
};

// Size: 0x50
class UEditableGameplayTagQueryExpression_AnyTagsMatch : public UEditableGameplayTagQueryExpression {
    /* 0x0030 */ FGameplayTagContainer Tags;
};

// Size: 0x40
class UEditableGameplayTagQueryExpression_NoExprMatch : public UEditableGameplayTagQueryExpression {
    /* 0x0030 */ TArray<UEditableGameplayTagQueryExpression*> Expressions;
};

// Size: 0x50
class UEditableGameplayTagQueryExpression_NoTagsMatch : public UEditableGameplayTagQueryExpression {
    /* 0x0030 */ FGameplayTagContainer Tags;
};

// Size: 0xc
struct FGameplayTag {
    /* 0x0000 */ FName TagName;
};

// Size: 0x30
class IGameplayTagAssetInterface : public UInterface {

    void GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const;
    bool HasAllMatchingGameplayTags(const FGameplayTagContainer& TagContainer) const;
    bool HasAnyMatchingGameplayTags(const FGameplayTagContainer& TagContainer) const;
    bool HasMatchingGameplayTag(FGameplayTag TagToCheck) const;
};

// Size: 0x20
struct FGameplayTagCategoryRemap {
    /* 0x0000 */ FString BaseCategory;
    /* 0x0010 */ TArray<FString> RemapCategories;
};

// Size: 0x20
struct FGameplayTagContainer {
    /* 0x0000 */ TArray<FGameplayTag> GameplayTags;
    /* 0x0010 */ TArray<FGameplayTag> ParentTags;
};

// Size: 0x1
struct FGameplayTagCreationWidgetHelper {
};

// Size: 0x78
struct FGameplayTagNode {
};

// Size: 0x48
struct FGameplayTagQuery {
    /* 0x0000 */ int32_t TokenStreamVersion;
    /* 0x0008 */ TArray<FGameplayTag> TagDictionary;
    /* 0x0018 */ TArray<uint8_t> QueryTokenStream;
    /* 0x0028 */ FString UserDescription;
    /* 0x0038 */ FString AutoDescription;
};

// Size: 0x18
struct FGameplayTagRedirect {
    /* 0x0000 */ FName OldTagName;
    /* 0x000c */ FName NewTagName;
};

// Size: 0x10
struct FGameplayTagReferenceHelper {
};

// Size: 0x20
struct FGameplayTagSource {
    /* 0x0000 */ FName SourceName;
    /* 0x000c */ EGameplayTagSourceType SourceType;
    /* 0x0010 */ UGameplayTagsList* SourceTagList;
    /* 0x0018 */ URestrictedGameplayTagsList* SourceRestrictedTagList;
};

// Size: 0x28
struct FGameplayTagTableRow : public FTableRowBase {
    /* 0x0008 */ FName Tag;
    /* 0x0018 */ FString DevComment;
};

// Size: 0x80
class UGameplayTagsDeveloperSettings : public UDeveloperSettings {
    /* 0x0060 */ FString DeveloperConfigName;
    /* 0x0070 */ FName FavoriteTagSource;
};

// Size: 0x50
class UGameplayTagsList : public UObject {
    /* 0x0030 */ FString ConfigFileName;
    /* 0x0040 */ TArray<FGameplayTagTableRow> GameplayTagList;
};

// Size: 0x410
class UGameplayTagsManager : public UObject {
    /* 0x02b8 */ TMap<FName, FGameplayTagSource> TagSources;
    /* 0x0400 */ TArray<UDataTable*> GameplayTagTables;
};

// Size: 0xe0
class UGameplayTagsSettings : public UGameplayTagsList {
    /* 0x0050 */ bool ImportTagsFromConfig;
    /* 0x0051 */ bool WarnOnInvalidTags;
    /* 0x0052 */ bool ClearInvalidTags;
    /* 0x0053 */ bool FastReplication;
    /* 0x0058 */ FString InvalidTagCharacters;
    /* 0x0068 */ TArray<FGameplayTagCategoryRemap> CategoryRemapping;
    /* 0x0078 */ TArray<FSoftObjectPath> GameplayTagTableList;
    /* 0x0088 */ TArray<FGameplayTagRedirect> GameplayTagRedirects;
    /* 0x0098 */ TArray<FName> CommonlyReplicatedTags;
    /* 0x00a8 */ int32_t NumBitsForContainerSize;
    /* 0x00ac */ int32_t NetIndexFirstBitSegment;
    /* 0x00b0 */ TArray<FRestrictedConfigInfo> RestrictedConfigFiles;
    /* 0x00c0 */ FString RestrictedTagList;
};

// Size: 0x20
struct FRestrictedConfigInfo {
    /* 0x0000 */ FString RestrictedConfigName;
    /* 0x0010 */ TArray<FString> Owners;
};

// Size: 0x30
struct FRestrictedGameplayTagTableRow : public FGameplayTagTableRow {
    /* 0x0028 */ bool bAllowNonRestrictedChildren;
};

// Size: 0x50
class URestrictedGameplayTagsList : public UObject {
    /* 0x0030 */ FString ConfigFileName;
    /* 0x0040 */ TArray<FRestrictedGameplayTagTableRow> RestrictedGameplayTagList;
};

// Size: 0x30
class UGameplayTagSearchFilter : public UContentBrowserFrontEndFilterExtension {
};

// Size: 0xc8
class UGameplayTagsK2Node_LiteralGameplayTag : public UK2Node {
};

// Size: 0xe0
class UGameplayTagsK2Node_MultiCompareBase : public UK2Node {
    /* 0x00c8 */ int32_t NumberOfPins;
    /* 0x00d0 */ TArray<FName> PinNames;
};

// Size: 0xe0
class UGameplayTagsK2Node_MultiCompareGameplayTagAssetInterface : public UGameplayTagsK2Node_MultiCompareBase {
};

// Size: 0xe0
class UGameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags : public UGameplayTagsK2Node_MultiCompareBase {
};

// Size: 0xe0
class UGameplayTagsK2Node_MultiCompareGameplayTagContainer : public UGameplayTagsK2Node_MultiCompareBase {
};

// Size: 0xe0
class UGameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags : public UGameplayTagsK2Node_MultiCompareBase {
};

// Size: 0x108
class UGameplayTagsK2Node_SwitchGameplayTag : public UK2Node_Switch {
    /* 0x00e8 */ TArray<FGameplayTag> PinTags;
    /* 0x00f8 */ TArray<FName> PinNames;
};

// Size: 0x108
class UGameplayTagsK2Node_SwitchGameplayTagContainer : public UK2Node_Switch {
    /* 0x00e8 */ TArray<FGameplayTagContainer> PinContainers;
    /* 0x00f8 */ TArray<FName> PinNames;
};

enum class EGameplayTaskRunResult {
    Error = 0,
    Failed = 1,
    Success_Paused = 2,
    Success_Active = 3,
    Success_Finished = 4,
    EGameplayTaskRunResult_MAX = 5,
};

enum class EGameplayTaskState {
    Uninitialized = 0,
    AwaitingActivation = 1,
    Paused = 2,
    Active = 3,
    Finished = 4,
    EGameplayTaskState_MAX = 5,
};

enum class ETaskResourceOverlapPolicy {
    StartOnTop = 0,
    StartAtEnd = 1,
    ETaskResourceOverlapPolicy_MAX = 2,
};

// Size: 0x2
struct FGameplayResourceSet {
};

// Size: 0x80
class UGameplayTask : public UObject {
    /* 0x0038 */ FName InstanceName;
    /* 0x0046 */ ETaskResourceOverlapPolicy ResourceOverlapPolicy;
    /* 0x0068 */ UGameplayTask* ChildTask;

    void EndTask();
    void GenericGameplayTaskDelegate__DelegateSignature();
    void ReadyForActivation();
};

// Size: 0x30
class IGameplayTaskOwnerInterface : public UInterface {
};

// Size: 0x40
class UGameplayTaskResource : public UObject {
    /* 0x0030 */ int32_t ManualResourceID;
    /* 0x0034 */ int8_t AutoResourceID;
    /* 0x0038 */ bool bManuallySetID;
};

// Size: 0x80
class UGameplayTask_ClaimResource : public UGameplayTask {

    static UGameplayTask_ClaimResource* ClaimResource(TScriptInterface<IGameplayTaskOwnerInterface> InTaskOwner, UClass* ResourceClass, const uint8_t Priority, const FName TaskInstanceName);
    static UGameplayTask_ClaimResource* ClaimResources(TScriptInterface<IGameplayTaskOwnerInterface> InTaskOwner, TArray<UClass*> ResourceClasses, const uint8_t Priority, const FName TaskInstanceName);
};

// Size: 0xc0
class UGameplayTask_SpawnActor : public UGameplayTask {
    /* 0x0080 */ FMulticastInlineDelegate Success;
    /* 0x0090 */ FMulticastInlineDelegate DidNotSpawn;
    /* 0x00b8 */ UClass* ClassToSpawn;

    bool BeginSpawningActor(UObject* WorldContextObject, AActor*& SpawnedActor);
    void FinishSpawningActor(UObject* WorldContextObject, AActor* SpawnedActor);
    static UGameplayTask_SpawnActor* SpawnActor(TScriptInterface<IGameplayTaskOwnerInterface> TaskOwner, FVector SpawnLocation, FRotator SpawnRotation, UClass* Class, bool bSpawnOnlyOnAuthority);
};

// Size: 0xb0
class UGameplayTask_TimeLimitedExecution : public UGameplayTask {
    /* 0x0080 */ FMulticastInlineDelegate OnFinished;
    /* 0x0090 */ FMulticastInlineDelegate OnTimeExpired;

    void TaskFinishDelegate__DelegateSignature();
};

// Size: 0x98
class UGameplayTask_WaitDelay : public UGameplayTask {
    /* 0x0080 */ FMulticastInlineDelegate OnFinish;

    void TaskDelayDelegate__DelegateSignature();
    static UGameplayTask_WaitDelay* TaskWaitDelay(TScriptInterface<IGameplayTaskOwnerInterface> TaskOwner, float Time, const uint8_t Priority);
};

// Size: 0x130
class UGameplayTasksComponent : public UActorComponent {
    /* 0x00cc */ bool bIsNetDirty;
    /* 0x00d0 */ TArray<UGameplayTask*> SimulatedTasks;
    /* 0x00e0 */ TArray<UGameplayTask*> TaskPriorityQueue;
    /* 0x0100 */ TArray<UGameplayTask*> TickingTasks;
    /* 0x0110 */ TArray<UGameplayTask*> KnownTasks;
    /* 0x0120 */ FMulticastInlineDelegate OnClaimedResourcesChange;

    static EGameplayTaskRunResult K2_RunGameplayTask(TScriptInterface<IGameplayTaskOwnerInterface> TaskOwner, UGameplayTask* Task, uint8_t Priority, TArray<UClass*> AdditionalRequiredResources, TArray<UClass*> AdditionalClaimedResources);
    void OnRep_SimulatedTasks();
};

// Size: 0x108
class UK2Node_LatentGameplayTaskCall : public UK2Node_BaseAsyncTask {
    /* 0x00f8 */ TArray<FName> SpawnParamPins;
};

// Size: 0x88
class UGeometryCache : public UObject {
    /* 0x0038 */ UAssetImportData* AssetImportData;
    /* 0x0040 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x0048 */ TArray<UMaterialInterface*> Materials;
    /* 0x0058 */ TArray<UGeometryCacheTrack*> Tracks;
    /* 0x0078 */ int32_t StartFrame;
    /* 0x007c */ int32_t EndFrame;
    /* 0x0080 */ uint64_t Hash;
};

// Size: 0x300
class AGeometryCacheActor : public AActor {
    /* 0x02f8 */ UGeometryCacheComponent* GeometryCacheComponent;

    UGeometryCacheComponent* GetGeometryCacheComponent() const;
};

// Size: 0x48
class UGeometryCacheCodecBase : public UObject {
    /* 0x0038 */ TArray<int32_t> TopologyRanges;
};

// Size: 0x60
class UGeometryCacheCodecRaw : public UGeometryCacheCodecBase {
    /* 0x0048 */ int32_t DummyProperty;
};

// Size: 0x70
class UGeometryCacheCodecV1 : public UGeometryCacheCodecBase {
};

// Size: 0x560
class UGeometryCacheComponent : public UMeshComponent {
    /* 0x0500 */ UGeometryCache* GeometryCache;
    /* 0x0508 */ bool bRunning;
    /* 0x0509 */ bool bLooping;
    /* 0x050a */ bool bExtrapolateFrames;
    /* 0x050c */ float StartTimeOffset;
    /* 0x0510 */ float PlaybackSpeed;
    /* 0x0514 */ float MotionVectorScale;
    /* 0x0518 */ int32_t NumTracks;
    /* 0x051c */ float ElapsedTime;
    /* 0x0554 */ float Duration;
    /* 0x0558 */ bool bManualTick;

    float GetAnimationTime() const;
    float GetDuration() const;
    float GetMotionVectorScale() const;
    int32_t GetNumberOfFrames() const;
    float GetPlaybackDirection() const;
    float GetPlaybackSpeed() const;
    float GetStartTimeOffset() const;
    bool IsExtrapolatingFrames() const;
    bool IsLooping() const;
    bool IsPlaying() const;
    bool IsPlayingReversed() const;
    void Pause();
    void Play();
    void PlayFromStart();
    void PlayReversed();
    void PlayReversedFromEnd();
    void SetExtrapolateFrames(const bool bNewExtrapolating);
    bool SetGeometryCache(UGeometryCache* NewGeomCache);
    void SetLooping(const bool bNewLooping);
    void SetMotionVectorScale(const float NewMotionVectorScale);
    void SetPlaybackSpeed(const float NewPlaybackSpeed);
    void SetStartTimeOffset(const float NewStartTimeOffset);
    void Stop();
    void TickAtThisTime(const float Time, bool bInIsRunning, bool bInBackwards, bool bInIsLooping);
};

// Size: 0xc
struct FGeometryCacheMeshBatchInfo {
};

// Size: 0xb0
struct FGeometryCacheMeshData {
};

// Size: 0x60
class UGeometryCacheTrack : public UObject {
    /* 0x0030 */ float Duration;
};

// Size: 0xf0
class UGeometryCacheTrackStreamable : public UGeometryCacheTrack {
    /* 0x0060 */ UGeometryCacheCodecBase* Codec;
    /* 0x00e0 */ float StartSampleTime;
};

// Size: 0x88
class UGeometryCacheTrack_FlipbookAnimation : public UGeometryCacheTrack {
    /* 0x0060 */ uint32_t NumMeshSamples;

    void AddMeshSample(const FGeometryCacheMeshData& MeshData, const float SampleTime);
};

// Size: 0x110
class UGeometryCacheTrack_TransformAnimation : public UGeometryCacheTrack {

    void SetMesh(const FGeometryCacheMeshData& NewMeshData);
};

// Size: 0x110
class UGeometryCacheTrack_TransformGroupAnimation : public UGeometryCacheTrack {

    void SetMesh(const FGeometryCacheMeshData& NewMeshData);
};

// Size: 0x8
struct FGeometryCacheVertexInfo {
};

// Size: 0x70
struct FTrackRenderData {
};

// Size: 0x78
class UActorFactoryGeometryCache : public UActorFactory {
};

// Size: 0x40
class UGeometryCacheThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x48
struct FMovieSceneGeometryCacheParams {
    /* 0x0000 */ UGeometryCache* GeometryCacheAsset;
    /* 0x0008 */ FFrameNumber FirstLoopStartFrameOffset;
    /* 0x000c */ FFrameNumber StartFrameOffset;
    /* 0x0010 */ FFrameNumber EndFrameOffset;
    /* 0x0014 */ float PlayRate;
    /* 0x0018 */ bool bReverse;
    /* 0x001c */ float StartOffset;
    /* 0x0020 */ float EndOffset;
    /* 0x0028 */ FSoftObjectPath GeometryCache;
};

// Size: 0x178
class UMovieSceneGeometryCacheSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneGeometryCacheParams Params;
};

// Size: 0x70
struct FMovieSceneGeometryCacheSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneGeometryCacheSectionTemplateParameters Params;
};

// Size: 0x50
struct FMovieSceneGeometryCacheSectionTemplateParameters : public FMovieSceneGeometryCacheParams {
    /* 0x0048 */ FFrameNumber SectionStartTime;
    /* 0x004c */ FFrameNumber SectionEndTime;
};

// Size: 0xf0
class UMovieSceneGeometryCacheTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> AnimationSections;
};

// Size: 0x78
class UActorFactoryGeometryCollection : public UActorFactory {
};

// Size: 0xa0
class UGeometryCollectionCacheFactory : public UFactory {
    /* 0x0088 */ UGeometryCollection* TargetCollection;
};

// Size: 0x88
class UGeometryCollectionFactory : public UFactory {
};

// Size: 0x40
class UGeometryCollectionThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x1c
struct FChaosBreakingEventData {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FVector Velocity;
    /* 0x0018 */ float Mass;
};

// Size: 0x18
struct FChaosBreakingEventRequestSettings {
    /* 0x0000 */ int32_t MaxNumberOfResults;
    /* 0x0004 */ float MinRadius;
    /* 0x0008 */ float MinSpeed;
    /* 0x000c */ float MinMass;
    /* 0x0010 */ float MaxDistance;
    /* 0x0014 */ EChaosBreakingSortMethod SortMethod;
};

// Size: 0x58
struct FChaosCollisionEventData {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FVector Normal;
    /* 0x0018 */ FVector Velocity1;
    /* 0x0024 */ FVector Velocity2;
    /* 0x0030 */ float Mass1;
    /* 0x0034 */ float Mass2;
    /* 0x0038 */ FVector Impulse;
};

// Size: 0x18
struct FChaosCollisionEventRequestSettings {
    /* 0x0000 */ int32_t MaxNumberResults;
    /* 0x0004 */ float MinMass;
    /* 0x0008 */ float MinSpeed;
    /* 0x000c */ float MinImpulse;
    /* 0x0010 */ float MaxDistance;
    /* 0x0014 */ EChaosCollisionSortMethod SortMethod;
};

// Size: 0x450
class UChaosDestructionListener : public USceneComponent {
    /* 0x0228 */ bool bIsCollisionEventListeningEnabled;
    /* 0x0228 */ bool bIsBreakingEventListeningEnabled;
    /* 0x0228 */ bool bIsTrailingEventListeningEnabled;
    /* 0x022c */ FChaosCollisionEventRequestSettings CollisionEventRequestSettings;
    /* 0x0244 */ FChaosBreakingEventRequestSettings BreakingEventRequestSettings;
    /* 0x025c */ FChaosTrailingEventRequestSettings TrailingEventRequestSettings;
    /* 0x0278 */ TSet<AChaosSolverActor*> ChaosSolverActors;
    /* 0x02c8 */ TSet<AGeometryCollectionActor*> GeometryCollectionActors;
    /* 0x0318 */ FMulticastInlineDelegate OnCollisionEvents;
    /* 0x0328 */ FMulticastInlineDelegate OnBreakingEvents;
    /* 0x0338 */ FMulticastInlineDelegate OnTrailingEvents;

    void AddChaosSolverActor(AChaosSolverActor* ChaosSolverActor);
    void AddGeometryCollectionActor(AGeometryCollectionActor* GeometryCollectionActor);
    bool IsEventListening() const;
    void RemoveChaosSolverActor(AChaosSolverActor* ChaosSolverActor);
    void RemoveGeometryCollectionActor(AGeometryCollectionActor* GeometryCollectionActor);
    void SetBreakingEventEnabled(bool bIsEnabled);
    void SetBreakingEventRequestSettings(const FChaosBreakingEventRequestSettings& InSettings);
    void SetCollisionEventEnabled(bool bIsEnabled);
    void SetCollisionEventRequestSettings(const FChaosCollisionEventRequestSettings& InSettings);
    void SetTrailingEventEnabled(bool bIsEnabled);
    void SetTrailingEventRequestSettings(const FChaosTrailingEventRequestSettings& InSettings);
    void SortBreakingEvents(TArray<FChaosBreakingEventData>& BreakingEvents, EChaosBreakingSortMethod SortMethod);
    void SortCollisionEvents(TArray<FChaosCollisionEventData>& CollisionEvents, EChaosCollisionSortMethod SortMethod);
    void SortTrailingEvents(TArray<FChaosTrailingEventData>& TrailingEvents, EChaosTrailingSortMethod SortMethod);
};

// Size: 0x2c
struct FChaosTrailingEventData {
    /* 0x0000 */ FVector Location;
    /* 0x000c */ FVector Velocity;
    /* 0x0018 */ FVector AngularVelocity;
    /* 0x0024 */ float Mass;
    /* 0x0028 */ int32_t ParticleIndex;
};

// Size: 0x18
struct FChaosTrailingEventRequestSettings {
    /* 0x0000 */ int32_t MaxNumberOfResults;
    /* 0x0004 */ float MinMass;
    /* 0x0008 */ float MinSpeed;
    /* 0x000c */ float MinAngularSpeed;
    /* 0x0010 */ float MaxDistance;
    /* 0x0014 */ EChaosTrailingSortMethod SortMethod;
};

enum class EChaosBreakingSortMethod {
    SortNone = 0,
    SortByHighestMass = 1,
    SortByHighestSpeed = 2,
    SortByNearestFirst = 3,
    Count = 4,
    EChaosBreakingSortMethod_MAX = 5,
};

enum class EChaosCollisionSortMethod {
    SortNone = 0,
    SortByHighestMass = 1,
    SortByHighestSpeed = 2,
    SortByHighestImpulse = 3,
    SortByNearestFirst = 4,
    Count = 5,
    EChaosCollisionSortMethod_MAX = 6,
};

enum class EChaosTrailingSortMethod {
    SortNone = 0,
    SortByHighestMass = 1,
    SortByHighestSpeed = 2,
    SortByNearestFirst = 3,
    Count = 4,
    EChaosTrailingSortMethod_MAX = 5,
};

enum class ECollectionAttributeEnum {
    Chaos_Active = 0,
    Chaos_DynamicState = 1,
    Chaos_CollisionGroup = 2,
    Chaos_Max = 3,
    Chaos_Max = 4,
};

enum class ECollectionGroupEnum {
    Chaos_Traansform = 0,
    Chaos_Max = 1,
    Chaos_Max = 2,
};

enum class EGeometryCollectionDebugDrawActorHideGeometry {
    HideNone = 0,
    HideWithCollision = 1,
    HideSelected = 2,
    HideWholeCollection = 3,
    HideAll = 4,
    EGeometryCollectionDebugDrawActorHideGeometry_MAX = 5,
};

// Size: 0x50
struct FGeomComponentCacheParameters {
    /* 0x0000 */ EGeometryCollectionCacheType CacheMode;
    /* 0x0008 */ UGeometryCollectionCache* TargetCache;
    /* 0x0010 */ float ReverseCacheBeginTime;
    /* 0x0014 */ bool SaveCollisionData;
    /* 0x0015 */ bool DoGenerateCollisionData;
    /* 0x0018 */ int32_t CollisionDataSizeMax;
    /* 0x001c */ bool DoCollisionDataSpatialHash;
    /* 0x0020 */ float CollisionDataSpatialHashRadius;
    /* 0x0024 */ int32_t MaxCollisionPerCell;
    /* 0x0028 */ bool SaveBreakingData;
    /* 0x0029 */ bool DoGenerateBreakingData;
    /* 0x002c */ int32_t BreakingDataSizeMax;
    /* 0x0030 */ bool DoBreakingDataSpatialHash;
    /* 0x0034 */ float BreakingDataSpatialHashRadius;
    /* 0x0038 */ int32_t MaxBreakingPerCell;
    /* 0x003c */ bool SaveTrailingData;
    /* 0x003d */ bool DoGenerateTrailingData;
    /* 0x0040 */ int32_t TrailingDataSizeMax;
    /* 0x0044 */ float TrailingMinSpeedThreshold;
    /* 0x0048 */ float TrailingMinVolumeThreshold;
};

// Size: 0x140
class UGeometryCollection : public UObject {
    /* 0x0040 */ bool EnableClustering;
    /* 0x0044 */ int32_t ClusterGroupIndex;
    /* 0x0048 */ int32_t MaxClusterLevel;
    /* 0x0050 */ TArray<float> DamageThreshold;
    /* 0x0060 */ EClusterConnectionTypeEnum ClusterConnectionType;
    /* 0x0068 */ TArray<FGeometryCollectionSource> GeometrySource;
    /* 0x0078 */ TArray<UMaterialInterface*> Materials;
    /* 0x0088 */ ECollisionTypeEnum CollisionType;
    /* 0x0089 */ EImplicitTypeEnum ImplicitType;
    /* 0x008c */ int32_t MinLevelSetResolution;
    /* 0x0090 */ int32_t MaxLevelSetResolution;
    /* 0x0094 */ int32_t MinClusterLevelSetResolution;
    /* 0x0098 */ int32_t MaxClusterLevelSetResolution;
    /* 0x009c */ float CollisionObjectReductionPercentage;
    /* 0x00a0 */ bool bMassAsDensity;
    /* 0x00a4 */ float Mass;
    /* 0x00a8 */ float MinimumMassClamp;
    /* 0x00ac */ float CollisionParticlesFraction;
    /* 0x00b0 */ int32_t MaximumCollisionParticles;
    /* 0x00b8 */ TArray<FGeometryCollectionSizeSpecificData> SizeSpecificData;
    /* 0x00c8 */ bool EnableRemovePiecesOnFracture;
    /* 0x00d0 */ TArray<UMaterialInterface*> RemoveOnFractureMaterials;
    /* 0x00e0 */ UThumbnailInfo* ThumbnailInfo;
    /* 0x00e8 */ FGuid PersistentGuid;
    /* 0x00f8 */ FGuid StateGuid;
    /* 0x0128 */ int32_t BoneSelectedMaterialIndex;
};

// Size: 0x308
class AGeometryCollectionActor : public AActor {
    /* 0x02f8 */ UGeometryCollectionComponent* GeometryCollectionComponent;
    /* 0x0300 */ UGeometryCollectionDebugDrawComponent* GeometryCollectionDebugDrawComponent;

    bool RaycastSingle(FVector Start, FVector End, FHitResult& OutHit) const;
};

// Size: 0x58
class UGeometryCollectionCache : public UObject {
    /* 0x0030 */ FRecordedTransformTrack RecordedData;
    /* 0x0040 */ UGeometryCollection* SupportedCollection;
    /* 0x0048 */ FGuid CompatibleCollectionState;
};

// Size: 0x9f0
class UGeometryCollectionComponent : public UMeshComponent {
    /* 0x0508 */ AChaosSolverActor* ChaosSolverActor;
    /* 0x05f0 */ UGeometryCollection* RestCollection;
    /* 0x05f8 */ TArray<AFieldSystemActor*> InitializationFields;
    /* 0x0608 */ bool Simulating;
    /* 0x0610 */ EObjectStateTypeEnum ObjectType;
    /* 0x0611 */ bool EnableClustering;
    /* 0x0614 */ int32_t ClusterGroupIndex;
    /* 0x0618 */ int32_t MaxClusterLevel;
    /* 0x0620 */ TArray<float> DamageThreshold;
    /* 0x0630 */ EClusterConnectionTypeEnum ClusterConnectionType;
    /* 0x0634 */ int32_t CollisionGroup;
    /* 0x0638 */ float CollisionSampleFraction;
    /* 0x063c */ float LinearEtherDrag;
    /* 0x0640 */ float AngularEtherDrag;
    /* 0x0648 */ UChaosPhysicalMaterial* PhysicalMaterial;
    /* 0x0650 */ EInitialVelocityTypeEnum InitialVelocityType;
    /* 0x0654 */ FVector InitialLinearVelocity;
    /* 0x0660 */ FVector InitialAngularVelocity;
    /* 0x0670 */ UPhysicalMaterial* PhysicalMaterialOverride;
    /* 0x0678 */ FGeomComponentCacheParameters CacheParameters;
    /* 0x06c8 */ FMulticastInlineDelegate NotifyGeometryCollectionPhysicsStateChange;
    /* 0x06d8 */ FMulticastInlineDelegate NotifyGeometryCollectionPhysicsLoadingStateChange;
    /* 0x0700 */ FMulticastInlineDelegate OnChaosBreakEvent;
    /* 0x0710 */ float DesiredCacheTime;
    /* 0x0714 */ bool CachePlayback;
    /* 0x0718 */ FMulticastInlineDelegate OnChaosPhysicsCollision;
    /* 0x0728 */ bool bNotifyBreaks;
    /* 0x0729 */ bool bNotifyCollisions;
    /* 0x072a */ bool bEnableReplication;
    /* 0x072b */ bool bEnableAbandonAfterLevel;
    /* 0x072c */ int32_t ReplicationAbandonClusterLevel;
    /* 0x0730 */ FGeometryCollectionRepData RepData;
    /* 0x0788 */ TArray<int32_t> SelectedBones;
    /* 0x0798 */ TArray<int32_t> HighlightedBones;
    /* 0x09b8 */ UBodySetup* DummyBodySetup;
    /* 0x09c0 */ AActor* EditorActor;

    void ApplyKinematicField(float Radius, FVector Position);
    void ApplyPhysicsField(bool Enabled, EGeometryCollectionPhysicsTypeEnum Target, UFieldSystemMetaData* MetaData, UFieldNodeBase* Field);
    void NetAbandonCluster(int32_t TransformIndex);
    void NotifyGeometryCollectionPhysicsLoadingStateChange__DelegateSignature(UGeometryCollectionComponent* FracturedComponent);
    void NotifyGeometryCollectionPhysicsStateChange__DelegateSignature(UGeometryCollectionComponent* FracturedComponent);
    void OnRep_RepData(const FGeometryCollectionRepData& OldData);
    void ReceivePhysicsCollision(const FChaosPhysicsCollisionInfo& CollisionInfo);
    void SetNotifyBreaks(bool bNewNotifyBreaks);
};

// Size: 0x3e0
class AGeometryCollectionDebugDrawActor : public AActor {
    /* 0x02f8 */ FGeometryCollectionDebugDrawWarningMessage WarningMessage;
    /* 0x0300 */ FGeometryCollectionDebugDrawActorSelectedRigidBody SelectedRigidBody;
    /* 0x0318 */ bool bDebugDrawWholeCollection;
    /* 0x0319 */ bool bDebugDrawHierarchy;
    /* 0x031a */ bool bDebugDrawClustering;
    /* 0x031b */ EGeometryCollectionDebugDrawActorHideGeometry HideGeometry;
    /* 0x031c */ bool bShowRigidBodyId;
    /* 0x031d */ bool bShowRigidBodyCollision;
    /* 0x031e */ bool bCollisionAtOrigin;
    /* 0x031f */ bool bShowRigidBodyTransform;
    /* 0x0320 */ bool bShowRigidBodyInertia;
    /* 0x0321 */ bool bShowRigidBodyVelocity;
    /* 0x0322 */ bool bShowRigidBodyForce;
    /* 0x0323 */ bool bShowRigidBodyInfos;
    /* 0x0324 */ bool bShowTransformIndex;
    /* 0x0325 */ bool bShowTransform;
    /* 0x0326 */ bool bShowParent;
    /* 0x0327 */ bool bShowLevel;
    /* 0x0328 */ bool bShowConnectivityEdges;
    /* 0x0329 */ bool bShowGeometryIndex;
    /* 0x032a */ bool bShowGeometryTransform;
    /* 0x032b */ bool bShowBoundingBox;
    /* 0x032c */ bool bShowFaces;
    /* 0x032d */ bool bShowFaceIndices;
    /* 0x032e */ bool bShowFaceNormals;
    /* 0x032f */ bool bShowSingleFace;
    /* 0x0330 */ int32_t SingleFaceIndex;
    /* 0x0334 */ bool bShowVertices;
    /* 0x0335 */ bool bShowVertexIndices;
    /* 0x0336 */ bool bShowVertexNormals;
    /* 0x0337 */ bool bUseActiveVisualization;
    /* 0x0338 */ float PointThickness;
    /* 0x033c */ float LineThickness;
    /* 0x0340 */ bool bTextShadow;
    /* 0x0344 */ float TextScale;
    /* 0x0348 */ float NormalScale;
    /* 0x034c */ float AxisScale;
    /* 0x0350 */ float ArrowScale;
    /* 0x0354 */ FColor RigidBodyIdColor;
    /* 0x0358 */ float RigidBodyTransformScale;
    /* 0x035c */ FColor RigidBodyCollisionColor;
    /* 0x0360 */ FColor RigidBodyInertiaColor;
    /* 0x0364 */ FColor RigidBodyVelocityColor;
    /* 0x0368 */ FColor RigidBodyForceColor;
    /* 0x036c */ FColor RigidBodyInfoColor;
    /* 0x0370 */ FColor TransformIndexColor;
    /* 0x0374 */ float TransformScale;
    /* 0x0378 */ FColor LevelColor;
    /* 0x037c */ FColor ParentColor;
    /* 0x0380 */ float ConnectivityEdgeThickness;
    /* 0x0384 */ FColor GeometryIndexColor;
    /* 0x0388 */ float GeometryTransformScale;
    /* 0x038c */ FColor BoundingBoxColor;
    /* 0x0390 */ FColor FaceColor;
    /* 0x0394 */ FColor FaceIndexColor;
    /* 0x0398 */ FColor FaceNormalColor;
    /* 0x039c */ FColor SingleFaceColor;
    /* 0x03a0 */ FColor VertexColor;
    /* 0x03a4 */ FColor VertexIndexColor;
    /* 0x03a8 */ FColor VertexNormalColor;
    /* 0x03b0 */ UBillboardComponent* SpriteComponent;
};

// Size: 0x18
struct FGeometryCollectionDebugDrawActorSelectedRigidBody {
    /* 0x0000 */ int32_t ID;
    /* 0x0008 */ AChaosSolverActor* Solver;
    /* 0x0010 */ AGeometryCollectionActor* GeometryCollection;
};

// Size: 0x6b0
class UGeometryCollectionDebugDrawComponent : public UActorComponent {
    /* 0x00c0 */ AGeometryCollectionDebugDrawActor* GeometryCollectionDebugDrawActor;
    /* 0x00c8 */ AGeometryCollectionRenderLevelSetActor* GeometryCollectionRenderLevelSetActor;
};

// Size: 0x1
struct FGeometryCollectionDebugDrawWarningMessage {
};

// Size: 0x390
class AGeometryCollectionRenderLevelSetActor : public AActor {
    /* 0x02f8 */ UVolumeTexture* TargetVolumeTexture;
    /* 0x0300 */ UMaterial* RayMarchMaterial;
    /* 0x0308 */ float SurfaceTolerance;
    /* 0x030c */ float Isovalue;
    /* 0x0310 */ bool Enabled;
    /* 0x0311 */ bool RenderVolumeBoundingBox;
};

// Size: 0x18
struct FGeometryCollectionRepData {
};

// Size: 0x24
struct FGeometryCollectionSizeSpecificData {
    /* 0x0000 */ float MaxSize;
    /* 0x0004 */ ECollisionTypeEnum CollisionType;
    /* 0x0005 */ EImplicitTypeEnum ImplicitType;
    /* 0x0008 */ int32_t MinLevelSetResolution;
    /* 0x000c */ int32_t MaxLevelSetResolution;
    /* 0x0010 */ int32_t MinClusterLevelSetResolution;
    /* 0x0014 */ int32_t MaxClusterLevelSetResolution;
    /* 0x0018 */ int32_t CollisionObjectReductionPercentage;
    /* 0x001c */ float CollisionParticlesFraction;
    /* 0x0020 */ int32_t MaximumCollisionParticles;
};

// Size: 0x60
struct FGeometryCollectionSource {
    /* 0x0000 */ FSoftObjectPath SourceGeometryObject;
    /* 0x0020 */ FTransform LocalTransform;
    /* 0x0050 */ TArray<UMaterialInterface*> SourceMaterial;
};

// Size: 0x148
class USkeletalMeshSimulationComponent : public UActorComponent {
    /* 0x00c8 */ UChaosPhysicalMaterial* PhysicalMaterial;
    /* 0x00d0 */ AChaosSolverActor* ChaosSolverActor;
    /* 0x00d8 */ UPhysicsAsset* OverridePhysicsAsset;
    /* 0x00e0 */ bool bSimulating;
    /* 0x00e1 */ bool bNotifyCollisions;
    /* 0x00e2 */ EObjectStateTypeEnum ObjectType;
    /* 0x00e4 */ float Density;
    /* 0x00e8 */ float MinMass;
    /* 0x00ec */ float MaxMass;
    /* 0x00f0 */ ECollisionTypeEnum CollisionType;
    /* 0x00f4 */ float ImplicitShapeParticlesPerUnitArea;
    /* 0x00f8 */ int32_t ImplicitShapeMinNumParticles;
    /* 0x00fc */ int32_t ImplicitShapeMaxNumParticles;
    /* 0x0100 */ int32_t MinLevelSetResolution;
    /* 0x0104 */ int32_t MaxLevelSetResolution;
    /* 0x0108 */ int32_t CollisionGroup;
    /* 0x010c */ EInitialVelocityTypeEnum InitialVelocityType;
    /* 0x0110 */ FVector InitialLinearVelocity;
    /* 0x011c */ FVector InitialAngularVelocity;
    /* 0x0128 */ FMulticastInlineDelegate OnChaosPhysicsCollision;

    void ReceivePhysicsCollision(const FChaosPhysicsCollisionInfo& CollisionInfo);
};

// Size: 0x148
class UStaticMeshSimulationComponent : public UActorComponent {
    /* 0x00c8 */ bool Simulating;
    /* 0x00c9 */ bool bNotifyCollisions;
    /* 0x00ca */ EObjectStateTypeEnum ObjectType;
    /* 0x00cc */ float Mass;
    /* 0x00d0 */ ECollisionTypeEnum CollisionType;
    /* 0x00d1 */ EImplicitTypeEnum ImplicitType;
    /* 0x00d4 */ int32_t MinLevelSetResolution;
    /* 0x00d8 */ int32_t MaxLevelSetResolution;
    /* 0x00dc */ EInitialVelocityTypeEnum InitialVelocityType;
    /* 0x00e0 */ FVector InitialLinearVelocity;
    /* 0x00ec */ FVector InitialAngularVelocity;
    /* 0x00f8 */ float DamageThreshold;
    /* 0x0100 */ UChaosPhysicalMaterial* PhysicalMaterial;
    /* 0x0108 */ AChaosSolverActor* ChaosSolverActor;
    /* 0x0110 */ FMulticastInlineDelegate OnChaosPhysicsCollision;
    /* 0x0130 */ TArray<UPrimitiveComponent*> SimulatedComponents;

    void ForceRecreatePhysicsState();
    void ReceivePhysicsCollision(const FChaosPhysicsCollisionInfo& CollisionInfo);
};

// Size: 0x38
struct FMovieSceneGeometryCollectionParams {
    /* 0x0008 */ FSoftObjectPath GeometryCollectionCache;
    /* 0x0028 */ FFrameNumber StartFrameOffset;
    /* 0x002c */ FFrameNumber EndFrameOffset;
    /* 0x0030 */ float PlayRate;
};

// Size: 0x168
class UMovieSceneGeometryCollectionSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneGeometryCollectionParams Params;
};

// Size: 0x60
struct FMovieSceneGeometryCollectionSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneGeometryCollectionSectionTemplateParameters Params;
};

// Size: 0x40
struct FMovieSceneGeometryCollectionSectionTemplateParameters : public FMovieSceneGeometryCollectionParams {
    /* 0x0038 */ FFrameNumber SectionStartTime;
    /* 0x003c */ FFrameNumber SectionEndTime;
};

// Size: 0xf0
class UMovieSceneGeometryCollectionTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> AnimationSections;
};

// Size: 0x38
class UBrushEditingSubsystemImpl : public UBrushEditingSubsystem {
};

// Size: 0x78
class UGeomModifier : public UObject {
    /* 0x0030 */ FText Description;
    /* 0x0048 */ FText Tooltip;
    /* 0x0060 */ FName ToolbarIconName;
    /* 0x006c */ bool bPushButton;
    /* 0x006c */ bool bInitialized;
    /* 0x006c */ bool bPendingPivotOffsetUpdate;
    /* 0x006c */ bool bAppearsInToolbar;
    /* 0x0070 */ UPolys* CachedPolys;
};

// Size: 0xa0
class UGeomModifier_Clip : public UGeomModifier_Edit {
    /* 0x0078 */ bool bFlipNormal;
    /* 0x0078 */ bool bSplit;
    /* 0x0080 */ TArray<FVector> ClipMarkers;
    /* 0x0090 */ FVector SnappedMouseWorldSpacePos;
};

// Size: 0x78
class UGeomModifier_Create : public UGeomModifier_Edit {
};

// Size: 0x78
class UGeomModifier_Delete : public UGeomModifier_Edit {
};

// Size: 0x78
class UGeomModifier_Edit : public UGeomModifier {
};

// Size: 0x88
class UGeomModifier_Extrude : public UGeomModifier_Edit {
    /* 0x0078 */ int32_t Length;
    /* 0x007c */ int32_t Segments;
    /* 0x0080 */ int32_t SaveCoordSystem;
};

// Size: 0x78
class UGeomModifier_Flip : public UGeomModifier_Edit {
};

// Size: 0x88
class UGeomModifier_Lathe : public UGeomModifier_Edit {
    /* 0x0078 */ int32_t TotalSegments;
    /* 0x007c */ int32_t Segments;
    /* 0x0080 */ bool AlignToSide;
    /* 0x0084 */ uint8_t Axis;
};

// Size: 0x78
class UGeomModifier_Optimize : public UGeomModifier_Triangulate {
};

// Size: 0xa8
class UGeomModifier_Pen : public UGeomModifier_Edit {
    /* 0x0078 */ bool bAutoExtrude;
    /* 0x0078 */ bool bCreateConvexPolygons;
    /* 0x0078 */ bool bCreateBrushShape;
    /* 0x007c */ int32_t ExtrudeDepth;
    /* 0x0080 */ TArray<FVector> ShapeVertices;
    /* 0x0090 */ FVector MouseWorldSpacePos;
};

// Size: 0x78
class UGeomModifier_Split : public UGeomModifier_Edit {
};

// Size: 0x78
class UGeomModifier_Triangulate : public UGeomModifier_Edit {
};

// Size: 0x78
class UGeomModifier_Turn : public UGeomModifier_Edit {
};

// Size: 0x78
class UGeomModifier_Weld : public UGeomModifier_Edit {
};

enum class EGooglePADCellularDataConfirmStatus {
    AssetPack_CONFIRM_UNKNOWN = 0,
    AssetPack_CONFIRM_PENDING = 1,
    AssetPack_CONFIRM_USER_APPROVED = 2,
    AssetPack_CONFIRM_USER_CANCELED = 3,
    AssetPack_CONFIRM_MAX = 4,
};

enum class EGooglePADDownloadStatus {
    AssetPack_UNKNOWN = 0,
    AssetPack_DOWNLOAD_PENDING = 1,
    AssetPack_DOWNLOADING = 2,
    AssetPack_TRANSFERRING = 3,
    AssetPack_DOWNLOAD_COMPLETED = 4,
    AssetPack_DOWNLOAD_FAILED = 5,
    AssetPack_DOWNLOAD_CANCELED = 6,
    AssetPack_WAITING_FOR_WIFI = 7,
    AssetPack_NOT_INSTALLED = 8,
    AssetPack_INFO_PENDING = 9,
    AssetPack_INFO_FAILED = 10,
    AssetPack_REMOVAL_PENDING = 11,
    AssetPack_REMOVAL_FAILED = 12,
    AssetPack_MAX = 13,
};

enum class EGooglePADErrorCode {
    AssetPack_NO_ERROR = 0,
    AssetPack_APP_UNAVAILABLE = 1,
    AssetPack_UNAVAILABLE = 2,
    AssetPack_INVALID_REQUEST = 3,
    AssetPack_DOWNLOAD_NOT_FOUND = 4,
    AssetPack_API_NOT_AVAILABLE = 5,
    AssetPack_NETWORK_ERROR = 6,
    AssetPack_ACCESS_DENIED = 7,
    AssetPack_INSUFFICIENT_STORAGE = 8,
    AssetPack_PLAY_STORE_NOT_FOUND = 9,
    AssetPack_NETWORK_UNRESTRICTED = 10,
    AssetPack_INTERNAL_ERROR = 11,
    AssetPack_INITIALIZATION_NEEDED = 12,
    AssetPack_INITIALIZATION_FAILED = 13,
    AssetPack_MAX = 14,
};

enum class EGooglePADStorageMethod {
    AssetPack_STORAGE_FILES = 0,
    AssetPack_STORAGE_APK = 1,
    AssetPack_STORAGE_UNKNOWN = 2,
    AssetPack_STORAGE_NOT_INSTALLED = 3,
    AssetPack_STORAGE_MAX = 4,
};

// Size: 0x30
class UGooglePADFunctionLibrary : public UBlueprintFunctionLibrary {

    static EGooglePADErrorCode CancelDownload(const TArray<FString> AssetPacks);
    static EGooglePADErrorCode GetAssetPackLocation(FString Name, int32_t& Location);
    static FString GetAssetsPath(const int32_t Location);
    static int32_t GetBytesDownloaded(const int32_t State);
    static EGooglePADErrorCode GetDownloadState(FString Name, int32_t& State);
    static EGooglePADDownloadStatus GetDownloadStatus(const int32_t State);
    static EGooglePADErrorCode GetShowCellularDataConfirmationStatus(EGooglePADCellularDataConfirmStatus& Status);
    static EGooglePADStorageMethod GetStorageMethod(const int32_t Location);
    static int32_t GetTotalBytesToDownload(const int32_t State);
    static void ReleaseAssetPackLocation(const int32_t Location);
    static void ReleaseDownloadState(const int32_t State);
    static EGooglePADErrorCode RequestDownload(const TArray<FString> AssetPacks);
    static EGooglePADErrorCode RequestInfo(const TArray<FString> AssetPacks);
    static EGooglePADErrorCode RequestRemoval(FString Name);
    static EGooglePADErrorCode ShowCellularDataConfirmation();
};

// Size: 0x38
class UGooglePADRuntimeSettings : public UObject {
    /* 0x0030 */ bool bEnablePlugin;
    /* 0x0031 */ bool bOnlyDistribution;
    /* 0x0032 */ bool bOnlyShipping;
};

enum class EGraphPanningMouseButton {
    Right = 0,
    Middle = 1,
    Both = 2,
    EGraphPanningMouseButton_MAX = 3,
};

// Size: 0x2f0
class UGraphEditorSettings : public UObject {
    /* 0x0030 */ uint8_t DataPinStyle;
    /* 0x0031 */ EGraphPanningMouseButton PanningMouseButton;
    /* 0x0034 */ float PaddingAbovePin;
    /* 0x0038 */ float PaddingBelowPin;
    /* 0x003c */ float PaddingRightOfInput;
    /* 0x0040 */ float PaddingLeftOfOutput;
    /* 0x0044 */ float PaddingTowardsNodeEdge;
    /* 0x0048 */ bool bTreatSplinesLikePins;
    /* 0x004c */ float SplineHoverTolerance;
    /* 0x0050 */ float ForwardSplineHorizontalDeltaRange;
    /* 0x0054 */ float ForwardSplineVerticalDeltaRange;
    /* 0x0058 */ FVector2D ForwardSplineTangentFromHorizontalDelta;
    /* 0x0060 */ FVector2D ForwardSplineTangentFromVerticalDelta;
    /* 0x0068 */ float BackwardSplineHorizontalDeltaRange;
    /* 0x006c */ float BackwardSplineVerticalDeltaRange;
    /* 0x0070 */ FVector2D BackwardSplineTangentFromHorizontalDelta;
    /* 0x0078 */ FVector2D BackwardSplineTangentFromVerticalDelta;
    /* 0x0080 */ FLinearColor DefaultPinTypeColor;
    /* 0x0090 */ FLinearColor ExecutionPinTypeColor;
    /* 0x00a0 */ FLinearColor BooleanPinTypeColor;
    /* 0x00b0 */ FLinearColor BytePinTypeColor;
    /* 0x00c0 */ FLinearColor ClassPinTypeColor;
    /* 0x00d0 */ FLinearColor IntPinTypeColor;
    /* 0x00e0 */ FLinearColor Int64PinTypeColor;
    /* 0x00f0 */ FLinearColor FloatPinTypeColor;
    /* 0x0100 */ FLinearColor NamePinTypeColor;
    /* 0x0110 */ FLinearColor SoftObjectPinTypeColor;
    /* 0x0120 */ FLinearColor SoftClassPinTypeColor;
    /* 0x0130 */ FLinearColor DelegatePinTypeColor;
    /* 0x0140 */ FLinearColor ObjectPinTypeColor;
    /* 0x0150 */ FLinearColor InterfacePinTypeColor;
    /* 0x0160 */ FLinearColor StringPinTypeColor;
    /* 0x0170 */ FLinearColor TextPinTypeColor;
    /* 0x0180 */ FLinearColor StructPinTypeColor;
    /* 0x0190 */ FLinearColor WildcardPinTypeColor;
    /* 0x01a0 */ FLinearColor VectorPinTypeColor;
    /* 0x01b0 */ FLinearColor RotatorPinTypeColor;
    /* 0x01c0 */ FLinearColor TransformPinTypeColor;
    /* 0x01d0 */ FLinearColor IndexPinTypeColor;
    /* 0x01e0 */ FLinearColor EventNodeTitleColor;
    /* 0x01f0 */ FLinearColor FunctionCallNodeTitleColor;
    /* 0x0200 */ FLinearColor PureFunctionCallNodeTitleColor;
    /* 0x0210 */ FLinearColor ParentFunctionCallNodeTitleColor;
    /* 0x0220 */ FLinearColor FunctionTerminatorNodeTitleColor;
    /* 0x0230 */ FLinearColor ExecBranchNodeTitleColor;
    /* 0x0240 */ FLinearColor ExecSequenceNodeTitleColor;
    /* 0x0250 */ FLinearColor ResultNodeTitleColor;
    /* 0x0260 */ FLinearColor DefaultCommentNodeTitleColor;
    /* 0x0270 */ FLinearColor PreviewNodeTitleColor;
    /* 0x0280 */ float DefaultDataWireThickness;
    /* 0x0284 */ float DefaultExecutionWireThickness;
    /* 0x0288 */ FLinearColor TraceAttackColor;
    /* 0x0298 */ float TraceAttackWireThickness;
    /* 0x029c */ float TraceAttackHoldPeriod;
    /* 0x02a0 */ float TraceDecayPeriod;
    /* 0x02a4 */ float TraceDecayExponent;
    /* 0x02a8 */ FLinearColor TraceSustainColor;
    /* 0x02b8 */ float TraceSustainWireThickness;
    /* 0x02bc */ float TraceSustainHoldPeriod;
    /* 0x02c0 */ FLinearColor TraceReleaseColor;
    /* 0x02d0 */ float TraceReleaseWireThickness;
    /* 0x02d4 */ float TraceReleasePeriod;
    /* 0x02d8 */ float TraceReleaseExponent;
    /* 0x02dc */ float TracePositionBonusPeriod;
    /* 0x02e0 */ float TracePositionExponent;
    /* 0x02e4 */ float PaddingAutoCollateIncrement;
    /* 0x02e8 */ bool bOpenCreateMenuOnBlankGraphAreas;
    /* 0x02e9 */ uint8_t DefaultCommentNodeMoveMode;
    /* 0x02ea */ bool bShowCommentBubbleWhenZoomedOut;
};

// Size: 0x8
struct FPinStructEditWrapper {
};

enum class EGraphicsPreset {
    Unspecified = 0,
    Maximum = 1,
    Scalable = 2,
    EGraphicsPreset_MAX = 3,
};

enum class EHardwareClass {
    Unspecified = 0,
    Desktop = 1,
    Mobile = 2,
    EHardwareClass_MAX = 3,
};

// Size: 0x50
class UHardwareTargetingSettings : public UObject {
    /* 0x0030 */ uint8_t TargetedHardwareClass;
    /* 0x0031 */ uint8_t AppliedTargetedHardwareClass;
    /* 0x0032 */ uint8_t DefaultGraphicsPerformance;
    /* 0x0033 */ uint8_t AppliedDefaultGraphicsPerformance;
};

// Size: 0x68
class UAsyncTask_LoadXRDeviceVisComponent : public UBlueprintAsyncActionBase {
    /* 0x0038 */ FMulticastInlineDelegate OnModelLoaded;
    /* 0x0048 */ FMulticastInlineDelegate OnLoadFailure;
    /* 0x0060 */ UPrimitiveComponent* SpawnedComponent;

    static UAsyncTask_LoadXRDeviceVisComponent* AddDeviceVisualizationComponentAsync(AActor* Target, const FXRDeviceId& XRDeviceId, bool bManualAttachment, const FTransform& RelativeTransform, UPrimitiveComponent*& NewComponent);
    static UAsyncTask_LoadXRDeviceVisComponent* AddNamedDeviceVisualizationComponentAsync(AActor* Target, const FName SystemName, const FName DeviceName, bool bManualAttachment, const FTransform& RelativeTransform, FXRDeviceId& XRDeviceId, UPrimitiveComponent*& NewComponent);
};

enum class EHMDTrackingOrigin {
    Floor = 0,
    Eye = 1,
    Stage = 2,
    EHMDTrackingOrigin_MAX = 3,
};

enum class EHMDWornState {
    Unknown = 0,
    Worn = 1,
    NotWorn = 2,
    EHMDWornState_MAX = 3,
};

enum class EHandKeypoint {
    Palm = 0,
    Wrist = 1,
    ThumbMetacarpal = 2,
    ThumbProximal = 3,
    ThumbDistal = 4,
    ThumbTip = 5,
    IndexMetacarpal = 6,
    IndexProximal = 7,
    IndexIntermediate = 8,
    IndexDistal = 9,
    IndexTip = 10,
    MiddleMetacarpal = 11,
    MiddleProximal = 12,
    MiddleIntermediate = 13,
    MiddleDistal = 14,
    MiddleTip = 15,
    RingMetacarpal = 16,
    RingProximal = 17,
    RingIntermediate = 18,
    RingDistal = 19,
    RingTip = 20,
    LittleMetacarpal = 21,
    LittleProximal = 22,
    LittleIntermediate = 23,
    LittleDistal = 24,
    LittleTip = 25,
    EHandKeypoint_MAX = 26,
};

enum class EOrientPositionSelector {
    Orientation = 0,
    Position = 1,
    OrientationAndPosition = 2,
    EOrientPositionSelector_MAX = 3,
};

enum class ESpatialInputGestureAxis {
    None = 0,
    Manipulation = 1,
    Navigation = 2,
    NavigationRails = 3,
    ESpatialInputGestureAxis_MAX = 4,
};

enum class ESpectatorScreenMode {
    Disabled = 0,
    SingleEyeLetterboxed = 1,
    Undistorted = 2,
    Distorted = 3,
    SingleEye = 4,
    SingleEyeCroppedToFill = 5,
    Texture = 6,
    TexturePlusEye = 7,
    ESpectatorScreenMode_MAX = 8,
};

enum class ETrackingStatus {
    NotTracked = 0,
    InertialOnly = 1,
    Tracked = 2,
    ETrackingStatus_MAX = 3,
};

enum class EXRDeviceConnectionResult {
    NoTrackingSystem = 0,
    FeatureNotSupported = 1,
    NoValidViewport = 2,
    MiscFailure = 3,
    Success = 4,
    EXRDeviceConnectionResult_MAX = 5,
};

enum class EXRSystemFlags {
    NoFlags = 0,
    IsAR = 1,
    IsTablet = 2,
    IsHeadMounted = 4,
    SupportsHandTracking = 8,
    EXRSystemFlags_MAX = 9,
};

enum class EXRTrackedDeviceType {
    HeadMountedDisplay = 0,
    Controller = 1,
    TrackingReference = 2,
    Other = 3,
    Invalid = 254,
    Any = 255,
    EXRTrackedDeviceType_MAX = 256,
};

enum class EXRVisualType {
    Controller = 0,
    Hand = 1,
    EXRVisualType_MAX = 2,
};

// Size: 0x30
class UHandKeypointConversion : public UBlueprintFunctionLibrary {

    static int32_t Conv_HandKeypointToInt32(EHandKeypoint Input);
};

// Size: 0x30
class UHeadMountedDisplayFunctionLibrary : public UBlueprintFunctionLibrary {

    static void BreakKey(FKey InKey, FString& InteractionProfile, EControllerHand& hand, FName& MotionSource, FString& Indentifier, FString& Component);
    static void CalibrateExternalTrackingToHMD(const FTransform& ExternalTrackingTransform);
    static void ClearXRTimedInputActionDelegate(const FName& ActionPath);
    static bool ConfigureGestures(const FXRGestureConfig& GestureConfig);
    static uint8_t ConnectRemoteXRDevice(FString IpAddress, const int32_t BitRate);
    static void DisconnectRemoteXRDevice();
    static bool EnableHMD(bool bEnable);
    static void EnableLowPersistenceMode(bool bEnable);
    static TArray<FXRDeviceId> EnumerateTrackedDevices(const FName SystemId, EXRTrackedDeviceType DeviceType);
    static bool GetControllerTransformForTime(UObject* WorldContext, const int32_t ControllerIndex, const FName MotionSource, FTimespan Time, bool& bTimeWasUsed, FRotator& Orientation, FVector& Position, bool& bProvidedLinearVelocity, FVector& LinearVelocity, bool& bProvidedAngularVelocity, FVector& AngularVelocityRadPerSec);
    static void GetDevicePose(const FXRDeviceId& XRDeviceId, bool& bIsTracked, FRotator& Orientation, bool& bHasPositionalTracking, FVector& Position);
    static void GetDeviceWorldPose(UObject* WorldContext, const FXRDeviceId& XRDeviceId, bool& bIsTracked, FRotator& Orientation, bool& bHasPositionalTracking, FVector& Position);
    static void GetHMDData(UObject* WorldContext, FXRHMDData& HMDData);
    static FName GetHMDDeviceName();
    static uint8_t GetHMDWornState();
    static void GetMotionControllerData(UObject* WorldContext, const EControllerHand hand, FXRMotionControllerData& MotionControllerData);
    static int32_t GetNumOfTrackingSensors();
    static void GetOrientationAndPosition(FRotator& DeviceRotation, FVector& DevicePosition);
    static float GetPixelDensity();
    static FVector2D GetPlayAreaBounds(uint8_t Origin);
    static void GetPositionalTrackingCameraParameters(FVector& CameraOrigin, FRotator& CameraRotation, float& HFOV, float& VFOV, float& CameraDistance, float& NearPlane, float& FarPlane);
    static float GetScreenPercentage();
    static uint8_t GetTrackingOrigin();
    static void GetTrackingSensorParameters(FVector& Origin, FRotator& Rotation, float& LeftFOV, float& RightFOV, float& TopFOV, float& BottomFOV, float& Distance, float& NearPlane, float& FarPlane, bool& IsActive, int32_t index);
    static FTransform GetTrackingToWorldTransform(UObject* WorldContext);
    static void GetVRFocusState(bool& bUseFocus, bool& bHasFocus);
    static FString GetVersionString();
    static float GetWorldToMetersScale(UObject* WorldContext);
    static int32_t GetXRSystemFlags();
    static bool HasValidTrackingPosition();
    static bool IsDeviceTracking(const FXRDeviceId& XRDeviceId);
    static bool IsHeadMountedDisplayConnected();
    static bool IsHeadMountedDisplayEnabled();
    static bool IsInLowPersistenceMode();
    static bool IsSpectatorScreenModeControllable();
    static void ResetOrientationAndPosition(float Yaw, uint8_t Options);
    static void SetClippingPlanes(float Near, float Far);
    static void SetSpectatorScreenMode(ESpectatorScreenMode Mode);
    static void SetSpectatorScreenModeTexturePlusEyeLayout(FVector2D EyeRectMin, FVector2D EyeRectMax, FVector2D TextureRectMin, FVector2D TextureRectMax, bool bDrawEyeFirst, bool bClearBlack, bool bUseAlpha);
    static void SetSpectatorScreenTexture(UTexture* InTexture);
    static void SetTrackingOrigin(uint8_t Origin);
    static void SetWorldToMetersScale(UObject* WorldContext, float NewScale);
    static void SetXRDisconnectDelegate(const FDelegate& InDisconnectedDelegate);
    static void SetXRTimedInputActionDelegate(const FName& ActionName, const FDelegate& InDelegate);
    static void UpdateExternalTrackingHMDPosition(const FTransform& ExternalTrackingTransform);
};

// Size: 0x5a0
class UMotionControllerComponent : public UPrimitiveComponent {
    /* 0x04d8 */ int32_t PlayerIndex;
    /* 0x04dc */ EControllerHand hand;
    /* 0x04e0 */ FName MotionSource;
    /* 0x04ec */ bool bDisableLowLatencyUpdate;
    /* 0x04f0 */ ETrackingStatus CurrentTrackingStatus;
    /* 0x04f1 */ bool bDisplayDeviceModel;
    /* 0x04f4 */ FName DisplayModelSource;
    /* 0x0500 */ UStaticMesh* CustomDisplayMesh;
    /* 0x0508 */ TArray<UMaterialInterface*> DisplayMeshMaterialOverrides;
    /* 0x0580 */ UPrimitiveComponent* DisplayComponent;

    FVector GetHandJointPosition(int32_t jointIndex, bool& bValueFound);
    float GetParameterValue(FName InName, bool& bValueFound);
    EControllerHand GetTrackingSource() const;
    bool IsTracked() const;
    void OnMotionControllerUpdated();
    void SetAssociatedPlayerIndex(const int32_t NewPlayer);
    void SetCustomDisplayMesh(UStaticMesh* NewDisplayMesh);
    void SetDisplayModelSource(const FName NewDisplayModelSource);
    void SetShowDeviceModel(const bool bShowControllerModel);
    void SetTrackingMotionSource(const FName NewSource);
    void SetTrackingSource(const EControllerHand NewSource);
};

// Size: 0x30
class UMotionTrackedDeviceFunctionLibrary : public UBlueprintFunctionLibrary {

    static void DisableMotionTrackingForComponent(const UMotionControllerComponent* MotionControllerComponent);
    static void DisableMotionTrackingOfAllControllers();
    static void DisableMotionTrackingOfControllersForPlayer(int32_t PlayerIndex);
    static void DisableMotionTrackingOfDevice(int32_t PlayerIndex, EControllerHand hand);
    static void DisableMotionTrackingOfSource(int32_t PlayerIndex, FName SourceName);
    static bool EnableMotionTrackingForComponent(UMotionControllerComponent* MotionControllerComponent);
    static bool EnableMotionTrackingOfDevice(int32_t PlayerIndex, EControllerHand hand);
    static bool EnableMotionTrackingOfSource(int32_t PlayerIndex, FName SourceName);
    static TArray<FName> EnumerateMotionSources();
    static FName GetActiveTrackingSystemName();
    static int32_t GetMaximumMotionTrackedControllerCount();
    static int32_t GetMotionTrackingEnabledControllerCount();
    static bool IsMotionSourceTracking(int32_t PlayerIndex, FName SourceName);
    static bool IsMotionTrackedDeviceCountManagementNecessary();
    static bool IsMotionTrackingEnabledForComponent(const UMotionControllerComponent* MotionControllerComponent);
    static bool IsMotionTrackingEnabledForDevice(int32_t PlayerIndex, EControllerHand hand);
    static bool IsMotionTrackingEnabledForSource(int32_t PlayerIndex, FName SourceName);
    static void SetIsControllerMotionTrackingEnabledByDefault(bool Enable);
};

// Size: 0x150
class UVRNotificationsComponent : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate;
    /* 0x00d0 */ FMulticastInlineDelegate HMDTrackingInitializedDelegate;
    /* 0x00e0 */ FMulticastInlineDelegate HMDRecenteredDelegate;
    /* 0x00f0 */ FMulticastInlineDelegate HMDLostDelegate;
    /* 0x0100 */ FMulticastInlineDelegate HMDReconnectedDelegate;
    /* 0x0110 */ FMulticastInlineDelegate HMDConnectCanceledDelegate;
    /* 0x0120 */ FMulticastInlineDelegate HMDPutOnHeadDelegate;
    /* 0x0130 */ FMulticastInlineDelegate HMDRemovedFromHeadDelegate;
    /* 0x0140 */ FMulticastInlineDelegate VRControllerRecenteredDelegate;

    void VRNotificationsDelegate__DelegateSignature();
};

// Size: 0x30
class UXRAssetFunctionLibrary : public UBlueprintFunctionLibrary {

    static UPrimitiveComponent* AddDeviceVisualizationComponentBlocking(AActor* Target, const FXRDeviceId& XRDeviceId, bool bManualAttachment, const FTransform& RelativeTransform);
    static UPrimitiveComponent* AddNamedDeviceVisualizationComponentBlocking(AActor* Target, const FName SystemName, const FName DeviceName, bool bManualAttachment, const FTransform& RelativeTransform, FXRDeviceId& XRDeviceId);
};

// Size: 0x10
struct FXRDeviceId {
    /* 0x0000 */ FName SystemName;
    /* 0x000c */ int32_t DeviceID;
};

// Size: 0x6
struct FXRGestureConfig {
    /* 0x0000 */ bool bTap;
    /* 0x0001 */ bool bHold;
    /* 0x0002 */ ESpatialInputGestureAxis AxisGesture;
    /* 0x0003 */ bool bNavigationAxisX;
    /* 0x0004 */ bool bNavigationAxisY;
    /* 0x0005 */ bool bNavigationAxisZ;
};

// Size: 0x40
struct FXRHMDData {
    /* 0x0000 */ bool bValid;
    /* 0x0004 */ FName DeviceName;
    /* 0x0010 */ FGuid ApplicationInstanceID;
    /* 0x0020 */ ETrackingStatus TrackingStatus;
    /* 0x0024 */ FVector Position;
    /* 0x0030 */ FQuat Rotation;
};

// Size: 0x30
class UXRLoadingScreenFunctionLibrary : public UBlueprintFunctionLibrary {

    static void AddLoadingScreenSplash(UTexture* Texture, FVector Translation, FRotator Rotation, FVector2D Size, FRotator DeltaRotation, bool bClearBeforeAdd);
    static void ClearLoadingScreenSplashes();
    static void HideLoadingScreen();
    static void SetLoadingScreen(UTexture* Texture, FVector2D Scale, FVector Offset, bool bShowLoadingMovie, bool bShowOnSet);
    static void ShowLoadingScreen();
};

// Size: 0xa0
struct FXRMotionControllerData {
    /* 0x0000 */ bool bValid;
    /* 0x0004 */ FName DeviceName;
    /* 0x0010 */ FGuid ApplicationInstanceID;
    /* 0x0020 */ EXRVisualType DeviceVisualType;
    /* 0x0021 */ EControllerHand HandIndex;
    /* 0x0022 */ ETrackingStatus TrackingStatus;
    /* 0x0024 */ FVector GripPosition;
    /* 0x0030 */ FQuat GripRotation;
    /* 0x0040 */ FVector AimPosition;
    /* 0x0050 */ FQuat AimRotation;
    /* 0x0060 */ TArray<FVector> HandKeyPositions;
    /* 0x0070 */ TArray<FQuat> HandKeyRotations;
    /* 0x0080 */ TArray<float> HandKeyRadii;
    /* 0x0090 */ bool bIsGrasped;
};

enum class EHierarchicalLODActionType {
    InvalidAction = 0,
    CreateCluster = 1,
    AddActorToCluster = 2,
    MoveActorToCluster = 3,
    RemoveActorFromCluster = 4,
    MergeClusters = 5,
    ChildCluster = 6,
    MAX = 7,
};

enum class EIOSCloudKitSyncStrategy {
    None = 0,
    OnlyAtGameStart = 1,
    Always = 2,
    EIOSCloudKitSyncStrategy_MAX = 3,
};

enum class EIOSLandscapeOrientation {
    LandscapeLeft = 0,
    LandscapeRight = 1,
    EIOSLandscapeOrientation_MAX = 2,
};

enum class EIOSMetalShaderStandard {
    IOSMetalSLStandard_1_2 = 2,
    IOSMetalSLStandard_2_0 = 3,
    IOSMetalSLStandard_2_1 = 4,
    IOSMetalSLStandard_MAX = 5,
};

enum class EIOSVersion {
    IOS_12 = 12,
    IOS_13 = 13,
    IOS_14 = 14,
    IOS_MAX = 15,
};

enum class EPowerUsageFrameRateLock {
    PUFRL_None = 0,
    PUFRL_20 = 20,
    PUFRL_30 = 30,
    PUFRL_60 = 60,
    PUFRL_MAX = 61,
};

// Size: 0x10
struct FIOSBuildResourceDirectory {
    /* 0x0000 */ FString Path;
};

// Size: 0x10
struct FIOSBuildResourceFilePath {
    /* 0x0000 */ FString FilePath;
};

// Size: 0x240
class UIOSRuntimeSettings : public UObject {
    /* 0x0030 */ bool bEnableGameCenterSupport;
    /* 0x0030 */ bool bEnableCloudKitSupport;
    /* 0x0034 */ EIOSCloudKitSyncStrategy IOSCloudKitSyncStrategy;
    /* 0x0038 */ bool bEnableRemoteNotificationsSupport;
    /* 0x0038 */ bool bEnableBackgroundFetch;
    /* 0x003c */ bool bSupportsMetal;
    /* 0x003d */ bool bSupportsMetalMRT;
    /* 0x003e */ bool bCookPVRTCTextures;
    /* 0x003f */ bool bCookASTCTextures;
    /* 0x0040 */ bool bBuildAsFramework;
    /* 0x0048 */ FIOSBuildResourceDirectory WindowsMetalToolchainOverride;
    /* 0x0058 */ bool bGeneratedSYMFile;
    /* 0x0059 */ bool bGeneratedSYMBundle;
    /* 0x005a */ bool bGenerateCrashReportSymbols;
    /* 0x005b */ bool bGenerateXCArchive;
    /* 0x005c */ bool bShipForBitcode;
    /* 0x005d */ bool bEnableAdvertisingIdentifier;
    /* 0x0060 */ FString AdditionalLinkerFlags;
    /* 0x0070 */ FString AdditionalShippingLinkerFlags;
    /* 0x0080 */ FString RemoteServerName;
    /* 0x0090 */ bool bUseRSync;
    /* 0x0098 */ FString RSyncUsername;
    /* 0x00a8 */ FString RemoteServerOverrideBuildPath;
    /* 0x00b8 */ FIOSBuildResourceDirectory CwRsyncInstallPath;
    /* 0x00c8 */ FString SSHPrivateKeyLocation;
    /* 0x00d8 */ FIOSBuildResourceFilePath SSHPrivateKeyOverridePath;
    /* 0x00e8 */ bool bRunAsCurrentUser;
    /* 0x00e9 */ bool bGameSupportsMultipleActiveControllers;
    /* 0x00ea */ bool bAllowRemoteRotation;
    /* 0x00eb */ bool bUseRemoteAsVirtualJoystick;
    /* 0x00ec */ bool bUseRemoteAbsoluteDpadValues;
    /* 0x00ed */ bool bAllowControllers;
    /* 0x00ee */ bool bControllersBlockDeviceFeedback;
    /* 0x00ef */ bool bDisableMotionData;
    /* 0x00f0 */ bool bSupportsPortraitOrientation;
    /* 0x00f0 */ bool bSupportsUpsideDownOrientation;
    /* 0x00f0 */ bool bSupportsLandscapeLeftOrientation;
    /* 0x00f0 */ bool bSupportsLandscapeRightOrientation;
    /* 0x00f0 */ bool bSupportsITunesFileSharing;
    /* 0x00f0 */ bool bSupportsFilesApp;
    /* 0x00f4 */ EIOSLandscapeOrientation PreferredLandscapeOrientation;
    /* 0x00f8 */ FString BundleDisplayName;
    /* 0x0108 */ FString BundleName;
    /* 0x0118 */ FString BundleIdentifier;
    /* 0x0128 */ FString VersionInfo;
    /* 0x0138 */ EPowerUsageFrameRateLock FrameRateLock;
    /* 0x0139 */ bool bEnableDynamicMaxFPS;
    /* 0x013a */ EIOSVersion MinimumiOSVersion;
    /* 0x013c */ bool bSupportsIPad;
    /* 0x013c */ bool bSupportsIPhone;
    /* 0x0140 */ FString AdditionalPlistData;
    /* 0x0150 */ bool bCustomLaunchscreenStoryboard;
    /* 0x0151 */ bool bEnableFacebookSupport;
    /* 0x0158 */ FString FacebookAppID;
    /* 0x0168 */ FString MobileProvision;
    /* 0x0178 */ FString SigningCertificate;
    /* 0x0188 */ bool bAutomaticSigning;
    /* 0x0190 */ FString IOSTeamID;
    /* 0x01a0 */ bool bDisableHTTPS;
    /* 0x01a1 */ uint8_t MaxShaderLanguageVersion;
    /* 0x01a2 */ bool UseFastIntrinsics;
    /* 0x01a3 */ bool ForceFloats;
    /* 0x01a4 */ bool EnableMathOptimisations;
    /* 0x01a8 */ int32_t IndirectArgumentTier;
    /* 0x01ac */ bool bUseIntegratedKeyboard;
    /* 0x01b0 */ int32_t AudioSampleRate;
    /* 0x01b4 */ int32_t AudioCallbackBufferFrameSize;
    /* 0x01b8 */ int32_t AudioNumBuffersToEnqueue;
    /* 0x01bc */ int32_t AudioMaxChannels;
    /* 0x01c0 */ int32_t AudioNumSourceWorkers;
    /* 0x01c8 */ FString SpatializationPlugin;
    /* 0x01d8 */ FString ReverbPlugin;
    /* 0x01e8 */ FString OcclusionPlugin;
    /* 0x01f8 */ FPlatformRuntimeAudioCompressionOverrides CompressionOverrides;
    /* 0x0208 */ bool bUseAudioStreamCaching;
    /* 0x020c */ int32_t CacheSizeKB;
    /* 0x0210 */ int32_t MaxChunkSizeOverrideKB;
    /* 0x0214 */ bool bResampleForDevice;
    /* 0x0218 */ int32_t SoundCueCookQualityIndex;
    /* 0x021c */ float MaxSampleRate;
    /* 0x0220 */ float HighSampleRate;
    /* 0x0224 */ float MedSampleRate;
    /* 0x0228 */ float LowSampleRate;
    /* 0x022c */ float MinSampleRate;
    /* 0x0230 */ float CompressionQualityModifier;
    /* 0x0234 */ float AutoStreamingThreshold;
    /* 0x0238 */ bool bStreamLandscapeMeshLODs;
};

enum class EBitmapCSType {
    BCST_BLCS_CALIBRATED_RGB = 0,
    BCST_LCS_sRGB = 1934772034,
    BCST_LCS_WINDOWS_COLOR_SPACE = 1466527264,
    BCST_PROFILE_LINKED = 1279872587,
    BCST_PROFILE_EMBEDDED = 1296188740,
    BCST_MAX = 1934772035,
};

enum class EBitmapHeaderVersion {
    BHV_BITMAPINFOHEADER = 0,
    BHV_BITMAPV2INFOHEADER = 1,
    BHV_BITMAPV3INFOHEADER = 2,
    BHV_BITMAPV4HEADER = 3,
    BHV_BITMAPV5HEADER = 4,
    BHV_MAX = 5,
};

enum class EDesiredImageFormat {
    PNG = 0,
    JPG = 1,
    BMP = 2,
    EXR = 3,
    EDesiredImageFormat_MAX = 4,
};

// Size: 0x30
class UImageWriteBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void ExportToDisk(UTexture* Texture, FString Filename, const FImageWriteOptions& Options);
};

// Size: 0x70
struct FImageWriteOptions {
    /* 0x0000 */ EDesiredImageFormat Format;
    /* 0x0004 */ FDelegate OnComplete;
    /* 0x0018 */ int32_t CompressionQuality;
    /* 0x001c */ bool bOverwriteFile;
    /* 0x001d */ bool bAsync;
};

// Size: 0x178
class UImgMediaSource : public UBaseMediaSource {
    /* 0x0138 */ bool IsPathRelativeToProjectRoot;
    /* 0x013c */ FFrameRate FrameRateOverride;
    /* 0x0148 */ FString ProxyOverride;
    /* 0x0158 */ FDirectoryPath SequencePath;

    void AddGlobalCamera(AActor* InActor);
    void AddTargetObject(AActor* InActor, float Width);
    void GetProxies(TArray<FString>& OutProxies) const;
    FString GetSequencePath() const;
    void RemoveGlobalCamera(AActor* InActor);
    void RemoveTargetObject(AActor* InActor);
    void SetMipLevelDistance(float Distance);
    void SetSequencePath(FString Path);
};

// Size: 0x88
class UImgMediaSourceFactory : public UFactory {
};

// Size: 0x88
class UImgMediaSourceFactoryNew : public UFactory {
};

// Size: 0xe8
class UImgMediaPlaybackComponent : public UActorComponent {
    /* 0x00c0 */ float Width;
    /* 0x00c4 */ float LODBias;
};

// Size: 0x70
class UImgMediaSettings : public UObject {
    /* 0x0030 */ FFrameRate DefaultFrameRate;
    /* 0x0038 */ float CacheBehindPercentage;
    /* 0x003c */ float CacheSizeGB;
    /* 0x0040 */ int32_t CacheThreads;
    /* 0x0044 */ int32_t CacheThreadStackSizeKB;
    /* 0x0048 */ float GlobalCacheSizeGB;
    /* 0x004c */ bool UseGlobalCache;
    /* 0x0050 */ uint32_t ExrDecoderThreads;
    /* 0x0058 */ FString DefaultProxy;
    /* 0x0068 */ bool UseDefaultProxy;
};

// Size: 0x60
class UEditorKeyboardShortcutSettings : public UDeveloperSettings {
};

enum class EConsoleForGamepadLabels {
    None = 0,
    XBoxOne = 1,
    PS4 = 2,
    EConsoleForGamepadLabels_MAX = 3,
};

enum class EControllerHand {
    Left = 0,
    Right = 1,
    AnyHand = 2,
    Pad = 3,
    ExternalCamera = 4,
    Gun = 5,
    Special_1 = 6,
    Special_2 = 7,
    Special_3 = 8,
    Special_4 = 9,
    Special_5 = 10,
    Special_6 = 11,
    Special_7 = 12,
    Special_8 = 13,
    Special_9 = 14,
    Special_10 = 15,
    Special_11 = 16,
    ControllerHand_Count = 17,
    EControllerHand_MAX = 18,
};

enum class ETouchIndex {
    Touch1 = 0,
    Touch2 = 1,
    Touch3 = 2,
    Touch4 = 3,
    Touch5 = 4,
    Touch6 = 5,
    Touch7 = 6,
    Touch8 = 7,
    Touch9 = 8,
    Touch10 = 9,
    CursorPointerIndex = 10,
    MAX_TOUCHES = 11,
    ETouchIndex_MAX = 12,
};

enum class ETouchType {
    Began = 0,
    Moved = 1,
    Stationary = 2,
    ForceChanged = 3,
    FirstMove = 4,
    Ended = 5,
    NumTypes = 6,
    ETouchType_MAX = 7,
};

// Size: 0x30
class UInputCoreTypes : public UObject {
};

// Size: 0x20
struct FKey {
    /* 0x0000 */ FName KeyName;
};

// Size: 0x30
struct FActiveGizmo {
};

// Size: 0x90
class UAnyButtonInputBehavior : public UInputBehavior {
};

// Size: 0xf8
class UAxisAngleGizmo : public UInteractiveGizmo {
    /* 0x0050 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x0060 */ TScriptInterface<IGizmoFloatParameterSource> AngleSource;
    /* 0x0070 */ TScriptInterface<IGizmoClickTarget> HitTarget;
    /* 0x0080 */ TScriptInterface<IGizmoStateTarget> StateTarget;
    /* 0x0090 */ bool bInInteraction;
    /* 0x0094 */ FVector RotationOrigin;
    /* 0x00a0 */ FVector RotationAxis;
    /* 0x00ac */ FVector RotationPlaneX;
    /* 0x00b8 */ FVector RotationPlaneY;
    /* 0x00c4 */ FVector InteractionStartPoint;
    /* 0x00d0 */ FVector InteractionCurPoint;
    /* 0x00dc */ float InteractionStartAngle;
    /* 0x00e0 */ float InteractionCurAngle;
};

// Size: 0x30
class UAxisAngleGizmoBuilder : public UInteractiveGizmoBuilder {
};

// Size: 0xe0
class UAxisPositionGizmo : public UInteractiveGizmo {
    /* 0x0050 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x0060 */ TScriptInterface<IGizmoFloatParameterSource> ParameterSource;
    /* 0x0070 */ TScriptInterface<IGizmoClickTarget> HitTarget;
    /* 0x0080 */ TScriptInterface<IGizmoStateTarget> StateTarget;
    /* 0x0090 */ bool bEnableSignedAxis;
    /* 0x0091 */ bool bInInteraction;
    /* 0x0094 */ FVector InteractionOrigin;
    /* 0x00a0 */ FVector InteractionAxis;
    /* 0x00ac */ FVector InteractionStartPoint;
    /* 0x00b8 */ FVector InteractionCurPoint;
    /* 0x00c4 */ float InteractionStartParameter;
    /* 0x00c8 */ float InteractionCurParameter;
    /* 0x00cc */ float ParameterSign;
};

// Size: 0x30
class UAxisPositionGizmoBuilder : public UInteractiveGizmoBuilder {
};

// Size: 0x1d0
class UBaseBrushTool : public UMeshSurfacePointTool {
    /* 0x00c8 */ UBrushBaseProperties* BrushProperties;
    /* 0x00d0 */ bool bInBrushStroke;
    /* 0x00d4 */ float WorldToLocalScale;
    /* 0x00d8 */ FBrushStampData LastBrushStamp;
    /* 0x0198 */ TSoftClassPtr<UBrushBaseProperties> PropertyClass;
    /* 0x01c8 */ UBrushStampIndicator* BrushStampIndicator;
};

// Size: 0x20
struct FBehaviorInfo {
    /* 0x0000 */ UInputBehavior* Behavior;
};

// Size: 0x80
class UBrushBaseProperties : public UInteractiveToolPropertySet {
    /* 0x0068 */ float BrushSize;
    /* 0x006c */ bool bSpecifyRadius;
    /* 0x0070 */ float BrushRadius;
    /* 0x0074 */ float BrushStrength;
    /* 0x0078 */ float BrushFalloffAmount;
    /* 0x007c */ bool bShowStrength;
    /* 0x007d */ bool bShowFalloff;
};

// Size: 0xb0
struct FBrushStampData {
};

// Size: 0xb8
class UBrushStampIndicator : public UInteractiveGizmo {
    /* 0x0040 */ float BrushRadius;
    /* 0x0044 */ float BrushFalloff;
    /* 0x0048 */ FVector BrushPosition;
    /* 0x0054 */ FVector BrushNormal;
    /* 0x0060 */ bool bDrawIndicatorLines;
    /* 0x0061 */ bool bDrawRadiusCircle;
    /* 0x0064 */ int32_t SampleStepCount;
    /* 0x0068 */ FLinearColor LineColor;
    /* 0x0078 */ float LineThickness;
    /* 0x007c */ bool bDepthTested;
    /* 0x007d */ bool bDrawSecondaryLines;
    /* 0x0080 */ float SecondaryLineThickness;
    /* 0x0084 */ FLinearColor SecondaryLineColor;
    /* 0x0098 */ UPrimitiveComponent* AttachedComponent;
};

// Size: 0x30
class UBrushStampIndicatorBuilder : public UInteractiveGizmoBuilder {
};

// Size: 0x160
class UClickDragInputBehavior : public UAnyButtonInputBehavior {
    /* 0x0140 */ bool bUpdateModifiersDuringDrag;
};

// Size: 0x90
class UClickDragTool : public UInteractiveTool {
};

// Size: 0x30
class UClickDragToolBuilder : public UInteractiveToolBuilder {
};

enum class EInputCaptureRequestType {
    Begin = 1,
    Ignore = 2,
    EInputCaptureRequestType_MAX = 3,
};

enum class EInputCaptureSide {
    None = 0,
    Left = 1,
    Right = 2,
    Both = 3,
    Any = 99,
    EInputCaptureSide_MAX = 100,
};

enum class EInputCaptureState {
    Begin = 1,
    Continue = 2,
    End = 3,
    Ignore = 4,
    EInputCaptureState_MAX = 5,
};

enum class EInputDevices {
    None = 0,
    Keyboard = 1,
    Mouse = 2,
    Gamepad = 4,
    OculusTouch = 8,
    HTCViveWands = 16,
    AnySpatialDevice = 24,
    TabletFingers = 1024,
    EInputDevices_MAX = 1025,
};

enum class ESceneSnapQueryTargetType {
    None = 0,
    MeshVertex = 1,
    MeshEdge = 2,
    Grid = 4,
    All = 7,
    ESceneSnapQueryTargetType_MAX = 8,
};

enum class ESceneSnapQueryType {
    Position = 1,
    Rotation = 2,
    ESceneSnapQueryType_MAX = 3,
};

enum class ESelectedObjectsModificationType {
    Replace = 0,
    Add = 1,
    Remove = 2,
    Clear = 3,
    ESelectedObjectsModificationType_MAX = 4,
};

enum class EStandardToolContextMaterials {
    VertexColorMaterial = 1,
    EStandardToolContextMaterials_MAX = 2,
};

enum class EToolChangeTrackingMode {
    NoChangeTracking = 1,
    UndoToExit = 2,
    FullUndoRedo = 3,
    EToolChangeTrackingMode_MAX = 4,
};

enum class EToolContextCoordinateSystem {
    World = 0,
    Local = 1,
    EToolContextCoordinateSystem_MAX = 2,
};

enum class EToolMessageLevel {
    Internal = 0,
    UserMessage = 1,
    UserNotification = 2,
    UserWarning = 3,
    UserError = 4,
    EToolMessageLevel_MAX = 5,
};

enum class EToolSide {
    Left = 1,
    Mouse = 1,
    Right = 2,
    EToolSide_MAX = 3,
};

enum class ETransformGizmoSubElements {
    None = 0,
    TranslateAxisX = 2,
    TranslateAxisY = 4,
    TranslateAxisZ = 8,
    TranslateAllAxes = 14,
    TranslatePlaneXY = 16,
    TranslatePlaneXZ = 32,
    TranslatePlaneYZ = 64,
    TranslateAllPlanes = 112,
    RotateAxisX = 128,
    RotateAxisY = 256,
    RotateAxisZ = 512,
    RotateAllAxes = 896,
    ScaleAxisX = 1024,
    ScaleAxisY = 2048,
    ScaleAxisZ = 4096,
    ScaleAllAxes = 7168,
    ScalePlaneYZ = 8192,
    ScalePlaneXZ = 16384,
    ScalePlaneXY = 32768,
    ScaleAllPlanes = 57344,
    ScaleUniform = 65536,
    StandardTranslateRotate = 1022,
    TranslateRotateUniformScale = 66558,
    FullTranslateRotateScale = 131070,
    ETransformGizmoSubElements_MAX = 131071,
};

enum class EViewInteractionState {
    None = 0,
    Hovered = 1,
    Focused = 2,
    EViewInteractionState_MAX = 3,
};

// Size: 0x2f8
class AGizmoActor : public AInternalToolFrameworkActor {
};

// Size: 0x520
class UGizmoArrowComponent : public UGizmoBaseComponent {
    /* 0x04f8 */ FVector Direction;
    /* 0x0504 */ float Gap;
    /* 0x0508 */ float Length;
    /* 0x050c */ float Thickness;
};

// Size: 0x68
class UGizmoAxisIntervalParameterSource : public UGizmoBaseFloatParameterSource {
    /* 0x0050 */ TScriptInterface<IGizmoFloatParameterSource> FloatParameterSource;
    /* 0x0060 */ float MinParameter;
    /* 0x0064 */ float MaxParameter;
};

// Size: 0x120
class UGizmoAxisRotationParameterSource : public UGizmoBaseFloatParameterSource {
    /* 0x00a0 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x00b0 */ TScriptInterface<IGizmoTransformSource> TransformSource;
    /* 0x00c0 */ float Angle;
    /* 0x00c4 */ FGizmoFloatParameterChange LastChange;
    /* 0x00cc */ FVector CurRotationAxis;
    /* 0x00d8 */ FVector CurRotationOrigin;
    /* 0x00f0 */ FTransform InitialTransform;
};

// Size: 0xd0
class UGizmoAxisScaleParameterSource : public UGizmoBaseFloatParameterSource {
    /* 0x0050 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x0060 */ TScriptInterface<IGizmoTransformSource> TransformSource;
    /* 0x0070 */ float ScaleMultiplier;
    /* 0x0074 */ float Parameter;
    /* 0x0078 */ FGizmoFloatParameterChange LastChange;
    /* 0x0080 */ FVector CurScaleAxis;
    /* 0x008c */ FVector CurScaleOrigin;
    /* 0x00a0 */ FTransform InitialTransform;
};

// Size: 0x30
class IGizmoAxisSource : public UInterface {

    FVector GetDirection() const;
    FVector GetOrigin() const;
    void GetTangentVectors(FVector& TangentXOut, FVector& TangentYOut) const;
    bool HasTangentVectors() const;
};

// Size: 0x120
class UGizmoAxisTranslationParameterSource : public UGizmoBaseFloatParameterSource {
    /* 0x00a0 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x00b0 */ TScriptInterface<IGizmoTransformSource> TransformSource;
    /* 0x00c0 */ float Parameter;
    /* 0x00c4 */ FGizmoFloatParameterChange LastChange;
    /* 0x00cc */ FVector CurTranslationAxis;
    /* 0x00d8 */ FVector CurTranslationOrigin;
    /* 0x00f0 */ FTransform InitialTransform;
};

// Size: 0x500
class UGizmoBaseComponent : public UPrimitiveComponent {
    /* 0x04d8 */ FLinearColor Color;
    /* 0x04e8 */ float HoverSizeMultiplier;
    /* 0x04ec */ float PixelHitDistanceThreshold;

    void UpdateHoverState(bool bHoveringIn);
    void UpdateWorldLocalState(bool bWorldIn);
};

// Size: 0x50
class UGizmoBaseFloatParameterSource : public UObject {
};

// Size: 0x50
class UGizmoBaseTransformSource : public UObject {
};

// Size: 0x50
class UGizmoBaseVec2ParameterSource : public UObject {
};

// Size: 0x540
class UGizmoBoxComponent : public UGizmoBaseComponent {
    /* 0x04f8 */ FVector Origin;
    /* 0x0510 */ FQuat Rotation;
    /* 0x0520 */ FVector Dimensions;
    /* 0x052c */ float LineThickness;
    /* 0x0530 */ bool bRemoveHiddenLines;
    /* 0x0531 */ bool bEnableAxisFlip;
};

// Size: 0x520
class UGizmoCircleComponent : public UGizmoBaseComponent {
    /* 0x04f8 */ FVector Normal;
    /* 0x0504 */ float Radius;
    /* 0x0508 */ float Thickness;
    /* 0x050c */ int32_t NumSides;
    /* 0x0510 */ bool bViewAligned;
    /* 0x0511 */ bool bOnlyAllowFrontFacingHits;
};

// Size: 0x30
class IGizmoClickTarget : public UInterface {

    void UpdateHoverState(bool bHovering) const;
};

// Size: 0x48
class UGizmoComponentAxisSource : public UObject {
    /* 0x0038 */ USceneComponent* Component;
    /* 0x0040 */ int32_t AxisIndex;
    /* 0x0044 */ bool bLocalAxes;
};

// Size: 0x90
class UGizmoComponentHitTarget : public UObject {
    /* 0x0038 */ UPrimitiveComponent* Component;
};

// Size: 0x60
class UGizmoComponentWorldTransformSource : public UGizmoBaseTransformSource {
    /* 0x0050 */ USceneComponent* Component;
    /* 0x0058 */ bool bModifyComponentOnTransform;
};

// Size: 0x50
class UGizmoConstantAxisSource : public UObject {
    /* 0x0038 */ FVector Origin;
    /* 0x0044 */ FVector Direction;
};

// Size: 0x68
class UGizmoConstantFrameAxisSource : public UObject {
    /* 0x0038 */ FVector Origin;
    /* 0x0044 */ FVector Direction;
    /* 0x0050 */ FVector TangentX;
    /* 0x005c */ FVector TangentY;
};

// Size: 0x8
struct FGizmoFloatParameterChange {
    /* 0x0000 */ float InitialValue;
    /* 0x0004 */ float CurrentValue;
};

// Size: 0x30
class IGizmoFloatParameterSource : public UInterface {

    void BeginModify();
    void EndModify();
    float GetParameter() const;
    void SetParameter(float NewValue);
};

// Size: 0xe0
class UGizmoLambdaHitTarget : public UObject {
};

// Size: 0xe0
class UGizmoLambdaStateTarget : public UObject {
};

// Size: 0x520
class UGizmoLineHandleComponent : public UGizmoBaseComponent {
    /* 0x04f8 */ FVector Normal;
    /* 0x0504 */ float HandleSize;
    /* 0x0508 */ float Thickness;
    /* 0x050c */ FVector Direction;
    /* 0x0518 */ float Length;
    /* 0x051c */ bool bImageScale;
};

// Size: 0x60
class UGizmoLocalFloatParameterSource : public UGizmoBaseFloatParameterSource {
    /* 0x0050 */ float Value;
    /* 0x0054 */ FGizmoFloatParameterChange LastChange;
};

// Size: 0x68
class UGizmoLocalVec2ParameterSource : public UGizmoBaseVec2ParameterSource {
    /* 0x0050 */ FVector2D Value;
    /* 0x0058 */ FGizmoVec2ParameterChange LastChange;
};

// Size: 0x38
class UGizmoNilStateTarget : public UObject {
};

// Size: 0x60
class UGizmoObjectModifyStateTarget : public UObject {
};

// Size: 0x140
class UGizmoPlaneScaleParameterSource : public UGizmoBaseVec2ParameterSource {
    /* 0x00a0 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x00b0 */ TScriptInterface<IGizmoTransformSource> TransformSource;
    /* 0x00c0 */ float ScaleMultiplier;
    /* 0x00c4 */ FVector2D Parameter;
    /* 0x00cc */ FGizmoVec2ParameterChange LastChange;
    /* 0x00dc */ FVector CurScaleOrigin;
    /* 0x00e8 */ FVector CurScaleNormal;
    /* 0x00f4 */ FVector CurScaleAxisX;
    /* 0x0100 */ FVector CurScaleAxisY;
    /* 0x0110 */ FTransform InitialTransform;
};

// Size: 0x140
class UGizmoPlaneTranslationParameterSource : public UGizmoBaseVec2ParameterSource {
    /* 0x00a0 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x00b0 */ TScriptInterface<IGizmoTransformSource> TransformSource;
    /* 0x00c0 */ FVector2D Parameter;
    /* 0x00c8 */ FGizmoVec2ParameterChange LastChange;
    /* 0x00d8 */ FVector CurTranslationOrigin;
    /* 0x00e4 */ FVector CurTranslationNormal;
    /* 0x00f0 */ FVector CurTranslationAxisX;
    /* 0x00fc */ FVector CurTranslationAxisY;
    /* 0x0110 */ FTransform InitialTransform;
};

// Size: 0x530
class UGizmoRectangleComponent : public UGizmoBaseComponent {
    /* 0x04f8 */ FVector DirectionX;
    /* 0x0504 */ FVector DirectionY;
    /* 0x0510 */ float OffsetX;
    /* 0x0514 */ float OffsetY;
    /* 0x0518 */ float LengthX;
    /* 0x051c */ float LengthY;
    /* 0x0520 */ float Thickness;
    /* 0x0524 */ uint8_t SegmentFlags;
};

// Size: 0x100
class UGizmoScaledTransformSource : public UGizmoBaseTransformSource {
    /* 0x0050 */ TScriptInterface<IGizmoTransformSource> ChildTransformSource;
};

// Size: 0x30
class IGizmoStateTarget : public UInterface {

    void BeginUpdate();
    void EndUpdate();
};

// Size: 0xf0
class UGizmoTransformChangeStateTarget : public UObject {
    /* 0x0058 */ TScriptInterface<IToolContextTransactionProvider> TransactionManager;
};

// Size: 0x58
class UGizmoTransformProxyTransformSource : public UGizmoBaseTransformSource {
    /* 0x0050 */ UTransformProxy* Proxy;
};

// Size: 0x30
class IGizmoTransformSource : public UInterface {

    FTransform GetTransform() const;
    void SetTransform(const FTransform& NewTransform);
};

// Size: 0xf0
class UGizmoUniformScaleParameterSource : public UGizmoBaseVec2ParameterSource {
    /* 0x0050 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x0060 */ TScriptInterface<IGizmoTransformSource> TransformSource;
    /* 0x0070 */ float ScaleMultiplier;
    /* 0x0074 */ FVector2D Parameter;
    /* 0x007c */ FGizmoVec2ParameterChange LastChange;
    /* 0x008c */ FVector CurScaleOrigin;
    /* 0x0098 */ FVector CurScaleNormal;
    /* 0x00a4 */ FVector CurScaleAxisX;
    /* 0x00b0 */ FVector CurScaleAxisY;
    /* 0x00c0 */ FTransform InitialTransform;
};

// Size: 0x10
struct FGizmoVec2ParameterChange {
    /* 0x0000 */ FVector2D InitialValue;
    /* 0x0008 */ FVector2D CurrentValue;
};

// Size: 0x30
class IGizmoVec2ParameterSource : public UInterface {

    void BeginModify();
    void EndModify();
    FVector2D GetParameter() const;
    void SetParameter(const FVector2D& NewValue);
};

// Size: 0x48
class UGizmoWorldAxisSource : public UObject {
    /* 0x0038 */ FVector Origin;
    /* 0x0044 */ int32_t AxisIndex;
};

// Size: 0x38
class UInputBehavior : public UObject {
};

// Size: 0x40
class UInputBehaviorSet : public UObject {
    /* 0x0030 */ TArray<FBehaviorInfo> Behaviors;
};

// Size: 0x30
class IInputBehaviorSource : public UInterface {
};

// Size: 0x28
struct FInputRayHit {
};

// Size: 0xb8
class UInputRouter : public UObject {
    /* 0x0030 */ bool bAutoInvalidateOnHover;
    /* 0x0031 */ bool bAutoInvalidateOnCapture;
    /* 0x0040 */ UInputBehaviorSet* ActiveInputBehaviors;
};

// Size: 0x38
class UInteractionMechanic : public UObject {
};

// Size: 0x40
class UInteractiveGizmo : public UObject {
    /* 0x0038 */ UInputBehaviorSet* InputBehaviors;
};

// Size: 0x30
class UInteractiveGizmoBuilder : public UObject {
};

// Size: 0xc0
class UInteractiveGizmoManager : public UObject {
    /* 0x0038 */ TArray<FActiveGizmo> ActiveGizmos;
    /* 0x0060 */ TMap<FString, UInteractiveGizmoBuilder*> GizmoBuilders;
};

// Size: 0x88
class UInteractiveTool : public UObject {
    /* 0x0050 */ UInputBehaviorSet* InputBehaviors;
    /* 0x0058 */ TArray<UObject*> ToolPropertyObjects;
};

// Size: 0x30
class UInteractiveToolBuilder : public UObject {
};

// Size: 0x140
class UInteractiveToolManager : public UObject {
    /* 0x0038 */ UInteractiveTool* ActiveLeftTool;
    /* 0x0040 */ UInteractiveTool* ActiveRightTool;
    /* 0x0098 */ TMap<FString, UInteractiveToolBuilder*> ToolBuilders;
};

// Size: 0x68
class UInteractiveToolPropertySet : public UObject {
    /* 0x0040 */ UInteractiveToolPropertySet* CachedProperties;
    /* 0x0048 */ bool bIsPropertySetEnabled;
};

// Size: 0xa8
class UInteractiveToolsContext : public UObject {
    /* 0x0060 */ UInputRouter* InputRouter;
    /* 0x0068 */ UInteractiveToolManager* ToolManager;
    /* 0x0070 */ UInteractiveGizmoManager* GizmoManager;
    /* 0x0078 */ TSoftClassPtr<UInteractiveToolManager> ToolManagerClass;
};

// Size: 0x2f8
class AInternalToolFrameworkActor : public AActor {
};

// Size: 0x160
class UIntervalGizmo : public UInteractiveGizmo {
    /* 0x0040 */ UGizmoTransformChangeStateTarget* StateTarget;
    /* 0x0058 */ UTransformProxy* TransformProxy;
    /* 0x0060 */ TArray<UPrimitiveComponent*> ActiveComponents;
    /* 0x0070 */ TArray<UInteractiveGizmo*> ActiveGizmos;
    /* 0x0098 */ UGizmoComponentAxisSource* AxisYSource;
    /* 0x00a0 */ UGizmoComponentAxisSource* AxisZSource;
};

// Size: 0x310
class AIntervalGizmoActor : public AGizmoActor {
    /* 0x02f8 */ UGizmoLineHandleComponent* UpIntervalComponent;
    /* 0x0300 */ UGizmoLineHandleComponent* DownIntervalComponent;
    /* 0x0308 */ UGizmoLineHandleComponent* ForwardIntervalComponent;
};

// Size: 0xe0
class UIntervalGizmoBuilder : public UInteractiveGizmoBuilder {
};

// Size: 0x140
class UKeyAsModifierInputBehavior : public UInputBehavior {
};

// Size: 0x2f0
class ULocalClickDragInputBehavior : public UClickDragInputBehavior {
};

// Size: 0x88
class UMeshSelectionSet : public USelectionSet {
    /* 0x0048 */ TArray<int32_t> Vertices;
    /* 0x0058 */ TArray<int32_t> Edges;
    /* 0x0068 */ TArray<int32_t> Faces;
    /* 0x0078 */ TArray<int32_t> Groups;
};

// Size: 0xc8
class UMeshSurfacePointTool : public USingleSelectionTool {
};

// Size: 0x38
class UMeshSurfacePointToolBuilder : public UInteractiveToolBuilder {
};

// Size: 0xa0
class UMouseHoverBehavior : public UInputBehavior {
};

// Size: 0x150
class UMultiClickSequenceInputBehavior : public UAnyButtonInputBehavior {
};

// Size: 0x98
class UMultiSelectionTool : public UInteractiveTool {
};

// Size: 0x108
class UPlanePositionGizmo : public UInteractiveGizmo {
    /* 0x0050 */ TScriptInterface<IGizmoAxisSource> AxisSource;
    /* 0x0060 */ TScriptInterface<IGizmoVec2ParameterSource> ParameterSource;
    /* 0x0070 */ TScriptInterface<IGizmoClickTarget> HitTarget;
    /* 0x0080 */ TScriptInterface<IGizmoStateTarget> StateTarget;
    /* 0x0090 */ bool bEnableSignedAxis;
    /* 0x0091 */ bool bFlipX;
    /* 0x0092 */ bool bFlipY;
    /* 0x0093 */ bool bInInteraction;
    /* 0x0094 */ FVector InteractionOrigin;
    /* 0x00a0 */ FVector InteractionNormal;
    /* 0x00ac */ FVector InteractionAxisX;
    /* 0x00b8 */ FVector InteractionAxisY;
    /* 0x00c4 */ FVector InteractionStartPoint;
    /* 0x00d0 */ FVector InteractionCurPoint;
    /* 0x00dc */ FVector2D InteractionStartParameter;
    /* 0x00e4 */ FVector2D InteractionCurParameter;
    /* 0x00ec */ FVector2D ParameterSigns;
};

// Size: 0x30
class UPlanePositionGizmoBuilder : public UInteractiveGizmoBuilder {
};

// Size: 0x48
class USelectionSet : public UObject {
};

// Size: 0x150
class USingleClickInputBehavior : public UAnyButtonInputBehavior {
    /* 0x00e0 */ bool HitTestOnRelease;
};

// Size: 0x90
class USingleClickTool : public UInteractiveTool {
};

// Size: 0x30
class USingleClickToolBuilder : public UInteractiveToolBuilder {
};

// Size: 0x90
class USingleSelectionTool : public UInteractiveTool {
};

// Size: 0x30
class IToolContextTransactionProvider : public UInterface {
};

// Size: 0x30
class IToolFrameworkComponent : public UInterface {
};

// Size: 0x1d0
class UTransformGizmo : public UInteractiveGizmo {
    /* 0x0048 */ UTransformProxy* ActiveTarget;
    /* 0x0050 */ bool bSnapToWorldGrid;
    /* 0x0051 */ bool bGridSizeIsExplicit;
    /* 0x0054 */ FVector ExplicitGridSize;
    /* 0x0060 */ bool bRotationGridSizeIsExplicit;
    /* 0x0064 */ FRotator ExplicitRotationGridSize;
    /* 0x0070 */ bool bSnapToWorldRotGrid;
    /* 0x0071 */ bool bUseContextCoordinateSystem;
    /* 0x0074 */ EToolContextCoordinateSystem CurrentCoordinateSystem;
    /* 0x0130 */ TArray<UPrimitiveComponent*> ActiveComponents;
    /* 0x0140 */ TArray<UPrimitiveComponent*> NonuniformScaleComponents;
    /* 0x0150 */ TArray<UInteractiveGizmo*> ActiveGizmos;
    /* 0x0170 */ UGizmoConstantFrameAxisSource* CameraAxisSource;
    /* 0x0178 */ UGizmoComponentAxisSource* AxisXSource;
    /* 0x0180 */ UGizmoComponentAxisSource* AxisYSource;
    /* 0x0188 */ UGizmoComponentAxisSource* AxisZSource;
    /* 0x0190 */ UGizmoComponentAxisSource* UnitAxisXSource;
    /* 0x0198 */ UGizmoComponentAxisSource* UnitAxisYSource;
    /* 0x01a0 */ UGizmoComponentAxisSource* UnitAxisZSource;
    /* 0x01a8 */ UGizmoTransformChangeStateTarget* StateTarget;
    /* 0x01b0 */ UGizmoScaledTransformSource* ScaledTransformSource;
};

// Size: 0x378
class ATransformGizmoActor : public AGizmoActor {
    /* 0x02f8 */ UPrimitiveComponent* TranslateX;
    /* 0x0300 */ UPrimitiveComponent* TranslateY;
    /* 0x0308 */ UPrimitiveComponent* TranslateZ;
    /* 0x0310 */ UPrimitiveComponent* TranslateYZ;
    /* 0x0318 */ UPrimitiveComponent* TranslateXZ;
    /* 0x0320 */ UPrimitiveComponent* TranslateXY;
    /* 0x0328 */ UPrimitiveComponent* RotateX;
    /* 0x0330 */ UPrimitiveComponent* RotateY;
    /* 0x0338 */ UPrimitiveComponent* RotateZ;
    /* 0x0340 */ UPrimitiveComponent* UniformScale;
    /* 0x0348 */ UPrimitiveComponent* AxisScaleX;
    /* 0x0350 */ UPrimitiveComponent* AxisScaleY;
    /* 0x0358 */ UPrimitiveComponent* AxisScaleZ;
    /* 0x0360 */ UPrimitiveComponent* PlaneScaleYZ;
    /* 0x0368 */ UPrimitiveComponent* PlaneScaleXZ;
    /* 0x0370 */ UPrimitiveComponent* PlaneScaleXY;
};

// Size: 0xe0
class UTransformGizmoBuilder : public UInteractiveGizmoBuilder {
};

// Size: 0xf0
class UTransformProxy : public UObject {
    /* 0x0078 */ bool bRotatePerObject;
    /* 0x0079 */ bool bSetPivotMode;
    /* 0x0090 */ FTransform SharedTransform;
    /* 0x00c0 */ FTransform InitialSharedTransform;
};

enum class ETimezoneSetting {
    InternationalDateLineWest = 0,
    CoordinatedUniversalTimeNeg11 = 1,
    Samoa = 2,
    Hawaii = 3,
    Alaska = 4,
    PacificTime_USCAN = 5,
    BajaCalifornia = 6,
    MountainTime_USCAN = 7,
    Chihuahua_LaPaz_Mazatlan = 8,
    Arizona = 9,
    Saskatchewan = 10,
    CentralAmerica = 11,
    CentralTime_USCAN = 12,
    Guadalajara_MexicoCity_Monterrey = 13,
    EasternTime_USCAN = 14,
    Bogota_Lima_Quito = 15,
    Indiana_US = 16,
    Caracas = 17,
    AtlanticTime_Canada = 18,
    Cuiaba = 19,
    Santiago = 20,
    Georgetown_LaPaz_Manaus_SanJuan = 21,
    Asuncion = 22,
    Newfoundland = 23,
    Brasilia = 24,
    Greenland = 25,
    Montevideo = 26,
    Cayenne_Fortaleza = 27,
    BuenosAires = 28,
    MidAtlantic = 29,
    CoordinatedUniversalTimeNeg02 = 30,
    Azores = 31,
    CaboVerdeIs = 32,
    Dublin_Edinburgh_Lisbon_London = 33,
    Monrovia_Reykjavik = 34,
    Casablanca = 35,
    UTC = 36,
    Belgrade_Bratislava_Budapest_Ljubljana_Prague = 37,
    Sarajevo_Skopje_Warsaw_Zagreb = 38,
    Brussels_Copenhagen_Madrid_Paris = 39,
    WestCentralAfrica = 40,
    Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna = 41,
    Windhoek = 42,
    Minsk = 43,
    Cairo = 44,
    Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius = 45,
    Athens_Bucharest = 46,
    Jerusalem = 47,
    Amman = 48,
    Beirut = 49,
    Harare_Pretoria = 50,
    Damascus = 51,
    Istanbul = 52,
    Kuwait_Riyadh = 53,
    Baghdad = 54,
    Nairobi = 55,
    Kaliningrad = 56,
    Tehran = 57,
    Moscow_StPetersburg_Volgograd = 58,
    AbuDhabi_Muscat = 59,
    Baku = 60,
    Yerevan = 61,
    Tbilisi = 62,
    PortLouis = 63,
    Kabul = 64,
    Tashkent = 65,
    Islamabad_Karachi = 66,
    Chennai_Kolkata_Mumbai_NewDelhi = 67,
    SriJayawardenepura = 68,
    Kathmandu = 69,
    Ekaterinburg = 70,
    Astana = 71,
    Dhaka = 72,
    Yangon_Rangoon = 73,
    Novosibirsk = 74,
    Bangkok_Hanoi_Jakarta = 75,
    Krasnoyarsk = 76,
    Beijing_Chongqing_HongKong_Urumqi = 77,
    KualaLumpur_Singapore = 78,
    Taipei = 79,
    Perth = 80,
    Ulaanbaatar = 81,
    Irkutsk = 82,
    Seoul = 83,
    Osaka_Sapporo_Tokyo = 84,
    Darwin = 85,
    Adelaide = 86,
    Yakutsk = 87,
    Canberra_Melbourne_Sydney = 88,
    Brisbane = 89,
    Hobart = 90,
    Guam_PortMoresby = 91,
    Vladivostok = 92,
    SolomonIs_NewCaledonia = 93,
    Magadan = 94,
    Fiji = 95,
    Auckland_Wellington = 96,
    CoordinatedUniversalTime12 = 97,
    Nukualofa = 98,
    LocalTime = 99,
    ETimezoneSetting_MAX = 100,
};

// Size: 0x38
class UInternationalizationSettingsModel : public UObject {
    /* 0x0030 */ ETimezoneSetting DisplayTimezone;
};

enum class ETutorialAnchorIdentifier {
    None = 0,
    NamedWidget = 1,
    Asset = 2,
    ETutorialAnchorIdentifier_MAX = 3,
};

enum class ETutorialContent {
    None = 0,
    Text = 1,
    UDNExcerpt = 2,
    RichText = 3,
    ETutorialContent_MAX = 4,
};

// Size: 0x160
class UEditorTutorial : public UObject {
    /* 0x0030 */ FText Title;
    /* 0x0048 */ int32_t SortOrder;
    /* 0x0050 */ FString Icon;
    /* 0x0060 */ UTexture2D* Texture;
    /* 0x0068 */ FString Category;
    /* 0x0078 */ FTutorialContent SummaryContent;
    /* 0x00b8 */ TArray<FTutorialStage> Stages;
    /* 0x00c8 */ FSoftClassPath PreviousTutorial;
    /* 0x00e8 */ FSoftClassPath NextTutorial;
    /* 0x0108 */ bool bIsStandalone;
    /* 0x0110 */ FSoftObjectPath AssetToUse;
    /* 0x0130 */ FString ImportPath;
    /* 0x0140 */ bool bHideInBrowser;
    /* 0x0148 */ FText SearchTags;

    static void BeginTutorial(UEditorTutorial* TutorialToStart, bool bRestart);
    AActor* GetActorReference(FString PathToActor);
    static bool GetEngineFolderVisibilty();
    static void GoToNextTutorialStage();
    static void GoToPreviousTutorialStage();
    void OnTutorialClosed();
    void OnTutorialLaunched();
    void OnTutorialStageEnded(FName StageName);
    void OnTutorialStageStarted(FName StageName);
    static void OpenAsset(UObject* Asset);
    static void SetEngineFolderVisibilty(bool bNewVisibility);
};

// Size: 0x88
class UEditorTutorialFactory : public UFactory {
};

// Size: 0xa8
class UEditorTutorialImportFactory : public UFactory {
};

// Size: 0x78
class UEditorTutorialSettings : public UObject {
    /* 0x0030 */ bool bDisableAllTutorialAlerts;
    /* 0x0038 */ TArray<FTutorialCategory> Categories;
    /* 0x0048 */ FSoftClassPath StartupTutorial;
    /* 0x0068 */ TArray<FTutorialContext> TutorialContexts;
};

// Size: 0x78
struct FTutorialCategory {
    /* 0x0000 */ FString Identifier;
    /* 0x0010 */ FText Title;
    /* 0x0028 */ int32_t SortOrder;
    /* 0x0030 */ FText Description;
    /* 0x0048 */ FString Icon;
    /* 0x0058 */ FSoftObjectPath Texture;
};

// Size: 0x40
struct FTutorialContent {
    /* 0x0000 */ uint8_t Type;
    /* 0x0008 */ FString Content;
    /* 0x0018 */ FString ExcerptName;
    /* 0x0028 */ FText text;
};

// Size: 0x78
struct FTutorialContentAnchor {
    /* 0x0000 */ uint8_t Type;
    /* 0x0004 */ FName WrapperIdentifier;
    /* 0x0010 */ FSoftObjectPath Asset;
    /* 0x0030 */ bool bDrawHighlight;
    /* 0x0038 */ FString TabToFocusOrOpen;
    /* 0x0048 */ FString FriendlyName;
    /* 0x0058 */ FString GuidString;
    /* 0x0068 */ FString OuterName;
};

// Size: 0x60
struct FTutorialContext {
    /* 0x0000 */ FName Context;
    /* 0x0010 */ FString BrowserFilter;
    /* 0x0020 */ FSoftClassPath AttractTutorial;
    /* 0x0040 */ FSoftClassPath LaunchTutorial;
};

// Size: 0x28
struct FTutorialProgress {
    /* 0x0000 */ FSoftClassPath Tutorial;
    /* 0x0020 */ int32_t CurrentStage;
    /* 0x0024 */ bool bUserDismissed;
};

// Size: 0x60
class UTutorialSettings : public UObject {
    /* 0x0030 */ TArray<FTutorialCategory> Categories;
    /* 0x0040 */ FSoftClassPath StartupTutorial;
};

// Size: 0xa8
struct FTutorialStage {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ FTutorialContent Content;
    /* 0x0050 */ TArray<FTutorialWidgetContent> WidgetContent;
    /* 0x0060 */ FText NextButtonText;
    /* 0x0078 */ FText BackButtonText;
    /* 0x0090 */ TArray<FString> PlatformsToTest;
    /* 0x00a0 */ bool bInvertPlatformTest;
};

// Size: 0x98
class UTutorialStateSettings : public UObject {
    /* 0x0030 */ TArray<FTutorialProgress> TutorialsProgress;
    /* 0x0090 */ bool bDismissedAllTutorials;
};

// Size: 0xd0
struct FTutorialWidgetContent {
    /* 0x0000 */ FTutorialContent Content;
    /* 0x0040 */ FTutorialContentAnchor WidgetAnchor;
    /* 0x00b8 */ uint8_t HorizontalAlignment;
    /* 0x00b9 */ uint8_t VerticalAlignment;
    /* 0x00bc */ FVector2D Offset;
    /* 0x00c4 */ float ContentWidth;
    /* 0x00c8 */ bool bAutoFocus;
};

// Size: 0x20
struct FJsonObjectWrapper {
    /* 0x0000 */ FString JsonString;
};

// Size: 0x30
class UJsonUtilitiesDummyObject : public UObject {
};

// Size: 0x28
struct FBPGraphClipboardData {
    /* 0x0000 */ FName GraphName;
    /* 0x000c */ uint8_t GraphType;
    /* 0x0010 */ TWeakObjectPtr<UBlueprint> OriginalBlueprint;
    /* 0x0018 */ FString NodesString;
};

// Size: 0x1a8
struct FBlueprintActionMenuItem : public FEdGraphSchemaAction {
};

// Size: 0x10
struct FBlueprintCompiledData {
    /* 0x0000 */ TArray<UEdGraph*> IntermediateGraphs;
};

// Size: 0x30
class UBlueprintCompilerExtension : public UObject {
};

// Size: 0x150
struct FBlueprintDragDropMenuItem : public FEdGraphSchemaAction {
};

// Size: 0x40
class UBlueprintEditorToolMenuContext : public UObject {
};

// Size: 0x78
class UBlueprintPaletteFavorites : public UObject {
    /* 0x0048 */ TArray<FString> CustomFavorites;
    /* 0x0058 */ TArray<FFavoritedBlueprintPaletteItem> CurrentFavorites;
    /* 0x0068 */ FString CurrentProfile;
};

enum class EContextTargetFlags {
    TARGET_Blueprint = 1,
    TARGET_SubComponents = 2,
    TARGET_NodeTarget = 4,
    TARGET_PinObject = 8,
    TARGET_SiblingPinObjects = 16,
    TARGET_BlueprintLibraries = 32,
    ContextTargetFlagsEnd = 33,
    EContextTargetFlags_MAX = 34,
};

enum class EFiBVersion {
    FIB_VER_NONE = -1,
    FIB_VER_BASE = 0,
    FIB_VER_VARIABLE_REFERENCE = 1,
    FIB_VER_INTERFACE_GRAPHS = 2,
    FIB_VER_PLUS_ONE = 3,
    FIB_VER_LATEST = 2,
    FIB_VER_MAX = 4,
};

// Size: 0x70
struct FFavoritedBlueprintPaletteItem {
};

// Size: 0x40
class USCSEditorExtensionContext : public UObject {
};

// Size: 0x48
class USSCSEditorMenuContext : public UObject {
};

// Size: 0x300
class AControlPointMeshActor : public AActor {
    /* 0x02f8 */ UControlPointMeshComponent* ControlPointMeshComponent;
};

// Size: 0x5d0
class UControlPointMeshComponent : public UStaticMeshComponent {
    /* 0x05c8 */ bool bSelected;
    /* 0x05cc */ float VirtualTextureMainPassMaxDrawDistance;
};

enum class EGrassScaling {
    Uniform = 0,
    Free = 1,
    LockXY = 2,
    EGrassScaling_MAX = 3,
};

enum class EHeightmapRTType {
    HeightmapRT_CombinedAtlas = 0,
    HeightmapRT_CombinedNonAtlas = 1,
    HeightmapRT_Scratch1 = 2,
    HeightmapRT_Scratch2 = 3,
    HeightmapRT_Scratch3 = 4,
    HeightmapRT_Mip1 = 5,
    HeightmapRT_Mip2 = 6,
    HeightmapRT_Mip3 = 7,
    HeightmapRT_Mip4 = 8,
    HeightmapRT_Mip5 = 9,
    HeightmapRT_Mip6 = 10,
    HeightmapRT_Mip7 = 11,
    HeightmapRT_Count = 12,
    HeightmapRT_MAX = 13,
};

enum class ELandscapeBlendMode {
    LSBM_AdditiveBlend = 0,
    LSBM_AlphaBlend = 1,
    LSBM_MAX = 2,
};

enum class ELandscapeClearMode {
    Clear_Weightmap = 1,
    Clear_Heightmap = 2,
    Clear_All = 3,
    Clear_MAX = 4,
};

enum class ELandscapeCustomizedCoordType {
    LCCT_None = 0,
    LCCT_CustomUV0 = 1,
    LCCT_CustomUV1 = 2,
    LCCT_CustomUV2 = 3,
    LCCT_WeightMapUV = 4,
    LCCT_MAX = 5,
};

enum class ELandscapeGizmoType {
    LGT_None = 0,
    LGT_Height = 1,
    LGT_Weight = 2,
    LGT_MAX = 3,
};

enum class ELandscapeImportAlphamapType {
    Additive = 0,
    Layered = 1,
    ELandscapeImportAlphamapType_MAX = 2,
};

enum class ELandscapeLODFalloff {
    Linear = 0,
    SquareRoot = 1,
    ELandscapeLODFalloff_MAX = 2,
};

enum class ELandscapeLayerBlendType {
    LB_WeightBlend = 0,
    LB_AlphaBlend = 1,
    LB_HeightBlend = 2,
    LB_MAX = 3,
};

enum class ELandscapeLayerDisplayMode {
    Default = 0,
    Alphabetical = 1,
    UserSpecific = 2,
    ELandscapeLayerDisplayMode_MAX = 3,
};

enum class ELandscapeLayerPaintingRestriction {
    None = 0,
    UseMaxLayers = 1,
    ExistingOnly = 2,
    UseComponentWhitelist = 3,
    ELandscapeLayerPaintingRestriction_MAX = 4,
};

enum class ELandscapeSetupErrors {
    LSE_None = 0,
    LSE_NoLandscapeInfo = 1,
    LSE_CollsionXY = 2,
    LSE_NoLayerInfo = 3,
    LSE_MAX = 4,
};

enum class ERTDrawingType {
    RTAtlas = 0,
    RTAtlasToNonAtlas = 1,
    RTNonAtlasToAtlas = 2,
    RTNonAtlas = 3,
    RTMips = 4,
    ERTDrawingType_MAX = 5,
};

enum class ESplineModulationColorMask {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
    ESplineModulationColorMask_MAX = 4,
};

enum class ETerrainCoordMappingType {
    TCMT_Auto = 0,
    TCMT_XY = 1,
    TCMT_XZ = 2,
    TCMT_YZ = 3,
    TCMT_MAX = 4,
};

enum class EWeightmapRTType {
    WeightmapRT_Scratch_RGBA = 0,
    WeightmapRT_Scratch1 = 1,
    WeightmapRT_Scratch2 = 2,
    WeightmapRT_Scratch3 = 3,
    WeightmapRT_Mip0 = 4,
    WeightmapRT_Mip1 = 5,
    WeightmapRT_Mip2 = 6,
    WeightmapRT_Mip3 = 7,
    WeightmapRT_Mip4 = 8,
    WeightmapRT_Mip5 = 9,
    WeightmapRT_Mip6 = 10,
    WeightmapRT_Mip7 = 11,
    WeightmapRT_Count = 12,
    WeightmapRT_MAX = 13,
};

// Size: 0x38
struct FForeignControlPointData {
    /* 0x0000 */ FGuid ModificationKey;
    /* 0x0010 */ UControlPointMeshComponent* MeshComponent;
    /* 0x0018 */ TLazyObjectPtr<ULandscapeSplineControlPoint> Identifier;
};

// Size: 0x40
struct FForeignSplineSegmentData {
    /* 0x0000 */ FGuid ModificationKey;
    /* 0x0010 */ TArray<USplineMeshComponent*> MeshComponents;
    /* 0x0020 */ TLazyObjectPtr<ULandscapeSplineSegment> Identifier;
};

// Size: 0xc0
struct FForeignWorldSplineData {
    /* 0x0000 */ TMap<TLazyObjectPtr<ULandscapeSplineControlPoint>, FForeignControlPointData> ForeignControlPointDataMap;
    /* 0x0050 */ TArray<FForeignControlPointData> ForeignControlPointData;
    /* 0x0060 */ TMap<TLazyObjectPtr<ULandscapeSplineSegment>, FForeignSplineSegmentData> ForeignSplineSegmentDataMap;
    /* 0x00b0 */ TArray<FForeignSplineSegmentData> ForeignSplineSegmentData;
};

// Size: 0x58
struct FGizmoSelectData {
    /* 0x0000 */ float Ratio;
    /* 0x0004 */ float HeightData;
};

// Size: 0x50
struct FGrassInput {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ ULandscapeGrassType* GrassType;
    /* 0x0018 */ FExpressionInput Input;
};

// Size: 0x150
struct FGrassVariety {
    /* 0x0000 */ UStaticMesh* GrassMesh;
    /* 0x0008 */ TArray<UMaterialInterface*> OverrideMaterials;
    /* 0x0018 */ FPerPlatformFloat GrassDensity;
    /* 0x0070 */ bool bUseGrid;
    /* 0x0074 */ float PlacementJitter;
    /* 0x0078 */ FPerPlatformInt StartCullDistance;
    /* 0x00d0 */ FPerPlatformInt EndCullDistance;
    /* 0x0128 */ int32_t MinLOD;
    /* 0x012c */ EGrassScaling Scaling;
    /* 0x0130 */ FFloatInterval ScaleX;
    /* 0x0138 */ FFloatInterval ScaleY;
    /* 0x0140 */ FFloatInterval ScaleZ;
    /* 0x0148 */ bool RandomRotation;
    /* 0x0149 */ bool AlignToSurface;
    /* 0x014a */ bool bUseLandscapeLightmap;
    /* 0x014b */ FLightingChannels LightingChannels;
    /* 0x014c */ bool bReceivesDecals;
    /* 0x014d */ bool bCastDynamicShadow;
    /* 0x014e */ bool bKeepInstanceBufferCPUCopy;
};

// Size: 0x8
struct FHeightmapData {
    /* 0x0000 */ UTexture2D* Texture;
};

// Size: 0x990
class ALandscape : public ALandscapeProxy {
    /* 0x0848 */ bool bCanHaveLayersContent;
    /* 0x084c */ FGuid LandscapeSplinesTargetLayerGuid;
    /* 0x0870 */ TArray<FLandscapeLayer> LandscapeLayers;
    /* 0x0880 */ TArray<UTextureRenderTarget2D*> HeightmapRTList;
    /* 0x0890 */ TArray<UTextureRenderTarget2D*> WeightmapRTList;
    /* 0x08d0 */ TSet<ULandscapeComponent*> LandscapeSplinesAffectedComponents;
    /* 0x0948 */ bool bLandscapeLayersAreInitialized;
    /* 0x0949 */ bool WasCompilingShaders;
    /* 0x094c */ uint32_t LayerContentUpdateModes;
    /* 0x0950 */ bool bSplineLayerUpdateRequested;
};

// Size: 0x320
class ALandscapeBlueprintBrushBase : public AActor {
    /* 0x02f8 */ ALandscape* OwningLandscape;
    /* 0x0300 */ bool AffectHeightmap;
    /* 0x0301 */ bool AffectWeightmap;
    /* 0x0308 */ TArray<FName> AffectedWeightmapLayers;
    /* 0x0318 */ bool bIsVisible;

    void GetBlueprintRenderDependencies(TArray<UObject*>& OutStreamableAssets);
    void Initialize(const FTransform& InLandscapeTransform, const FIntPoint& InLandscapeSize, const FIntPoint& InLandscapeRenderTargetSize);
    UTextureRenderTarget2D* Render(bool InIsHeightmap, UTextureRenderTarget2D* InCombinedResult, const FName& InWeightmapLayerName);
    void RequestLandscapeUpdate();
};

// Size: 0x890
class ULandscapeComponent : public UPrimitiveComponent {
    /* 0x04d8 */ int32_t SectionBaseX;
    /* 0x04dc */ int32_t SectionBaseY;
    /* 0x04e0 */ int32_t ComponentSizeQuads;
    /* 0x04e4 */ int32_t SubsectionSizeQuads;
    /* 0x04e8 */ int32_t NumSubsections;
    /* 0x04f0 */ UMaterialInterface* OverrideMaterial;
    /* 0x04f8 */ UMaterialInterface* OverrideHoleMaterial;
    /* 0x0500 */ TArray<FLandscapeComponentMaterialOverride> OverrideMaterials;
    /* 0x0510 */ UMaterialInstanceConstant* MaterialInstance;
    /* 0x0518 */ TArray<UMaterialInstanceConstant*> MaterialInstances;
    /* 0x0528 */ TArray<UMaterialInstanceDynamic*> MaterialInstancesDynamic;
    /* 0x0538 */ TArray<int8_t> LODIndexToMaterialIndex;
    /* 0x0548 */ TArray<int8_t> MaterialIndexToDisabledTessellationMaterial;
    /* 0x0558 */ UTexture2D* XYOffsetmapTexture;
    /* 0x0560 */ FVector4 WeightmapScaleBias;
    /* 0x0570 */ float WeightmapSubsectionOffset;
    /* 0x0580 */ FVector4 HeightmapScaleBias;
    /* 0x0590 */ FBox CachedLocalBox;
    /* 0x05ac */ TLazyObjectPtr<ULandscapeHeightfieldCollisionComponent> CollisionComponent;
    /* 0x05c8 */ FGuid LightingGuid;
    /* 0x05d8 */ TMap<FGuid, FLandscapeLayerComponentData> LayersData;
    /* 0x0650 */ TArray<ULandscapeWeightmapUsage*> WeightmapTexturesUsage;
    /* 0x0660 */ uint32_t LayerUpdateFlagPerMode;
    /* 0x0664 */ bool bPendingCollisionDataUpdate;
    /* 0x0665 */ bool bPendingLayerCollisionDataUpdate;
    /* 0x0678 */ UTexture2D* HeightmapTexture;
    /* 0x0680 */ TArray<FWeightmapLayerAllocationInfo> WeightmapLayerAllocations;
    /* 0x0690 */ TArray<UTexture2D*> WeightmapTextures;
    /* 0x06a0 */ ULandscapeLODStreamingProxy* LODStreamingProxy;
    /* 0x06a8 */ FGuid MapBuildDataId;
    /* 0x06b8 */ TArray<FGuid> IrrelevantLights;
    /* 0x06c8 */ int32_t CollisionMipLevel;
    /* 0x06cc */ int32_t SimpleCollisionMipLevel;
    /* 0x06d0 */ float NegativeZBoundsExtension;
    /* 0x06d4 */ float PositiveZBoundsExtension;
    /* 0x06d8 */ float StaticLightingResolution;
    /* 0x06dc */ int32_t ForcedLOD;
    /* 0x06e0 */ int32_t LODBias;
    /* 0x06e4 */ FGuid StateId;
    /* 0x06f4 */ FGuid BakedTextureMaterialGuid;
    /* 0x0708 */ UTexture2D* GIBakedBaseColorTexture;
    /* 0x0710 */ int32_t LightingLODBias;
    /* 0x0718 */ TArray<ULandscapeLayerInfoObject*> LayerWhitelist;
    /* 0x0728 */ FLandscapeEditToolRenderData EditToolRenderData;
    /* 0x0760 */ FGuid MobileDataSourceHash;
    /* 0x0770 */ TMap<UMaterialInterface*, int8_t> MaterialPerLOD;
    /* 0x07c4 */ uint32_t SplineHash;
    /* 0x07c8 */ uint32_t PhysicalMaterialHash;
    /* 0x07cc */ uint8_t MobileBlendableLayerMask;
    /* 0x07d0 */ UMaterialInterface* MobileMaterialInterface;
    /* 0x07d8 */ TArray<UMaterialInterface*> MobileMaterialInterfaces;
    /* 0x07e8 */ TArray<UTexture2D*> MobileWeightmapTextures;
    /* 0x0808 */ TArray<UMaterialInstanceConstant*> MobileCombinationMaterialInstances;
    /* 0x0818 */ UMaterialInstanceConstant* MobileCombinationMaterialInstance;

    float EditorGetPaintLayerWeightAtLocation(const FVector& InLocation, ULandscapeLayerInfoObject* PaintLayer);
    float EditorGetPaintLayerWeightByNameAtLocation(const FVector& InLocation, const FName InPaintLayerName);
    UMaterialInstanceDynamic* GetMaterialInstanceDynamic(int32_t InIndex) const;
};

// Size: 0x60
struct FLandscapeComponentMaterialOverride {
    /* 0x0000 */ FPerPlatformInt LODIndex;
    /* 0x0058 */ UMaterialInterface* Material;
};

// Size: 0x38
struct FLandscapeEditToolRenderData {
    /* 0x0000 */ UMaterialInterface* ToolMaterial;
    /* 0x0008 */ UMaterialInterface* GizmoMaterial;
    /* 0x0010 */ int32_t SelectedType;
    /* 0x0014 */ int32_t DebugChannelR;
    /* 0x0018 */ int32_t DebugChannelG;
    /* 0x001c */ int32_t DebugChannelB;
    /* 0x0020 */ UTexture2D* DataTexture;
    /* 0x0028 */ UTexture2D* LayerContributionTexture;
    /* 0x0030 */ UTexture2D* DirtyTexture;
};

// Size: 0x18
struct FLandscapeEditorLayerSettings {
    /* 0x0000 */ ULandscapeLayerInfoObject* LayerInfoObj;
    /* 0x0008 */ FString ReimportLayerFilePath;
};

// Size: 0x458
class ALandscapeGizmoActiveActor : public ALandscapeGizmoActor {
    /* 0x0320 */ uint8_t DataType;
    /* 0x0328 */ UTexture2D* GizmoTexture;
    /* 0x0330 */ FVector2D TextureScale;
    /* 0x0338 */ TArray<FVector> SampledHeight;
    /* 0x0348 */ TArray<FVector> SampledNormal;
    /* 0x0358 */ int32_t SampleSizeX;
    /* 0x035c */ int32_t SampleSizeY;
    /* 0x0360 */ float CachedWidth;
    /* 0x0364 */ float CachedHeight;
    /* 0x0368 */ float CachedScaleXY;
    /* 0x036c */ FVector FrustumVerts[8];
    /* 0x03d0 */ UMaterial* GizmoMaterial;
    /* 0x03d8 */ UMaterialInstance* GizmoDataMaterial;
    /* 0x03e0 */ UMaterial* GizmoMeshMaterial;
    /* 0x03e8 */ TArray<ULandscapeLayerInfoObject*> LayerInfos;
    /* 0x03f8 */ bool bSnapToLandscapeGrid;
    /* 0x03fc */ FRotator UnsnappedRotation;
};

// Size: 0x320
class ALandscapeGizmoActor : public AActor {
    /* 0x02f8 */ float Width;
    /* 0x02fc */ float Height;
    /* 0x0300 */ float LengthZ;
    /* 0x0304 */ float MarginZ;
    /* 0x0308 */ float MinRelativeZ;
    /* 0x030c */ float RelativeScaleZ;
    /* 0x0310 */ ULandscapeInfo* TargetLandscapeInfo;
    /* 0x0318 */ UBillboardComponent* SpriteComponent;
};

// Size: 0x4e0
class ULandscapeGizmoRenderComponent : public UPrimitiveComponent {
};

// Size: 0x68
class ULandscapeGrassType : public UObject {
    /* 0x0030 */ TArray<FGrassVariety> GrassVarieties;
    /* 0x0040 */ bool bEnableDensityScaling;
    /* 0x0048 */ UStaticMesh* GrassMesh;
    /* 0x0050 */ float GrassDensity;
    /* 0x0054 */ float PlacementJitter;
    /* 0x0058 */ int32_t StartCullDistance;
    /* 0x005c */ int32_t EndCullDistance;
    /* 0x0060 */ bool RandomRotation;
    /* 0x0061 */ bool AlignToSurface;
};

// Size: 0x7d0
class ULandscapeHeightfieldCollisionComponent : public UPrimitiveComponent {
    /* 0x04d8 */ TArray<ULandscapeLayerInfoObject*> ComponentLayerInfos;
    /* 0x04e8 */ int32_t SectionBaseX;
    /* 0x04ec */ int32_t SectionBaseY;
    /* 0x04f0 */ int32_t CollisionSizeQuads;
    /* 0x04f4 */ float CollisionScale;
    /* 0x04f8 */ int32_t SimpleCollisionSizeQuads;
    /* 0x0500 */ TArray<uint8_t> CollisionQuadFlags;
    /* 0x0510 */ FGuid HeightfieldGuid;
    /* 0x0520 */ FBox CachedLocalBox;
    /* 0x053c */ TLazyObjectPtr<ULandscapeComponent> RenderComponent;
    /* 0x0728 */ TArray<UPhysicalMaterial*> PhysicalMaterialRenderObjects;
    /* 0x0770 */ TArray<UPhysicalMaterial*> CookedPhysicalMaterials;

    ULandscapeComponent* GetRenderComponent() const;
};

// Size: 0x38
struct FLandscapeImportLayerInfo {
    /* 0x0000 */ FName LayerName;
    /* 0x0010 */ ULandscapeLayerInfoObject* LayerInfo;
    /* 0x0018 */ FString SourceFilePath;
};

// Size: 0x278
class ULandscapeInfo : public UObject {
    /* 0x0030 */ TLazyObjectPtr<ALandscape> LandscapeActor;
    /* 0x004c */ FGuid LandscapeGuid;
    /* 0x005c */ int32_t ComponentSizeQuads;
    /* 0x0060 */ int32_t SubsectionSizeQuads;
    /* 0x0064 */ int32_t ComponentNumSubsections;
    /* 0x0068 */ FVector DrawScale;
    /* 0x0078 */ TArray<FLandscapeInfoLayerSettings> Layers;
    /* 0x0178 */ TArray<ALandscapeStreamingProxy*> Proxies;
};

// Size: 0x30
struct FLandscapeInfoLayerSettings {
    /* 0x0000 */ ULandscapeLayerInfoObject* LayerInfoObj;
    /* 0x0008 */ FName LayerName;
    /* 0x0018 */ UMaterialInstanceConstant* ThumbnailMIC;
    /* 0x0020 */ ALandscapeProxy* Owner;
    /* 0x0028 */ int32_t DebugColorChannel;
    /* 0x002c */ bool bValid;
};

// Size: 0x88
class ULandscapeInfoMap : public UObject {
};

// Size: 0x70
class ULandscapeLODStreamingProxy : public UStreamableRenderAsset {
};

// Size: 0x90
struct FLandscapeLayer {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ FName Name;
    /* 0x001c */ bool bVisible;
    /* 0x001d */ bool bLocked;
    /* 0x0020 */ float HeightmapAlpha;
    /* 0x0024 */ float WeightmapAlpha;
    /* 0x0028 */ uint8_t BlendMode;
    /* 0x0030 */ TArray<FLandscapeLayerBrush> Brushes;
    /* 0x0040 */ TMap<ULandscapeLayerInfoObject*, bool> WeightmapLayerAllocationBlend;
};

// Size: 0x50
struct FLandscapeLayerBrush {
    /* 0x0000 */ ALandscapeBlueprintBrushBase* BlueprintBrush;
};

// Size: 0x38
struct FLandscapeLayerComponentData {
    /* 0x0000 */ FHeightmapData HeightmapData;
    /* 0x0008 */ FWeightmapData WeightmapData;
};

// Size: 0x88
class ULandscapeLayerInfoObject : public UObject {
    /* 0x0030 */ FName LayerName;
    /* 0x0040 */ UPhysicalMaterial* PhysMaterial;
    /* 0x0048 */ float Hardness;
    /* 0x004c */ float MinimumCollisionRelevanceWeight;
    /* 0x0050 */ bool bNoWeightBlend;
    /* 0x0058 */ UTexture2D* SplineFalloffModulationTexture;
    /* 0x0060 */ ESplineModulationColorMask SplineFalloffModulationColorMask;
    /* 0x0064 */ float SplineFalloffModulationTiling;
    /* 0x0068 */ float SplineFalloffModulationBias;
    /* 0x006c */ float SplineFalloffModulationScale;
    /* 0x0070 */ bool IsReferencedFromLoadedData;
    /* 0x0074 */ FLinearColor LayerUsageDebugColor;
};

// Size: 0x30
struct FLandscapeLayerStruct {
    /* 0x0000 */ ULandscapeLayerInfoObject* LayerInfoObj;
    /* 0x0008 */ ULandscapeMaterialInstanceConstant* ThumbnailMIC;
    /* 0x0010 */ ALandscapeProxy* Owner;
    /* 0x0018 */ int32_t DebugColorChannel;
    /* 0x001c */ bool bSelected;
    /* 0x0020 */ FString SourceFilePath;
};

// Size: 0x5d8
class ULandscapeMaterialInstanceConstant : public UMaterialInstanceConstant {
    /* 0x05c0 */ TArray<FLandscapeMaterialTextureStreamingInfo> TextureStreamingInfo;
    /* 0x05d0 */ bool bIsLayerThumbnail;
    /* 0x05d0 */ bool bDisableTessellation;
    /* 0x05d0 */ bool bMobile;
    /* 0x05d0 */ bool bEditorToolUsage;
};

// Size: 0x10
struct FLandscapeMaterialTextureStreamingInfo {
    /* 0x0000 */ FName TextureName;
    /* 0x000c */ float TexelFactor;
};

// Size: 0x880
class ULandscapeMeshCollisionComponent : public ULandscapeHeightfieldCollisionComponent {
    /* 0x07d0 */ FGuid MeshGuid;
};

// Size: 0x300
class ALandscapeMeshProxyActor : public AActor {
    /* 0x02f8 */ ULandscapeMeshProxyComponent* LandscapeMeshProxyComponent;
};

// Size: 0x5f0
class ULandscapeMeshProxyComponent : public UStaticMeshComponent {
    /* 0x05c8 */ FGuid LandscapeGuid;
    /* 0x05d8 */ TArray<FIntPoint> ProxyComponentBases;
    /* 0x05e8 */ int8_t ProxyLOD;
};

// Size: 0x848
class ALandscapeProxy : public AActor {
    /* 0x02f8 */ ULandscapeSplinesComponent* SplineComponent;
    /* 0x0300 */ FGuid LandscapeGuid;
    /* 0x0310 */ FIntPoint LandscapeSectionOffset;
    /* 0x0318 */ int32_t MaxLODLevel;
    /* 0x031c */ float LODDistanceFactor;
    /* 0x0320 */ uint8_t LODFalloff;
    /* 0x0324 */ float ComponentScreenSizeToUseSubSections;
    /* 0x0328 */ float LOD0ScreenSize;
    /* 0x032c */ float LOD0DistributionSetting;
    /* 0x0330 */ float LODDistributionSetting;
    /* 0x0334 */ float TessellationComponentScreenSize;
    /* 0x0338 */ bool UseTessellationComponentScreenSizeFalloff;
    /* 0x033c */ float TessellationComponentScreenSizeFalloff;
    /* 0x0340 */ int32_t OccluderGeometryLOD;
    /* 0x0344 */ int32_t ExportLOD;
    /* 0x0348 */ TArray<FName> TargetDisplayOrderList;
    /* 0x0358 */ ELandscapeLayerDisplayMode TargetDisplayOrder;
    /* 0x035c */ int32_t StaticLightingLOD;
    /* 0x0360 */ UPhysicalMaterial* DefaultPhysMaterial;
    /* 0x0368 */ float StreamingDistanceMultiplier;
    /* 0x0370 */ UMaterialInterface* LandscapeMaterial;
    /* 0x0378 */ UMaterialInterface* LandscapeHoleMaterial;
    /* 0x0380 */ TArray<FLandscapeProxyMaterialOverride> LandscapeMaterialsOverride;
    /* 0x0390 */ UMaterialInterface* PreEditLandscapeMaterial;
    /* 0x0398 */ UMaterialInterface* PreEditLandscapeHoleMaterial;
    /* 0x03a0 */ TArray<FLandscapeProxyMaterialOverride> PreEditLandscapeMaterialsOverride;
    /* 0x03b0 */ bool bIsPerformingInteractiveActionOnLandscapeMaterialOverride;
    /* 0x03b1 */ bool bMeshHoles;
    /* 0x03b2 */ uint8_t MeshHolesMaxLod;
    /* 0x03b8 */ TArray<URuntimeVirtualTexture*> RuntimeVirtualTextures;
    /* 0x03c8 */ int32_t VirtualTextureNumLods;
    /* 0x03cc */ int32_t VirtualTextureLodBias;
    /* 0x03d0 */ ERuntimeVirtualTextureMainPassType VirtualTextureRenderPassType;
    /* 0x03d4 */ float NegativeZBoundsExtension;
    /* 0x03d8 */ float PositiveZBoundsExtension;
    /* 0x03e0 */ TArray<ULandscapeComponent*> LandscapeComponents;
    /* 0x03f0 */ TArray<ULandscapeHeightfieldCollisionComponent*> CollisionComponents;
    /* 0x0400 */ TArray<UHierarchicalInstancedStaticMeshComponent*> FoliageComponents;
    /* 0x0474 */ bool bHasLandscapeGrass;
    /* 0x0478 */ float StaticLightingResolution;
    /* 0x047c */ bool CastShadow;
    /* 0x047c */ bool bCastDynamicShadow;
    /* 0x047c */ bool bCastStaticShadow;
    /* 0x0480 */ bool bCastFarShadow;
    /* 0x0484 */ bool bCastHiddenShadow;
    /* 0x0488 */ bool bCastShadowAsTwoSided;
    /* 0x048c */ bool bAffectDistanceFieldLighting;
    /* 0x048d */ FLightingChannels LightingChannels;
    /* 0x0490 */ bool bUseMaterialPositionOffsetInStaticLighting;
    /* 0x0490 */ bool bRenderCustomDepth;
    /* 0x0494 */ ERendererStencilMask CustomDepthStencilWriteMask;
    /* 0x0498 */ int32_t CustomDepthStencilValue;
    /* 0x049c */ float LDMaxDrawDistance;
    /* 0x04a0 */ bool bIsMovingToLevel;
    /* 0x04a4 */ FLightmassPrimitiveSettings LightmassSettings;
    /* 0x04bc */ int32_t CollisionMipLevel;
    /* 0x04c0 */ int32_t SimpleCollisionMipLevel;
    /* 0x04c4 */ float CollisionThickness;
    /* 0x04c8 */ FBodyInstance BodyInstance;
    /* 0x0658 */ bool bGenerateOverlapEvents;
    /* 0x0658 */ bool bBakeMaterialPositionOffsetIntoCollision;
    /* 0x0660 */ TArray<ULandscapeLayerInfoObject*> EditorCachedLayerInfos;
    /* 0x0670 */ FString ReimportHeightmapFilePath;
    /* 0x0680 */ FGuid ReimportDestinationLayerGuid;
    /* 0x0690 */ TArray<FLandscapeEditorLayerSettings> EditorLayerSettings;
    /* 0x0750 */ int32_t ComponentSizeQuads;
    /* 0x0754 */ int32_t SubsectionSizeQuads;
    /* 0x0758 */ int32_t NumSubsections;
    /* 0x075c */ bool bUsedForNavigation;
    /* 0x075c */ bool bFillCollisionUnderLandscapeForNavmesh;
    /* 0x0760 */ bool bUseDynamicMaterialInstance;
    /* 0x0761 */ ENavDataGatheringMode NavigationGeometryGatheringMode;
    /* 0x0764 */ int32_t MaxPaintedLayersPerComponent;
    /* 0x0768 */ bool bUseLandscapeForCullingInvisibleHLODVertices;
    /* 0x0769 */ bool bHasLayersContent;
    /* 0x07c0 */ TMap<UTexture2D*, ULandscapeWeightmapUsage*> WeightmapUsageMap;

    void ChangeComponentScreenSizeToUseSubSections(float InComponentScreenSizeToUseSubSections);
    void ChangeLODDistanceFactor(float InLODDistanceFactor);
    void ChangeTessellationComponentScreenSize(float InTessellationComponentScreenSize);
    void ChangeTessellationComponentScreenSizeFalloff(float InUseTessellationComponentScreenSizeFalloff);
    void ChangeUseTessellationComponentScreenSizeFalloff(bool InComponentScreenSizeToUseSubSections);
    void EditorApplySpline(USplineComponent* InSplineComponent, float StartWidth, float EndWidth, float StartSideFalloff, float EndSideFalloff, float StartRoll, float EndRoll, int32_t NumSubdivisions, bool bRaiseHeights, bool bLowerHeights, ULandscapeLayerInfoObject* PaintLayer, FName EditLayerName);
    void EditorSetLandscapeMaterial(UMaterialInterface* NewLandscapeMaterial);
    bool LandscapeExportHeightmapToRenderTarget(UTextureRenderTarget2D* InRenderTarget, bool InExportHeightIntoRGChannel, bool InExportLandscapeProxies);
    bool LandscapeExportWeightmapToRenderTarget(UTextureRenderTarget2D* InRenderTarget, FName InLayerName);
    bool LandscapeImportHeightmapFromRenderTarget(UTextureRenderTarget2D* InRenderTarget, bool InImportHeightFromRGChannel);
    bool LandscapeImportWeightmapFromRenderTarget(UTextureRenderTarget2D* InRenderTarget, FName InLayerName);
    void SetLandscapeMaterialScalarParameterValue(FName ParameterName, float Value);
    void SetLandscapeMaterialTextureParameterValue(FName ParameterName, UTexture* Value);
    void SetLandscapeMaterialVectorParameterValue(FName ParameterName, FLinearColor Value);
};

// Size: 0x60
struct FLandscapeProxyMaterialOverride {
    /* 0x0000 */ FPerPlatformInt LODIndex;
    /* 0x0058 */ UMaterialInterface* Material;
};

// Size: 0x68
class ULandscapeSettings : public UDeveloperSettings {
    /* 0x0060 */ int32_t MaxNumberOfLayers;
};

// Size: 0x10
struct FLandscapeSplineConnection {
    /* 0x0000 */ ULandscapeSplineSegment* Segment;
    /* 0x0008 */ bool End;
};

// Size: 0x310
class ULandscapeSplineControlPoint : public UObject {
    /* 0x0030 */ FVector Location;
    /* 0x003c */ FRotator Rotation;
    /* 0x0048 */ float Width;
    /* 0x004c */ float LayerWidthRatio;
    /* 0x0050 */ float SideFalloff;
    /* 0x0054 */ float LeftSideFalloffFactor;
    /* 0x0058 */ float RightSideFalloffFactor;
    /* 0x005c */ float LeftSideLayerFalloffFactor;
    /* 0x0060 */ float RightSideLayerFalloffFactor;
    /* 0x0064 */ float EndFalloff;
    /* 0x0068 */ float SegmentMeshOffset;
    /* 0x006c */ FName LayerName;
    /* 0x0078 */ bool bRaiseTerrain;
    /* 0x0078 */ bool bLowerTerrain;
    /* 0x0080 */ UStaticMesh* Mesh;
    /* 0x0088 */ TArray<UMaterialInterface*> MaterialOverrides;
    /* 0x0098 */ FVector MeshScale;
    /* 0x00a4 */ bool bEnableCollision;
    /* 0x00a8 */ FName CollisionProfileName;
    /* 0x00b4 */ bool bCastShadow;
    /* 0x00b8 */ bool bHiddenInGame;
    /* 0x00bc */ bool bPlaceSplineMeshesInStreamingLevels;
    /* 0x00c0 */ float LDMaxDrawDistance;
    /* 0x00c4 */ int32_t TranslucencySortPriority;
    /* 0x00c8 */ bool bRenderCustomDepth;
    /* 0x00c9 */ ERendererStencilMask CustomDepthStencilWriteMask;
    /* 0x00cc */ int32_t CustomDepthStencilValue;
    /* 0x00d0 */ TArray<URuntimeVirtualTexture*> RuntimeVirtualTextures;
    /* 0x00e0 */ int32_t VirtualTextureLodBias;
    /* 0x00e4 */ int32_t VirtualTextureCullMips;
    /* 0x00e8 */ float VirtualTextureMainPassMaxDrawDistance;
    /* 0x00ec */ ERuntimeVirtualTextureMainPassType VirtualTextureRenderPassType;
    /* 0x00f0 */ FBodyInstance BodyInstance;
    /* 0x0280 */ bool bSelected;
    /* 0x0280 */ bool bNavDirty;
    /* 0x0288 */ TArray<FLandscapeSplineConnection> ConnectedSegments;
    /* 0x0298 */ TArray<FLandscapeSplineInterpPoint> Points;
    /* 0x02a8 */ FBox Bounds;
    /* 0x02c8 */ UControlPointMeshComponent* LocalMeshComponent;
    /* 0x02d0 */ TSoftObjectPtr<UWorld> ForeignWorld;
    /* 0x0300 */ FGuid ModificationKey;
};

// Size: 0x70
struct FLandscapeSplineInterpPoint {
    /* 0x0000 */ FVector Center;
    /* 0x000c */ FVector Left;
    /* 0x0018 */ FVector Right;
    /* 0x0024 */ FVector FalloffLeft;
    /* 0x0030 */ FVector FalloffRight;
    /* 0x003c */ FVector LayerLeft;
    /* 0x0048 */ FVector LayerRight;
    /* 0x0054 */ FVector LayerFalloffLeft;
    /* 0x0060 */ FVector LayerFalloffRight;
    /* 0x006c */ float StartEndFalloff;
};

// Size: 0x38
struct FLandscapeSplineMeshEntry {
    /* 0x0000 */ UStaticMesh* Mesh;
    /* 0x0008 */ TArray<UMaterialInterface*> MaterialOverrides;
    /* 0x0018 */ bool bCenterH;
    /* 0x001c */ FVector2D CenterAdjust;
    /* 0x0024 */ bool bScaleToWidth;
    /* 0x0028 */ FVector Scale;
    /* 0x0034 */ uint8_t Orientation;
    /* 0x0035 */ uint8_t ForwardAxis;
    /* 0x0036 */ uint8_t UpAxis;
};

enum class LandscapeSplineMeshOrientation {
    LSMO_XUp = 0,
    LSMO_YUp = 1,
    LSMO_MAX = 2,
};

// Size: 0x2d8
class ULandscapeSplineSegment : public UObject {
    /* 0x0030 */ FLandscapeSplineSegmentConnection Connections[2];
    /* 0x0060 */ FName LayerName;
    /* 0x006c */ bool bRaiseTerrain;
    /* 0x006c */ bool bLowerTerrain;
    /* 0x0070 */ TArray<FLandscapeSplineMeshEntry> SplineMeshes;
    /* 0x0080 */ bool bEnableCollision;
    /* 0x0084 */ FName CollisionProfileName;
    /* 0x0090 */ bool bCastShadow;
    /* 0x0090 */ bool bHiddenInGame;
    /* 0x0090 */ bool bPlaceSplineMeshesInStreamingLevels;
    /* 0x0094 */ int32_t RandomSeed;
    /* 0x0098 */ float LDMaxDrawDistance;
    /* 0x009c */ int32_t TranslucencySortPriority;
    /* 0x00a0 */ bool bRenderCustomDepth;
    /* 0x00a1 */ ERendererStencilMask CustomDepthStencilWriteMask;
    /* 0x00a4 */ int32_t CustomDepthStencilValue;
    /* 0x00a8 */ TArray<URuntimeVirtualTexture*> RuntimeVirtualTextures;
    /* 0x00b8 */ int32_t VirtualTextureLodBias;
    /* 0x00bc */ int32_t VirtualTextureCullMips;
    /* 0x00c0 */ float VirtualTextureMainPassMaxDrawDistance;
    /* 0x00c4 */ ERuntimeVirtualTextureMainPassType VirtualTextureRenderPassType;
    /* 0x00c8 */ FBodyInstance BodyInstance;
    /* 0x0258 */ bool bSelected;
    /* 0x0258 */ bool bNavDirty;
    /* 0x0260 */ FInterpCurveVector SplineInfo;
    /* 0x0278 */ TArray<FLandscapeSplineInterpPoint> Points;
    /* 0x0288 */ FBox Bounds;
    /* 0x02a8 */ TArray<USplineMeshComponent*> LocalMeshComponents;
    /* 0x02b8 */ TArray<TSoftObjectPtr<UWorld>> ForeignWorlds;
    /* 0x02c8 */ FGuid ModificationKey;
};

// Size: 0x18
struct FLandscapeSplineSegmentConnection {
    /* 0x0000 */ ULandscapeSplineControlPoint* ControlPoint;
    /* 0x0008 */ float TangentLen;
    /* 0x000c */ FName SocketName;
};

// Size: 0x620
class ULandscapeSplinesComponent : public UPrimitiveComponent {
    /* 0x04d8 */ float SplineResolution;
    /* 0x04dc */ FColor SplineColor;
    /* 0x04e0 */ UTexture2D* ControlPointSprite;
    /* 0x04e8 */ UStaticMesh* SplineEditorMesh;
    /* 0x04f0 */ bool bShowSplineEditorMesh;
    /* 0x04f8 */ TArray<ULandscapeSplineControlPoint*> ControlPoints;
    /* 0x0508 */ TArray<ULandscapeSplineSegment*> Segments;
    /* 0x0518 */ TMap<TSoftObjectPtr<UWorld>, FForeignWorldSplineData> ForeignWorldSplineDataMap;
    /* 0x0608 */ TArray<UMeshComponent*> CookedForeignMeshComponents;

    TArray<USplineMeshComponent*> GetSplineMeshComponents();
};

// Size: 0x868
class ALandscapeStreamingProxy : public ALandscapeProxy {
    /* 0x0848 */ TLazyObjectPtr<ALandscape> LandscapeActor;
};

// Size: 0x60
class ULandscapeSubsystem : public UTickableWorldSubsystem {
};

// Size: 0x60
class ULandscapeWeightmapUsage : public UObject {
    /* 0x0030 */ ULandscapeComponent* ChannelUsage[4];
    /* 0x0050 */ FGuid LayerGuid;
};

// Size: 0x98
struct FLayerBlendInput {
    /* 0x0000 */ FName LayerName;
    /* 0x000c */ uint8_t BlendType;
    /* 0x0010 */ FExpressionInput LayerInput;
    /* 0x0048 */ FExpressionInput HeightInput;
    /* 0x0080 */ float PreviewWeight;
    /* 0x0084 */ FVector ConstLayerInput;
    /* 0x0090 */ float ConstHeightInput;
};

// Size: 0xc0
class UMaterialExpressionLandscapeGrassOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ TArray<FGrassInput> GrassTypes;
};

// Size: 0xd0
class UMaterialExpressionLandscapeLayerBlend : public UMaterialExpression {
    /* 0x00b0 */ TArray<FLayerBlendInput> Layers;
    /* 0x00c0 */ FGuid ExpressionGUID;
};

// Size: 0xc8
class UMaterialExpressionLandscapeLayerCoords : public UMaterialExpression {
    /* 0x00b0 */ uint8_t MappingType;
    /* 0x00b1 */ uint8_t CustomUVType;
    /* 0x00b4 */ float MappingScale;
    /* 0x00b8 */ float MappingRotation;
    /* 0x00bc */ float MappingPanU;
    /* 0x00c0 */ float MappingPanV;
};

// Size: 0xd0
class UMaterialExpressionLandscapeLayerSample : public UMaterialExpression {
    /* 0x00b0 */ FName ParameterName;
    /* 0x00bc */ float PreviewWeight;
    /* 0x00c0 */ FGuid ExpressionGUID;
};

// Size: 0x140
class UMaterialExpressionLandscapeLayerSwitch : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput LayerUsed;
    /* 0x00e8 */ FExpressionInput LayerNotUsed;
    /* 0x0120 */ FName ParameterName;
    /* 0x012c */ bool PreviewUsed;
    /* 0x0130 */ FGuid ExpressionGUID;
};

// Size: 0x150
class UMaterialExpressionLandscapeLayerWeight : public UMaterialExpression {
    /* 0x00b0 */ FExpressionInput Base;
    /* 0x00e8 */ FExpressionInput Layer;
    /* 0x0120 */ FName ParameterName;
    /* 0x012c */ float PreviewWeight;
    /* 0x0130 */ FVector ConstBase;
    /* 0x013c */ FGuid ExpressionGUID;
};

// Size: 0xc0
class UMaterialExpressionLandscapePhysicalMaterialOutput : public UMaterialExpressionCustomOutput {
    /* 0x00b0 */ TArray<FPhysicalMaterialInput> Inputs;
};

// Size: 0xc0
class UMaterialExpressionLandscapeVisibilityMask : public UMaterialExpression {
    /* 0x00b0 */ FGuid ExpressionGUID;
};

// Size: 0x40
struct FPhysicalMaterialInput {
    /* 0x0000 */ UPhysicalMaterial* PhysicalMaterial;
    /* 0x0008 */ FExpressionInput Input;
};

// Size: 0x30
struct FWeightmapData {
    /* 0x0000 */ TArray<UTexture2D*> Textures;
    /* 0x0010 */ TArray<FWeightmapLayerAllocationInfo> LayerAllocations;
    /* 0x0020 */ TArray<ULandscapeWeightmapUsage*> TextureUsages;
};

// Size: 0x10
struct FWeightmapLayerAllocationInfo {
    /* 0x0000 */ ULandscapeLayerInfoObject* LayerInfo;
    /* 0x0008 */ uint8_t WeightmapTextureIndex;
    /* 0x0009 */ uint8_t WeightmapTextureChannel;
};

// Size: 0x78
class UActorFactoryLandscape : public UActorFactory {
};

enum class EColorChannel {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
    EColorChannel_MAX = 4,
};

enum class ELandscapeConvertMode {
    Invalid = -1,
    Expand = 0,
    Clip = 1,
    Resample = 2,
    ELandscapeConvertMode_MAX = 3,
};

enum class ELandscapeImportHeightmapError {
    None = 0,
    FileNotFound = 1,
    InvalidSize = 2,
    CorruptFile = 3,
    ColorPng = 4,
    LowBitDepth = 5,
    ELandscapeImportHeightmapError_MAX = 6,
};

enum class ELandscapeImportLayerError {
    None = 0,
    MissingLayerInfo = 1,
    FileNotFound = 2,
    FileSizeMismatch = 3,
    CorruptFile = 4,
    ColorPng = 5,
    ELandscapeImportLayerError_MAX = 6,
};

enum class ELandscapeImportResult {
    Success = 0,
    Warning = 1,
    Error = 2,
    ELandscapeImportResult_MAX = 3,
};

enum class ELandscapeMirrorOperation {
    MinusXToPlusX = 0,
    PlusXToMinusX = 1,
    MinusYToPlusY = 2,
    PlusYToMinusY = 3,
    RotateMinusXToPlusX = 4,
    RotatePlusXToMinusX = 5,
    RotateMinusYToPlusY = 6,
    RotatePlusYToMinusY = 7,
    ELandscapeMirrorOperation_MAX = 8,
};

enum class ELandscapeToolErosionMode {
    Invalid = -1,
    Both = 0,
    Raise = 1,
    Lower = 2,
    ELandscapeToolErosionMode_MAX = 3,
};

enum class ELandscapeToolFlattenMode {
    Invalid = -1,
    Both = 0,
    Raise = 1,
    Lower = 2,
    Interval = 3,
    Terrace = 4,
    ELandscapeToolFlattenMode_MAX = 5,
};

enum class ELandscapeToolHydroErosionMode {
    Invalid = -1,
    Both = 0,
    Positive = 1,
    ELandscapeToolHydroErosionMode_MAX = 2,
};

enum class ELandscapeToolNoiseMode {
    Invalid = -1,
    Both = 0,
    Add = 1,
    Sub = 2,
    ELandscapeToolNoiseMode_MAX = 3,
};

enum class ELandscapeToolPasteMode {
    Invalid = -1,
    Both = 0,
    Raise = 1,
    Lower = 2,
    ELandscapeToolPasteMode_MAX = 3,
};

// Size: 0x28
struct FGizmoImportLayer {
    /* 0x0000 */ FString LayerFilename;
    /* 0x0010 */ FString LayerName;
    /* 0x0020 */ bool bNoImport;
};

// Size: 0x250
class ULandscapeEditorObject : public UObject {
    /* 0x0038 */ float ToolStrength;
    /* 0x003c */ bool bUseWeightTargetValue;
    /* 0x0040 */ float WeightTargetValue;
    /* 0x0044 */ float MaximumValueRadius;
    /* 0x0048 */ bool bCombinedLayersOperation;
    /* 0x0049 */ ELandscapeToolFlattenMode FlattenMode;
    /* 0x004a */ bool bUseSlopeFlatten;
    /* 0x004b */ bool bPickValuePerApply;
    /* 0x004c */ bool bUseFlattenTarget;
    /* 0x0050 */ float FlattenTarget;
    /* 0x0054 */ bool bShowFlattenTargetPreview;
    /* 0x0058 */ float TerraceInterval;
    /* 0x005c */ float TerraceSmooth;
    /* 0x0060 */ bool bFlattenEyeDropperModeActivated;
    /* 0x0064 */ float FlattenEyeDropperModeDesiredTarget;
    /* 0x0068 */ float RampWidth;
    /* 0x006c */ float RampSideFalloff;
    /* 0x0070 */ int32_t SmoothFilterKernelSize;
    /* 0x0074 */ bool bDetailSmooth;
    /* 0x0078 */ float DetailScale;
    /* 0x007c */ int32_t ErodeThresh;
    /* 0x0080 */ int32_t ErodeSurfaceThickness;
    /* 0x0084 */ int32_t ErodeIterationNum;
    /* 0x0088 */ ELandscapeToolErosionMode ErosionNoiseMode;
    /* 0x008c */ float ErosionNoiseScale;
    /* 0x0090 */ int32_t RainAmount;
    /* 0x0094 */ float SedimentCapacity;
    /* 0x0098 */ int32_t HErodeIterationNum;
    /* 0x009c */ ELandscapeToolHydroErosionMode RainDistMode;
    /* 0x00a0 */ float RainDistScale;
    /* 0x00a4 */ bool bHErosionDetailSmooth;
    /* 0x00a8 */ float HErosionDetailScale;
    /* 0x00ac */ ELandscapeToolNoiseMode NoiseMode;
    /* 0x00b0 */ float NoiseScale;
    /* 0x00b4 */ bool bUseSelectedRegion;
    /* 0x00b5 */ bool bUseNegativeMask;
    /* 0x00b6 */ ELandscapeToolPasteMode PasteMode;
    /* 0x00b7 */ bool bApplyToAllTargets;
    /* 0x00b8 */ bool bSnapGizmo;
    /* 0x00b9 */ bool bSmoothGizmoBrush;
    /* 0x00c0 */ FString GizmoHeightmapFilenameString;
    /* 0x00d0 */ FIntPoint GizmoImportSize;
    /* 0x00d8 */ TArray<FGizmoImportLayer> GizmoImportLayers;
    /* 0x00f8 */ FVector2D MirrorPoint;
    /* 0x0100 */ ELandscapeMirrorOperation MirrorOp;
    /* 0x0104 */ int32_t MirrorSmoothingWidth;
    /* 0x0108 */ UClass* BlueprintBrush;
    /* 0x0110 */ int32_t ResizeLandscape_QuadsPerSection;
    /* 0x0114 */ int32_t ResizeLandscape_SectionsPerComponent;
    /* 0x0118 */ FIntPoint ResizeLandscape_ComponentCount;
    /* 0x0120 */ ELandscapeConvertMode ResizeLandscape_ConvertMode;
    /* 0x0134 */ TWeakObjectPtr<UMaterialInterface> NewLandscape_Material;
    /* 0x013c */ int32_t NewLandscape_QuadsPerSection;
    /* 0x0140 */ int32_t NewLandscape_SectionsPerComponent;
    /* 0x0144 */ FIntPoint NewLandscape_ComponentCount;
    /* 0x014c */ FVector NewLandscape_Location;
    /* 0x0158 */ FRotator NewLandscape_Rotation;
    /* 0x0164 */ FVector NewLandscape_Scale;
    /* 0x0170 */ ELandscapeImportResult ImportLandscape_HeightmapImportResult;
    /* 0x0178 */ FText ImportLandscape_HeightmapErrorMessage;
    /* 0x0190 */ FString ImportLandscape_HeightmapFilename;
    /* 0x01a0 */ uint32_t ImportLandscape_Width;
    /* 0x01a4 */ uint32_t ImportLandscape_Height;
    /* 0x01a8 */ TArray<uint16_t> ImportLandscape_Data;
    /* 0x01b8 */ bool bCanHaveLayersContent;
    /* 0x01b9 */ ELandscapeImportAlphamapType ImportLandscape_AlphamapType;
    /* 0x01c0 */ TArray<FLandscapeImportLayer> ImportLandscape_Layers;
    /* 0x01d0 */ float BrushRadius;
    /* 0x01d4 */ float BrushFalloff;
    /* 0x01d8 */ bool bUseClayBrush;
    /* 0x01dc */ float AlphaBrushScale;
    /* 0x01e0 */ bool bAlphaBrushAutoRotate;
    /* 0x01e4 */ float AlphaBrushRotation;
    /* 0x01e8 */ float AlphaBrushPanU;
    /* 0x01ec */ float AlphaBrushPanV;
    /* 0x01f0 */ bool bUseWorldSpacePatternBrush;
    /* 0x01f4 */ FLandscapePatternBrushWorldSpaceSettings WorldSpacePatternBrushSettings;
    /* 0x0208 */ UTexture2D* AlphaTexture;
    /* 0x0210 */ uint8_t AlphaTextureChannel;
    /* 0x0214 */ int32_t AlphaTextureSizeX;
    /* 0x0218 */ int32_t AlphaTextureSizeY;
    /* 0x0220 */ TArray<uint8_t> AlphaTextureData;
    /* 0x0230 */ int32_t BrushComponentSize;
    /* 0x0234 */ ELandscapeLayerPaintingRestriction PaintingRestriction;
    /* 0x0235 */ ELandscapeLayerDisplayMode TargetDisplayOrder;
    /* 0x0236 */ bool ShowUnusedLayers;
    /* 0x0238 */ int32_t CurrentLayerIndex;
};

// Size: 0x60
struct FLandscapeImportLayer : public FLandscapeImportLayerInfo {
    /* 0x0038 */ ULandscapeMaterialInstanceConstant* ThumbnailMIC;
    /* 0x0040 */ ELandscapeImportResult ImportResult;
    /* 0x0048 */ FText ErrorMessage;
};

// Size: 0x14
struct FLandscapePatternBrushWorldSpaceSettings {
    /* 0x0000 */ FVector2D Origin;
    /* 0x0008 */ float Rotation;
    /* 0x000c */ bool bCenterTextureOnOrigin;
    /* 0x0010 */ float RepeatSize;
};

// Size: 0x2f8
class ALandscapePlaceholder : public AActor {
};

// Size: 0x320
class ALandscapeBlueprintBrush : public ALandscapeBlueprintBrushBase {
};

// Size: 0x20
struct FIOSLaunchDaemonLaunchApp {
    /* 0x0000 */ FString AppID;
    /* 0x0010 */ FString Parameters;
};

// Size: 0x1
struct FIOSLaunchDaemonPing {
};

// Size: 0x48
struct FIOSLaunchDaemonPong {
    /* 0x0000 */ FString DeviceID;
    /* 0x0010 */ FString DeviceName;
    /* 0x0020 */ FString DeviceStatus;
    /* 0x0030 */ FString DeviceType;
    /* 0x0040 */ bool bCanPowerOff;
    /* 0x0041 */ bool bCanPowerOn;
    /* 0x0042 */ bool bCanReboot;
};

// Size: 0x58
class ULevelEditorContextMenuContext : public UObject {
};

// Size: 0x40
class ULevelEditorMenuContext : public UObject {
};

// Size: 0x50
class ULevelViewportToolBarContext : public UObject {
};

// Size: 0x60
class UAnimSequenceLevelSequenceLink : public UAssetUserData {
    /* 0x0030 */ FGuid SkelTrackGuid;
    /* 0x0040 */ FSoftObjectPath PathToLevelSequence;
};

// Size: 0x18
struct FBoundActorProxy {
    /* 0x0000 */ AActor* BoundActor;
};

// Size: 0x70
class UDefaultLevelSequenceInstanceData : public UObject {
    /* 0x0038 */ AActor* TransformOriginActor;
    /* 0x0040 */ FTransform TransformOrigin;
};

// Size: 0x4d8
class ULegacyLevelSequenceDirectorBlueprint : public UBlueprint {
};

// Size: 0x1e8
class ULevelSequence : public UMovieSceneSequence {
    /* 0x0070 */ UMovieScene* MovieScene;
    /* 0x0078 */ FLevelSequenceObjectReferenceMap ObjectReferences;
    /* 0x00c8 */ FLevelSequenceBindingReferences BindingReferences;
    /* 0x0168 */ TMap<FString, FLevelSequenceObject> PossessedObjects;
    /* 0x01b8 */ UBlueprint* DirectorBlueprint;
    /* 0x01c0 */ UClass* DirectorClass;
    /* 0x01c8 */ TArray<UObject*> MetaDataObjects;
    /* 0x01d8 */ TArray<UAssetUserData*> AssetUserData;

    UObject* CopyMetaData(UObject* InMetaData);
    UObject* FindMetaDataByClass(UClass* InClass) const;
    UObject* FindOrAddMetaDataByClass(UClass* InClass);
    void RemoveMetaDataByClass(UClass* InClass);
};

// Size: 0x388
class ALevelSequenceActor : public AActor {
    /* 0x0310 */ FMovieSceneSequencePlaybackSettings PlaybackSettings;
    /* 0x0328 */ ULevelSequencePlayer* SequencePlayer;
    /* 0x0330 */ FSoftObjectPath LevelSequence;
    /* 0x0350 */ FLevelSequenceCameraSettings CameraSettings;
    /* 0x0358 */ ULevelSequenceBurnInOptions* BurnInOptions;
    /* 0x0360 */ UMovieSceneBindingOverrides* BindingOverrides;
    /* 0x0368 */ bool bAutoPlay;
    /* 0x0368 */ bool bOverrideInstanceData;
    /* 0x0368 */ bool bReplicatePlayback;
    /* 0x0370 */ UObject* DefaultInstanceData;
    /* 0x0378 */ ULevelSequenceBurnIn* BurnInInstance;
    /* 0x0380 */ bool bShowBurnin;

    void AddBinding(FMovieSceneObjectBindingID Binding, AActor* Actor, bool bAllowBindingsFromAsset);
    void AddBindingByTag(FName BindingTag, AActor* Actor, bool bAllowBindingsFromAsset);
    FMovieSceneObjectBindingID FindNamedBinding(FName Tag) const;
    TArray<FMovieSceneObjectBindingID> FindNamedBindings(FName Tag) const;
    ULevelSequence* GetSequence() const;
    ULevelSequencePlayer* GetSequencePlayer() const;
    void HideBurnin();
    ULevelSequence* LoadSequence() const;
    void OnLevelSequenceLoaded__DelegateSignature();
    void RemoveBinding(FMovieSceneObjectBindingID Binding, AActor* Actor);
    void RemoveBindingByTag(FName Tag, AActor* Actor);
    void ResetBinding(FMovieSceneObjectBindingID Binding);
    void ResetBindings();
    void SetBinding(FMovieSceneObjectBindingID Binding, const TArray<AActor*>& Actors, bool bAllowBindingsFromAsset);
    void SetBindingByTag(FName BindingTag, const TArray<AActor*>& Actors, bool bAllowBindingsFromAsset);
    void SetReplicatePlayback(bool ReplicatePlayback);
    void SetSequence(ULevelSequence* InSequence);
    void ShowBurnin();
};

// Size: 0x40
class ULevelSequenceAnimSequenceLink : public UAssetUserData {
    /* 0x0030 */ TArray<FLevelSequenceAnimSequenceLinkItem> AnimSequenceLinks;
};

// Size: 0x38
struct FLevelSequenceAnimSequenceLinkItem {
    /* 0x0000 */ FGuid SkelTrackGuid;
    /* 0x0010 */ FSoftObjectPath PathToAnimSequence;
    /* 0x0030 */ bool bExportTransforms;
    /* 0x0031 */ bool bExportCurves;
    /* 0x0032 */ bool bRecordInWorldSpace;
};

// Size: 0x40
struct FLevelSequenceBindingReference {
    /* 0x0000 */ FString PackageName;
    /* 0x0010 */ FSoftObjectPath ExternalObjectPath;
    /* 0x0030 */ FString ObjectPath;
};

// Size: 0x10
struct FLevelSequenceBindingReferenceArray {
    /* 0x0000 */ TArray<FLevelSequenceBindingReference> References;
};

// Size: 0xa0
struct FLevelSequenceBindingReferences {
    /* 0x0000 */ TMap<FGuid, FLevelSequenceBindingReferenceArray> BindingIdToReferences;
    /* 0x0050 */ TSet<FGuid> AnimSequenceInstances;
};

// Size: 0x4c0
class ULevelSequenceBurnIn : public UUserWidget {
    /* 0x03f8 */ FLevelSequencePlayerSnapshot FrameInformation;
    /* 0x04b8 */ ALevelSequenceActor* LevelSequenceActor;

    UClass* GetSettingsClass() const;
    void SetSettings(UObject* InSettings);
};

// Size: 0x30
class ULevelSequenceBurnInInitSettings : public UObject {
};

// Size: 0x60
class ULevelSequenceBurnInOptions : public UObject {
    /* 0x0030 */ bool bUseBurnIn;
    /* 0x0038 */ FSoftClassPath BurnInClass;
    /* 0x0058 */ ULevelSequenceBurnInInitSettings* Settings;

    void SetBurnIn(FSoftClassPath InBurnInClass);
};

// Size: 0x2
struct FLevelSequenceCameraSettings {
    /* 0x0000 */ bool bOverrideAspectRatioAxisConstraint;
    /* 0x0001 */ uint8_t AspectRatioAxisConstraint;
};

// Size: 0x40
class ULevelSequenceDirector : public UObject {
    /* 0x0030 */ ULevelSequencePlayer* Player;
    /* 0x0038 */ int32_t SubSequenceID;
    /* 0x003c */ int32_t MovieScenePlayerIndex;

    AActor* GetBoundActor(FMovieSceneObjectBindingID ObjectBinding);
    TArray<AActor*> GetBoundActors(FMovieSceneObjectBindingID ObjectBinding);
    UObject* GetBoundObject(FMovieSceneObjectBindingID ObjectBinding);
    TArray<UObject*> GetBoundObjects(FMovieSceneObjectBindingID ObjectBinding);
    UMovieSceneSequence* GetSequence();
    void OnCreated();
};

// Size: 0x20
struct FLevelSequenceLegacyObjectReference {
};

// Size: 0x320
class ALevelSequenceMediaController : public AActor {
    /* 0x0300 */ ALevelSequenceActor* Sequence;
    /* 0x0308 */ UMediaComponent* MediaComponent;
    /* 0x0310 */ float ServerStartTimeSeconds;

    UMediaComponent* GetMediaComponent() const;
    ALevelSequenceActor* GetSequence() const;
    void OnRep_ServerStartTimeSeconds();
    void Play();
    void SynchronizeToServer(float DesyncThresholdSeconds);
};

// Size: 0x30
class ILevelSequenceMetaData : public UInterface {
};

// Size: 0x38
struct FLevelSequenceObject {
    /* 0x0000 */ TLazyObjectPtr<UObject> ObjectOrOwner;
    /* 0x0020 */ FString ComponentName;
    /* 0x0030 */ TWeakObjectPtr<UObject> CachedComponent;
};

// Size: 0x50
struct FLevelSequenceObjectReferenceMap {
};

// Size: 0x628
class ULevelSequencePlayer : public UMovieSceneSequencePlayer {
    /* 0x0500 */ FMulticastInlineDelegate OnCameraCut;

    static ULevelSequencePlayer* CreateLevelSequencePlayer(UObject* WorldContextObject, ULevelSequence* LevelSequence, FMovieSceneSequencePlaybackSettings Settings, ALevelSequenceActor*& OutActor);
    UCameraComponent* GetActiveCameraComponent() const;
};

// Size: 0xc0
struct FLevelSequencePlayerSnapshot {
    /* 0x0000 */ FString MasterName;
    /* 0x0010 */ FQualifiedFrameTime MasterTime;
    /* 0x0020 */ FQualifiedFrameTime SourceTime;
    /* 0x0030 */ FString CurrentShotName;
    /* 0x0040 */ FQualifiedFrameTime CurrentShotLocalTime;
    /* 0x0050 */ FQualifiedFrameTime CurrentShotSourceTime;
    /* 0x0060 */ FString SourceTimecode;
    /* 0x0070 */ TSoftObjectPtr<UCameraComponent> CameraComponent;
    /* 0x00a0 */ FLevelSequenceSnapshotSettings Settings;
    /* 0x00b0 */ ULevelSequence* ActiveShot;
    /* 0x00b8 */ FMovieSceneSequenceID ShotID;
};

// Size: 0x90
class ULevelSequenceProjectSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bDefaultLockEngineToDisplayRate;
    /* 0x0068 */ FString DefaultDisplayRate;
    /* 0x0078 */ FString DefaultTickResolution;
    /* 0x0088 */ EUpdateClockSource DefaultClockSource;
};

// Size: 0xc
struct FLevelSequenceSnapshotSettings {
    /* 0x0000 */ uint8_t ZeroPadAmount;
    /* 0x0004 */ FFrameRate FrameRate;
};

// Size: 0x30
class ULevelSequenceEditorBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void CloseLevelSequence();
    static void EmptySelection();
    static TArray<UObject*> GetBoundObjects(FMovieSceneObjectBindingID ObjectBinding);
    static ULevelSequence* GetCurrentLevelSequence();
    static int32_t GetCurrentLocalTime();
    static int32_t GetCurrentTime();
    static ULevelSequence* GetFocusedLevelSequence();
    static TArray<FSequencerChannelProxy> GetSelectedChannels();
    static TArray<UMovieSceneFolder*> GetSelectedFolders();
    static TArray<FGuid> GetSelectedObjects();
    static TArray<UMovieSceneSection*> GetSelectedSections();
    static TArray<UMovieSceneTrack*> GetSelectedTracks();
    static bool IsLevelSequenceLocked();
    static bool IsPlaying();
    static bool OpenLevelSequence(ULevelSequence* LevelSequence);
    static void Pause();
    static void Play();
    static void PlayTo(FMovieSceneSequencePlaybackParams PlaybackParams);
    static void RefreshCurrentLevelSequence();
    static void SelectChannels(const TArray<FSequencerChannelProxy>& Channels);
    static void SelectFolders(const TArray<UMovieSceneFolder*>& Folders);
    static void SelectObjects(TArray<FGuid> ObjectBinding);
    static void SelectSections(const TArray<UMovieSceneSection*>& Sections);
    static void SelectTracks(const TArray<UMovieSceneTrack*>& Tracks);
    static void SetCurrentLocalTime(int32_t NewFrame);
    static void SetCurrentTime(int32_t NewFrame);
    static void SetLockLevelSequence(bool bLock);
};

// Size: 0x48
class ULevelSequenceEditorSettings : public UObject {
    /* 0x0030 */ TArray<FLevelSequenceTrackSettings> TrackSettings;
    /* 0x0040 */ bool bAutoBindToPIE;
    /* 0x0041 */ bool bAutoBindToSimulate;
};

// Size: 0x88
class ULevelSequenceFactoryNew : public UFactory {
};

// Size: 0x98
class ULevelSequenceMasterSequenceSettings : public UObject {
    /* 0x0030 */ FString MasterSequenceName;
    /* 0x0040 */ FString MasterSequenceSuffix;
    /* 0x0050 */ FDirectoryPath MasterSequenceBasePath;
    /* 0x0060 */ uint32_t MasterSequenceNumShots;
    /* 0x0064 */ TLazyObjectPtr<ULevelSequence> MasterSequenceLevelSequenceToDuplicate;
    /* 0x0080 */ TArray<FName> SubSequenceNames;
    /* 0x0090 */ bool bInstanceSubSequences;
};

// Size: 0x20
struct FLevelSequencePropertyTrackSettings {
    /* 0x0000 */ FString ComponentPath;
    /* 0x0010 */ FString PropertyPath;
};

// Size: 0x60
struct FLevelSequenceTrackSettings {
    /* 0x0000 */ FSoftClassPath MatchingActorClass;
    /* 0x0020 */ TArray<FSoftClassPath> DefaultTracks;
    /* 0x0030 */ TArray<FSoftClassPath> ExcludeDefaultTracks;
    /* 0x0040 */ TArray<FLevelSequencePropertyTrackSettings> DefaultPropertyTracks;
    /* 0x0050 */ TArray<FLevelSequencePropertyTrackSettings> ExcludeDefaultPropertyTracks;
};

// Size: 0x18
struct FSequencerChannelProxy {
    /* 0x0000 */ FName ChannelName;
    /* 0x0010 */ UMovieSceneSection* Section;
};

// Size: 0x88
class ULightPropagationVolumeBlendableFactory : public UFactory {
};

// Size: 0x80
class ULightPropagationVolumeBlendable : public UObject {
    /* 0x0038 */ FLightPropagationVolumeSettings Settings;
    /* 0x0078 */ float BlendWeight;
};

// Size: 0x78
class ULinuxTargetSettings : public UObject {
    /* 0x0030 */ FString SpatializationPlugin;
    /* 0x0040 */ FString ReverbPlugin;
    /* 0x0050 */ FString OcclusionPlugin;
    /* 0x0060 */ int32_t SoundCueCookQualityIndex;
    /* 0x0068 */ TArray<FString> TargetedRHIs;
};

enum class ELiveCodingStartupMode {
    Automatic = 0,
    AutomaticButHidden = 1,
    Manual = 2,
    ELiveCodingStartupMode_MAX = 3,
};

// Size: 0x48
class ULiveCodingSettings : public UObject {
    /* 0x0030 */ bool bEnabled;
    /* 0x0031 */ ELiveCodingStartupMode Startup;
    /* 0x0032 */ bool bPreloadEngineModules;
    /* 0x0033 */ bool bPreloadEnginePluginModules;
    /* 0x0034 */ bool bPreloadProjectModules;
    /* 0x0035 */ bool bPreloadProjectPluginModules;
    /* 0x0038 */ TArray<FName> PreloadNamedModules;
};

// Size: 0x68
struct FAnimNode_LiveLinkPose : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink InputPose;
    /* 0x0028 */ FLiveLinkSubjectName LiveLinkSubjectName;
    /* 0x0034 */ FName SubjectName;
    /* 0x0040 */ UClass* RetargetAsset;
    /* 0x0048 */ ULiveLinkRetargetAsset* CurrentRetargetAsset;
};

enum class ELiveLinkAxis {
    X = 0,
    Y = 1,
    Z = 2,
    XNeg = 3,
    YNeg = 4,
    ZNeg = 5,
    ELiveLinkAxis_MAX = 6,
};

enum class ELiveLinkTimecodeProviderEvaluationType {
    Lerp = 0,
    Nearest = 1,
    Latest = 2,
    ELiveLinkTimecodeProviderEvaluationType_MAX = 3,
};

// Size: 0x68
class ULiveLinkAnimationAxisSwitchPreProcessor : public ULiveLinkTransformAxisSwitchPreProcessor {
};

// Size: 0x58
class ULiveLinkAnimationFrameInterpolationProcessor : public ULiveLinkBasicFrameInterpolationProcessor {
};

// Size: 0x50
class ULiveLinkAnimationRoleToTransform : public ULiveLinkFrameTranslator {
    /* 0x0030 */ FName BoneName;
};

// Size: 0x170
class ULiveLinkAnimationVirtualSubject : public ULiveLinkVirtualSubject {
    /* 0x0169 */ bool bAppendSubjectNameToBones;
};

// Size: 0x48
class ULiveLinkBasicFrameInterpolationProcessor : public ULiveLinkFrameInterpolationProcessor {
    /* 0x0030 */ bool bInterpolatePropertyValues;
};

// Size: 0x30
class ULiveLinkBlueprintLibrary : public UBlueprintFunctionLibrary {

    static int32_t ChildCount(FLiveLinkTransform& LiveLinkTransform);
    static void ComponentSpaceTransform(FLiveLinkTransform& LiveLinkTransform, FTransform& Transform);
    static bool EvaluateLiveLinkFrame(FLiveLinkSubjectRepresentation SubjectRepresentation, FLiveLinkBaseBlueprintData& OutBlueprintData);
    static bool EvaluateLiveLinkFrameAtSceneTime(FLiveLinkSubjectName SubjectName, UClass* Role, FTimecode SceneTime, FLiveLinkBaseBlueprintData& OutBlueprintData);
    static bool EvaluateLiveLinkFrameAtWorldTimeOffset(FLiveLinkSubjectName SubjectName, UClass* Role, float WorldTimeOffset, FLiveLinkBaseBlueprintData& OutBlueprintData);
    static bool EvaluateLiveLinkFrameWithSpecificRole(FLiveLinkSubjectName SubjectName, UClass* Role, FLiveLinkBaseBlueprintData& OutBlueprintData);
    static bool GetAnimationFrameData(FSubjectFrameHandle& SubjectFrameHandle, FLiveLinkAnimationFrameData& AnimationFrameData);
    static bool GetAnimationStaticData(FSubjectFrameHandle& SubjectFrameHandle, FLiveLinkSkeletonStaticData& AnimationStaticData);
    static void GetBasicData(FSubjectFrameHandle& SubjectFrameHandle, FLiveLinkBasicBlueprintData& BasicBlueprintData);
    static void GetChildren(FLiveLinkTransform& LiveLinkTransform, TArray<FLiveLinkTransform>& Children);
    static void GetCurves(FSubjectFrameHandle& SubjectFrameHandle, TMap<FName, float>& Curves);
    static TArray<FLiveLinkSubjectName> GetLiveLinkEnabledSubjectNames(bool bIncludeVirtualSubject);
    static UClass* GetLiveLinkSubjectRole(const FLiveLinkSubjectName SubjectName);
    static TArray<FLiveLinkSubjectKey> GetLiveLinkSubjects(bool bIncludeDisabledSubject, bool bIncludeVirtualSubject);
    static void GetMetaData(FSubjectFrameHandle& SubjectFrameHandle, FSubjectMetadata& MetaData);
    static void GetParent(FLiveLinkTransform& LiveLinkTransform, FLiveLinkTransform& Parent);
    static bool GetPropertyValue(FLiveLinkBasicBlueprintData& BasicData, FName PropertyName, float& Value);
    static void GetRootTransform(FSubjectFrameHandle& SubjectFrameHandle, FLiveLinkTransform& LiveLinkTransform);
    static FText GetSourceMachineName(FLiveLinkSourceHandle& SourceHandle);
    static FText GetSourceStatus(FLiveLinkSourceHandle& SourceHandle);
    static FText GetSourceType(FLiveLinkSourceHandle& SourceHandle);
    static UClass* GetSpecificLiveLinkSubjectRole(const FLiveLinkSubjectKey SubjectKey);
    static void GetTransformByIndex(FSubjectFrameHandle& SubjectFrameHandle, int32_t TransformIndex, FLiveLinkTransform& LiveLinkTransform);
    static void GetTransformByName(FSubjectFrameHandle& SubjectFrameHandle, FName TransformName, FLiveLinkTransform& LiveLinkTransform);
    static bool HasParent(FLiveLinkTransform& LiveLinkTransform);
    static bool IsLiveLinkSubjectEnabled(const FLiveLinkSubjectName SubjectName);
    static bool IsSourceStillValid(FLiveLinkSourceHandle& SourceHandle);
    static bool IsSpecificLiveLinkSubjectEnabled(const FLiveLinkSubjectKey SubjectKey, bool bForThisFrame);
    static int32_t NumberOfTransforms(FSubjectFrameHandle& SubjectFrameHandle);
    static void ParentBoneSpaceTransform(FLiveLinkTransform& LiveLinkTransform, FTransform& Transform);
    static bool RemoveSource(FLiveLinkSourceHandle& SourceHandle);
    static void SetLiveLinkSubjectEnabled(const FLiveLinkSubjectKey SubjectKey, bool bEnabled);
    static void TransformName(FLiveLinkTransform& LiveLinkTransform, FName& Name);
    static void TransformNames(FSubjectFrameHandle& SubjectFrameHandle, TArray<FName>& TransformNames);
};

// Size: 0x190
class ULiveLinkBlueprintVirtualSubject : public ULiveLinkVirtualSubject {

    void OnInitialize();
    void OnUpdate();
    bool UpdateVirtualSubjectFrameData_Internal(const FLiveLinkBaseFrameData& InStruct, bool bInShouldStampCurrentTime);
    bool UpdateVirtualSubjectStaticData_Internal(const FLiveLinkBaseStaticData& InStruct);
};

// Size: 0xe0
class ULiveLinkComponent : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate OnLiveLinkUpdated;

    void GetAvailableSubjectNames(TArray<FName>& SubjectNames);
    void GetSubjectData(const FName SubjectName, bool& bSuccess, FSubjectFrameHandle& SubjectFrameHandle);
    void GetSubjectDataAtSceneTime(const FName SubjectName, const FTimecode& SceneTime, bool& bSuccess, FSubjectFrameHandle& SubjectFrameHandle);
    void GetSubjectDataAtWorldTime(const FName SubjectName, const float WorldTime, bool& bSuccess, FSubjectFrameHandle& SubjectFrameHandle);
};

// Size: 0xe0
class ULiveLinkDrivenComponent : public UActorComponent {
    /* 0x00c0 */ FLiveLinkSubjectName SubjectName;
    /* 0x00cc */ FName ActorTransformBone;
    /* 0x00d8 */ bool bModifyActorTransform;
    /* 0x00d9 */ bool bSetRelativeLocation;
};

// Size: 0x300
class ULiveLinkInstance : public UAnimInstance {
    /* 0x02f8 */ ULiveLinkRetargetAsset* CurrentRetargetAsset;

    void SetRetargetAsset(UClass* RetargetAsset);
    void SetSubject(FLiveLinkSubjectName SubjectName);
};

// Size: 0x880
struct FLiveLinkInstanceProxy : public FAnimInstanceProxy {
    /* 0x0810 */ FAnimNode_LiveLinkPose PoseNode;
};

// Size: 0x88
class ULiveLinkMessageBusFinder : public UObject {

    static void ConnectToProvider(FProviderPollResult& Provider, FLiveLinkSourceHandle& SourceHandle);
    static ULiveLinkMessageBusFinder* ConstructMessageBusFinder();
    void GetAvailableProviders(UObject* WorldContextObject, FLatentActionInfo LatentInfo, float Duration, TArray<FProviderPollResult>& AvailableProviders);
};

// Size: 0x30
class ULiveLinkMessageBusSourceFactory : public ULiveLinkSourceFactory {
};

// Size: 0xc0
class ULiveLinkMessageBusSourceSettings : public ULiveLinkSourceSettings {
};

// Size: 0x50
class ULiveLinkPreset : public UObject {
    /* 0x0030 */ TArray<FLiveLinkSourcePreset> Sources;
    /* 0x0040 */ TArray<FLiveLinkSubjectPreset> Subjects;

    bool AddToClient(const bool bRecreatePresets) const;
    bool ApplyToClient() const;
    void BuildFromClient();
};

// Size: 0xd8
class ULiveLinkRemapAsset : public ULiveLinkRetargetAsset {

    FName GetRemappedBoneName(FName BoneName) const;
    FName GetRemappedCurveName(FName CurveName) const;
    void RemapCurveElements(TMap<FName, float>& CurveItems) const;
};

// Size: 0x30
class ULiveLinkRetargetAsset : public UObject {
};

// Size: 0x1
struct FLiveLinkRetargetAssetReference {
};

// Size: 0x28
struct FLiveLinkRoleProjectSetting {
    /* 0x0000 */ UClass* Role;
    /* 0x0008 */ UClass* SettingClass;
    /* 0x0010 */ UClass* FrameInterpolationProcessor;
    /* 0x0018 */ TArray<UClass*> FramePreProcessors;
};

// Size: 0xe0
class ULiveLinkSettings : public UObject {
    /* 0x0030 */ TArray<FLiveLinkRoleProjectSetting> DefaultRoleSettings;
    /* 0x0040 */ UClass* FrameInterpolationProcessor;
    /* 0x0048 */ TSoftObjectPtr<ULiveLinkPreset> DefaultLiveLinkPreset;
    /* 0x0078 */ FDirectoryPath PresetSaveDir;
    /* 0x0088 */ float ClockOffsetCorrectionStep;
    /* 0x008c */ ELiveLinkSourceMode DefaultMessageBusSourceMode;
    /* 0x0090 */ double MessageBusPingRequestFrequency;
    /* 0x0098 */ double MessageBusHeartbeatFrequency;
    /* 0x00a0 */ double MessageBusHeartbeatTimeout;
    /* 0x00a8 */ double MessageBusTimeBeforeRemovingInactiveSource;
    /* 0x00b0 */ double TimeWithoutFrameToBeConsiderAsInvalid;
    /* 0x00b8 */ FLinearColor ValidColor;
    /* 0x00c8 */ FLinearColor InvalidColor;
    /* 0x00d8 */ uint8_t TextSizeSource;
    /* 0x00d9 */ uint8_t TextSizeSubject;
};

// Size: 0x98
class ULiveLinkTimeSynchronizationSource : public UTimeSynchronizationSource {
    /* 0x0038 */ FLiveLinkSubjectName SubjectName;
};

// Size: 0xd8
class ULiveLinkTimecodeProvider : public UTimecodeProvider {
    /* 0x0038 */ FLiveLinkSubjectKey SubjectKey;
    /* 0x0054 */ ELiveLinkTimecodeProviderEvaluationType Evaluation;
    /* 0x0058 */ bool bOverrideFrameRate;
    /* 0x005c */ FFrameRate OverrideFrameRate;
    /* 0x0064 */ int32_t BufferSize;
};

// Size: 0x68
class ULiveLinkTransformAxisSwitchPreProcessor : public ULiveLinkFramePreProcessor {
    /* 0x0030 */ ELiveLinkAxis OrientationAxisX;
    /* 0x0031 */ ELiveLinkAxis OrientationAxisY;
    /* 0x0032 */ ELiveLinkAxis OrientationAxisZ;
    /* 0x0033 */ ELiveLinkAxis TranslationAxisX;
    /* 0x0034 */ ELiveLinkAxis TranslationAxisY;
    /* 0x0035 */ ELiveLinkAxis TranslationAxisZ;
    /* 0x0036 */ ELiveLinkAxis FrontAxis;
    /* 0x0037 */ ELiveLinkAxis RightAxis;
    /* 0x0038 */ ELiveLinkAxis UpAxis;
    /* 0x0039 */ bool bUseOffsetPosition;
    /* 0x003a */ bool bUseOffsetOrientation;
    /* 0x003c */ FVector OffsetPosition;
    /* 0x0048 */ FRotator OffsetOrientation;
};

// Size: 0xd0
class ULiveLinkVirtualSubjectSourceSettings : public ULiveLinkSourceSettings {
    /* 0x00c0 */ FName SourceName;
};

// Size: 0x38
struct FProviderPollResult {
    /* 0x0010 */ FString Name;
    /* 0x0020 */ FString MachineName;
    /* 0x0030 */ double MachineTimeOffset;
};

// Size: 0x180
class ULiveLinkComponentController : public UActorComponent {
    /* 0x00c0 */ FLiveLinkSubjectRepresentation SubjectRepresentation;
    /* 0x00d8 */ ULiveLinkControllerBase* Controller;
    /* 0x00e0 */ TMap<UClass*, ULiveLinkControllerBase*> ControllerMap;
    /* 0x0130 */ bool bUpdateInEditor;
    /* 0x0138 */ FMulticastInlineDelegate OnLiveLinkUpdated;
    /* 0x0148 */ FComponentReference ComponentToControl;
    /* 0x0178 */ bool bDisableEvaluateLiveLinkWhenSpawnable;
    /* 0x0179 */ bool bEvaluateLiveLink;
};

// Size: 0x80
class ULiveLinkComponentSettings : public UObject {
    /* 0x0030 */ TMap<UClass*, UClass*> DefaultControllerForRole;
};

// Size: 0x50
class ULiveLinkControllerBase : public UObject {
};

// Size: 0x88
class ULiveLinkLightController : public ULiveLinkControllerBase {
    /* 0x0050 */ FComponentReference ComponentToControl;
    /* 0x0080 */ FLiveLinkTransformControllerData TransformData;
};

// Size: 0x88
class ULiveLinkTransformController : public ULiveLinkControllerBase {
    /* 0x0050 */ FComponentReference ComponentToControl;
    /* 0x0080 */ FLiveLinkTransformControllerData TransformData;
};

// Size: 0x6
struct FLiveLinkTransformControllerData {
    /* 0x0000 */ bool bWorldTransform;
    /* 0x0001 */ bool bUseLocation;
    /* 0x0002 */ bool bUseRotation;
    /* 0x0003 */ bool bUseScale;
    /* 0x0004 */ bool bSweep;
    /* 0x0005 */ bool bTeleport;
};

// Size: 0x98
class ULiveLinkBlueprintVirtualSubjectFactory : public UFactory {
    /* 0x0088 */ UClass* ParentClass;
    /* 0x0090 */ UClass* Role;
};

// Size: 0x40
struct FLiveLinkInnerTestInternal {
    /* 0x0000 */ float InnerSingleFloat;
    /* 0x0004 */ int32_t InnerSingleInt;
    /* 0x0008 */ FVector InnerVectorDim[2];
    /* 0x0020 */ float InnerFloatDim[2];
    /* 0x0028 */ int32_t InnerIntDim[2];
    /* 0x0030 */ TArray<int32_t> InnerIntArray;
};

// Size: 0x58
class ULiveLinkPreviewController : public UPersonaPreviewSceneController {
    /* 0x0030 */ FName SubjectName;
    /* 0x003c */ FLiveLinkSubjectName LiveLinkSubjectName;
    /* 0x0048 */ bool bEnableCameraSync;
    /* 0x0050 */ UClass* RetargetAsset;
};

// Size: 0x30
class ULiveLinkSequencerTrackFilter : public USequencerTrackFilterExtension {
};

// Size: 0x138
struct FLiveLinkTestFrameDataInternal : public FLiveLinkBaseFrameData {
    /* 0x00a0 */ float NotInterpolated;
    /* 0x00a4 */ FVector SingleVector;
    /* 0x00b0 */ FLiveLinkInnerTestInternal SingleStruct;
    /* 0x00f0 */ float SingleFloat;
    /* 0x00f4 */ int32_t SingleInt;
    /* 0x00f8 */ TArray<FVector> VectorArray;
    /* 0x0108 */ TArray<FLiveLinkInnerTestInternal> StructArray;
    /* 0x0118 */ TArray<float> FloatArray;
    /* 0x0128 */ TArray<int32_t> IntArray;
};

// Size: 0x1d8
class UAnimGraphNode_LiveLinkPose : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_LiveLinkPose Node;
};

// Size: 0xc8
class UK2Node_EvaluateLiveLinkFrame : public UK2Node {
};

// Size: 0xc8
class UK2Node_EvaluateLiveLinkFrameAtSceneTime : public UK2Node_EvaluateLiveLinkFrame {
};

// Size: 0xc8
class UK2Node_EvaluateLiveLinkFrameAtWorldTime : public UK2Node_EvaluateLiveLinkFrame {
};

// Size: 0xc8
class UK2Node_EvaluateLiveLinkFrameWithSpecificRole : public UK2Node_EvaluateLiveLinkFrame {
};

// Size: 0xc8
class UK2Node_UpdateVirtualSubjectDataBase : public UK2Node {
};

// Size: 0xc8
class UK2Node_UpdateVirtualSubjectFrameData : public UK2Node_UpdateVirtualSubjectDataBase {
};

// Size: 0xc8
class UK2Node_UpdateVirtualSubjectStaticData : public UK2Node_UpdateVirtualSubjectDataBase {
};

// Size: 0x160
struct FCachedSubjectFrame {
};

enum class ELiveLinkCameraProjectionMode {
    Perspective = 0,
    Orthographic = 1,
    ELiveLinkCameraProjectionMode_MAX = 2,
};

enum class ELiveLinkSourceMode {
    Latest = 0,
    EngineTime = 1,
    Timecode = 2,
    ELiveLinkSourceMode_MAX = 3,
};

// Size: 0xb0
struct FLiveLinkAnimationFrameData : public FLiveLinkBaseFrameData {
    /* 0x00a0 */ TArray<FTransform> Transforms;
};

// Size: 0x30
class ULiveLinkAnimationRole : public ULiveLinkBasicRole {
};

// Size: 0x8
struct FLiveLinkBaseBlueprintData {
};

// Size: 0xa0
struct FLiveLinkBaseFrameData {
    /* 0x0000 */ FLiveLinkWorldTime WorldTime;
    /* 0x0010 */ FLiveLinkMetaData MetaData;
    /* 0x0070 */ TArray<float> PropertyValues;
};

// Size: 0x10
struct FLiveLinkBaseStaticData {
    /* 0x0000 */ TArray<FName> PropertyNames;
};

// Size: 0xb8
struct FLiveLinkBasicBlueprintData : public FLiveLinkBaseBlueprintData {
    /* 0x0008 */ FLiveLinkBaseStaticData StaticData;
    /* 0x0018 */ FLiveLinkBaseFrameData FrameData;
};

// Size: 0x30
class ULiveLinkBasicRole : public ULiveLinkRole {
};

// Size: 0x120
struct FLiveLinkCameraBlueprintData : public FLiveLinkBaseBlueprintData {
    /* 0x0008 */ FLiveLinkCameraStaticData StaticData;
    /* 0x0030 */ FLiveLinkCameraFrameData FrameData;
};

// Size: 0xf0
struct FLiveLinkCameraFrameData : public FLiveLinkTransformFrameData {
    /* 0x00d0 */ float FieldOfView;
    /* 0x00d4 */ float AspectRatio;
    /* 0x00d8 */ float FocalLength;
    /* 0x00dc */ float Aperture;
    /* 0x00e0 */ float FocusDistance;
    /* 0x00e4 */ ELiveLinkCameraProjectionMode ProjectionMode;
};

// Size: 0x30
class ULiveLinkCameraRole : public ULiveLinkTransformRole {
};

// Size: 0x28
struct FLiveLinkCameraStaticData : public FLiveLinkTransformStaticData {
    /* 0x0018 */ bool bIsFieldOfViewSupported;
    /* 0x0019 */ bool bIsAspectRatioSupported;
    /* 0x001a */ bool bIsFocalLengthSupported;
    /* 0x001b */ bool bIsProjectionModeSupported;
    /* 0x001c */ float FilmBackWidth;
    /* 0x0020 */ float FilmBackHeight;
    /* 0x0024 */ bool bIsApertureSupported;
    /* 0x0025 */ bool bIsFocusDistanceSupported;
};

// Size: 0x30
class ULiveLinkController : public UObject {
};

// Size: 0x50
struct FLiveLinkCurveConversionSettings {
    /* 0x0000 */ TMap<FString, FSoftObjectPath> CurveConversionAssetMap;
};

// Size: 0x10
struct FLiveLinkCurveElement {
    /* 0x0000 */ FName CurveName;
    /* 0x000c */ float CurveValue;
};

// Size: 0x110
class ULiveLinkCurveRemapSettings : public ULiveLinkSourceSettings {
    /* 0x00c0 */ FLiveLinkCurveConversionSettings CurveConversionSettings;
};

// Size: 0x90
struct FLiveLinkFrameData {
    /* 0x0000 */ TArray<FTransform> Transforms;
    /* 0x0010 */ TArray<FLiveLinkCurveElement> CurveElements;
    /* 0x0020 */ FLiveLinkWorldTime WorldTime;
    /* 0x0030 */ FLiveLinkMetaData MetaData;
};

// Size: 0x30
class ULiveLinkFrameInterpolationProcessor : public UObject {
};

// Size: 0x30
class ULiveLinkFramePreProcessor : public UObject {
};

// Size: 0x8
struct FLiveLinkFrameRate : public FFrameRate {
};

// Size: 0x30
class ULiveLinkFrameTranslator : public UObject {
};

// Size: 0x8
struct FLiveLinkInterpolationSettings {
    /* 0x0000 */ bool bUseInterpolation;
    /* 0x0004 */ float InterpolationOffset;
};

// Size: 0x130
struct FLiveLinkLightBlueprintData : public FLiveLinkBaseBlueprintData {
    /* 0x0008 */ FLiveLinkLightStaticData StaticData;
    /* 0x0030 */ FLiveLinkLightFrameData FrameData;
};

// Size: 0x100
struct FLiveLinkLightFrameData : public FLiveLinkTransformFrameData {
    /* 0x00d0 */ float Temperature;
    /* 0x00d4 */ float Intensity;
    /* 0x00d8 */ FColor LightColor;
    /* 0x00dc */ float InnerConeAngle;
    /* 0x00e0 */ float OuterConeAngle;
    /* 0x00e4 */ float AttenuationRadius;
    /* 0x00e8 */ float SourceRadius;
    /* 0x00ec */ float SoftSourceRadius;
    /* 0x00f0 */ float SourceLength;
};

// Size: 0x30
class ULiveLinkLightRole : public ULiveLinkTransformRole {
};

// Size: 0x28
struct FLiveLinkLightStaticData : public FLiveLinkTransformStaticData {
    /* 0x0018 */ bool bIsTemperatureSupported;
    /* 0x0019 */ bool bIsIntensitySupported;
    /* 0x001a */ bool bIsLightColorSupported;
    /* 0x001b */ bool bIsInnerConeAngleSupported;
    /* 0x001c */ bool bIsOuterConeAngleSupported;
    /* 0x001d */ bool bIsAttenuationRadiusSupported;
    /* 0x001e */ bool bIsSourceLenghtSupported;
    /* 0x001f */ bool bIsSourceRadiusSupported;
    /* 0x0020 */ bool bIsSoftSourceRadiusSupported;
};

// Size: 0x60
struct FLiveLinkMetaData {
    /* 0x0000 */ TMap<FName, FString> StringMetadata;
    /* 0x0050 */ FQualifiedFrameTime SceneTime;
};

// Size: 0x20
struct FLiveLinkRefSkeleton {
    /* 0x0000 */ TArray<FName> BoneNames;
    /* 0x0010 */ TArray<int32_t> BoneParents;
};

// Size: 0x30
class ULiveLinkRole : public UObject {
};

// Size: 0x30
struct FLiveLinkSkeletonStaticData : public FLiveLinkBaseStaticData {
    /* 0x0010 */ TArray<FName> BoneNames;
    /* 0x0020 */ TArray<int32_t> BoneParents;
};

// Size: 0x60
struct FLiveLinkSourceBufferManagementSettings {
    /* 0x0000 */ bool bValidEngineTimeEnabled;
    /* 0x0004 */ float ValidEngineTime;
    /* 0x0008 */ float EngineTimeOffset;
    /* 0x0010 */ double EngineTimeClockOffset;
    /* 0x0018 */ FFrameRate TimecodeFrameRate;
    /* 0x0020 */ bool bGenerateSubFrame;
    /* 0x0024 */ FFrameRate DetectedFrameRate;
    /* 0x002c */ bool bUseTimecodeSmoothLatest;
    /* 0x0030 */ FFrameRate SourceTimecodeFrameRate;
    /* 0x0038 */ bool bValidTimecodeFrameEnabled;
    /* 0x003c */ int32_t ValidTimecodeFrame;
    /* 0x0040 */ float TimecodeFrameOffset;
    /* 0x0048 */ double TimecodeClockOffset;
    /* 0x0050 */ int32_t LatestOffset;
    /* 0x0054 */ int32_t MaxNumberOfFrameToBuffered;
    /* 0x0058 */ bool bKeepAtLeastOneFrame;
};

// Size: 0x14
struct FLiveLinkSourceDebugInfo {
    /* 0x0000 */ FLiveLinkSubjectName SubjectName;
    /* 0x000c */ int32_t SnapshotIndex;
    /* 0x0010 */ int32_t NumberOfBufferAtSnapshot;
};

// Size: 0x30
class ULiveLinkSourceFactory : public UObject {
};

// Size: 0x18
struct FLiveLinkSourceHandle {
};

// Size: 0x30
struct FLiveLinkSourcePreset {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ ULiveLinkSourceSettings* Settings;
    /* 0x0018 */ FText SourceType;
};

// Size: 0xc0
class ULiveLinkSourceSettings : public UObject {
    /* 0x0030 */ ELiveLinkSourceMode Mode;
    /* 0x0038 */ FLiveLinkSourceBufferManagementSettings BufferSettings;
    /* 0x0098 */ FString ConnectionString;
    /* 0x00a8 */ UClass* Factory;
    /* 0x00b0 */ TArray<FLiveLinkSourceDebugInfo> SourceDebugInfos;
};

// Size: 0x1c
struct FLiveLinkSubjectKey {
    /* 0x0000 */ FGuid Source;
    /* 0x0010 */ FLiveLinkSubjectName SubjectName;
};

// Size: 0xc
struct FLiveLinkSubjectName {
    /* 0x0000 */ FName Name;
};

// Size: 0x40
struct FLiveLinkSubjectPreset {
    /* 0x0000 */ FLiveLinkSubjectKey Key;
    /* 0x0020 */ UClass* Role;
    /* 0x0028 */ ULiveLinkSubjectSettings* Settings;
    /* 0x0030 */ ULiveLinkVirtualSubject* VirtualSubject;
    /* 0x0038 */ bool bEnabled;
};

// Size: 0x18
struct FLiveLinkSubjectRepresentation {
    /* 0x0000 */ FLiveLinkSubjectName Subject;
    /* 0x0010 */ UClass* Role;
};

// Size: 0x70
class ULiveLinkSubjectSettings : public UObject {
    /* 0x0030 */ TArray<ULiveLinkFramePreProcessor*> PreProcessors;
    /* 0x0040 */ ULiveLinkFrameInterpolationProcessor* InterpolationProcessor;
    /* 0x0048 */ TArray<ULiveLinkFrameTranslator*> Translators;
    /* 0x0058 */ UClass* Role;
    /* 0x0060 */ FFrameRate FrameRate;
    /* 0x0068 */ bool bRebroadcastSubject;
};

// Size: 0x18
struct FLiveLinkTime {
    /* 0x0000 */ double WorldTime;
    /* 0x0008 */ FQualifiedFrameTime SceneTime;
};

// Size: 0x10
struct FLiveLinkTimeCode : public FLiveLinkTimeCode_Base_DEPRECATED {
};

// Size: 0x10
struct FLiveLinkTimeCode_Base_DEPRECATED {
    /* 0x0000 */ int32_t Seconds;
    /* 0x0004 */ int32_t Frames;
    /* 0x0008 */ FLiveLinkFrameRate FrameRate;
};

// Size: 0xc
struct FLiveLinkTimeSynchronizationSettings {
    /* 0x0000 */ FFrameRate FrameRate;
    /* 0x0008 */ FFrameNumber FrameOffset;
};

// Size: 0x20
struct FLiveLinkTransform {
};

// Size: 0xf0
struct FLiveLinkTransformBlueprintData : public FLiveLinkBaseBlueprintData {
    /* 0x0008 */ FLiveLinkTransformStaticData StaticData;
    /* 0x0020 */ FLiveLinkTransformFrameData FrameData;
};

// Size: 0xd0
struct FLiveLinkTransformFrameData : public FLiveLinkBaseFrameData {
    /* 0x00a0 */ FTransform Transform;
};

// Size: 0x30
class ULiveLinkTransformRole : public ULiveLinkBasicRole {
};

// Size: 0x18
struct FLiveLinkTransformStaticData : public FLiveLinkBaseStaticData {
    /* 0x0010 */ bool bIsLocationSupported;
    /* 0x0011 */ bool bIsRotationSupported;
    /* 0x0012 */ bool bIsScaleSupported;
};

// Size: 0x168
class ULiveLinkVirtualSubject : public UObject {
    /* 0x0038 */ UClass* Role;
    /* 0x0040 */ TArray<FLiveLinkSubjectName> Subjects;
    /* 0x0050 */ TArray<ULiveLinkFrameTranslator*> FrameTranslators;
    /* 0x0060 */ bool bRebroadcastSubject;
};

// Size: 0x10
struct FLiveLinkWorldTime {
    /* 0x0000 */ double Time;
    /* 0x0008 */ double Offset;
};

// Size: 0x18
struct FSubjectFrameHandle : public FLiveLinkBaseBlueprintData {
};

// Size: 0x70
struct FSubjectMetadata {
    /* 0x0000 */ TMap<FName, FString> StringMetadata;
    /* 0x0050 */ FTimecode SceneTimecode;
    /* 0x0064 */ FFrameRate SceneFramerate;
};

// Size: 0xc
struct FLiveLinkClearSubject {
    /* 0x0000 */ FName SubjectName;
};

// Size: 0x4
struct FLiveLinkConnectMessage {
    /* 0x0000 */ int32_t LiveLinkVersion;
};

// Size: 0x1
struct FLiveLinkHeartbeatMessage {
};

// Size: 0x14
struct FLiveLinkPingMessage {
    /* 0x0000 */ FGuid PollRequest;
    /* 0x0010 */ int32_t LiveLinkVersion;
};

// Size: 0x40
struct FLiveLinkPongMessage {
    /* 0x0000 */ FString ProviderName;
    /* 0x0010 */ FString MachineName;
    /* 0x0020 */ FGuid PollRequest;
    /* 0x0030 */ int32_t LiveLinkVersion;
    /* 0x0038 */ double CreationPlatformTime;
};

// Size: 0x30
struct FLiveLinkSubjectDataMessage {
    /* 0x0000 */ FLiveLinkRefSkeleton RefSkeleton;
    /* 0x0020 */ FName SubjectName;
};

// Size: 0x98
struct FLiveLinkSubjectFrameMessage {
    /* 0x0000 */ FName SubjectName;
    /* 0x0010 */ TArray<FTransform> Transforms;
    /* 0x0020 */ TArray<FLiveLinkCurveElement> Curves;
    /* 0x0030 */ FLiveLinkMetaData MetaData;
    /* 0x0090 */ double Time;
};

// Size: 0x60
struct FLiveLinkPropertyData {
    /* 0x0000 */ FName PropertyName;
    /* 0x0010 */ TArray<FMovieSceneFloatChannel> FloatChannel;
    /* 0x0020 */ TArray<FMovieSceneStringChannel> StringChannel;
    /* 0x0030 */ TArray<FMovieSceneIntegerChannel> IntegerChannel;
    /* 0x0040 */ TArray<FMovieSceneBoolChannel> BoolChannel;
    /* 0x0050 */ TArray<FMovieSceneByteChannel> ByteChannel;
};

// Size: 0x10
struct FLiveLinkSubSectionData {
    /* 0x0000 */ TArray<FLiveLinkPropertyData> Properties;
};

// Size: 0x278
class UMovieSceneLiveLinkSection : public UMovieSceneSection {
    /* 0x0128 */ FLiveLinkSubjectPreset SubjectPreset;
    /* 0x0168 */ TArray<bool> ChannelMask;
    /* 0x0178 */ TArray<UMovieSceneLiveLinkSubSection*> SubSections;
    /* 0x0198 */ FName SubjectName;
    /* 0x01a8 */ FLiveLinkFrameData TemplateToPush;
    /* 0x0238 */ FLiveLinkRefSkeleton RefSkeleton;
    /* 0x0258 */ TArray<FName> CurveNames;
    /* 0x0268 */ TArray<FMovieSceneFloatChannel> PropertyFloatChannels;
};

// Size: 0xc8
struct FMovieSceneLiveLinkSectionTemplate : public FMovieScenePropertySectionTemplate {
    /* 0x0040 */ FLiveLinkSubjectPreset SubjectPreset;
    /* 0x0080 */ TArray<bool> ChannelMask;
    /* 0x0090 */ TArray<FLiveLinkSubSectionData> SubSectionsData;
};

// Size: 0x58
class UMovieSceneLiveLinkSubSection : public UObject {
    /* 0x0030 */ FLiveLinkSubSectionData SubSectionData;
    /* 0x0040 */ UClass* SubjectRole;
};

// Size: 0x68
class UMovieSceneLiveLinkSubSectionAnimation : public UMovieSceneLiveLinkSubSection {
};

// Size: 0x68
class UMovieSceneLiveLinkSubSectionBasicRole : public UMovieSceneLiveLinkSubSection {
};

// Size: 0x68
class UMovieSceneLiveLinkSubSectionProperties : public UMovieSceneLiveLinkSubSection {
};

// Size: 0x148
class UMovieSceneLiveLinkTrack : public UMovieScenePropertyTrack {
    /* 0x0140 */ UClass* TrackRole;
};

// Size: 0xb0
class ULiveLinkSequencerSettings : public UDeveloperSettings {
    /* 0x0060 */ TMap<UClass*, UClass*> DefaultTrackRecordersForController;
};

// Size: 0x40
class ULiveLinkSubjectProperties : public UObject {
    /* 0x0030 */ TArray<FLiveLinkSubjectProperty> Properties;
};

// Size: 0x10
struct FLiveLinkSubjectProperty {
    /* 0x0000 */ FName SubjectName;
    /* 0x000c */ bool bEnabled;
};

// Size: 0xa0
class UMovieSceneLiveLinkControllerMapTrackRecorder : public UMovieSceneTrackRecorder {
};

// Size: 0x98
class UMovieSceneLiveLinkControllerTrackRecorder : public UMovieSceneTrackRecorder {
    /* 0x0090 */ ULiveLinkControllerBase* LiveLinkControllerToRecord;
};

// Size: 0x110
class UMovieSceneLiveLinkTrackRecorder : public UMovieSceneTrackRecorder {
};

// Size: 0x60
class UTakeRecorderLiveLinkSource : public UTakeRecorderSource {
    /* 0x0040 */ bool bReduceKeys;
    /* 0x0044 */ FName SubjectName;
    /* 0x0050 */ bool bSaveSubjectSettings;
    /* 0x0051 */ bool bUseSourceTimecode;
    /* 0x0052 */ bool bDiscardSamplesBeforeStart;
    /* 0x0058 */ UMovieSceneLiveLinkTrackRecorder* TrackRecorder;
};

// Size: 0x18
struct FCultureStatistics {
    /* 0x0000 */ FString CultureName;
    /* 0x0010 */ uint32_t WordCount;
};

enum class ELocTextPlatformSplitMode {
    None = 0,
    Confidential = 1,
    All = 2,
    ELocTextPlatformSplitMode_MAX = 3,
};

enum class ELocalizationGatherPathRoot {
    Auto = 0,
    Engine = 1,
    Project = 2,
    ELocalizationGatherPathRoot_MAX = 3,
};

enum class ELocalizationTargetConflictStatus {
    Unknown = 0,
    ConflictsPresent = 1,
    Clear = 2,
    ELocalizationTargetConflictStatus_MAX = 3,
};

enum class ELocalizationTargetLoadingPolicy {
    Never = 0,
    Always = 1,
    Editor = 2,
    Game = 3,
    PropertyNames = 4,
    ToolTips = 5,
    ELocalizationTargetLoadingPolicy_MAX = 6,
};

enum class ELocalizedTextCollapseMode {
    IdenticalTextIdAndSource = 0,
    IdenticalPackageIdTextIdAndSource = 1,
    IdenticalNamespaceAndSource = 2,
    ELocalizedTextCollapseMode_MAX = 3,
};

enum class EPortableObjectFormat {
    Unreal = 0,
    Crowdin = 1,
    EPortableObjectFormat_MAX = 2,
};

// Size: 0x18
struct FGatherTextExcludePath {
    /* 0x0000 */ ELocalizationGatherPathRoot PathRoot;
    /* 0x0008 */ FString Pattern;
};

// Size: 0x10
struct FGatherTextFileExtension {
    /* 0x0000 */ FString Pattern;
};

// Size: 0x40
struct FGatherTextFromMetaDataConfiguration {
    /* 0x0000 */ bool IsEnabled;
    /* 0x0008 */ TArray<FGatherTextIncludePath> IncludePathWildcards;
    /* 0x0018 */ TArray<FGatherTextExcludePath> ExcludePathWildcards;
    /* 0x0028 */ TArray<FMetaDataKeyGatherSpecification> KeySpecifications;
    /* 0x0038 */ bool ShouldGatherFromEditorOnlyData;
};

// Size: 0x60
struct FGatherTextFromPackagesConfiguration {
    /* 0x0000 */ bool IsEnabled;
    /* 0x0008 */ TArray<FGatherTextIncludePath> IncludePathWildcards;
    /* 0x0018 */ TArray<FGatherTextExcludePath> ExcludePathWildcards;
    /* 0x0028 */ TArray<FGatherTextFileExtension> FileExtensions;
    /* 0x0038 */ TArray<FName> Collections;
    /* 0x0048 */ TArray<FSoftClassPath> ExcludeClasses;
    /* 0x0058 */ bool ShouldExcludeDerivedClasses;
    /* 0x0059 */ bool ShouldGatherFromEditorOnlyData;
    /* 0x005a */ bool SkipGatherCache;
};

// Size: 0x40
struct FGatherTextFromTextFilesConfiguration {
    /* 0x0000 */ bool IsEnabled;
    /* 0x0008 */ TArray<FGatherTextSearchDirectory> SearchDirectories;
    /* 0x0018 */ TArray<FGatherTextExcludePath> ExcludePathWildcards;
    /* 0x0028 */ TArray<FGatherTextFileExtension> FileExtensions;
    /* 0x0038 */ bool ShouldGatherFromEditorOnlyData;
};

// Size: 0x18
struct FGatherTextIncludePath {
    /* 0x0000 */ ELocalizationGatherPathRoot PathRoot;
    /* 0x0008 */ FString Pattern;
};

// Size: 0x18
struct FGatherTextSearchDirectory {
    /* 0x0000 */ ELocalizationGatherPathRoot PathRoot;
    /* 0x0008 */ FString Path;
};

// Size: 0x3
struct FLocalizationCompilationSettings {
    /* 0x0000 */ bool SkipSourceCheck;
    /* 0x0001 */ bool ValidateFormatPatterns;
    /* 0x0002 */ bool ValidateSafeWhitespace;
};

// Size: 0x4
struct FLocalizationExportingSettings {
    /* 0x0000 */ ELocalizedTextCollapseMode CollapseMode;
    /* 0x0001 */ EPortableObjectFormat POFormat;
    /* 0x0002 */ bool ShouldPersistCommentsOnExport;
    /* 0x0003 */ bool ShouldAddSourceLocationsAsComments;
};

// Size: 0x28
struct FLocalizationImportDialogueSettings {
    /* 0x0000 */ FDirectoryPath RawAudioPath;
    /* 0x0010 */ FString ImportedDialogueFolder;
    /* 0x0020 */ bool bImportNativeAsSource;
};

// Size: 0x60
class ULocalizationSettings : public UObject {
    /* 0x0030 */ ULocalizationTargetSet* EngineTargetSet;
    /* 0x0038 */ TArray<FLocalizationTargetSettings> EngineTargetsSettings;
    /* 0x0048 */ ULocalizationTargetSet* GameTargetSet;
    /* 0x0050 */ TArray<FLocalizationTargetSettings> GameTargetsSettings;
};

// Size: 0x1b0
class ULocalizationTarget : public UObject {
    /* 0x0030 */ FLocalizationTargetSettings Settings;
};

// Size: 0x40
class ULocalizationTargetSet : public UObject {
    /* 0x0030 */ TArray<ULocalizationTarget*> TargetObjects;
};

// Size: 0x180
struct FLocalizationTargetSettings {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FGuid Guid;
    /* 0x0020 */ ELocalizationTargetConflictStatus ConflictStatus;
    /* 0x0028 */ TArray<FGuid> TargetDependencies;
    /* 0x0038 */ TArray<FFilePath> AdditionalManifestDependencies;
    /* 0x0048 */ TArray<FString> RequiredModuleNames;
    /* 0x0058 */ FGatherTextFromTextFilesConfiguration GatherFromTextFiles;
    /* 0x0098 */ FGatherTextFromPackagesConfiguration GatherFromPackages;
    /* 0x00f8 */ FGatherTextFromMetaDataConfiguration GatherFromMetaData;
    /* 0x0138 */ FLocalizationExportingSettings ExportSettings;
    /* 0x013c */ FLocalizationCompilationSettings CompileSettings;
    /* 0x0140 */ FLocalizationImportDialogueSettings ImportDialogueSettings;
    /* 0x0168 */ int32_t NativeCultureIndex;
    /* 0x0170 */ TArray<FCultureStatistics> SupportedCulturesStatistics;
};

// Size: 0x30
struct FMetaDataKeyGatherSpecification {
    /* 0x0000 */ FMetaDataKeyName MetaDataKey;
    /* 0x0010 */ FString TextNamespace;
    /* 0x0020 */ FMetaDataTextKeyPattern TextKeyPattern;
};

// Size: 0x10
struct FMetaDataKeyName {
    /* 0x0000 */ FString Name;
};

// Size: 0x10
struct FMetaDataTextKeyPattern {
    /* 0x0000 */ FString Pattern;
};

// Size: 0x30
class ULocalizationDashboardSettings : public UObject {
};

enum class ELocationAccuracy {
    LA_ThreeKilometers = 0,
    LA_OneKilometer = 1,
    LA_HundredMeters = 2,
    LA_TenMeters = 3,
    LA_Best = 4,
    LA_Navigation = 5,
    LA_MAX = 6,
};

// Size: 0x30
class ULocationServices : public UBlueprintFunctionLibrary {

    static bool AreLocationServicesEnabled();
    static FLocationServicesData GetLastKnownLocation();
    static ULocationServicesImpl* GetLocationServicesImpl();
    static bool InitLocationServices(ELocationAccuracy Accuracy, float UpdateFrequency, float MinDistanceFilter);
    static bool IsLocationAccuracyAvailable(ELocationAccuracy Accuracy);
    static bool StartLocationServices();
    static bool StopLocationServices();
};

// Size: 0x18
struct FLocationServicesData {
    /* 0x0000 */ float Timestamp;
    /* 0x0004 */ float Longitude;
    /* 0x0008 */ float Latitude;
    /* 0x000c */ float HorizontalAccuracy;
    /* 0x0010 */ float VerticalAccuracy;
    /* 0x0014 */ float Altitude;
};

// Size: 0x40
class ULocationServicesImpl : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnLocationChanged;
};

// Size: 0x18
struct FCategoryFilter {
    /* 0x0000 */ FString CategoryName;
    /* 0x0010 */ int32_t LogVerbosity;
    /* 0x0014 */ bool Enabled;
};

// Size: 0x50
class ULogVisualizerSessionSettings : public UObject {
    /* 0x0030 */ bool bEnableGraphsVisualization;
};

// Size: 0xc0
class ULogVisualizerSettings : public UObject {
    /* 0x0030 */ bool bIgnoreTrivialLogs;
    /* 0x0034 */ int32_t TrivialLogsThreshold;
    /* 0x0038 */ bool bStickToRecentData;
    /* 0x0039 */ bool bResetDataWithNewSession;
    /* 0x003a */ bool bShowHistogramLabelsOutside;
    /* 0x003c */ float DefaultCameraDistance;
    /* 0x0040 */ bool bSearchInsideLogs;
    /* 0x0044 */ FColor GraphsBackgroundColor;
    /* 0x0048 */ bool bPresistentFilters;
    /* 0x0049 */ bool bDrawExtremesOnGraphs;
    /* 0x004a */ bool bConstrainGraphToLocalMinMax;
    /* 0x004b */ bool bUsePlayersOnlyForPause;
    /* 0x004c */ bool bLogNavOctreeOnStop;
    /* 0x004d */ bool bForceUniqueLogNames;
    /* 0x0050 */ FVisualLoggerFiltersData PresistentFilters;
    /* 0x0090 */ UMaterial* DebugMeshMaterialFakeLight;
    /* 0x0098 */ FString DebugMeshMaterialFakeLightName;
};

// Size: 0x790
class AVisualLoggerCameraController : public ADebugCameraController {
    /* 0x0768 */ AActor* PickedActor;
};

// Size: 0xd0
struct FVisualLoggerFilters : public FVisualLoggerFiltersData {
};

// Size: 0x40
struct FVisualLoggerFiltersData {
    /* 0x0000 */ FString SearchBoxFilter;
    /* 0x0010 */ FString ObjectNameFilter;
    /* 0x0020 */ TArray<FCategoryFilter> Categories;
    /* 0x0030 */ TArray<FString> SelectedClasses;
};

// Size: 0x410
class AVisualLoggerHUD : public ADebugCameraHUD {
};

// Size: 0x400
class AVisualLoggerRenderingActor : public AActor {
};

// Size: 0x530
class UVisualLoggerRenderingComponent : public UPrimitiveComponent {
};

// Size: 0x50
class UMagicLeapSDKSettings : public UObject {
    /* 0x0030 */ FDirectoryPath MLSDKPath;
};

enum class ELuminComponentSubElementType {
    FileExtension = 0,
    MimeType = 1,
    Mode = 2,
    MusicAttribute = 3,
    Schema = 4,
    ELuminComponentSubElementType_MAX = 5,
};

enum class ELuminComponentType {
    Universe = 0,
    Fullscreen = 1,
    SearchProvider = 2,
    MusicService = 3,
    Console = 4,
    SystemUI = 5,
    ELuminComponentType_MAX = 6,
};

enum class ELuminFrameTimingHint {
    Unspecified = 0,
    Maximum = 1,
    FPS_60 = 2,
    FPS_120 = 3,
    ELuminFrameTimingHint_MAX = 4,
};

enum class ELuminPrivilege {
    Invalid = 0,
    BatteryInfo = 1,
    CameraCapture = 2,
    ComputerVision = 3,
    WorldReconstruction = 4,
    InAppPurchase = 5,
    AudioCaptureMic = 6,
    DrmCertificates = 7,
    Occlusion = 8,
    LowLatencyLightwear = 9,
    Internet = 10,
    IdentityRead = 11,
    BackgroundDownload = 12,
    BackgroundUpload = 13,
    MediaDrm = 14,
    Media = 15,
    MediaMetadata = 16,
    PowerInfo = 17,
    LocalAreaNetwork = 18,
    VoiceInput = 19,
    Documents = 20,
    ConnectBackgroundMusicService = 21,
    RegisterBackgroundMusicService = 22,
    PcfRead = 23,
    PwFoundObjRead = 23,
    NormalNotificationsUsage = 24,
    MusicService = 25,
    ControllerPose = 26,
    GesturesSubscribe = 27,
    GesturesConfig = 28,
    AddressBookRead = 29,
    AddressBookWrite = 30,
    AddressBookBasicAccess = 31,
    CoarseLocation = 32,
    FineLocation = 33,
    HandMesh = 34,
    WifiStatusRead = 35,
    SocialConnectionsInvitesAccess = 36,
    SocialConnectionsSelectAccess = 37,
    SecureBrowserWindow = 38,
    BluetoothAdapterExternalApp = 39,
    BluetoothAdapterUser = 40,
    BluetoothGattWrite = 41,
    ELuminPrivilege_MAX = 42,
};

// Size: 0x20
struct FLocalizedAppName {
    /* 0x0000 */ FString LanguageCode;
    /* 0x0010 */ FString AppName;
};

// Size: 0x30
struct FLocalizedIconInfo {
    /* 0x0000 */ FString LanguageCode;
    /* 0x0010 */ FDirectoryPath IconModelPath;
    /* 0x0020 */ FDirectoryPath IconPortalPath;
};

// Size: 0x10
struct FLocalizedIconInfos {
    /* 0x0000 */ TArray<FLocalizedIconInfo> IconData;
};

// Size: 0x48
struct FLuminComponentElement {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FString VisibleName;
    /* 0x0020 */ FString ExecutableName;
    /* 0x0030 */ ELuminComponentType ComponentType;
    /* 0x0038 */ TArray<FLuminComponentSubElement> ExtraComponentSubElements;
};

// Size: 0x18
struct FLuminComponentSubElement {
    /* 0x0000 */ ELuminComponentSubElementType ElementType;
    /* 0x0008 */ FString Value;
};

// Size: 0x150
class ULuminRuntimeSettings : public UObject {
    /* 0x0030 */ FString PackageName;
    /* 0x0040 */ FString ApplicationDisplayName;
    /* 0x0050 */ ELuminFrameTimingHint FrameTimingHint;
    /* 0x0051 */ bool bProtectedContent;
    /* 0x0052 */ bool bManualCallToAppReady;
    /* 0x0053 */ bool bUseMobileRendering;
    /* 0x0054 */ bool bUseVulkan;
    /* 0x0058 */ FFilePath Certificate;
    /* 0x0068 */ FDirectoryPath IconModelPath;
    /* 0x0078 */ FDirectoryPath IconPortalPath;
    /* 0x0088 */ FLocalizedIconInfos LocalizedIconInfos;
    /* 0x0098 */ int32_t VersionCode;
    /* 0x009c */ int32_t MinimumAPILevel;
    /* 0x00a0 */ TArray<ELuminPrivilege> AppPrivileges;
    /* 0x00b0 */ TArray<FLuminComponentSubElement> ExtraComponentSubElements;
    /* 0x00c0 */ TArray<FLuminComponentElement> ExtraComponentElements;
    /* 0x00d0 */ FString SpatializationPlugin;
    /* 0x00e0 */ FString ReverbPlugin;
    /* 0x00f0 */ FString OcclusionPlugin;
    /* 0x0100 */ int32_t SoundCueCookQualityIndex;
    /* 0x0104 */ bool bRemoveDebugInfo;
    /* 0x0108 */ FDirectoryPath VulkanValidationLayerLibs;
    /* 0x0118 */ bool bFrameVignette;
    /* 0x0120 */ TArray<FLocalizedAppName> LocalizedAppNames;
};

enum class EMeshTrackerVertexColorMode {
    None = 0,
    Confidence = 1,
    Block = 2,
    EMeshTrackerVertexColorMode_MAX = 3,
};

// Size: 0x590
class UMRMeshComponent : public UPrimitiveComponent {
    /* 0x04e8 */ UMaterialInterface* Material;
    /* 0x04f0 */ UMaterialInterface* WireframeMaterial;
    /* 0x04f8 */ bool bCreateMeshProxySections;
    /* 0x04f9 */ bool bUpdateNavMeshOnMeshUpdate;
    /* 0x04fa */ bool bNeverCreateCollisionMesh;
    /* 0x0500 */ UBodySetup* CachedBodySetup;
    /* 0x0508 */ TArray<UBodySetup*> BodySetups;

    void Clear();
    void ForceNavMeshUpdate();
    bool GetEnableMeshOcclusion() const;
    bool GetUseWireframe() const;
    FLinearColor GetWireframeColor() const;
    bool IsConnected() const;
    void SetEnableMeshOcclusion(bool bEnable);
    void SetUseWireframe(bool bUseWireframe);
    void SetWireframeColor(const FLinearColor& InColor);
    void SetWireframeMaterial(UMaterialInterface* InMaterial);
};

// Size: 0x1
struct FMRMeshConfiguration {
};

// Size: 0x30
class UMeshReconstructorBase : public UObject {

    void ConnectMRMesh(UMRMeshComponent* Mesh);
    void DisconnectMRMesh();
    bool IsReconstructionPaused() const;
    bool IsReconstructionStarted() const;
    void PauseReconstruction();
    void StartReconstruction();
    void StopReconstruction();
};

// Size: 0x2a0
class UMockDataMeshTrackerComponent : public USceneComponent {
    /* 0x0228 */ FMulticastInlineDelegate OnMeshTrackerUpdated;
    /* 0x0238 */ bool ScanWorld;
    /* 0x0239 */ bool RequestNormals;
    /* 0x023a */ bool RequestVertexConfidence;
    /* 0x023b */ EMeshTrackerVertexColorMode VertexColorMode;
    /* 0x0240 */ TArray<FColor> BlockVertexColors;
    /* 0x0250 */ FLinearColor VertexColorFromConfidenceZero;
    /* 0x0260 */ FLinearColor VertexColorFromConfidenceOne;
    /* 0x0270 */ float UpdateInterval;
    /* 0x0278 */ UMRMeshComponent* MRMesh;

    void ConnectMRMesh(UMRMeshComponent* InMRMeshPtr);
    void DisconnectMRMesh(UMRMeshComponent* InMRMeshPtr);
    void OnMockDataMeshTrackerUpdated__DelegateSignature(int32_t index, const TArray<FVector>& Vertices, const TArray<int32_t>& Triangles, const TArray<FVector>& Normals, const TArray<float>& Confidence);
};

enum class EMacMetalShaderStandard {
    MacMetalSLStandard_2_0 = 3,
    MacMetalSLStandard_2_1 = 4,
    MacMetalSLStandard_2_MAX = 5,
};

enum class EMacTargetArchitecture {
    MacTargetArchitectureIntel = 0,
    MacTargetArchitectureUniversal = 1,
    MacTargetArchitectureAppleSil = 2,
    EMacTargetArchitecture_MAX = 3,
};

// Size: 0x98
class UMacTargetSettings : public UObject {
    /* 0x0030 */ TArray<FString> TargetedRHIs;
    /* 0x0040 */ EMacTargetArchitecture TargetArchitecture;
    /* 0x0041 */ uint8_t MaxShaderLanguageVersion;
    /* 0x0042 */ bool UseFastIntrinsics;
    /* 0x0043 */ bool ForceFloats;
    /* 0x0044 */ bool EnableMathOptimisations;
    /* 0x0048 */ int32_t IndirectArgumentTier;
    /* 0x004c */ int32_t AudioSampleRate;
    /* 0x0050 */ int32_t AudioCallbackBufferFrameSize;
    /* 0x0054 */ int32_t AudioNumBuffersToEnqueue;
    /* 0x0058 */ int32_t AudioMaxChannels;
    /* 0x005c */ int32_t AudioNumSourceWorkers;
    /* 0x0060 */ FString SpatializationPlugin;
    /* 0x0070 */ FString ReverbPlugin;
    /* 0x0080 */ FString OcclusionPlugin;
    /* 0x0090 */ int32_t SoundCueCookQualityIndex;
};

enum class CloudStatus {
    CloudStatus_NotDone = 0,
    CloudStatus_Done = 1,
    CloudStatus_MAX = 2,
};

enum class EFocusLostReason {
    EFocusLostReason_Invalid = 0,
    EFocusLostReason_System = 1,
    EFocusLostReason_MAX = 2,
};

enum class EMagicLeapHeadTrackingError {
    None = 0,
    NotEnoughFeatures = 1,
    LowLight = 2,
    Unknown = 3,
    EMagicLeapHeadTrackingError_MAX = 4,
};

enum class EMagicLeapHeadTrackingMapEvent {
    Lost = 0,
    Recovered = 1,
    RecoveryFailed = 2,
    NewSession = 3,
    EMagicLeapHeadTrackingMapEvent_MAX = 4,
};

enum class EMagicLeapHeadTrackingMode {
    PositionAndOrientation = 0,
    Unavailable = 1,
    Unknown = 2,
    EMagicLeapHeadTrackingMode_MAX = 3,
};

enum class EMagicLeapMeshLOD {
    Minimum = 0,
    Medium = 1,
    Maximum = 2,
    EMagicLeapMeshLOD_MAX = 3,
};

enum class EMagicLeapMeshState {
    New = 0,
    Updated = 1,
    Deleted = 2,
    Unchanged = 3,
    EMagicLeapMeshState_MAX = 4,
};

enum class EMagicLeapMeshType {
    Triangles = 0,
    PointCloud = 1,
    EMagicLeapMeshType_MAX = 2,
};

enum class EMagicLeapMeshVertexColorMode {
    None = 0,
    Confidence = 1,
    Block = 2,
    LOD = 3,
    EMagicLeapMeshVertexColorMode_MAX = 4,
};

enum class EMagicLeapRaycastResultState {
    RequestFailed = 0,
    NoCollision = 1,
    HitUnobserved = 2,
    HitObserved = 3,
    EMagicLeapRaycastResultState_MAX = 4,
};

// Size: 0x138
class UInAppPurchaseComponent : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate InAppPurchaseLogMessage;
    /* 0x00d0 */ FMulticastInlineDelegate GetItemsDetailsSuccess;
    /* 0x00e0 */ FMulticastInlineDelegate GetItemsDetailsFailure;
    /* 0x00f0 */ FMulticastInlineDelegate PurchaseConfirmationSuccess;
    /* 0x0100 */ FMulticastInlineDelegate PurchaseConfirmationFailure;
    /* 0x0110 */ FMulticastInlineDelegate GetPurchaseHistorySuccess;
    /* 0x0120 */ FMulticastInlineDelegate GetPurchaseHistoryFailure;

    void GetItemsDetailsFailure__DelegateSignature();
    void GetItemsDetailsSuccess__DelegateSignature(const TArray<FPurchaseItemDetails>& ItemsDetails);
    void GetPurchaseHistoryFailure__DelegateSignature();
    void GetPurchaseHistorySuccess__DelegateSignature(const TArray<FPurchaseConfirmation>& PurchaseHistory);
    void InAppPurchaseLogMessage__DelegateSignature(FString LogMessage);
    void PurchaseConfirmationFailure__DelegateSignature();
    void PurchaseConfirmationSuccess__DelegateSignature(const FPurchaseConfirmation& PurchaseConfirmations);
    bool TryGetItemsDetailsAsync(const TArray<FString>& ItemIDs);
    bool TryGetPurchaseHistoryAsync(int32_t InNumPages);
    bool TryPurchaseItemAsync(const FPurchaseItemDetails& ItemDetails);
};

// Size: 0x1a0
class ULuminApplicationLifecycleComponent : public UApplicationLifecycleComponent {
    /* 0x0150 */ FMulticastInlineDelegate DeviceHasReactivatedDelegate;
    /* 0x0160 */ FMulticastInlineDelegate DeviceWillEnterRealityModeDelegate;
    /* 0x0170 */ FMulticastInlineDelegate DeviceWillGoInStandbyDelegate;
    /* 0x0180 */ FMulticastInlineDelegate FocusLostDelegate;
    /* 0x0190 */ FMulticastInlineDelegate FocusGainedDelegate;

    void LuminApplicationLifetimeDelegate__DelegateSignature();
    void LuminApplicationLifetimeFocusLostDelegate__DelegateSignature(EFocusLostReason reason);
};

// Size: 0x1c
struct FMagicLeapGraphicsClientPerformanceInfo {
    /* 0x0000 */ float FrameStartCPUCompAcquireCPUTimeMs;
    /* 0x0004 */ float FrameStartCPUFrameEndGPUTimeMs;
    /* 0x0008 */ float FrameStartCPUFrameStartCPUTimeMs;
    /* 0x000c */ float FrameDurationCPUTimeMs;
    /* 0x0010 */ float FrameDurationGPUTimeMs;
    /* 0x0014 */ float FrameInternalDurationCPUTimeMs;
    /* 0x0018 */ float FrameInternalDurationGPUTimeMs;
};

// Size: 0x30
class UMagicLeapHMDFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool GetGraphicsClientPerformanceInfo(FMagicLeapGraphicsClientPerformanceInfo& PerformanceInfo);
    static bool GetHeadTrackingMapEvents(TSet<EMagicLeapHeadTrackingMapEvent>& MapEvents);
    static bool GetHeadTrackingState(FMagicLeapHeadTrackingState& State);
    static FString GetMLSDKVersion();
    static int32_t GetMLSDKVersionMajor();
    static int32_t GetMLSDKVersionMinor();
    static int32_t GetMLSDKVersionRevision();
    static int32_t GetMinimumAPILevel();
    static int32_t GetPlatformAPILevel();
    static bool IsRunningOnMagicLeapHMD();
    static bool SetAppReady();
    static void SetBaseOrientation(const FQuat& InBaseOrientation);
    static void SetBasePosition(const FVector& InBasePosition);
    static void SetBaseRotation(const FRotator& InBaseRotation);
    static void SetFocusActor(const AActor* InFocusActor, bool bSetStabilizationActor);
    static void SetStabilizationDepthActor(const AActor* InStabilizationDepthActor, bool bSetFocusActor);
};

// Size: 0x1e0
class UMagicLeapHeadTrackingNotificationsComponent : public UVRNotificationsComponent {
    /* 0x0150 */ FMulticastInlineDelegate OnHeadTrackingLost;
    /* 0x0160 */ FMulticastInlineDelegate OnHeadTrackingRecovered;
    /* 0x0170 */ FMulticastInlineDelegate OnHeadTrackingRecoveryFailed;
    /* 0x0180 */ FMulticastInlineDelegate OnHeadTrackingNewSessionStarted;
};

// Size: 0x8
struct FMagicLeapHeadTrackingState {
    /* 0x0000 */ EMagicLeapHeadTrackingMode Mode;
    /* 0x0001 */ EMagicLeapHeadTrackingError Error;
    /* 0x0004 */ float Confidence;
};

// Size: 0x48
struct FMagicLeapMeshBlockInfo {
    /* 0x0000 */ FGuid BlockID;
    /* 0x0010 */ FVector BlockPosition;
    /* 0x001c */ FRotator BlockOrientation;
    /* 0x0028 */ FVector BlockDimensions;
    /* 0x0038 */ FTimespan Timestamp;
    /* 0x0040 */ EMagicLeapMeshState BlockState;
};

// Size: 0x14
struct FMagicLeapMeshBlockRequest {
    /* 0x0000 */ FGuid BlockID;
    /* 0x0010 */ EMagicLeapMeshLOD LevelOfDetail;
};

// Size: 0x30
class IMagicLeapMeshBlockSelectorInterface : public UInterface {

    void SelectMeshBlocks(const FMagicLeapTrackingMeshInfo& NewMeshInfo, TArray<FMagicLeapMeshBlockRequest>& RequestedMesh);
};

// Size: 0x2c0
class UMagicLeapMeshTrackerComponent : public USceneComponent {
    /* 0x0230 */ FMulticastInlineDelegate OnMeshTrackerUpdated;
    /* 0x0240 */ bool ScanWorld;
    /* 0x0241 */ EMagicLeapMeshType MeshType;
    /* 0x0248 */ UBoxComponent* BoundingVolume;
    /* 0x0250 */ EMagicLeapMeshLOD LevelOfDetail;
    /* 0x0254 */ float PerimeterOfGapsToFill;
    /* 0x0258 */ bool Planarize;
    /* 0x025c */ float DisconnectedSectionArea;
    /* 0x0260 */ bool RequestNormals;
    /* 0x0261 */ bool RequestVertexConfidence;
    /* 0x0262 */ EMagicLeapMeshVertexColorMode VertexColorMode;
    /* 0x0268 */ TArray<FColor> BlockVertexColors;
    /* 0x0278 */ FLinearColor VertexColorFromConfidenceZero;
    /* 0x0288 */ FLinearColor VertexColorFromConfidenceOne;
    /* 0x0298 */ bool RemoveOverlappingTriangles;
    /* 0x02a0 */ UMRMeshComponent* MRMesh;
    /* 0x02a8 */ int32_t BricksPerFrame;

    void ConnectBlockSelector(TScriptInterface<IMagicLeapMeshBlockSelectorInterface> Selector);
    void ConnectMRMesh(UMRMeshComponent* InMRMeshPtr);
    void DisconnectBlockSelector();
    void DisconnectMRMesh(UMRMeshComponent* InMRMeshPtr);
    int32_t GetNumQueuedBlockUpdates();
    void OnMeshTrackerUpdated__DelegateSignature(FGuid ID, const TArray<FVector>& Vertices, const TArray<int32_t>& Triangles, const TArray<FVector>& Normals, const TArray<float>& Confidence);
    void SelectMeshBlocks(const FMagicLeapTrackingMeshInfo& NewMeshInfo, TArray<FMagicLeapMeshBlockRequest>& RequestedMesh);
};

// Size: 0x128
class UMagicLeapRaycastComponent : public UActorComponent {

    void RaycastResultDelegate__DelegateSignature(FMagicLeapRaycastHitResult HitResult);
    bool RequestRaycast(const FMagicLeapRaycastQueryParams& RequestParams, const FDelegate& ResultDelegate);
};

// Size: 0x30
class UMagicLeapRaycastFunctionLibrary : public UBlueprintFunctionLibrary {

    static FMagicLeapRaycastQueryParams MakeRaycastQueryParams(FVector Position, FVector Direction, FVector UpVector, int32_t Width, int32_t Height, float HorizontalFovDegrees, bool CollideWithUnobserved, int32_t UserData);
};

// Size: 0x24
struct FMagicLeapRaycastHitResult {
    /* 0x0000 */ EMagicLeapRaycastResultState HitState;
    /* 0x0004 */ FVector HitPoint;
    /* 0x0010 */ FVector Normal;
    /* 0x001c */ float Confidence;
    /* 0x0020 */ int32_t UserData;
};

// Size: 0x38
struct FMagicLeapRaycastQueryParams {
    /* 0x0000 */ FVector Position;
    /* 0x000c */ FVector Direction;
    /* 0x0018 */ FVector UpVector;
    /* 0x0024 */ int32_t Width;
    /* 0x0028 */ int32_t Height;
    /* 0x002c */ float HorizontalFovDegrees;
    /* 0x0030 */ bool CollideWithUnobserved;
    /* 0x0034 */ int32_t UserData;
};

// Size: 0x18
struct FMagicLeapResult {
    /* 0x0000 */ bool bSuccess;
    /* 0x0008 */ FString AdditionalInfo;
};

// Size: 0x38
class UMagicLeapSettings : public UObject {
    /* 0x0030 */ bool bEnableZI;
    /* 0x0031 */ bool bUseVulkanForZI;
    /* 0x0032 */ bool bUseMLAudioForZI;
};

// Size: 0x18
struct FMagicLeapTrackingMeshInfo {
    /* 0x0000 */ FTimespan Timestamp;
    /* 0x0008 */ TArray<FMagicLeapMeshBlockInfo> BlockData;
};

// Size: 0x50
struct FPurchaseConfirmation {
    /* 0x0010 */ FString PackageName;
    /* 0x0048 */ PurchaseType Type;
};

// Size: 0x40
struct FPurchaseItemDetails {
    /* 0x0010 */ FString Price;
    /* 0x0020 */ FString Name;
    /* 0x0030 */ PurchaseType Type;
};

enum class PurchaseType {
    Consumable = 0,
    Nonconsumable = 1,
    Undefined = 2,
    PurchaseType_MAX = 3,
};

enum class ELuminARLineTraceChannel {
    None = 0,
    FeaturePoint = 1,
    InfinitePlane = 2,
    PlaneUsingExtent = 4,
    PlaneUsingBoundaryPolygon = 8,
    FeaturePointWithSurfaceNormal = 16,
    ELuminARLineTraceChannel_MAX = 17,
};

enum class ELuminARTrackingState {
    Tracking = 0,
    NotTracking = 1,
    StoppedTracking = 2,
    ELuminARTrackingState_MAX = 3,
};

// Size: 0x68
class ULuminARCandidateImage : public UARCandidateImage {
    /* 0x0060 */ bool bUseUnreliablePose;
    /* 0x0061 */ bool bImageIsStationary;
    /* 0x0062 */ EMagicLeapImageTargetOrientation AxisOrientation;

    EMagicLeapImageTargetOrientation GetAxisOrientation() const;
    bool GetImageIsStationary() const;
    bool GetUseUnreliablePose() const;
};

// Size: 0x30
class ULuminARFrameFunctionLibrary : public UBlueprintFunctionLibrary {

    static ELuminARTrackingState GetTrackingState();
    static bool LuminARLineTrace(UObject* WorldContextObject, const FVector2D& ScreenPosition, TSet<ELuminARLineTraceChannel> TraceChannels, TArray<FARTraceResult>& OutHitResults);
};

// Size: 0x30
class ULuminARImageTrackingFunctionLibrary : public UBlueprintFunctionLibrary {

    static ULuminARCandidateImage* AddLuminRuntimeCandidateImage(UARSessionConfig* SessionConfig, UTexture2D* CandidateTexture, FString FriendlyName, float PhysicalWidth, bool bUseUnreliablePose, bool bImageIsStationary);
    static ULuminARCandidateImage* AddLuminRuntimeCandidateImageEx(UARSessionConfig* SessionConfig, UTexture2D* CandidateTexture, FString FriendlyName, float PhysicalWidth, bool bUseUnreliablePose, bool bImageIsStationary, EMagicLeapImageTargetOrientation InAxisOrientation);
};

// Size: 0x58
class ULuminARLightEstimate : public UARBasicLightEstimate {
    /* 0x0048 */ TArray<float> AmbientIntensityNits;

    TArray<float> GetAmbientIntensityNits() const;
};

// Size: 0x3b8
class ALuminAROrigin : public AAROriginActor {
    /* 0x02f8 */ UMRMeshComponent* MRMeshComponent;
    /* 0x0300 */ UMaterialInterface* PlaneSurfaceMaterial;
    /* 0x0308 */ UMaterialInterface* WireframeMaterial;
};

// Size: 0x1b0
class ULuminARSessionConfig : public UARSessionConfig {
    /* 0x0120 */ FMagicLeapPlanesQuery PlanesQuery;
    /* 0x0180 */ int32_t MaxPlaneQueryResults;
    /* 0x0184 */ int32_t MinPlaneArea;
    /* 0x0188 */ bool bArbitraryOrientationPlaneDetection;
    /* 0x018c */ FVector PlaneSearchExtents;
    /* 0x0198 */ TArray<EMagicLeapPlaneQueryFlags> PlaneQueryFlags;
    /* 0x01a8 */ bool bDiscardZeroExtentPlanes;
    /* 0x01a9 */ bool bDefaultUseUnreliablePose;
};

// Size: 0x30
class ULuminARSessionFunctionLibrary : public UBlueprintFunctionLibrary {

    static void StartLuminARSession(UObject* WorldContextObject, FLatentActionInfo LatentInfo, ULuminARSessionConfig* Configuration);
};

enum class EMagicLeapARPinType {
    SingleUserSingleSession = 0,
    SingleUserMultiSession = 1,
    MultiUserMultiSession = 2,
    EMagicLeapARPinType_MAX = 3,
};

enum class EMagicLeapAutoPinType {
    OnlyOnDataRestoration = 0,
    Always = 1,
    Never = 2,
    EMagicLeapAutoPinType_MAX = 3,
};

enum class EMagicLeapPassableWorldError {
    None = 0,
    LowMapQuality = 1,
    UnableToLocalize = 2,
    Unavailable = 3,
    PrivilegeDenied = 4,
    InvalidParam = 5,
    UnspecifiedFailure = 6,
    PrivilegeRequestPending = 7,
    StartupPending = 8,
    SharedWorldNotEnabled = 9,
    NotImplemented = 10,
    PinNotFound = 11,
    EMagicLeapPassableWorldError_MAX = 12,
};

// Size: 0x3e0
class UMagicLeapARPinComponent : public USceneComponent {
    /* 0x0228 */ FString ObjectUID;
    /* 0x0238 */ int32_t UserIndex;
    /* 0x023c */ EMagicLeapAutoPinType AutoPinType;
    /* 0x023d */ bool bShouldPinActor;
    /* 0x0240 */ UClass* PinDataClass;
    /* 0x0248 */ TSet<EMagicLeapARPinType> SearchPinTypes;
    /* 0x0298 */ USphereComponent* SearchVolume;
    /* 0x02a0 */ FMulticastInlineDelegate OnPersistentEntityPinned;
    /* 0x02b0 */ FMulticastInlineDelegate OnPersistentEntityPinLost;
    /* 0x02c0 */ FMulticastInlineDelegate OnPinDataLoadAttemptCompleted;
    /* 0x02d0 */ FGuid PinnedCFUID;
    /* 0x02e0 */ USceneComponent* PinnedSceneComponent;
    /* 0x02e8 */ UMagicLeapARPinSaveGame* PinData;

    bool AttemptPinDataRestoration();
    void AttemptPinDataRestorationAsync();
    UMagicLeapARPinSaveGame* GetPinData(UClass* PinDataClass);
    bool GetPinState(FMagicLeapARPinState& State) const;
    bool GetPinnedPinID(FGuid& PinId) const;
    bool IsPinned() const;
    void MagicLeapARPinDataLoadAttemptCompleted__DelegateSignature(bool bDataRestored);
    void PersistentEntityPinLost__DelegateSignature();
    void PersistentEntityPinned__DelegateSignature(bool bRestoredOrSynced);
    bool PinActor(AActor* ActorToPin);
    bool PinRestoredOrSynced() const;
    bool PinSceneComponent(USceneComponent* ComponentToPin);
    void PinToBestFit();
    bool PinToID(const FGuid& PinId);
    bool PinToRestoredOrSyncedID();
    UMagicLeapARPinSaveGame* TryGetPinData(UClass* InPinDataClass, bool& OutPinDataValid);
    void UnPin();
};

// Size: 0x80
class UMagicLeapARPinContentBindings : public USaveGame {
    /* 0x0030 */ TMap<FGuid, FMagicLeapARPinObjectIdList> AllContentBindings;
};

// Size: 0x30
class UMagicLeapARPinFunctionLibrary : public UBlueprintFunctionLibrary {

    static FString ARPinIdToString(const FGuid& ARPinId);
    static void BindToOnMagicLeapARPinUpdatedDelegate(const FDelegate& delegate);
    static void BindToOnMagicLeapContentBindingFoundDelegate(const FDelegate& delegate);
    static EMagicLeapPassableWorldError CreateTracker();
    static EMagicLeapPassableWorldError DestroyTracker();
    static bool GetARPinPositionAndOrientation(const FGuid& PinId, FVector& Position, FRotator& Orientation, bool& PinFoundInEnvironment);
    static bool GetARPinPositionAndOrientation_TrackingSpace(const FGuid& PinId, FVector& Position, FRotator& Orientation, bool& PinFoundInEnvironment);
    static EMagicLeapPassableWorldError GetARPinState(const FGuid& PinId, FMagicLeapARPinState& State);
    static FString GetARPinStateToString(const FMagicLeapARPinState& State);
    static EMagicLeapPassableWorldError GetAvailableARPins(int32_t NumRequested, TArray<FGuid>& Pins);
    static EMagicLeapPassableWorldError GetClosestARPin(const FVector& SearchPoint, FGuid& PinId);
    static int32_t GetContentBindingSaveGameUserIndex();
    static EMagicLeapPassableWorldError GetGlobalQueryFilter(FMagicLeapARPinQuery& CurrentGlobalFilter);
    static EMagicLeapPassableWorldError GetNumAvailableARPins(int32_t& Count);
    static bool IsTrackerValid();
    static bool ParseStringToARPinId(FString PinIdString, FGuid& ARPinId);
    static EMagicLeapPassableWorldError QueryARPins(const FMagicLeapARPinQuery& Query, TArray<FGuid>& Pins);
    static void SetContentBindingSaveGameUserIndex(int32_t UserIndex);
    static EMagicLeapPassableWorldError SetGlobalQueryFilter(const FMagicLeapARPinQuery& InGlobalFilter);
    static void UnBindToOnMagicLeapARPinUpdatedDelegate(const FDelegate& delegate);
    static void UnBindToOnMagicLeapContentBindingFoundDelegate(const FDelegate& delegate);
};

// Size: 0x310
class AMagicLeapARPinInfoActorBase : public AActor {
    /* 0x02f8 */ FGuid PinId;
    /* 0x0308 */ bool bVisibilityOverride;

    void OnUpdateARPinState();
};

// Size: 0x50
struct FMagicLeapARPinObjectIdList {
    /* 0x0000 */ TSet<FString> ObjectIdList;
};

// Size: 0x68
struct FMagicLeapARPinQuery {
    /* 0x0000 */ TSet<EMagicLeapARPinType> Types;
    /* 0x0050 */ int32_t MaxResults;
    /* 0x0054 */ FVector TargetPoint;
    /* 0x0060 */ float Radius;
    /* 0x0064 */ bool bSorted;
};

// Size: 0x360
class AMagicLeapARPinRenderer : public AActor {
    /* 0x02f8 */ bool bInfoActorsVisibilityOverride;
    /* 0x0300 */ TMap<FGuid, AMagicLeapARPinInfoActorBase*> AllInfoActors;
    /* 0x0358 */ UClass* ClassToSpawn;

    void SetVisibilityOverride(const bool InVisibilityOverride);
};

// Size: 0xb0
class UMagicLeapARPinSaveGame : public USaveGame {
    /* 0x0030 */ FGuid PinnedID;
    /* 0x0040 */ FTransform ComponentWorldTransform;
    /* 0x0070 */ FTransform PinTransform;
    /* 0x00a0 */ bool bShouldPinActor;
};

// Size: 0x48
class UMagicLeapARPinSettings : public UObject {
    /* 0x0030 */ float UpdateCheckFrequency;
    /* 0x0034 */ FMagicLeapARPinState OnUpdatedEventTriggerDelta;
};

// Size: 0x14
struct FMagicLeapARPinState {
    /* 0x0000 */ float Confidence;
    /* 0x0004 */ float ValidRadius;
    /* 0x0008 */ float RotationError;
    /* 0x000c */ float TranslationError;
    /* 0x0010 */ EMagicLeapARPinType PinType;
};

// Size: 0x1
struct FMagicLeapAudioDummyStruct {
};

// Size: 0x30
class UMagicLeapAudioFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool IsMicMuted();
    static bool SetMicMute(bool IsMuted);
    static bool SetOnAudioJackPluggedDelegate(const FDelegate& ResultDelegate);
    static bool SetOnAudioJackUnpluggedDelegate(const FDelegate& ResultDelegate);
};

enum class EMagicLeapControllerHapticIntensity {
    Low = 0,
    Medium = 1,
    High = 2,
    EMagicLeapControllerHapticIntensity_MAX = 3,
};

enum class EMagicLeapControllerHapticPattern {
    None = 0,
    Click = 1,
    Bump = 2,
    DoubleClick = 3,
    Buzz = 4,
    Tick = 5,
    ForceDown = 6,
    ForceUp = 7,
    ForceDwell = 8,
    SecondForceDown = 9,
    EMagicLeapControllerHapticPattern_MAX = 10,
};

enum class EMagicLeapControllerLEDColor {
    BrightMissionRed = 0,
    PastelMissionRed = 1,
    BrightFloridaOrange = 2,
    PastelFloridaOrange = 3,
    BrightLunaYellow = 4,
    PastelLunaYellow = 5,
    BrightNebulaPink = 6,
    PastelNebulaPink = 7,
    BrightCosmicPurple = 8,
    PastelCosmicPurple = 9,
    BrightMysticBlue = 10,
    PastelMysticBlue = 11,
    BrightCelestialBlue = 12,
    PastelCelestialBlue = 13,
    BrightShaggleGreen = 14,
    PastelShaggleGreen = 15,
    EMagicLeapControllerLEDColor_MAX = 16,
};

enum class EMagicLeapControllerLEDEffect {
    RotateCW = 0,
    RotateCCW = 1,
    Pulse = 2,
    PaintCW = 3,
    PaintCCW = 4,
    Blink = 5,
    EMagicLeapControllerLEDEffect_MAX = 6,
};

enum class EMagicLeapControllerLEDPattern {
    None = 0,
    Clock01 = 1,
    Clock02 = 2,
    Clock03 = 3,
    Clock04 = 4,
    Clock05 = 5,
    Clock06 = 6,
    Clock07 = 7,
    Clock08 = 8,
    Clock09 = 9,
    Clock10 = 10,
    Clock11 = 11,
    Clock12 = 12,
    Clock01_07 = 13,
    Clock02_08 = 14,
    Clock03_09 = 15,
    Clock04_10 = 16,
    Clock05_11 = 17,
    Clock06_12 = 18,
    EMagicLeapControllerLEDPattern_MAX = 19,
};

enum class EMagicLeapControllerLEDSpeed {
    Slow = 0,
    Medium = 1,
    Fast = 2,
    EMagicLeapControllerLEDSpeed_MAX = 3,
};

enum class EMagicLeapControllerTrackingMode {
    InputService = 0,
    CoordinateFrameUID = 1,
    EMagicLeapControllerTrackingMode_MAX = 2,
};

enum class EMagicLeapControllerType {
    None = 0,
    Device = 1,
    MobileApp = 2,
    EMagicLeapControllerType_MAX = 3,
};

enum class EMagicLeapTouchpadGestureDirection {
    None = 0,
    Up = 1,
    Down = 2,
    Left = 3,
    Right = 4,
    In = 5,
    Out = 6,
    Clockwise = 7,
    CounterClockwise = 8,
    EMagicLeapTouchpadGestureDirection_MAX = 9,
};

enum class EMagicLeapTouchpadGestureType {
    None = 0,
    Tap = 1,
    ForceTapDown = 2,
    ForceTapUp = 3,
    ForceDwell = 4,
    SecondForceDown = 5,
    LongHold = 6,
    RadialScroll = 7,
    Swipe = 8,
    Scroll = 9,
    Pinch = 10,
    EMagicLeapTouchpadGestureType_MAX = 11,
};

// Size: 0x30
class UMagicLeapControllerFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool GetControllerMapping(int32_t ControllerIndex, EControllerHand& hand);
    static EMagicLeapControllerTrackingMode GetControllerTrackingMode();
    static EMagicLeapControllerType GetControllerType(FName MotionSource);
    static EControllerHand GetHandForMotionSource(FName MotionSource);
    static EMagicLeapControllerType GetMLControllerType(EControllerHand hand);
    static FName GetMotionSourceForHand(EControllerHand hand);
    static void InvertControllerMapping();
    static bool IsMLControllerConnected(FName MotionSource);
    static int32_t MaxSupportedMagicLeapControllers();
    static bool PlayControllerHapticFeedback(EControllerHand hand, EMagicLeapControllerHapticPattern HapticPattern, EMagicLeapControllerHapticIntensity Intensity);
    static bool PlayControllerLED(EControllerHand hand, EMagicLeapControllerLEDPattern LEDPattern, EMagicLeapControllerLEDColor LEDColor, float DurationInSec);
    static bool PlayControllerLEDEffect(EControllerHand hand, EMagicLeapControllerLEDEffect LEDEffect, EMagicLeapControllerLEDSpeed LEDSpeed, EMagicLeapControllerLEDPattern LEDPattern, EMagicLeapControllerLEDColor LEDColor, float DurationInSec);
    static bool PlayHapticPattern(FName MotionSource, EMagicLeapControllerHapticPattern HapticPattern, EMagicLeapControllerHapticIntensity Intensity);
    static bool PlayLEDEffect(FName MotionSource, EMagicLeapControllerLEDEffect LEDEffect, EMagicLeapControllerLEDSpeed LEDSpeed, EMagicLeapControllerLEDPattern LEDPattern, EMagicLeapControllerLEDColor LEDColor, float DurationInSec);
    static bool PlayLEDPattern(FName MotionSource, EMagicLeapControllerLEDPattern LEDPattern, EMagicLeapControllerLEDColor LEDColor, float DurationInSec);
    static bool SetControllerTrackingMode(EMagicLeapControllerTrackingMode TrackingMode);
    static bool SetMotionSourceForHand(EControllerHand hand, FName MotionSource);
};

// Size: 0x34
struct FMagicLeapTouchpadGesture {
    /* 0x0000 */ EControllerHand hand;
    /* 0x0004 */ FName MotionSource;
    /* 0x0010 */ EMagicLeapTouchpadGestureType Type;
    /* 0x0011 */ EMagicLeapTouchpadGestureDirection Direction;
    /* 0x0014 */ FVector PositionAndForce;
    /* 0x0020 */ float Speed;
    /* 0x0024 */ float Distance;
    /* 0x0028 */ float FingerGap;
    /* 0x002c */ float Radius;
    /* 0x0030 */ float Angle;
};

// Size: 0x150
class UMagicLeapTouchpadGesturesComponent : public UActorComponent {
    /* 0x00c8 */ FMulticastInlineDelegate OnTouchpadGestureStart;
    /* 0x00d8 */ FMulticastInlineDelegate OnTouchpadGestureContinue;
    /* 0x00e8 */ FMulticastInlineDelegate OnTouchpadGestureEnd;

    void TouchpadGestureEvent__DelegateSignature(const FMagicLeapTouchpadGesture& GestureData);
};

enum class EMagicLeapEyeTrackingCalibrationStatus {
    None = 0,
    Bad = 1,
    Good = 2,
    EMagicLeapEyeTrackingCalibrationStatus_MAX = 3,
};

enum class EMagicLeapEyeTrackingStatus {
    NotConnected = 0,
    Disabled = 1,
    UserNotPresent = 2,
    UserPresent = 3,
    UserPresentAndWatchingWindow = 4,
    EMagicLeapEyeTrackingStatus_MAX = 5,
};

// Size: 0x2
struct FMagicLeapEyeBlinkState {
    /* 0x0000 */ bool LeftEyeBlinked;
    /* 0x0001 */ bool RightEyeBlinked;
};

// Size: 0x30
class UMagicLeapEyeTrackerFunctionLibrary : public UBlueprintFunctionLibrary {

    static EMagicLeapEyeTrackingCalibrationStatus GetCalibrationStatus();
    static bool GetEyeBlinkState(FMagicLeapEyeBlinkState& BlinkState);
};

// Size: 0x18
struct FMagicLeapHandMesh {
    /* 0x0000 */ int32_t Version;
    /* 0x0004 */ int32_t DataCount;
    /* 0x0008 */ TArray<FMagicLeapHandMeshBlock> Data;
};

// Size: 0x28
struct FMagicLeapHandMeshBlock {
    /* 0x0000 */ int32_t IndexCount;
    /* 0x0004 */ int32_t VertexCount;
    /* 0x0008 */ TArray<FVector> Vertex;
    /* 0x0018 */ TArray<int32_t> index;
};

// Size: 0xc0
class UMagicLeapHandMeshingComponent : public UActorComponent {

    bool ConnectMRMesh(UMRMeshComponent* InMRMeshPtr);
    bool DisconnectMRMesh(UMRMeshComponent* InMRMeshPtr);
    void SetUseWeightedNormals(const bool bInUseWeightedNormals);
};

// Size: 0x30
class UMagicLeapHandMeshingFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool ConnectMRMesh(UMRMeshComponent* InMRMeshPtr);
    static bool CreateClient();
    static bool DestroyClient();
    static bool DisconnectMRMesh(UMRMeshComponent* InMRMeshPtr);
};

enum class EMagicLeapGestureTransformSpace {
    World = 0,
    Hand = 1,
    Tracking = 2,
    EMagicLeapGestureTransformSpace_MAX = 3,
};

enum class EMagicLeapHandTrackingGesture {
    Finger = 0,
    Fist = 1,
    Pinch = 2,
    Thumb = 3,
    L = 4,
    OpenHand = 5,
    OpenHandBack = 5,
    Ok = 6,
    C = 7,
    NoPose = 8,
    NoHand = 9,
    EMagicLeapHandTrackingGesture_MAX = 10,
};

enum class EMagicLeapHandTrackingGestureFilterLevel {
    NoFilter = 0,
    SlightRobustnessToFlicker = 1,
    MoreRobustnessToFlicker = 2,
    EMagicLeapHandTrackingGestureFilterLevel_MAX = 3,
};

enum class EMagicLeapHandTrackingKeypoint {
    Thumb_Tip = 0,
    Thumb_IP = 1,
    Thumb_MCP = 2,
    Thumb_CMC = 3,
    Index_Tip = 4,
    Index_DIP = 5,
    Index_PIP = 6,
    Index_MCP = 7,
    Middle_Tip = 8,
    Middle_DIP = 9,
    Middle_PIP = 10,
    Middle_MCP = 11,
    Ring_Tip = 12,
    Ring_DIP = 13,
    Ring_PIP = 14,
    Ring_MCP = 15,
    Pinky_Tip = 16,
    Pinky_DIP = 17,
    Pinky_PIP = 18,
    Pinky_MCP = 19,
    Wrist_Center = 20,
    Wrist_Ulnar = 21,
    Wrist_Radial = 22,
    Hand_Center = 23,
    EMagicLeapHandTrackingKeypoint_MAX = 24,
};

enum class EMagicLeapHandTrackingKeypointFilterLevel {
    NoFilter = 0,
    SimpleSmoothing = 1,
    PredictiveSmoothing = 2,
    EMagicLeapHandTrackingKeypointFilterLevel_MAX = 3,
};

// Size: 0x30
class ULiveLinkMagicLeapHandTrackingSourceFactory : public ULiveLinkSourceFactory {
};

// Size: 0x30
class UMagicLeapHandTrackingFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool GetConfiguration(TArray<EMagicLeapHandTrackingGesture>& ActiveStaticGestures, EMagicLeapHandTrackingKeypointFilterLevel& KeypointsFilterLevel, EMagicLeapHandTrackingGestureFilterLevel& GestureFilterLevel, bool& bTrackingEnabled);
    static bool GetCurrentGesture(EControllerHand hand, EMagicLeapHandTrackingGesture& Gesture);
    static bool GetCurrentGestureConfidence(EControllerHand hand, float& Confidence);
    static bool GetGestureKeypointTransform(EControllerHand hand, EMagicLeapHandTrackingKeypoint Keypoint, EMagicLeapGestureTransformSpace TransformSpace, FTransform& Transform);
    static bool GetGestureKeypoints(EControllerHand hand, TArray<FTransform>& Keypoints);
    static bool GetHandCenter(EControllerHand hand, FTransform& HandCenter);
    static bool GetHandCenterNormalized(EControllerHand hand, FVector& HandCenterNormalized);
    static bool GetHandIndexFingerTip(EControllerHand hand, EMagicLeapGestureTransformSpace TransformSpace, FTransform& Pointer);
    static bool GetHandKeypointForMotionSource(FName MotionSource, EMagicLeapHandTrackingKeypoint& OutKeyPoint);
    static bool GetHandThumbTip(EControllerHand hand, EMagicLeapGestureTransformSpace TransformSpace, FTransform& Secondary);
    static bool GetMagicLeapHandTrackingLiveLinkSource(FLiveLinkSourceHandle& SourceHandle);
    static bool GetMotionSourceForHandKeypoint(EControllerHand hand, EMagicLeapHandTrackingKeypoint Keypoint, FName& OutMotionSource);
    static float GetStaticGestureConfidenceThreshold(EMagicLeapHandTrackingGesture Gesture);
    static bool IsHoldingControl(EControllerHand hand);
    static bool SetConfiguration(const TArray<EMagicLeapHandTrackingGesture>& StaticGesturesToActivate, EMagicLeapHandTrackingKeypointFilterLevel KeypointsFilterLevel, EMagicLeapHandTrackingGestureFilterLevel GestureFilterLevel, bool bTrackingEnabled);
    static void SetStaticGestureConfidenceThreshold(EMagicLeapHandTrackingGesture Gesture, float Confidence);
};

enum class EMagicLeapIdentityError {
    Ok = 0,
    InvalidParam = 1,
    AllocFailed = 2,
    PrivilegeDenied = 3,
    FailedToConnectToLocalService = 4,
    FailedToConnectToCloudService = 5,
    CloudAuthentication = 6,
    InvalidInformationFromCloud = 7,
    NotLoggedIn = 8,
    ExpiredCredentials = 9,
    FailedToGetUserProfile = 10,
    Unauthorized = 11,
    CertificateError = 12,
    RejectedByCloud = 13,
    AlreadyLoggedIn = 14,
    ModifyIsNotSupported = 15,
    NetworkError = 16,
    UnspecifiedFailure = 17,
    EMagicLeapIdentityError_MAX = 18,
};

enum class EMagicLeapIdentityKey {
    GivenName = 0,
    FamilyName = 1,
    Email = 2,
    Bio = 3,
    PhoneNumber = 4,
    Avatar2D = 5,
    Avatar3D = 6,
    Unknown = 7,
    EMagicLeapIdentityKey_MAX = 8,
};

// Size: 0x40
class UMagicLeapIdentity : public UObject {

    void AvailableIdentityAttributesDelegate__DelegateSignature(EMagicLeapIdentityError ResultCode, const TArray<EMagicLeapIdentityKey>& AvailableAttributes);
    EMagicLeapIdentityError GetAllAvailableAttributes(TArray<EMagicLeapIdentityKey>& AvailableAttributes);
    void GetAllAvailableAttributesAsync(const FDelegate& ResultDelegate);
    void ModifyIdentityAttributeValueDelegate__DelegateSignature(EMagicLeapIdentityError ResultCode, const TArray<EMagicLeapIdentityKey>& AttributesUpdatedSuccessfully);
    EMagicLeapIdentityError RequestAttributeValue(const TArray<EMagicLeapIdentityKey>& RequestedAttributeList, TArray<FMagicLeapIdentityAttribute>& RequestedAttributeValues);
    EMagicLeapIdentityError RequestAttributeValueAsync(const TArray<EMagicLeapIdentityKey>& RequestedAttributeList, const FDelegate& ResultDelegate);
    void RequestIdentityAttributeValueDelegate__DelegateSignature(EMagicLeapIdentityError ResultCode, const TArray<FMagicLeapIdentityAttribute>& AttributeValue);
};

// Size: 0x18
struct FMagicLeapIdentityAttribute {
    /* 0x0000 */ EMagicLeapIdentityKey Attribute;
    /* 0x0008 */ FString Value;
};

enum class EMagicLeapImageTargetOrientation {
    ForwardAxisAsNormal = 0,
    UpAxisAsNormal = 1,
    EMagicLeapImageTargetOrientation_MAX = 2,
};

enum class EMagicLeapImageTargetStatus {
    Tracked = 0,
    Unreliable = 1,
    NotTracked = 2,
    EMagicLeapImageTargetStatus_MAX = 3,
};

// Size: 0x20
struct FMagicLeapImageTargetSettings {
    /* 0x0000 */ UTexture2D* ImageTexture;
    /* 0x0008 */ FString Name;
    /* 0x0018 */ float LongerDimension;
    /* 0x001c */ bool bIsStationary;
    /* 0x001d */ bool bIsEnabled;
};

// Size: 0x1c
struct FMagicLeapImageTargetState {
    /* 0x0000 */ EMagicLeapImageTargetStatus TrackingStatus;
    /* 0x0004 */ FVector Location;
    /* 0x0010 */ FRotator Rotation;
};

// Size: 0x2b0
class UMagicLeapImageTrackerComponent : public USceneComponent {
    /* 0x0228 */ UTexture2D* TargetImageTexture;
    /* 0x0230 */ FString Name;
    /* 0x0240 */ float LongerDimension;
    /* 0x0244 */ bool bIsStationary;
    /* 0x0245 */ bool bUseUnreliablePose;
    /* 0x0246 */ EMagicLeapImageTargetOrientation AxisOrientation;
    /* 0x0248 */ FMulticastInlineDelegate OnSetImageTargetSucceeded;
    /* 0x0258 */ FMulticastInlineDelegate OnSetImageTargetFailed;
    /* 0x0268 */ FMulticastInlineDelegate OnImageTargetFound;
    /* 0x0278 */ FMulticastInlineDelegate OnImageTargetLost;
    /* 0x0288 */ FMulticastInlineDelegate OnImageTargetUnreliableTracking;

    bool RemoveTargetAsync();
    bool SetTargetAsync(UTexture2D* ImageTarget);
};

// Size: 0x30
class UMagicLeapImageTrackerFunctionLibrary : public UBlueprintFunctionLibrary {

    static void EnableImageTracking(bool bEnable);
    static int32_t GetMaxSimultaneousTargets();
    static bool IsImageTrackingEnabled();
    static void SetMaxSimultaneousTargets(int32_t MaxSimultaneousTargets);
};

enum class EMagicLeapLightEstimationCamera {
    Left = 0,
    Right = 1,
    FarLeft = 2,
    FarRight = 3,
    EMagicLeapLightEstimationCamera_MAX = 4,
};

// Size: 0x18
struct FMagicLeapLightEstimationAmbientGlobalState {
    /* 0x0000 */ TArray<float> AmbientIntensityNits;
    /* 0x0010 */ FTimespan Timestamp;
};

// Size: 0x20
struct FMagicLeapLightEstimationColorTemperatureState {
    /* 0x0000 */ float ColorTemperatureKelvin;
    /* 0x0004 */ FLinearColor AmbientColor;
    /* 0x0018 */ FTimespan Timestamp;
};

// Size: 0x30
class UMagicLeapLightEstimationFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool CreateTracker();
    static void DestroyTracker();
    static bool GetAmbientGlobalState(FMagicLeapLightEstimationAmbientGlobalState& GlobalAmbientState);
    static bool GetColorTemperatureState(FMagicLeapLightEstimationColorTemperatureState& ColorTemperatureState);
    static bool IsTrackerValid();
};

// Size: 0xd0
class UMagicLeapLightingTrackingComponent : public UActorComponent {
    /* 0x00c0 */ bool UseGlobalAmbience;
    /* 0x00c1 */ bool UseColorTemp;
};

// Size: 0x88
class UMagicLeapFileMediaSourceFactory : public UFactory {
};

enum class EMagicLeapPlaneQueryFlags {
    Vertical = 0,
    Horizontal = 1,
    Arbitrary = 2,
    OrientToGravity = 3,
    PreferInner = 4,
    Ceiling = 5,
    Floor = 6,
    Wall = 7,
    Polygons = 8,
    EMagicLeapPlaneQueryFlags_MAX = 9,
};

enum class EMagicLeapPlaneQueryType {
    Bulk = 0,
    Delta = 1,
    EMagicLeapPlaneQueryType_MAX = 2,
};

// Size: 0x20
struct FMagicLeapPlaneBoundaries {
    /* 0x0000 */ FGuid ID;
    /* 0x0010 */ TArray<FMagicLeapPlaneBoundary> Boundaries;
};

// Size: 0x20
struct FMagicLeapPlaneBoundary {
    /* 0x0000 */ FMagicLeapPolygon Polygon;
    /* 0x0010 */ TArray<FMagicLeapPolygon> Holes;
};

// Size: 0x60
struct FMagicLeapPlaneResult {
    /* 0x0000 */ FVector PlanePosition;
    /* 0x000c */ FRotator PlaneOrientation;
    /* 0x0018 */ FRotator ContentOrientation;
    /* 0x0024 */ FVector2D PlaneDimensions;
    /* 0x0030 */ TArray<EMagicLeapPlaneQueryFlags> PlaneFlags;
    /* 0x0040 */ FGuid ID;
    /* 0x0050 */ FGuid InnerID;
};

// Size: 0x290
class UMagicLeapPlanesComponent : public USceneComponent {
    /* 0x0228 */ TArray<EMagicLeapPlaneQueryFlags> QueryFlags;
    /* 0x0238 */ UBoxComponent* SearchVolume;
    /* 0x0240 */ int32_t MaxResults;
    /* 0x0244 */ float MinHolePerimeter;
    /* 0x0248 */ float MinPlaneArea;
    /* 0x024c */ EMagicLeapPlaneQueryType QueryType;
    /* 0x0250 */ float SimilarityThreshold;
    /* 0x0258 */ FMulticastInlineDelegate OnPlanesQueryResult;
    /* 0x0268 */ FMulticastInlineDelegate OnPersistentPlanesQueryResult;

    bool RequestPlanesAsync();
};

// Size: 0x30
class UMagicLeapPlanesFunctionLibrary : public UBlueprintFunctionLibrary {

    static FGuid AddPersistentQuery(EMagicLeapPlaneQueryType PersistentQueryType);
    static bool CreateTracker();
    static bool DestroyTracker();
    static FTransform GetContentScale(const AActor* ContentActor, const FMagicLeapPlaneResult& PlaneResult);
    static bool IsTrackerValid();
    static bool PlanesPersistentQueryBeginAsync(const FMagicLeapPlanesQuery& Query, const FGuid& Handle, const FDelegate& ResultDelegate);
    static bool PlanesQueryBeginAsync(const FMagicLeapPlanesQuery& Query, const FDelegate& ResultDelegate);
    static void RemoveFlagsNotInQuery(const TArray<EMagicLeapPlaneQueryFlags>& InQueryFlags, const TArray<EMagicLeapPlaneQueryFlags>& InResultFlags, TArray<EMagicLeapPlaneQueryFlags>& OutFlags);
    static bool RemovePersistentQuery(FGuid Handle);
    static void ReorderPlaneFlags(const TArray<EMagicLeapPlaneQueryFlags>& InPriority, const TArray<EMagicLeapPlaneQueryFlags>& InFlagsToReorder, TArray<EMagicLeapPlaneQueryFlags>& OutReorderedFlags);
};

// Size: 0x60
struct FMagicLeapPlanesQuery {
    /* 0x0000 */ TArray<EMagicLeapPlaneQueryFlags> Flags;
    /* 0x0010 */ UBoxComponent* SearchVolume;
    /* 0x0018 */ int32_t MaxResults;
    /* 0x001c */ float MinHoleLength;
    /* 0x0020 */ float MinPlaneArea;
    /* 0x0024 */ FVector SearchVolumePosition;
    /* 0x0030 */ FQuat SearchVolumeOrientation;
    /* 0x0040 */ FVector SearchVolumeExtents;
    /* 0x004c */ float SimilarityThreshold;
    /* 0x0050 */ bool bSearchVolumeTrackingSpace;
    /* 0x0051 */ bool bResultTrackingSpace;
};

// Size: 0x10
struct FMagicLeapPolygon {
    /* 0x0000 */ TArray<FVector> Vertices;
};

enum class EMagicLeapPrivilege {
    Invalid = 0,
    BatteryInfo = 1,
    CameraCapture = 2,
    ComputerVision = 3,
    WorldReconstruction = 4,
    InAppPurchase = 5,
    AudioCaptureMic = 6,
    DrmCertificates = 7,
    Occlusion = 8,
    LowLatencyLightwear = 9,
    Internet = 10,
    IdentityRead = 11,
    BackgroundDownload = 12,
    BackgroundUpload = 13,
    MediaDrm = 14,
    Media = 15,
    MediaMetadata = 16,
    PowerInfo = 17,
    LocalAreaNetwork = 18,
    VoiceInput = 19,
    Documents = 20,
    ConnectBackgroundMusicService = 21,
    RegisterBackgroundMusicService = 22,
    PcfRead = 23,
    PwFoundObjRead = 23,
    NormalNotificationsUsage = 24,
    MusicService = 25,
    ControllerPose = 26,
    GesturesSubscribe = 27,
    GesturesConfig = 28,
    AddressBookRead = 29,
    AddressBookWrite = 30,
    AddressBookBasicAccess = 31,
    CoarseLocation = 32,
    FineLocation = 33,
    HandMesh = 34,
    WifiStatusRead = 35,
    SocialConnectionsInvitesAccess = 36,
    SecureBrowserWindow = 37,
    EMagicLeapPrivilege_MAX = 38,
};

// Size: 0x30
class UMagicLeapPrivilegesFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool CheckPrivilege(EMagicLeapPrivilege Privilege);
    static bool RequestPrivilege(EMagicLeapPrivilege Privilege);
    static bool RequestPrivilegeAsync(EMagicLeapPrivilege Privilege, const FDelegate& ResultDelegate);
};

// Size: 0x30
class UMagicLeapSecureStorage : public UBlueprintFunctionLibrary {

    static bool DeleteSecureData(FString Key);
    static bool GetSecureArray(FString Key, TArray<int32_t>& DataToRetrieve);
    static bool GetSecureBool(FString Key, bool& DataToRetrieve);
    static bool GetSecureByte(FString Key, uint8_t& DataToRetrieve);
    static bool GetSecureFloat(FString Key, float& DataToRetrieve);
    static bool GetSecureInt(FString Key, int32_t& DataToRetrieve);
    static bool GetSecureInt64(FString Key, int64_t& DataToRetrieve);
    static bool GetSecureRotator(FString Key, FRotator& DataToRetrieve);
    static bool GetSecureSaveGame(FString Key, USaveGame*& ObjectToRetrieve);
    static bool GetSecureString(FString Key, FString& DataToRetrieve);
    static bool GetSecureTransform(FString Key, FTransform& DataToRetrieve);
    static bool GetSecureVector(FString Key, FVector& DataToRetrieve);
    static bool PutSecureArray(FString Key, const TArray<int32_t>& DataToStore);
    static bool PutSecureBool(FString Key, bool DataToStore);
    static bool PutSecureByte(FString Key, uint8_t DataToStore);
    static bool PutSecureFloat(FString Key, float DataToStore);
    static bool PutSecureInt(FString Key, int32_t DataToStore);
    static bool PutSecureInt64(FString Key, int64_t DataToStore);
    static bool PutSecureRotator(FString Key, const FRotator& DataToStore);
    static bool PutSecureSaveGame(FString Key, USaveGame* ObjectToStore);
    static bool PutSecureString(FString Key, FString DataToStore);
    static bool PutSecureTransform(FString Key, const FTransform& DataToStore);
    static bool PutSecureVector(FString Key, const FVector& DataToStore);
};

// Size: 0x10
struct FMagicLeapSharedWorldAlignmentTransforms {
    /* 0x0000 */ TArray<FTransform> AlignmentTransforms;
};

// Size: 0x4c0
class AMagicLeapSharedWorldGameMode : public AGameMode {
    /* 0x03f0 */ FMagicLeapSharedWorldSharedData SharedWorldData;
    /* 0x0400 */ FMulticastInlineDelegate OnNewLocalDataFromClients;
    /* 0x0410 */ float PinSelectionConfidenceThreshold;
    /* 0x04b8 */ AMagicLeapSharedWorldPlayerController* ChosenOne;

    void DetermineSharedWorldData(FMagicLeapSharedWorldSharedData& NewSharedWorldData);
    void MagicLeapOnNewLocalDataFromClients__DelegateSignature();
    void SelectChosenOne();
    bool SendSharedWorldDataToClients();
};

// Size: 0x3b8
class AMagicLeapSharedWorldGameState : public AGameState {
    /* 0x0378 */ FMagicLeapSharedWorldSharedData SharedWorldData;
    /* 0x0388 */ FMagicLeapSharedWorldAlignmentTransforms AlignmentTransforms;
    /* 0x0398 */ FMulticastInlineDelegate OnSharedWorldDataUpdated;
    /* 0x03a8 */ FMulticastInlineDelegate OnAlignmentTransformsUpdated;

    FTransform CalculateXRCameraRootTransform() const;
    void MagicLeapSharedWorldEvent__DelegateSignature();
    void OnReplicate_AlignmentTransforms();
    void OnReplicate_SharedWorldData();
};

// Size: 0x10
struct FMagicLeapSharedWorldLocalData {
    /* 0x0000 */ TArray<FMagicLeapSharedWorldPinData> LocalPins;
};

// Size: 0x24
struct FMagicLeapSharedWorldPinData {
    /* 0x0000 */ FGuid PinId;
    /* 0x0010 */ FMagicLeapARPinState PinState;
};

// Size: 0x678
class AMagicLeapSharedWorldPlayerController : public APlayerController {

    bool CanSendLocalDataToServer() const;
    void ClientMarkReadyForSendingLocalData();
    void ClientSetChosenOne(bool bChosenOne);
    bool IsChosenOne() const;
    void ServerSetAlignmentTransforms(const FMagicLeapSharedWorldAlignmentTransforms InAlignmentTransforms);
    void ServerSetLocalWorldData(const FMagicLeapSharedWorldLocalData LocalWorldReplicationData);
};

// Size: 0x10
struct FMagicLeapSharedWorldSharedData {
    /* 0x0000 */ TArray<FGuid> PinIDs;
};

// Size: 0x30
class UAssetBakeOptions : public UObject {
};

enum class EMaterialBakeMethod {
    IndividualMaterial = 0,
    AtlasMaterial = 1,
    BinnedMaterial = 2,
    EMaterialBakeMethod_MAX = 3,
};

// Size: 0x38
class UMaterialMergeOptions : public UObject {
    /* 0x0030 */ EMaterialBakeMethod Method;
    /* 0x0031 */ uint8_t BlendMode;
};

// Size: 0x60
class UMaterialOptions : public UObject {
    /* 0x0030 */ TArray<FPropertyEntry> Properties;
    /* 0x0040 */ FIntPoint TextureSize;
    /* 0x0048 */ TArray<int32_t> LODIndices;
    /* 0x0058 */ bool bUseMeshData;
    /* 0x0059 */ bool bUseSpecificUVIndex;
    /* 0x005c */ int32_t TextureCoordinateIndex;
};

// Size: 0x14
struct FPropertyEntry {
    /* 0x0000 */ uint8_t Property;
    /* 0x0001 */ bool bUseCustomSize;
    /* 0x0004 */ FIntPoint CustomSize;
    /* 0x000c */ bool bUseConstantValue;
    /* 0x0010 */ float ConstantValue;
};

// Size: 0x30
class UMaterialEditingLibrary : public UBlueprintFunctionLibrary {

    static void ClearAllMaterialInstanceParameters(UMaterialInstanceConstant* Instance);
    static bool ConnectMaterialExpressions(UMaterialExpression* FromExpression, FString FromOutputName, UMaterialExpression* ToExpression, FString ToInputName);
    static bool ConnectMaterialProperty(UMaterialExpression* FromExpression, FString FromOutputName, uint8_t Property);
    static UMaterialExpression* CreateMaterialExpression(UMaterial* Material, UClass* ExpressionClass, int32_t NodePosX, int32_t NodePosY);
    static UMaterialExpression* CreateMaterialExpressionInFunction(UMaterialFunction* MaterialFunction, UClass* ExpressionClass, int32_t NodePosX, int32_t NodePosY);
    static void DeleteAllMaterialExpressions(UMaterial* Material);
    static void DeleteAllMaterialExpressionsInFunction(UMaterialFunction* MaterialFunction);
    static void DeleteMaterialExpression(UMaterial* Material, UMaterialExpression* Expression);
    static void DeleteMaterialExpressionInFunction(UMaterialFunction* MaterialFunction, UMaterialExpression* Expression);
    static void GetChildInstances(UMaterialInterface* Parent, TArray<FAssetData>& ChildInstances);
    static TArray<UMaterialExpression*> GetInputsForMaterialExpression(UMaterial* Material, UMaterialExpression* MaterialExpression);
    static float GetMaterialDefaultScalarParameterValue(UMaterial* Material, FName ParameterName);
    static bool GetMaterialDefaultStaticSwitchParameterValue(UMaterial* Material, FName ParameterName);
    static UTexture* GetMaterialDefaultTextureParameterValue(UMaterial* Material, FName ParameterName);
    static FLinearColor GetMaterialDefaultVectorParameterValue(UMaterial* Material, FName ParameterName);
    static float GetMaterialInstanceScalarParameterValue(UMaterialInstanceConstant* Instance, FName ParameterName);
    static bool GetMaterialInstanceStaticSwitchParameterValue(UMaterialInstanceConstant* Instance, FName ParameterName);
    static UTexture* GetMaterialInstanceTextureParameterValue(UMaterialInstanceConstant* Instance, FName ParameterName);
    static FLinearColor GetMaterialInstanceVectorParameterValue(UMaterialInstanceConstant* Instance, FName ParameterName);
    static UMaterialExpression* GetMaterialPropertyInputNode(UMaterial* Material, uint8_t Property);
    static TSet<UObject*> GetMaterialSelectedNodes(UMaterial* Material);
    static int32_t GetNumMaterialExpressions(const UMaterial* Material);
    static int32_t GetNumMaterialExpressionsInFunction(const UMaterialFunction* MaterialFunction);
    static void GetScalarParameterNames(UMaterialInterface* Material, TArray<FName>& ParameterNames);
    static bool GetScalarParameterSource(UMaterialInterface* Material, const FName ParameterName, FSoftObjectPath& ParameterSource);
    static void GetStaticSwitchParameterNames(UMaterialInterface* Material, TArray<FName>& ParameterNames);
    static bool GetStaticSwitchParameterSource(UMaterialInterface* Material, const FName ParameterName, FSoftObjectPath& ParameterSource);
    static FMaterialStatistics GetStatistics(UMaterialInterface* Material);
    static void GetTextureParameterNames(UMaterialInterface* Material, TArray<FName>& ParameterNames);
    static bool GetTextureParameterSource(UMaterialInterface* Material, const FName ParameterName, FSoftObjectPath& ParameterSource);
    static TArray<UTexture*> GetUsedTextures(UMaterial* Material);
    static void GetVectorParameterNames(UMaterialInterface* Material, TArray<FName>& ParameterNames);
    static bool GetVectorParameterSource(UMaterialInterface* Material, const FName ParameterName, FSoftObjectPath& ParameterSource);
    static bool HasMaterialUsage(UMaterial* Material, uint8_t Usage);
    static void LayoutMaterialExpressions(UMaterial* Material);
    static void LayoutMaterialFunctionExpressions(UMaterialFunction* MaterialFunction);
    static void RecompileMaterial(UMaterial* Material);
    static void SetMaterialInstanceParent(UMaterialInstanceConstant* Instance, UMaterialInterface* NewParent);
    static bool SetMaterialInstanceScalarParameterValue(UMaterialInstanceConstant* Instance, FName ParameterName, float Value);
    static bool SetMaterialInstanceTextureParameterValue(UMaterialInstanceConstant* Instance, FName ParameterName, UTexture* Value);
    static bool SetMaterialInstanceVectorParameterValue(UMaterialInstanceConstant* Instance, FName ParameterName, FLinearColor Value);
    static bool SetMaterialUsage(UMaterial* Material, uint8_t Usage, bool& bNeedsRecompile);
    static void UpdateMaterialFunction(UMaterialFunctionInterface* MaterialFunction, UMaterial* PreviewMaterial);
    static void UpdateMaterialInstance(UMaterialInstanceConstant* Instance);
};

// Size: 0x40
class UMaterialEditorMenuContext : public UObject {
};

// Size: 0x48
class UMaterialEditorSettings : public UObject {
    /* 0x0030 */ FFilePath MaliOfflineCompilerPath;
    /* 0x0040 */ int32_t DefaultPreviewWidth;
    /* 0x0044 */ int32_t DefaultPreviewHeight;
};

// Size: 0x20
struct FMaterialStatistics {
    /* 0x0000 */ int32_t NumVertexShaderInstructions;
    /* 0x0004 */ int32_t NumPixelShaderInstructions;
    /* 0x0008 */ int32_t NumSamplers;
    /* 0x000c */ int32_t NumVertexTextureSamples;
    /* 0x0010 */ int32_t NumPixelTextureSamples;
    /* 0x0014 */ int32_t NumVirtualTextureSamples;
    /* 0x0018 */ int32_t NumUVScalars;
    /* 0x001c */ int32_t NumInterpolatorScalars;
};

// Size: 0xa0
struct FSortedParamData {
    /* 0x0008 */ UDEditorParameterValue* Parameter;
};

// Size: 0x60
struct FUnsortedParamData {
    /* 0x0000 */ UDEditorParameterValue* Parameter;
};

enum class EMobileShadowQuality {
    NoFiltering = 0,
    PCF_1x1 = 1,
    PCF_2x2 = 2,
    PCF_3x3 = 3,
    EMobileShadowQuality_MAX = 4,
};

// Size: 0x9
struct FMaterialQualityOverrides {
    /* 0x0000 */ bool bDiscardQualityDuringCook;
    /* 0x0001 */ bool bEnableOverride;
    /* 0x0002 */ bool bForceFullyRough;
    /* 0x0003 */ bool bForceNonMetal;
    /* 0x0004 */ bool bForceDisableLMDirectionality;
    /* 0x0005 */ bool bForceLQReflections;
    /* 0x0006 */ bool bForceDisablePreintegratedGF;
    /* 0x0007 */ bool bDisableMaterialNormalCalculation;
    /* 0x0008 */ EMobileShadowQuality MobileShadowQuality;
};

// Size: 0x98
class UMaterialShaderQualitySettings : public UObject {
    /* 0x0030 */ TMap<FName, UShaderPlatformQualitySettings*> ForwardSettingMap;
};

// Size: 0x68
class UShaderPlatformQualitySettings : public UObject {
    /* 0x0030 */ FMaterialQualityOverrides QualityOverrides[4];
};

enum class EFlattenMaterialProperties {
    Diffuse = 0,
    Metallic = 1,
    Specular = 2,
    Roughness = 3,
    Anisotropy = 4,
    Normal = 5,
    Tangent = 6,
    Opacity = 7,
    Emissive = 8,
    SubSurface = 9,
    OpacityMask = 10,
    AmbientOcclusion = 16,
    NumFlattenMaterialProperties = 17,
    EFlattenMaterialProperties_MAX = 18,
};

// Size: 0x138
class UBaseMediaSource : public UMediaSource {
    /* 0x0088 */ TMap<FString, FName> PlatformPlayerNames;
    /* 0x0128 */ FName PlayerName;
};

enum class EMediaAudioCaptureDeviceFilter {
    None = 0,
    Card = 1,
    Microphone = 2,
    Software = 4,
    Unknown = 8,
    EMediaAudioCaptureDeviceFilter_MAX = 9,
};

enum class EMediaPlayerTrack {
    Audio = 0,
    Caption = 1,
    Metadata = 2,
    Script = 3,
    Subtitle = 4,
    Text = 5,
    Video = 6,
    EMediaPlayerTrack_MAX = 7,
};

enum class EMediaSoundChannels {
    Mono = 0,
    Stereo = 1,
    Surround = 2,
    EMediaSoundChannels_MAX = 3,
};

enum class EMediaSoundComponentFFTSize {
    Min_64 = 0,
    Small_256 = 1,
    Medium_512 = 2,
    Large_1024 = 3,
    EMediaSoundComponentFFTSize_MAX = 4,
};

enum class EMediaVideoCaptureDeviceFilter {
    None = 0,
    Card = 1,
    Software = 2,
    Unknown = 4,
    Webcam = 8,
    EMediaVideoCaptureDeviceFilter_MAX = 9,
};

enum class EMediaWebcamCaptureDeviceFilter {
    None = 0,
    DepthSensor = 1,
    Front = 2,
    Rear = 4,
    Unknown = 8,
    EMediaWebcamCaptureDeviceFilter_MAX = 9,
};

// Size: 0x160
class UFileMediaSource : public UBaseMediaSource {
    /* 0x0138 */ FString FilePath;
    /* 0x0148 */ bool PrecacheFile;

    void SetFilePath(FString Path);
};

// Size: 0x30
class UMediaBlueprintFunctionLibrary : public UBlueprintFunctionLibrary {

    static void EnumerateAudioCaptureDevices(TArray<FMediaCaptureDevice>& OutDevices, int32_t Filter);
    static void EnumerateVideoCaptureDevices(TArray<FMediaCaptureDevice>& OutDevices, int32_t Filter);
    static void EnumerateWebcamCaptureDevices(TArray<FMediaCaptureDevice>& OutDevices, int32_t Filter);
};

// Size: 0x28
struct FMediaCaptureDevice {
    /* 0x0000 */ FText DisplayName;
    /* 0x0018 */ FString URL;
};

// Size: 0xd0
class UMediaComponent : public UActorComponent {
    /* 0x00c0 */ UMediaTexture* MediaTexture;
    /* 0x00c8 */ UMediaPlayer* MediaPlayer;

    UMediaPlayer* GetMediaPlayer() const;
    UMediaTexture* GetMediaTexture() const;
};

// Size: 0x140
class UMediaPlayer : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnEndReached;
    /* 0x0040 */ FMulticastInlineDelegate OnMediaClosed;
    /* 0x0050 */ FMulticastInlineDelegate OnMediaOpened;
    /* 0x0060 */ FMulticastInlineDelegate OnMediaOpenFailed;
    /* 0x0070 */ FMulticastInlineDelegate OnPlaybackResumed;
    /* 0x0080 */ FMulticastInlineDelegate OnPlaybackSuspended;
    /* 0x0090 */ FMulticastInlineDelegate OnSeekCompleted;
    /* 0x00a0 */ FMulticastInlineDelegate OnTracksChanged;
    /* 0x00b0 */ FTimespan CacheAhead;
    /* 0x00b8 */ FTimespan CacheBehind;
    /* 0x00c0 */ FTimespan CacheBehindGame;
    /* 0x00c8 */ bool NativeAudioOut;
    /* 0x00c9 */ bool PlayOnOpen;
    /* 0x00cc */ bool Shuffle;
    /* 0x00cc */ bool loop;
    /* 0x00d0 */ UMediaPlaylist* Playlist;
    /* 0x00d8 */ int32_t PlaylistIndex;
    /* 0x00e0 */ FTimespan TimeDelay;
    /* 0x00e8 */ float HorizontalFieldOfView;
    /* 0x00ec */ float VerticalFieldOfView;
    /* 0x00f0 */ FRotator ViewRotation;
    /* 0x0128 */ FGuid PlayerGuid;
    /* 0x013a */ bool AffectedByPIEHandling;

    bool CanPause() const;
    bool CanPlaySource(UMediaSource* MediaSource);
    bool CanPlayUrl(FString URL);
    void Close();
    int32_t GetAudioTrackChannels(int32_t TrackIndex, int32_t FormatIndex) const;
    int32_t GetAudioTrackSampleRate(int32_t TrackIndex, int32_t FormatIndex) const;
    FString GetAudioTrackType(int32_t TrackIndex, int32_t FormatIndex) const;
    FName GetDesiredPlayerName() const;
    FTimespan GetDuration() const;
    float GetHorizontalFieldOfView() const;
    FText GetMediaName() const;
    int32_t GetNumTrackFormats(EMediaPlayerTrack TrackType, int32_t TrackIndex) const;
    int32_t GetNumTracks(EMediaPlayerTrack TrackType) const;
    FName GetPlayerName() const;
    UMediaPlaylist* GetPlaylist() const;
    int32_t GetPlaylistIndex() const;
    float GetRate() const;
    int32_t GetSelectedTrack(EMediaPlayerTrack TrackType) const;
    void GetSupportedRates(TArray<FFloatRange>& OutRates, bool Unthinned) const;
    FTimespan GetTime() const;
    FTimespan GetTimeDelay() const;
    UMediaTimeStampInfo* GetTimeStamp() const;
    FText GetTrackDisplayName(EMediaPlayerTrack TrackType, int32_t TrackIndex) const;
    int32_t GetTrackFormat(EMediaPlayerTrack TrackType, int32_t TrackIndex) const;
    FString GetTrackLanguage(EMediaPlayerTrack TrackType, int32_t TrackIndex) const;
    FString GetUrl() const;
    float GetVerticalFieldOfView() const;
    float GetVideoTrackAspectRatio(int32_t TrackIndex, int32_t FormatIndex) const;
    FIntPoint GetVideoTrackDimensions(int32_t TrackIndex, int32_t FormatIndex) const;
    float GetVideoTrackFrameRate(int32_t TrackIndex, int32_t FormatIndex) const;
    FFloatRange GetVideoTrackFrameRates(int32_t TrackIndex, int32_t FormatIndex) const;
    FString GetVideoTrackType(int32_t TrackIndex, int32_t FormatIndex) const;
    FRotator GetViewRotation() const;
    bool HasError() const;
    bool IsBuffering() const;
    bool IsClosed() const;
    bool IsConnecting() const;
    bool IsLooping() const;
    bool IsPaused() const;
    bool IsPlaying() const;
    bool IsPreparing() const;
    bool IsReady() const;
    bool Next();
    bool OpenFile(FString FilePath);
    bool OpenPlaylist(UMediaPlaylist* InPlaylist);
    bool OpenPlaylistIndex(UMediaPlaylist* InPlaylist, int32_t index);
    bool OpenSource(UMediaSource* MediaSource);
    void OpenSourceLatent(const UObject* WorldContextObject, FLatentActionInfo LatentInfo, UMediaSource* MediaSource, const FMediaPlayerOptions& Options, bool& bSuccess);
    bool OpenSourceWithOptions(UMediaSource* MediaSource, const FMediaPlayerOptions& Options);
    bool OpenUrl(FString URL);
    bool Pause();
    bool Play();
    void PlayAndSeek();
    bool Previous();
    bool Reopen();
    bool Rewind();
    bool Seek(const FTimespan& Time);
    bool SelectTrack(EMediaPlayerTrack TrackType, int32_t TrackIndex);
    void SetBlockOnTime(const FTimespan& Time);
    void SetDesiredPlayerName(FName PlayerName);
    bool SetLooping(bool Looping);
    void SetMediaOptions(const UMediaSource* Options);
    bool SetNativeVolume(float Volume);
    bool SetRate(float Rate);
    void SetTimeDelay(FTimespan TimeDelay);
    bool SetTrackFormat(EMediaPlayerTrack TrackType, int32_t TrackIndex, int32_t FormatIndex);
    bool SetVideoTrackFrameRate(int32_t TrackIndex, int32_t FormatIndex, float FrameRate);
    bool SetViewField(float Horizontal, float Vertical, bool Absolute);
    bool SetViewRotation(const FRotator& Rotation, bool Absolute);
    bool SupportsRate(float Rate, bool Unthinned) const;
    bool SupportsScrubbing() const;
    bool SupportsSeeking() const;
};

// Size: 0x40
class UMediaPlaylist : public UObject {
    /* 0x0030 */ TArray<UMediaSource*> Items;

    bool Add(UMediaSource* MediaSource);
    bool AddFile(FString FilePath);
    bool AddUrl(FString URL);
    UMediaSource* Get(int32_t index);
    UMediaSource* GetNext(int32_t& InOutIndex);
    UMediaSource* GetPrevious(int32_t& InOutIndex);
    UMediaSource* GetRandom(int32_t& OutIndex);
    void Insert(UMediaSource* MediaSource, int32_t index);
    int32_t Num();
    bool Remove(UMediaSource* MediaSource);
    bool RemoveAt(int32_t index);
    bool Replace(int32_t index, UMediaSource* Replacement);
};

// Size: 0x880
class UMediaSoundComponent : public USynthComponent {
    /* 0x0720 */ EMediaSoundChannels Channels;
    /* 0x0724 */ bool DynamicRateAdjustment;
    /* 0x0728 */ float RateAdjustmentFactor;
    /* 0x072c */ FFloatRange RateAdjustmentRange;
    /* 0x0740 */ UMediaPlayer* MediaPlayer;

    bool BP_GetAttenuationSettingsToApply(FSoundAttenuationSettings& OutAttenuationSettings);
    float GetEnvelopeValue() const;
    UMediaPlayer* GetMediaPlayer() const;
    TArray<FMediaSoundComponentSpectralData> GetNormalizedSpectralData();
    TArray<FMediaSoundComponentSpectralData> GetSpectralData();
    void SetEnableEnvelopeFollowing(bool bInEnvelopeFollowing);
    void SetEnableSpectralAnalysis(bool bInSpectralAnalysisEnabled);
    void SetEnvelopeFollowingsettings(int32_t AttackTimeMsec, int32_t ReleaseTimeMsec);
    void SetMediaPlayer(UMediaPlayer* NewMediaPlayer);
    void SetSpectralAnalysisSettings(TArray<float> InFrequenciesToAnalyze, EMediaSoundComponentFFTSize InFFTSize);
};

// Size: 0x8
struct FMediaSoundComponentSpectralData {
    /* 0x0000 */ float FrequencyHz;
    /* 0x0004 */ float Magnitude;
};

// Size: 0x88
class UMediaSource : public UObject {

    FString GetUrl() const;
    void SetMediaOptionBool(const FName& Key, bool Value);
    void SetMediaOptionFloat(const FName& Key, float Value);
    void SetMediaOptionInt64(const FName& Key, int64_t Value);
    void SetMediaOptionString(const FName& Key, FString Value);
    bool Validate() const;
};

// Size: 0x480
class UMediaTexture : public UTexture {
    /* 0x0398 */ uint8_t AddressX;
    /* 0x0399 */ uint8_t AddressY;
    /* 0x039a */ bool AutoClear;
    /* 0x039c */ FLinearColor ClearColor;
    /* 0x03ac */ bool EnableGenMips;
    /* 0x03ad */ uint8_t NumMips;
    /* 0x03ae */ bool NewStyleOutput;
    /* 0x03af */ uint8_t OutputFormat;
    /* 0x03b0 */ float CurrentAspectRatio;
    /* 0x03b4 */ uint8_t CurrentOrientation;
    /* 0x03b8 */ UMediaPlayer* MediaPlayer;

    float GetAspectRatio() const;
    int32_t GetHeight() const;
    UMediaPlayer* GetMediaPlayer() const;
    int32_t GetTextureNumMips() const;
    int32_t GetWidth() const;
    void SetMediaPlayer(UMediaPlayer* NewMediaPlayer);
};

enum class MediaTextureOrientation {
    MTORI_Original = 0,
    MTORI_CW90 = 1,
    MTORI_CW180 = 2,
    MTORI_CW270 = 3,
    MTORI_MAX = 4,
};

enum class MediaTextureOutputFormat {
    MTOF_Default = 0,
    MTOF_SRGB_LINOUT = 1,
    MTOF_MAX = 2,
};

// Size: 0x40
class UMediaTimeStampInfo : public UObject {
    /* 0x0030 */ FTimespan Time;
    /* 0x0038 */ int64_t SequenceIndex;
};

// Size: 0x130
class UPlatformMediaSource : public UMediaSource {
    /* 0x0088 */ TMap<FString, UMediaSource*> PlatformMediaSources;
    /* 0x0128 */ UMediaSource* MediaSource;
};

// Size: 0x148
class UStreamMediaSource : public UBaseMediaSource {
    /* 0x0138 */ FString StreamUrl;
};

// Size: 0x148
class UTimeSynchronizableMediaSource : public UBaseMediaSource {
    /* 0x0138 */ bool bUseTimeSynchronization;
    /* 0x013c */ int32_t FrameDelay;
    /* 0x0140 */ double TimeDelay;
};

// Size: 0x138
class UMovieSceneMediaPlayerPropertySection : public UMovieSceneSection {
    /* 0x0128 */ UMediaSource* MediaSource;
    /* 0x0130 */ bool bLoop;
};

// Size: 0x50
struct FMovieSceneMediaPlayerPropertySectionTemplate : public FMovieScenePropertySectionTemplate {
    /* 0x0040 */ UMediaSource* MediaSource;
    /* 0x0048 */ FFrameNumber SectionStartFrame;
    /* 0x004c */ bool bLoop;
};

// Size: 0x140
class UMovieSceneMediaPlayerPropertyTrack : public UMovieScenePropertyTrack {
};

// Size: 0x160
class UMovieSceneMediaSection : public UMovieSceneSection {
    /* 0x0128 */ UMediaSource* MediaSource;
    /* 0x0130 */ bool bLooping;
    /* 0x0134 */ FFrameNumber StartFrameOffset;
    /* 0x0138 */ UMediaTexture* MediaTexture;
    /* 0x0140 */ UMediaSoundComponent* MediaSoundComponent;
    /* 0x0148 */ bool bUseExternalMediaPlayer;
    /* 0x0150 */ UMediaPlayer* ExternalMediaPlayer;
    /* 0x0158 */ float ThumbnailReferenceOffset;
};

// Size: 0x30
struct FMovieSceneMediaSectionParams {
    /* 0x0000 */ UMediaSoundComponent* MediaSoundComponent;
    /* 0x0008 */ UMediaSource* MediaSource;
    /* 0x0010 */ UMediaTexture* MediaTexture;
    /* 0x0018 */ UMediaPlayer* MediaPlayer;
    /* 0x0020 */ FFrameNumber SectionStartFrame;
    /* 0x0024 */ FFrameNumber SectionEndFrame;
    /* 0x0028 */ bool bLooping;
    /* 0x002c */ FFrameNumber StartFrameOffset;
};

// Size: 0x50
struct FMovieSceneMediaSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneMediaSectionParams Params;
};

// Size: 0xf0
class UMovieSceneMediaTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> MediaSections;
};

enum class EMediaPlayerRecordingImageFormat {
    PNG = 0,
    JPEG = 1,
    BMP = 2,
    EXR = 3,
    EMediaPlayerRecordingImageFormat_MAX = 4,
};

enum class EMediaPlayerRecordingNumerationStyle {
    AppendFrameNumber = 0,
    AppendSampleTime = 1,
    EMediaPlayerRecordingNumerationStyle_MAX = 2,
};

// Size: 0x70
class UMediaPlayerRecording : public USequenceRecordingBase {
    /* 0x0030 */ FMediaPlayerRecordingSettings RecordingSettings;
    /* 0x0058 */ TWeakObjectPtr<UMediaPlayer> MediaPlayerToRecord;
};

// Size: 0x28
struct FMediaPlayerRecordingSettings {
    /* 0x0000 */ bool bActive;
    /* 0x0001 */ bool bRecordMediaFrame;
    /* 0x0008 */ FString BaseFilename;
    /* 0x0018 */ EMediaPlayerRecordingNumerationStyle NumerationStyle;
    /* 0x0019 */ EMediaPlayerRecordingImageFormat ImageFormat;
    /* 0x001c */ int32_t CompressionQuality;
    /* 0x0020 */ bool bResetAlpha;
};

// Size: 0x48
class UMediaSequenceRecorderSettings : public UObject {
    /* 0x0030 */ bool bRecordMediaPlayerEnabled;
    /* 0x0038 */ FString MediaPlayerSubDirectory;
};

enum class EMediaPlayerEditorScale {
    Fill = 0,
    Fit = 1,
    Original = 2,
    EMediaPlayerEditorScale_MAX = 3,
};

// Size: 0x88
class UFileMediaSourceFactoryNew : public UFactory {
};

// Size: 0x58
class UMediaPlayerEditorMediaContext : public UToolMenuContextBase {
    /* 0x0030 */ UObject* SelectedAsset;
    /* 0x0038 */ FName StyleSetName;
};

// Size: 0x40
class UMediaPlayerEditorSettings : public UObject {
    /* 0x0030 */ FName DesiredPlayerName;
    /* 0x003c */ bool ShowTextOverlays;
    /* 0x003d */ EMediaPlayerEditorScale ViewportScale;
};

// Size: 0x90
class UMediaPlayerFactoryNew : public UFactory {
};

// Size: 0x88
class UMediaPlaylistFactoryNew : public UFactory {
};

// Size: 0x88
class UMediaTextureFactoryNew : public UFactory {
};

// Size: 0x88
class UPlatformMediaSourceFactoryNew : public UFactory {
};

// Size: 0x88
class UStreamMediaSourceFactoryNew : public UFactory {
};

enum class EMediaPlayerOptionBooleanOverride {
    UseMediaPlayerSetting = 0,
    Enabled = 1,
    Disabled = 2,
    EMediaPlayerOptionBooleanOverride_MAX = 3,
};

// Size: 0x30
struct FMediaPlayerOptions {
    /* 0x0000 */ FMediaPlayerTrackOptions Tracks;
    /* 0x0020 */ FTimespan SeekTime;
    /* 0x0028 */ EMediaPlayerOptionBooleanOverride PlayOnOpen;
    /* 0x0029 */ EMediaPlayerOptionBooleanOverride loop;
};

// Size: 0x1c
struct FMediaPlayerTrackOptions {
    /* 0x0000 */ int32_t Audio;
    /* 0x0004 */ int32_t Caption;
    /* 0x0008 */ int32_t MetaData;
    /* 0x000c */ int32_t Script;
    /* 0x0010 */ int32_t Subtitle;
    /* 0x0014 */ int32_t text;
    /* 0x0018 */ int32_t Video;
};

// Size: 0x48
class UMeshInstancingSettingsObject : public UObject {
    /* 0x0030 */ FMeshInstancingSettings Settings;
};

// Size: 0xe0
class UMeshMergingSettingsObject : public UObject {
    /* 0x0030 */ FMeshMergingSettings Settings;
};

// Size: 0xe8
class UMeshProxySettingsObject : public UObject {
    /* 0x0030 */ FMeshProxySettings Settings;
};

enum class EComputeNTBsOptions {
    None = 0,
    Normals = 1,
    Tangents = 2,
    WeightedNTBs = 4,
    EComputeNTBsOptions_MAX = 5,
};

// Size: 0x4
struct FEdgeID : public FElementID {
};

// Size: 0x4
struct FElementID {
    /* 0x0000 */ int32_t IDValue;
};

// Size: 0x30
class UMeshDescription : public UObject {
};

// Size: 0x398
class UMeshDescriptionBase : public UObject {

    void ComputePolygonTriangulation(FPolygonID PolygonID);
    FEdgeID CreateEdge(FVertexID VertexID0, FVertexID VertexID1);
    void CreateEdgeWithID(FEdgeID EdgeID, FVertexID VertexID0, FVertexID VertexID1);
    FPolygonID CreatePolygon(FPolygonGroupID PolygonGroupID, TArray<FVertexInstanceID>& VertexInstanceIDs, TArray<FEdgeID>& NewEdgeIDs);
    FPolygonGroupID CreatePolygonGroup();
    void CreatePolygonGroupWithID(FPolygonGroupID PolygonGroupID);
    void CreatePolygonWithID(FPolygonID PolygonID, FPolygonGroupID PolygonGroupID, TArray<FVertexInstanceID>& VertexInstanceIDs, TArray<FEdgeID>& NewEdgeIDs);
    FTriangleID CreateTriangle(FPolygonGroupID PolygonGroupID, const TArray<FVertexInstanceID>& VertexInstanceIDs, TArray<FEdgeID>& NewEdgeIDs);
    void CreateTriangleWithID(FTriangleID TriangleID, FPolygonGroupID PolygonGroupID, const TArray<FVertexInstanceID>& VertexInstanceIDs, TArray<FEdgeID>& NewEdgeIDs);
    FVertexID CreateVertex();
    FVertexInstanceID CreateVertexInstance(FVertexID VertexID);
    void CreateVertexInstanceWithID(FVertexInstanceID VertexInstanceID, FVertexID VertexID);
    void CreateVertexWithID(FVertexID VertexID);
    void DeleteEdge(FEdgeID EdgeID, TArray<FVertexID>& OrphanedVertices);
    void DeletePolygon(FPolygonID PolygonID, TArray<FEdgeID>& OrphanedEdges, TArray<FVertexInstanceID>& OrphanedVertexInstances, TArray<FPolygonGroupID>& OrphanedPolygonGroups);
    void DeletePolygonGroup(FPolygonGroupID PolygonGroupID);
    void DeleteTriangle(FTriangleID TriangleID, TArray<FEdgeID>& OrphanedEdges, TArray<FVertexInstanceID>& OrphanedVertexInstances, TArray<FPolygonGroupID>& OrphanedPolygonGroupsPtr);
    void DeleteVertex(FVertexID VertexID);
    void DeleteVertexInstance(FVertexInstanceID VertexInstanceID, TArray<FVertexID>& OrphanedVertices);
    void Empty();
    void GetEdgeConnectedPolygons(FEdgeID EdgeID, TArray<FPolygonID>& OutConnectedPolygonIDs) const;
    void GetEdgeConnectedTriangles(FEdgeID EdgeID, TArray<FTriangleID>& OutConnectedTriangleIDs) const;
    FVertexID GetEdgeVertex(FEdgeID EdgeID, int32_t VertexNumber) const;
    void GetEdgeVertices(const FEdgeID EdgeID, TArray<FVertexID>& OutVertexIDs) const;
    int32_t GetNumEdgeConnectedPolygons(FEdgeID EdgeID) const;
    int32_t GetNumEdgeConnectedTriangles(FEdgeID EdgeID) const;
    int32_t GetNumPolygonGroupPolygons(FPolygonGroupID PolygonGroupID) const;
    int32_t GetNumPolygonInternalEdges(FPolygonID PolygonID) const;
    int32_t GetNumPolygonTriangles(FPolygonID PolygonID) const;
    int32_t GetNumPolygonVertices(FPolygonID PolygonID) const;
    int32_t GetNumVertexConnectedEdges(FVertexID VertexID) const;
    int32_t GetNumVertexConnectedPolygons(FVertexID VertexID) const;
    int32_t GetNumVertexConnectedTriangles(FVertexID VertexID) const;
    int32_t GetNumVertexInstanceConnectedPolygons(FVertexInstanceID VertexInstanceID) const;
    int32_t GetNumVertexInstanceConnectedTriangles(FVertexInstanceID VertexInstanceID) const;
    int32_t GetNumVertexVertexInstances(FVertexID VertexID) const;
    void GetPolygonAdjacentPolygons(FPolygonID PolygonID, TArray<FPolygonID>& OutPolygonIDs) const;
    void GetPolygonGroupPolygons(FPolygonGroupID PolygonGroupID, TArray<FPolygonID>& OutPolygonIDs) const;
    void GetPolygonInternalEdges(FPolygonID PolygonID, TArray<FEdgeID>& OutEdgeIDs) const;
    void GetPolygonPerimeterEdges(FPolygonID PolygonID, TArray<FEdgeID>& OutEdgeIDs) const;
    FPolygonGroupID GetPolygonPolygonGroup(FPolygonID PolygonID) const;
    void GetPolygonTriangles(FPolygonID PolygonID, TArray<FTriangleID>& OutTriangleIDs) const;
    void GetPolygonVertexInstances(FPolygonID PolygonID, TArray<FVertexInstanceID>& OutVertexInstanceIDs) const;
    void GetPolygonVertices(FPolygonID PolygonID, TArray<FVertexID>& OutVertexIDs) const;
    void GetTriangleAdjacentTriangles(FTriangleID TriangleID, TArray<FTriangleID>& OutTriangleIDs) const;
    void GetTriangleEdges(FTriangleID TriangleID, TArray<FEdgeID>& OutEdgeIDs) const;
    FPolygonID GetTrianglePolygon(FTriangleID TriangleID) const;
    FPolygonGroupID GetTrianglePolygonGroup(FTriangleID TriangleID) const;
    FVertexInstanceID GetTriangleVertexInstance(FTriangleID TriangleID, int32_t index) const;
    void GetTriangleVertexInstances(FTriangleID TriangleID, TArray<FVertexInstanceID>& OutVertexInstanceIDs) const;
    void GetTriangleVertices(FTriangleID TriangleID, TArray<FVertexID>& OutVertexIDs) const;
    void GetVertexAdjacentVertices(FVertexID VertexID, TArray<FVertexID>& OutAdjacentVertexIDs) const;
    void GetVertexConnectedEdges(FVertexID VertexID, TArray<FEdgeID>& OutEdgeIDs) const;
    void GetVertexConnectedPolygons(FVertexID VertexID, TArray<FPolygonID>& OutConnectedPolygonIDs) const;
    void GetVertexConnectedTriangles(FVertexID VertexID, TArray<FTriangleID>& OutConnectedTriangleIDs) const;
    void GetVertexInstanceConnectedPolygons(FVertexInstanceID VertexInstanceID, TArray<FPolygonID>& OutConnectedPolygonIDs) const;
    void GetVertexInstanceConnectedTriangles(FVertexInstanceID VertexInstanceID, TArray<FTriangleID>& OutConnectedTriangleIDs) const;
    FVertexInstanceID GetVertexInstanceForPolygonVertex(FPolygonID PolygonID, FVertexID VertexID) const;
    FVertexInstanceID GetVertexInstanceForTriangleVertex(FTriangleID TriangleID, FVertexID VertexID) const;
    FEdgeID GetVertexInstancePairEdge(FVertexInstanceID VertexInstanceID0, FVertexInstanceID VertexInstanceID1) const;
    FVertexID GetVertexInstanceVertex(FVertexInstanceID VertexInstanceID) const;
    FEdgeID GetVertexPairEdge(FVertexID VertexID0, FVertexID VertexID1) const;
    FVector GetVertexPosition(FVertexID VertexID) const;
    void GetVertexVertexInstances(FVertexID VertexID, TArray<FVertexInstanceID>& OutVertexInstanceIDs) const;
    bool IsEdgeInternal(FEdgeID EdgeID) const;
    bool IsEdgeInternalToPolygon(FEdgeID EdgeID, FPolygonID PolygonID) const;
    bool IsEdgeValid(FEdgeID EdgeID) const;
    bool IsEmpty() const;
    bool IsPolygonGroupValid(FPolygonGroupID PolygonGroupID) const;
    bool IsPolygonValid(FPolygonID PolygonID) const;
    bool IsTrianglePartOfNgon(FTriangleID TriangleID) const;
    bool IsTriangleValid(const FTriangleID TriangleID) const;
    bool IsVertexInstanceValid(FVertexInstanceID VertexInstanceID) const;
    bool IsVertexOrphaned(FVertexID VertexID) const;
    bool IsVertexValid(FVertexID VertexID) const;
    void ReserveNewEdges(int32_t NumberOfNewEdges);
    void ReserveNewPolygonGroups(int32_t NumberOfNewPolygonGroups);
    void ReserveNewPolygons(const int32_t NumberOfNewPolygons);
    void ReserveNewTriangles(int32_t NumberOfNewTriangles);
    void ReserveNewVertexInstances(int32_t NumberOfNewVertexInstances);
    void ReserveNewVertices(int32_t NumberOfNewVertices);
    void ReversePolygonFacing(FPolygonID PolygonID);
    void SetPolygonPolygonGroup(FPolygonID PolygonID, FPolygonGroupID PolygonGroupID);
    void SetPolygonVertexInstance(FPolygonID PolygonID, int32_t PerimeterIndex, FVertexInstanceID VertexInstanceID);
    void SetVertexPosition(FVertexID VertexID, const FVector& Position);
};

// Size: 0x4
struct FPolygonGroupID : public FElementID {
};

// Size: 0x4
struct FPolygonID : public FElementID {
};

// Size: 0x4
struct FTriangleID : public FElementID {
};

// Size: 0x4
struct FVertexID : public FElementID {
};

// Size: 0x4
struct FVertexInstanceID : public FElementID {
};

enum class EMeshPaintColorViewMode {
    Normal = 0,
    RGB = 1,
    Alpha = 2,
    Red = 3,
    Green = 4,
    Blue = 5,
    EMeshPaintColorViewMode_MAX = 6,
};

enum class EMeshPaintMode {
    PaintColors = 0,
    PaintWeights = 1,
    EMeshPaintMode_MAX = 2,
};

enum class EMeshVertexPaintTarget {
    ComponentInstance = 0,
    Mesh = 1,
    EMeshVertexPaintTarget_MAX = 2,
};

// Size: 0x38
class UMeshPaintSettings : public UObject {
    /* 0x0030 */ float VertexPreviewSize;
};

// Size: 0x48
class UPaintBrushSettings : public UObject {
    /* 0x0030 */ float BrushRadius;
    /* 0x003c */ float BrushStrength;
    /* 0x0040 */ float BrushFalloffAmount;
    /* 0x0044 */ bool bEnableFlow;
    /* 0x0045 */ bool bOnlyFrontFacingTriangles;
    /* 0x0046 */ EMeshPaintColorViewMode ColorViewMode;
};

// Size: 0x98
class UVertexColorImportOptions : public UObject {
    /* 0x0030 */ int32_t UVIndex;
    /* 0x0034 */ int32_t LODIndex;
    /* 0x0038 */ bool bRed;
    /* 0x0039 */ bool bBlue;
    /* 0x003a */ bool bGreen;
    /* 0x003b */ bool bAlpha;
    /* 0x003c */ bool bImportToInstance;
    /* 0x0094 */ bool bCanImportToInstance;
};

enum class EMeshPaintColorView {
    Normal = 0,
    RGB = 1,
    Alpha = 2,
    Red = 3,
    Green = 4,
    Blue = 5,
    EMeshPaintColorView_MAX = 6,
};

// Size: 0x98
class UImportVertexColorOptions : public UObject {
    /* 0x0030 */ int32_t UVIndex;
    /* 0x0034 */ int32_t LODIndex;
    /* 0x0038 */ bool bRed;
    /* 0x0039 */ bool bBlue;
    /* 0x003a */ bool bGreen;
    /* 0x003b */ bool bAlpha;
    /* 0x003c */ bool bImportToInstance;
    /* 0x0094 */ bool bCanImportToInstance;
};

// Size: 0x1a8
class UMeshPaintMode : public UEdMode {
    /* 0x0188 */ UMeshPaintModeSettings* ModeSettings;
};

// Size: 0x38
class UMeshPaintModeSettings : public UObject {
    /* 0x0030 */ EMeshPaintDataColorViewMode ColorViewMode;
};

enum class EPaintMode {
    Vertices = 0,
    Textures = 1,
    EPaintMode_MAX = 2,
};

enum class ETexturePaintIndex {
    TextureOne = 0,
    TextureTwo = 1,
    TextureThree = 2,
    TextureFour = 3,
    TextureFive = 4,
    ETexturePaintIndex_MAX = 5,
};

enum class ETextureWeightTypes {
    AlphaLerp = 2,
    RGB = 3,
    ARGB = 4,
    OneMinusARGB = 5,
    ETextureWeightTypes_MAX = 6,
};

// Size: 0xa8
class UPaintModeSettings : public UMeshPaintSettings {
    /* 0x0038 */ EPaintMode PaintMode;
    /* 0x003c */ FVertexPaintSettings VertexPaintSettings;
    /* 0x0070 */ FTexturePaintSettings TexturePaintSettings;
};

// Size: 0x38
struct FTexturePaintSettings {
    /* 0x0004 */ FLinearColor PaintColor;
    /* 0x0014 */ FLinearColor EraseColor;
    /* 0x0024 */ bool bWriteRed;
    /* 0x0025 */ bool bWriteGreen;
    /* 0x0026 */ bool bWriteBlue;
    /* 0x0027 */ bool bWriteAlpha;
    /* 0x0028 */ int32_t UVChannel;
    /* 0x002c */ bool bEnableSeamPainting;
    /* 0x0030 */ UTexture2D* PaintTexture;
};

// Size: 0x30
struct FVertexPaintSettings {
    /* 0x0000 */ EMeshPaintMode MeshPaintMode;
    /* 0x0004 */ FLinearColor PaintColor;
    /* 0x0014 */ FLinearColor EraseColor;
    /* 0x0024 */ bool bWriteRed;
    /* 0x0025 */ bool bWriteGreen;
    /* 0x0026 */ bool bWriteBlue;
    /* 0x0027 */ bool bWriteAlpha;
    /* 0x0028 */ ETextureWeightTypes TextureWeightType;
    /* 0x0029 */ ETexturePaintIndex PaintTextureWeightIndex;
    /* 0x002a */ ETexturePaintIndex EraseTextureWeightIndex;
    /* 0x002b */ bool bPaintOnSpecificLOD;
    /* 0x002c */ int32_t LODIndex;
};

enum class EMeshPaintDataColorViewMode {
    Normal = 0,
    RGB = 1,
    Alpha = 2,
    Red = 3,
    Green = 4,
    Blue = 5,
    EMeshPaintDataColorViewMode_MAX = 6,
};

enum class EMeshPaintTextureIndex {
    TextureOne = 0,
    TextureTwo = 1,
    TextureThree = 2,
    TextureFour = 3,
    TextureFive = 4,
    EMeshPaintTextureIndex_MAX = 5,
};

enum class EMeshPaintWeightTypes {
    AlphaLerp = 2,
    RGB = 3,
    ARGB = 4,
    OneMinusARGB = 5,
    EMeshPaintWeightTypes_MAX = 6,
};

enum class EMeshVertexPaintModeTarget {
    ComponentInstance = 0,
    Mesh = 1,
    EMeshVertexPaintModeTarget_MAX = 2,
};

enum class ETexturePaintWeightIndex {
    TextureOne = 0,
    TextureTwo = 1,
    TextureThree = 2,
    TextureFour = 3,
    TextureFive = 4,
    ETexturePaintWeightIndex_MAX = 5,
};

enum class ETexturePaintWeightTypes {
    AlphaLerp = 2,
    RGB = 3,
    ARGB = 4,
    OneMinusARGB = 5,
    ETexturePaintWeightTypes_MAX = 6,
};

// Size: 0xa0
class UMeshClickTool : public USingleClickTool {
    /* 0x0098 */ UMeshPaintSelectionMechanic* SelectionMechanic;
};

// Size: 0x2f0
class UMeshColorPaintingTool : public UMeshVertexPaintingTool {
    /* 0x02e0 */ UMeshColorPaintingToolProperties* ColorProperties;
};

// Size: 0x30
class UMeshColorPaintingToolBuilder : public UInteractiveToolBuilder {
};

// Size: 0xb8
class UMeshColorPaintingToolProperties : public UMeshVertexPaintingToolProperties {
    /* 0x00a8 */ bool bWriteRed;
    /* 0x00a9 */ bool bWriteGreen;
    /* 0x00aa */ bool bWriteBlue;
    /* 0x00ab */ bool bWriteAlpha;
    /* 0x00ac */ bool bPaintOnSpecificLOD;
    /* 0x00b0 */ int32_t LODIndex;
};

// Size: 0x30
class IMeshPaintSelectionInterface : public UInterface {
};

// Size: 0x60
class UMeshPaintSelectionMechanic : public UInteractionMechanic {
    /* 0x0038 */ TArray<UMeshComponent*> CachedClickedComponents;
    /* 0x0048 */ TArray<AActor*> CachedClickedActors;
};

// Size: 0x30
class UMeshPaintingToolset : public UBlueprintFunctionLibrary {
};

// Size: 0x3b0
class UMeshTexturePaintingTool : public UBaseBrushTool {
    /* 0x01f8 */ UMeshTexturePaintingToolProperties* TextureProperties;
    /* 0x0200 */ TArray<UTexture*> Textures;
    /* 0x0320 */ UTextureRenderTarget2D* BrushRenderTargetTexture;
    /* 0x0328 */ UTextureRenderTarget2D* BrushMaskRenderTargetTexture;
    /* 0x0330 */ UTextureRenderTarget2D* SeamMaskRenderTargetTexture;
    /* 0x0338 */ TMap<UTexture2D*, FPaintTexture2DData> PaintTargetData;
    /* 0x0398 */ UMeshComponent* TexturePaintingCurrentMeshComponent;
    /* 0x03a0 */ UTexture2D* PaintingTexture2D;
};

// Size: 0x30
class UMeshTexturePaintingToolBuilder : public UInteractiveToolBuilder {
};

// Size: 0xc0
class UMeshTexturePaintingToolProperties : public UBrushBaseProperties {
    /* 0x0080 */ FLinearColor PaintColor;
    /* 0x0090 */ FLinearColor EraseColor;
    /* 0x00a0 */ bool bWriteRed;
    /* 0x00a1 */ bool bWriteGreen;
    /* 0x00a2 */ bool bWriteBlue;
    /* 0x00a3 */ bool bWriteAlpha;
    /* 0x00a4 */ int32_t UVChannel;
    /* 0x00a8 */ bool bEnableSeamPainting;
    /* 0x00b0 */ UTexture2D* PaintTexture;
    /* 0x00b8 */ bool bEnableFlow;
    /* 0x00b9 */ bool bOnlyFrontFacingTriangles;
};

// Size: 0x1d0
class UMeshToolManager : public UInteractiveToolManager {
};

// Size: 0x248
class UMeshToolsContext : public UEdModeInteractiveToolsContext {
};

// Size: 0x2e0
class UMeshVertexPaintingTool : public UBaseBrushTool {
    /* 0x0220 */ UMeshPaintSelectionMechanic* SelectionMechanic;
    /* 0x0228 */ UMeshVertexPaintingToolProperties* VertexProperties;
};

// Size: 0xa8
class UMeshVertexPaintingToolProperties : public UBrushBaseProperties {
    /* 0x0080 */ FLinearColor PaintColor;
    /* 0x0090 */ FLinearColor EraseColor;
    /* 0x00a0 */ bool bEnableFlow;
    /* 0x00a1 */ bool bOnlyFrontFacingTriangles;
    /* 0x00a4 */ float VertexPreviewSize;
};

// Size: 0x2e8
class UMeshWeightPaintingTool : public UMeshVertexPaintingTool {
    /* 0x02e0 */ UMeshWeightPaintingToolProperties* WeightProperties;
};

// Size: 0x30
class UMeshWeightPaintingToolBuilder : public UInteractiveToolBuilder {
};

// Size: 0xb0
class UMeshWeightPaintingToolProperties : public UMeshVertexPaintingToolProperties {
    /* 0x00a8 */ EMeshPaintWeightTypes TextureWeightType;
    /* 0x00a9 */ EMeshPaintTextureIndex PaintTextureWeightIndex;
    /* 0x00aa */ EMeshPaintTextureIndex EraseTextureWeightIndex;
};

// Size: 0x38
struct FPaintTexture2DData {
    /* 0x0000 */ UTexture2D* PaintingTexture2D;
    /* 0x0010 */ UTexture2D* PaintingTexture2DDuplicate;
    /* 0x0018 */ UTextureRenderTarget2D* PaintRenderTargetTexture;
    /* 0x0020 */ UTextureRenderTarget2D* CloneRenderTargetTexture;
    /* 0x0028 */ TArray<UMaterialInterface*> PaintingMaterials;
};

// Size: 0xa0
class UTextureAdapterClickTool : public UMeshClickTool {
};

// Size: 0x30
class UTextureAdapterClickToolBuilder : public USingleClickToolBuilder {
};

// Size: 0x30
class UTexturePaintToolset : public UBlueprintFunctionLibrary {
};

// Size: 0xa0
class UVertexAdapterClickTool : public UMeshClickTool {
};

// Size: 0x30
class UVertexAdapterClickToolBuilder : public USingleClickToolBuilder {
};

// Size: 0x10
struct FMessageRpcCancel {
    /* 0x0000 */ FGuid CallId;
};

// Size: 0x28
struct FMessageRpcProgress {
    /* 0x0000 */ float Completion;
    /* 0x0004 */ FGuid CallId;
    /* 0x0018 */ FString StatusText;
};

// Size: 0x10
struct FMessageRpcUnhandled {
    /* 0x0000 */ FGuid CallId;
};

// Size: 0x10
struct FRpcMessage {
    /* 0x0000 */ FGuid CallId;
};

// Size: 0x50
class UMobileInstalledContent : public UObject {

    float GetDiskFreeSpace();
    float GetInstalledContentSize();
    bool Mount(int32_t PakOrder, FString MountPoint);
};

// Size: 0x30
class UMobilePatchingLibrary : public UBlueprintFunctionLibrary {

    static FString GetActiveDeviceProfileName();
    static UMobileInstalledContent* GetInstalledContent(FString InstallDirectory);
    static TArray<FString> GetSupportedPlatformNames();
    static bool HasActiveWiFiConnection();
    static void RequestContent(FString RemoteManifestURL, FString CloudURL, FString InstallDirectory, FDelegate OnSucceeded, FDelegate OnFailed);
};

// Size: 0x90
class UMobilePendingContent : public UMobileInstalledContent {

    float GetDownloadSize();
    float GetDownloadSpeed();
    FText GetDownloadStatusText();
    float GetInstallProgress();
    float GetRequiredDiskSpace();
    float GetTotalDownloadedSize();
    void StartInstall(FDelegate OnSucceeded, FDelegate OnFailed);
};

// Size: 0xc
struct FGrainTableEntry {
    /* 0x0000 */ int32_t SampleIndex;
    /* 0x0004 */ float RPM;
    /* 0x0008 */ int32_t AnalysisSampleIndex;
};

// Size: 0x270
class UMotoSynthPreset : public UObject {
    /* 0x0030 */ FRuntimeFloatCurve EnginePreviewRPMCurve;
    /* 0x00b8 */ FMotoSynthRuntimeSettings Settings;

    void DumpRuntimeMemoryUsage();
    void StartEnginePreview();
    void StopEnginePreview();
};

// Size: 0x68
struct FMotoSynthRuntimeSettings {
    /* 0x0000 */ bool bSynthToneEnabled;
    /* 0x0004 */ float SynthToneVolume;
    /* 0x0008 */ float SynthToneFilterFrequency;
    /* 0x000c */ int32_t SynthOctaveShift;
    /* 0x0010 */ bool bGranularEngineEnabled;
    /* 0x0014 */ float GranularEngineVolume;
    /* 0x0018 */ float GranularEnginePitchScale;
    /* 0x001c */ int32_t NumSamplesToCrossfadeBetweenGrains;
    /* 0x0020 */ int32_t NumGrainTableEntriesPerGrain;
    /* 0x0024 */ int32_t GrainTableRandomOffsetForConstantRPMs;
    /* 0x0028 */ int32_t GrainCrossfadeSamplesForConstantRPMs;
    /* 0x0030 */ UMotoSynthSource* AccelerationSource;
    /* 0x0038 */ UMotoSynthSource* DecelerationSource;
    /* 0x0040 */ bool bStereoWidenerEnabled;
    /* 0x0044 */ float StereoDelayMsec;
    /* 0x0048 */ float StereoFeedback;
    /* 0x004c */ float StereoWidenerWetlevel;
    /* 0x0050 */ float StereoWidenerDryLevel;
    /* 0x0054 */ float StereoWidenerDelayRatio;
    /* 0x0058 */ bool bStereoWidenerFilterEnabled;
    /* 0x005c */ float StereoWidenerFilterFrequency;
    /* 0x0060 */ float StereoWidenerFilterQ;
};

// Size: 0x6c0
class UMotoSynthSource : public UObject {
    /* 0x0030 */ USoundWave* SoundWaveSource;
    /* 0x0038 */ bool bConvertTo8Bit;
    /* 0x003c */ float DownSampleFactor;
    /* 0x0040 */ FRuntimeFloatCurve RPMCurve;
    /* 0x00c8 */ float RPMSynthVolume;
    /* 0x00cc */ bool bEnableFilteringForAnalysis;
    /* 0x00d0 */ float LowPassFilterFrequency;
    /* 0x00d4 */ float HighPassFilterFrequency;
    /* 0x00d8 */ bool bEnableDynamicsProcessorForAnalysis;
    /* 0x00dc */ float DynamicsProcessorLookahead;
    /* 0x00e0 */ float DynamicsProcessorInputGainDb;
    /* 0x00e4 */ float DynamicsProcessorRatio;
    /* 0x00e8 */ float DynamicsKneeBandwidth;
    /* 0x00ec */ float DynamicsProcessorThreshold;
    /* 0x00f0 */ float DynamicsProcessorAttackTimeMsec;
    /* 0x00f4 */ float DynamicsProcessorReleaseTimeMsec;
    /* 0x00f8 */ bool bEnableNormalizationForAnalysis;
    /* 0x00fc */ int32_t SampleShiftOffset;
    /* 0x0100 */ int32_t RPMCycleCalibrationSample;
    /* 0x0104 */ int32_t RPMFirstCycleSampleEnd;
    /* 0x0108 */ int32_t RPMEstimationOctaveOffset;
    /* 0x010c */ bool bWriteAnalysisInputToFile;
    /* 0x0110 */ FString AnalysisInputFilePath;
    /* 0x0130 */ TArray<float> SourceData;
    /* 0x0140 */ TArray<int16_t> SourceDataPCM;
    /* 0x0150 */ int32_t SourceSampleRate;
    /* 0x0158 */ TArray<FGrainTableEntry> GrainTable;

    void PerformGrainTableAnalysis();
    void PlayToneMatch();
    void StopToneMatch();
};

// Size: 0x7e0
class USynthComponentMoto : public USynthComponent {
    /* 0x0720 */ UMotoSynthPreset* MotoSynthPreset;
    /* 0x0728 */ float RPM;

    void GetRPMRange(float& OutMinRPM, float& OutMaxRPM);
    bool IsEnabled() const;
    void SetRPM(float InRPM, float InTimeSec);
    void SetSettings(const FMotoSynthRuntimeSettings& InSettings);
};

// Size: 0x88
class UMotoSynthPresetFactory : public UFactory {
};

// Size: 0x90
class UMotoSynthSourceFactory : public UFactory {
};

enum class EMoviePlaybackType {
    MT_Normal = 0,
    MT_Looped = 1,
    MT_LoadingLoop = 2,
    MT_MAX = 3,
};

// Size: 0x48
class UMoviePlayerSettings : public UObject {
    /* 0x0030 */ bool bWaitForMoviesToComplete;
    /* 0x0031 */ bool bMoviesAreSkippable;
    /* 0x0038 */ TArray<FString> StartupMovies;
};

enum class EEvaluationMethod {
    Static = 0,
    Swept = 1,
    EEvaluationMethod_MAX = 2,
};

enum class EMovieSceneBlendType {
    Invalid = 0,
    Absolute = 1,
    Additive = 2,
    Relative = 4,
    AdditiveFromBase = 8,
    EMovieSceneBlendType_MAX = 9,
};

enum class EMovieSceneBuiltInEasing {
    Linear = 0,
    SinIn = 1,
    SinOut = 2,
    SinInOut = 3,
    QuadIn = 4,
    QuadOut = 5,
    QuadInOut = 6,
    CubicIn = 7,
    CubicOut = 8,
    CubicInOut = 9,
    QuartIn = 10,
    QuartOut = 11,
    QuartInOut = 12,
    QuintIn = 13,
    QuintOut = 14,
    QuintInOut = 15,
    ExpoIn = 16,
    ExpoOut = 17,
    ExpoInOut = 18,
    CircIn = 19,
    CircOut = 20,
    CircInOut = 21,
    EMovieSceneBuiltInEasing_MAX = 22,
};

enum class EMovieSceneCompletionMode {
    KeepState = 0,
    RestoreState = 1,
    ProjectDefault = 2,
    EMovieSceneCompletionMode_MAX = 3,
};

enum class EMovieSceneEvaluationType {
    FrameLocked = 0,
    WithSubFrames = 1,
    EMovieSceneEvaluationType_MAX = 2,
};

enum class EMovieSceneKeyInterpolation {
    Auto = 0,
    User = 1,
    Break = 2,
    Linear = 3,
    Constant = 4,
    EMovieSceneKeyInterpolation_MAX = 5,
};

enum class EMovieSceneObjectBindingSpace {
    Local = 0,
    Root = 1,
    Unused = 2,
    EMovieSceneObjectBindingSpace_MAX = 3,
};

enum class EMovieScenePlayerStatus {
    Stopped = 0,
    Playing = 1,
    Scrubbing = 2,
    Jumping = 3,
    Stepping = 4,
    Paused = 5,
    MAX = 6,
};

enum class EMovieScenePositionType {
    Frame = 0,
    Time = 1,
    MarkedFrame = 2,
    EMovieScenePositionType_MAX = 3,
};

enum class EMovieSceneSequenceFlags {
    None = 0,
    Volatile = 1,
    BlockingEvaluation = 2,
    InheritedFlags = 1,
    EMovieSceneSequenceFlags_MAX = 3,
};

enum class EMovieSceneServerClientMask {
    None = 0,
    Server = 1,
    Client = 2,
    All = 3,
    EMovieSceneServerClientMask_MAX = 4,
};

enum class ESectionEvaluationFlags {
    None = 0,
    PreRoll = 1,
    PostRoll = 2,
    ESectionEvaluationFlags_MAX = 3,
};

enum class ESpawnOwnership {
    InnerSequence = 0,
    MasterSequence = 1,
    External = 2,
    ESpawnOwnership_MAX = 3,
};

enum class EUpdateClockSource {
    Tick = 0,
    Platform = 1,
    Audio = 2,
    RelativeTimecode = 3,
    Timecode = 4,
    Custom = 5,
    EUpdateClockSource_MAX = 6,
};

enum class EUpdatePositionMethod {
    Play = 0,
    Jump = 1,
    Scrub = 2,
    EUpdatePositionMethod_MAX = 3,
};

// Size: 0x8
struct FEasingComponentData {
    /* 0x0000 */ UMovieSceneSection* Section;
};

// Size: 0x60
struct FGeneratedMovieSceneKeyStruct {
};

// Size: 0x3a8
class UMovieScene : public UMovieSceneSignedObject {
    /* 0x0058 */ FMovieSceneTimecodeSource TimecodeSource;
    /* 0x0070 */ TArray<FMovieSceneSpawnable> Spawnables;
    /* 0x0080 */ TArray<FMovieScenePossessable> Possessables;
    /* 0x0090 */ TArray<FMovieSceneBinding> ObjectBindings;
    /* 0x00a0 */ TMap<FName, FMovieSceneObjectBindingIDs> BindingGroups;
    /* 0x00f0 */ TArray<UMovieSceneTrack*> MasterTracks;
    /* 0x0100 */ UMovieSceneTrack* CameraCutTrack;
    /* 0x0108 */ FMovieSceneFrameRange SelectionRange;
    /* 0x0128 */ FMovieSceneFrameRange PlaybackRange;
    /* 0x0148 */ FFrameRate TickResolution;
    /* 0x0150 */ FFrameRate DisplayRate;
    /* 0x0158 */ EMovieSceneEvaluationType EvaluationType;
    /* 0x0159 */ EUpdateClockSource ClockSource;
    /* 0x0160 */ FSoftObjectPath CustomClockSourcePath;
    /* 0x0180 */ TArray<FMovieSceneMarkedFrame> MarkedFrames;
    /* 0x0190 */ bool bReadOnly;
    /* 0x0191 */ bool bPlaybackRangeLocked;
    /* 0x0198 */ TMap<FString, FText> ObjectsToDisplayNames;
    /* 0x01e8 */ TMap<FString, FMovieSceneTrackLabels> ObjectsToLabels;
    /* 0x0238 */ FMovieSceneEditorData EditorData;
    /* 0x0328 */ TArray<UMovieSceneFolder*> RootFolders;
    /* 0x0338 */ TArray<FString> SoloNodes;
    /* 0x0348 */ TArray<FString> MuteNodes;
    /* 0x0358 */ TArray<FMovieSceneSectionGroup> SectionGroups;
    /* 0x0368 */ UMovieSceneNodeGroupCollection* NodeGroupCollection;
    /* 0x0374 */ float InTime;
    /* 0x0378 */ float OutTime;
    /* 0x037c */ float StartTime;
    /* 0x0380 */ float EndTime;
    /* 0x0384 */ bool bForceFixedFrameIntervalPlayback;
    /* 0x0388 */ float FixedFrameInterval;
};

// Size: 0x38
struct FMovieSceneBinding {
    /* 0x0000 */ FGuid ObjectGuid;
    /* 0x0010 */ FString BindingName;
    /* 0x0020 */ TArray<UMovieSceneTrack*> Tracks;
    /* 0x0030 */ int32_t SortingOrder;
};

// Size: 0x28
struct FMovieSceneBindingOverrideData {
    /* 0x0000 */ FMovieSceneObjectBindingID ObjectBindingID;
    /* 0x001c */ TWeakObjectPtr<UObject> Object;
    /* 0x0024 */ bool bOverridesDefault;
};

// Size: 0x98
class UMovieSceneBindingOverrides : public UObject {
    /* 0x0030 */ TArray<FMovieSceneBindingOverrideData> BindingData;
};

// Size: 0x30
class IMovieSceneBindingOwnerInterface : public UInterface {
};

// Size: 0x78
class UMovieSceneBlenderSystem : public UMovieSceneEntitySystem {
};

// Size: 0x90
struct FMovieSceneBoolChannel : public FMovieSceneChannel {
    /* 0x0008 */ TArray<FFrameNumber> Times;
    /* 0x0018 */ bool DefaultValue;
    /* 0x0019 */ bool bHasDefaultValue;
    /* 0x0020 */ TArray<bool> Values;
};

// Size: 0x1c8
class UMovieSceneBoolSection : public UMovieSceneSection {
    /* 0x0128 */ bool DefaultValue;
    /* 0x0130 */ FMovieSceneBoolChannel BoolCurve;
    /* 0x01c0 */ bool bIsExternallyInverted;
};

// Size: 0x50
class UMovieSceneBoundSceneComponentInstantiator : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x40
class UMovieSceneBuiltInEasingFunction : public UObject {
    /* 0x0038 */ EMovieSceneBuiltInEasing Type;
};

// Size: 0x98
struct FMovieSceneByteChannel : public FMovieSceneChannel {
    /* 0x0008 */ TArray<FFrameNumber> Times;
    /* 0x0018 */ uint8_t DefaultValue;
    /* 0x0019 */ bool bHasDefaultValue;
    /* 0x0020 */ TArray<uint8_t> Values;
    /* 0x0030 */ UEnum* Enum;
};

// Size: 0x70
class UMovieSceneCachePreAnimatedStateSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x8
struct FMovieSceneChannel {
};

// Size: 0x410
class UMovieSceneCompiledData : public UObject {
    /* 0x0030 */ FMovieSceneEvaluationTemplate EvaluationTemplate;
    /* 0x0190 */ FMovieSceneSequenceHierarchy Hierarchy;
    /* 0x02a8 */ FMovieSceneEntityComponentField EntityComponentField;
    /* 0x0398 */ FMovieSceneEvaluationField TrackTemplateField;
    /* 0x03d8 */ TArray<FFrameTime> DeterminismFences;
    /* 0x03e8 */ FGuid CompiledSignature;
    /* 0x03f8 */ FGuid CompilerVersion;
    /* 0x0408 */ FMovieSceneSequenceCompilerMaskStruct AccumulatedMask;
    /* 0x0409 */ FMovieSceneSequenceCompilerMaskStruct AllocatedMask;
    /* 0x040a */ EMovieSceneSequenceFlags AccumulatedFlags;
};

// Size: 0x238
class UMovieSceneCompiledDataManager : public UObject {
    /* 0x00e0 */ TMap<int32_t, FMovieSceneSequenceHierarchy> Hierarchies;
    /* 0x0130 */ TMap<int32_t, FMovieSceneEvaluationTemplate> TrackTemplates;
    /* 0x0180 */ TMap<int32_t, FMovieSceneEvaluationField> TrackTemplateFields;
    /* 0x01d0 */ TMap<int32_t, FMovieSceneEntityComponentField> EntityComponentFields;
};

// Size: 0x1
struct FMovieSceneCompiledSequenceFlagStruct {
    /* 0x0000 */ bool bParentSequenceRequiresLowerFence;
    /* 0x0000 */ bool bParentSequenceRequiresUpperFence;
};

// Size: 0x30
class IMovieSceneCustomClockSource : public UInterface {

    FFrameTime OnRequestCurrentTime(const FQualifiedFrameTime& InCurrentTime, float InPlayRate);
    void OnStartPlaying(const FQualifiedFrameTime& InStartTime);
    void OnStopPlaying(const FQualifiedFrameTime& InStopTime);
    void OnTick(float DeltaSeconds, float InPlayRate);
};

// Size: 0x18
struct FMovieSceneDeterminismData {
    /* 0x0000 */ TArray<FFrameTime> Fences;
    /* 0x0010 */ bool bParentSequenceRequiresLowerFence;
    /* 0x0011 */ bool bParentSequenceRequiresUpperFence;
};

// Size: 0x30
class IMovieSceneDeterminismSource : public UInterface {
};

// Size: 0x40
class UMovieSceneEasingExternalCurve : public UObject {
    /* 0x0038 */ UCurveFloat* Curve;
};

// Size: 0x30
class IMovieSceneEasingFunction : public UInterface {

    float OnEvaluate(float Interp) const;
};

// Size: 0x48
struct FMovieSceneEasingSettings {
    /* 0x0000 */ int32_t AutoEaseInDuration;
    /* 0x0004 */ int32_t AutoEaseOutDuration;
    /* 0x0008 */ TScriptInterface<IMovieSceneEasingFunction> EaseIn;
    /* 0x0018 */ bool bManualEaseIn;
    /* 0x001c */ int32_t ManualEaseInDuration;
    /* 0x0020 */ TScriptInterface<IMovieSceneEasingFunction> EaseOut;
    /* 0x0030 */ bool bManualEaseOut;
    /* 0x0034 */ int32_t ManualEaseOutDuration;
    /* 0x0038 */ float AutoEaseInTime;
    /* 0x003c */ float AutoEaseOutTime;
    /* 0x0040 */ float ManualEaseInTime;
    /* 0x0044 */ float ManualEaseOutTime;
};

// Size: 0xf0
struct FMovieSceneEditorData {
    /* 0x0000 */ TMap<FString, FMovieSceneExpansionState> ExpansionStates;
    /* 0x0050 */ TArray<FString> PinnedNodes;
    /* 0x0060 */ double ViewStart;
    /* 0x0068 */ double ViewEnd;
    /* 0x0070 */ double WorkStart;
    /* 0x0078 */ double WorkEnd;
    /* 0x0080 */ TSet<FFrameNumber> MarkedFrames;
    /* 0x00d0 */ FFloatRange WorkingRange;
    /* 0x00e0 */ FFloatRange ViewRange;
};

// Size: 0x1
struct FMovieSceneEmptyStruct {
};

// Size: 0xf0
struct FMovieSceneEntityComponentField {
    /* 0x0000 */ FMovieSceneEvaluationFieldEntityTree PersistentEntityTree;
    /* 0x0060 */ FMovieSceneEvaluationFieldEntityTree OneShotEntityTree;
    /* 0x00c0 */ TArray<FMovieSceneEvaluationFieldEntity> Entities;
    /* 0x00d0 */ TArray<FMovieSceneEvaluationFieldEntityMetaData> EntityMetaData;
    /* 0x00e0 */ TArray<FMovieSceneEvaluationFieldSharedEntityMetaData> SharedMetaData;
};

// Size: 0x50
class UMovieSceneEntityInstantiatorSystem : public UMovieSceneEntitySystem {
};

// Size: 0x30
class IMovieSceneEntityProvider : public UInterface {
};

// Size: 0x50
class UMovieSceneEntitySystem : public UObject {
    /* 0x0030 */ UMovieSceneEntitySystemLinker* Linker;
};

// Size: 0x138
struct FMovieSceneEntitySystemGraph {
    /* 0x0080 */ FMovieSceneEntitySystemGraphNodes Nodes;
};

// Size: 0x28
struct FMovieSceneEntitySystemGraphNode {
    /* 0x0020 */ UMovieSceneEntitySystem* System;
};

// Size: 0x38
struct FMovieSceneEntitySystemGraphNodes {
};

// Size: 0x4f8
class UMovieSceneEntitySystemLinker : public UObject {
    /* 0x02a0 */ FMovieSceneEntitySystemGraph SystemGraph;
};

// Size: 0x20
struct FMovieSceneEvalTemplate : public FMovieSceneEvalTemplateBase {
    /* 0x0010 */ EMovieSceneCompletionMode CompletionMode;
    /* 0x0014 */ TWeakObjectPtr<UMovieSceneSection> SourceSectionPtr;
};

// Size: 0x10
struct FMovieSceneEvalTemplateBase {
};

// Size: 0x88
struct FMovieSceneEvalTemplatePtr {
};

// Size: 0x60
class UMovieSceneEvalTimeSystem : public UMovieSceneEntitySystem {
};

// Size: 0x40
struct FMovieSceneEvaluationField {
    /* 0x0000 */ FGuid Signature;
    /* 0x0010 */ TArray<FMovieSceneFrameRange> Ranges;
    /* 0x0020 */ TArray<FMovieSceneEvaluationGroup> Groups;
    /* 0x0030 */ TArray<FMovieSceneEvaluationMetaData> MetaData;
};

// Size: 0x10
struct FMovieSceneEvaluationFieldEntity {
    /* 0x0000 */ FMovieSceneEvaluationFieldEntityKey Key;
    /* 0x000c */ int32_t SharedMetaDataIndex;
};

// Size: 0xc
struct FMovieSceneEvaluationFieldEntityKey {
    /* 0x0000 */ TWeakObjectPtr<UObject> EntityOwner;
    /* 0x0008 */ uint32_t EntityID;
};

// Size: 0x20
struct FMovieSceneEvaluationFieldEntityMetaData {
    /* 0x0000 */ FString OverrideBoundPropertyPath;
    /* 0x0010 */ FFrameNumber ForcedTime;
    /* 0x0018 */ ESectionEvaluationFlags Flags;
    /* 0x0019 */ bool bEvaluateInSequencePreRoll;
    /* 0x0019 */ bool bEvaluateInSequencePostRoll;
};

// Size: 0x60
struct FMovieSceneEvaluationFieldEntityTree {
};

// Size: 0xc
struct FMovieSceneEvaluationFieldSegmentPtr : public FMovieSceneEvaluationFieldTrackPtr {
    /* 0x0008 */ FMovieSceneSegmentIdentifier SegmentID;
};

// Size: 0x10
struct FMovieSceneEvaluationFieldSharedEntityMetaData {
    /* 0x0000 */ FGuid ObjectBindingID;
};

// Size: 0x8
struct FMovieSceneEvaluationFieldTrackPtr {
    /* 0x0000 */ FMovieSceneSequenceID SequenceID;
    /* 0x0004 */ FMovieSceneTrackIdentifier TrackIdentifier;
};

// Size: 0x30
struct FMovieSceneEvaluationGroup {
    /* 0x0000 */ TArray<FMovieSceneEvaluationGroupLUTIndex> LUTIndices;
    /* 0x0010 */ TArray<FMovieSceneFieldEntry_EvaluationTrack> TrackLUT;
    /* 0x0020 */ TArray<FMovieSceneFieldEntry_ChildTemplate> SectionLUT;
};

// Size: 0x8
struct FMovieSceneEvaluationGroupLUTIndex {
    /* 0x0000 */ int32_t NumInitPtrs;
    /* 0x0004 */ int32_t NumEvalPtrs;
};

// Size: 0x30
class IMovieSceneEvaluationHook : public UInterface {
};

// Size: 0x20
struct FMovieSceneEvaluationHookComponent {
    /* 0x0000 */ TScriptInterface<IMovieSceneEvaluationHook> Interface;
};

// Size: 0x38
struct FMovieSceneEvaluationHookEvent {
    /* 0x0000 */ FMovieSceneEvaluationHookComponent Hook;
};

// Size: 0x10
struct FMovieSceneEvaluationHookEventContainer {
    /* 0x0000 */ TArray<FMovieSceneEvaluationHookEvent> Events;
};

// Size: 0xa0
class UMovieSceneEvaluationHookSystem : public UMovieSceneEntitySystem {
    /* 0x0050 */ TMap<FMovieSceneEvaluationInstanceKey, FMovieSceneEvaluationHookEventContainer> PendingEventsByRootInstance;
};

// Size: 0x4
struct FMovieSceneEvaluationInstanceKey {
};

// Size: 0xc
struct FMovieSceneEvaluationKey {
    /* 0x0000 */ FMovieSceneSequenceID SequenceID;
    /* 0x0004 */ FMovieSceneTrackIdentifier TrackIdentifier;
    /* 0x0008 */ uint32_t SectionIndex;
};

// Size: 0x20
struct FMovieSceneEvaluationMetaData {
    /* 0x0000 */ TArray<FMovieSceneSequenceID> ActiveSequences;
    /* 0x0010 */ TArray<FMovieSceneOrderedEvaluationKey> ActiveEntities;
};

// Size: 0x14
struct FMovieSceneEvaluationOperand {
    /* 0x0000 */ FGuid ObjectBindingID;
    /* 0x0010 */ FMovieSceneSequenceID SequenceID;
};

// Size: 0x160
struct FMovieSceneEvaluationTemplate {
    /* 0x0000 */ TMap<FMovieSceneTrackIdentifier, FMovieSceneEvaluationTrack> Tracks;
    /* 0x00a0 */ FGuid SequenceSignature;
    /* 0x00b0 */ FMovieSceneEvaluationTemplateSerialNumber TemplateSerialNumber;
    /* 0x00b8 */ FMovieSceneTemplateGenerationLedger TemplateLedger;
};

// Size: 0x4
struct FMovieSceneEvaluationTemplateSerialNumber {
    /* 0x0000 */ uint32_t Value;
};

// Size: 0x78
struct FMovieSceneEvaluationTrack {
    /* 0x0000 */ FGuid ObjectBindingID;
    /* 0x0010 */ uint16_t EvaluationPriority;
    /* 0x0012 */ EEvaluationMethod EvaluationMethod;
    /* 0x0014 */ TWeakObjectPtr<UMovieSceneTrack> SourceTrack;
    /* 0x0020 */ TArray<FMovieSceneEvalTemplatePtr> ChildTemplates;
    /* 0x0030 */ FMovieSceneTrackImplementationPtr TrackTemplate;
    /* 0x0068 */ FName EvaluationGroup;
    /* 0x0074 */ bool bEvaluateInPreroll;
    /* 0x0074 */ bool bEvaluateInPostroll;
    /* 0x0074 */ bool bTearDownPriority;
};

// Size: 0x1
struct FMovieSceneExpansionState {
    /* 0x0000 */ bool bExpanded;
};

// Size: 0x8
struct FMovieSceneFieldEntry_ChildTemplate {
    /* 0x0000 */ uint16_t ChildIndex;
    /* 0x0002 */ ESectionEvaluationFlags Flags;
    /* 0x0004 */ FFrameNumber ForcedTime;
};

// Size: 0xc
struct FMovieSceneFieldEntry_EvaluationTrack {
    /* 0x0000 */ FMovieSceneEvaluationFieldTrackPtr TrackPtr;
    /* 0x0008 */ uint16_t NumChildren;
};

// Size: 0xa0
struct FMovieSceneFloatChannel : public FMovieSceneChannel {
    /* 0x0008 */ uint8_t PreInfinityExtrap;
    /* 0x0009 */ uint8_t PostInfinityExtrap;
    /* 0x0010 */ TArray<FFrameNumber> Times;
    /* 0x0020 */ TArray<FMovieSceneFloatValue> Values;
    /* 0x0030 */ float DefaultValue;
    /* 0x0034 */ bool bHasDefaultValue;
    /* 0x0038 */ FMovieSceneKeyHandleMap KeyHandles;
    /* 0x0098 */ FFrameRate TickResolution;
};

// Size: 0x30
class IMovieSceneFloatDecomposer : public UInterface {
};

// Size: 0x1c
struct FMovieSceneFloatValue {
    /* 0x0000 */ float Value;
    /* 0x0004 */ FMovieSceneTangentData Tangent;
    /* 0x0018 */ uint8_t InterpMode;
    /* 0x0019 */ uint8_t TangentMode;
    /* 0x001a */ uint8_t PaddingByte;
};

// Size: 0x88
class UMovieSceneFolder : public UObject {
    /* 0x0030 */ FName FolderName;
    /* 0x0040 */ TArray<UMovieSceneFolder*> ChildFolders;
    /* 0x0050 */ TArray<UMovieSceneTrack*> ChildMasterTracks;
    /* 0x0060 */ TArray<FString> ChildObjectBindingStrings;
    /* 0x0070 */ FColor FolderColor;
    /* 0x0074 */ int32_t SortingOrder;
};

// Size: 0x20
struct FMovieSceneFrameRange {
};

// Size: 0x50
class UMovieSceneGenericBoundObjectInstantiator : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x140
class UMovieSceneHookSection : public UMovieSceneSection {
    /* 0x0138 */ bool bRequiresRangedHook;
    /* 0x0138 */ bool bRequiresTriggerHooks;
};

// Size: 0x90
struct FMovieSceneIntegerChannel : public FMovieSceneChannel {
    /* 0x0008 */ TArray<FFrameNumber> Times;
    /* 0x0018 */ int32_t DefaultValue;
    /* 0x001c */ bool bHasDefaultValue;
    /* 0x0020 */ TArray<int32_t> Values;
};

// Size: 0x60
struct FMovieSceneKeyHandleMap : public FKeyHandleLookupTable {
};

// Size: 0x30
class IMovieSceneKeyProxy : public UInterface {
};

// Size: 0x8
struct FMovieSceneKeyStruct {
};

// Size: 0x28
struct FMovieSceneKeyTimeStruct : public FMovieSceneKeyStruct {
    /* 0x0008 */ FFrameNumber Time;
};

// Size: 0x30
struct FMovieSceneMarkedFrame {
    /* 0x0000 */ FFrameNumber FrameNumber;
    /* 0x0008 */ FString Label;
    /* 0x0018 */ FLinearColor Color;
    /* 0x0028 */ bool bIsDeterminismFence;
};

// Size: 0x50
class UMovieSceneMasterInstantiatorSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0xd8
class UMovieSceneNameableTrack : public UMovieSceneTrack {
    /* 0x00c0 */ FText DisplayName;
};

// Size: 0x14
struct FMovieSceneNestedSequenceTransform {
    /* 0x0000 */ FMovieSceneTimeTransform LinearTransform;
    /* 0x000c */ FMovieSceneTimeWarping Warping;
};

// Size: 0x70
class UMovieSceneNodeGroup : public UObject {
    /* 0x0030 */ FName Name;
    /* 0x0040 */ TArray<FString> Nodes;
};

// Size: 0x60
class UMovieSceneNodeGroupCollection : public UObject {
    /* 0x0030 */ TArray<UMovieSceneNodeGroup*> NodeGroups;
};

// Size: 0x1c
struct FMovieSceneObjectBindingID {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ int32_t SequenceID;
    /* 0x0014 */ int32_t ResolveParentIndex;
    /* 0x0018 */ EMovieSceneObjectBindingSpace Space;
};

// Size: 0x10
struct FMovieSceneObjectBindingIDs {
    /* 0x0000 */ TArray<FMovieSceneObjectBindingID> IDs;
};

// Size: 0xc8
struct FMovieSceneObjectPathChannel : public FMovieSceneChannel {
    /* 0x0008 */ UClass* PropertyClass;
    /* 0x0010 */ TArray<FFrameNumber> Times;
    /* 0x0020 */ TArray<FMovieSceneObjectPathChannelKeyValue> Values;
    /* 0x0030 */ FMovieSceneObjectPathChannelKeyValue DefaultValue;
};

// Size: 0x38
struct FMovieSceneObjectPathChannelKeyValue {
    /* 0x0000 */ TSoftObjectPtr<UObject> SoftPtr;
    /* 0x0030 */ UObject* HardPtr;
};

// Size: 0x10
struct FMovieSceneOrderedEvaluationKey {
    /* 0x0000 */ FMovieSceneEvaluationKey Key;
    /* 0x000c */ uint16_t SetupIndex;
    /* 0x000e */ uint16_t TearDownIndex;
};

// Size: 0x30
class IMovieScenePlaybackClient : public UInterface {
};

// Size: 0x48
struct FMovieScenePossessable {
    /* 0x0000 */ TArray<FName> Tags;
    /* 0x0010 */ FGuid Guid;
    /* 0x0020 */ FString Name;
    /* 0x0030 */ UClass* PossessedObjectClass;
    /* 0x0038 */ FGuid ParentGuid;
};

// Size: 0x30
class IMovieScenePreAnimatedStateSystemInterface : public UInterface {
};

// Size: 0x1c
struct FMovieScenePropertyBinding {
    /* 0x0000 */ FName PropertyName;
    /* 0x000c */ FName PropertyPath;
    /* 0x0018 */ bool bCanUseClassLookup;
};

// Size: 0x20
struct FMovieScenePropertySectionData {
    /* 0x0000 */ FName PropertyName;
    /* 0x0010 */ FString PropertyPath;
};

// Size: 0x40
struct FMovieScenePropertySectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieScenePropertySectionData PropertyData;
};

// Size: 0x60
class UMovieSceneRestorePreAnimatedStateSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0xf0
struct FMovieSceneRootEvaluationTemplateInstance {
    /* 0x0000 */ TWeakObjectPtr<UMovieSceneSequence> WeakRootSequence;
    /* 0x0008 */ UMovieSceneCompiledDataManager* CompiledDataManager;
    /* 0x0018 */ UMovieSceneEntitySystemLinker* EntitySystemLinker;
    /* 0x0090 */ TMap<FMovieSceneSequenceID, UObject*> DirectorInstances;
};

// Size: 0x30
class IMovieSceneSceneComponentImpersonator : public UInterface {
};

// Size: 0x128
class UMovieSceneSection : public UMovieSceneSignedObject {
    /* 0x0058 */ FMovieSceneSectionEvalOptions EvalOptions;
    /* 0x0060 */ FMovieSceneEasingSettings Easing;
    /* 0x00a8 */ FMovieSceneFrameRange SectionRange;
    /* 0x00c8 */ FMovieSceneTimecodeSource TimecodeSource;
    /* 0x00e0 */ FFrameNumber PreRollFrames;
    /* 0x00e4 */ FFrameNumber PostRollFrames;
    /* 0x00e8 */ int32_t RowIndex;
    /* 0x00ec */ int32_t OverlapPriority;
    /* 0x00f0 */ bool bIsActive;
    /* 0x00f0 */ bool bIsLocked;
    /* 0x00f4 */ float StartTime;
    /* 0x00f8 */ float EndTime;
    /* 0x00fc */ float PrerollTime;
    /* 0x0100 */ float PostrollTime;
    /* 0x0104 */ bool bIsInfinite;
    /* 0x0108 */ bool bSupportsInfiniteRange;
    /* 0x0109 */ FOptionalMovieSceneBlendType BlendType;

    FOptionalMovieSceneBlendType GetBlendType() const;
    EMovieSceneCompletionMode GetCompletionMode() const;
    int32_t GetOverlapPriority() const;
    int32_t GetPostRollFrames() const;
    int32_t GetPreRollFrames() const;
    int32_t GetRowIndex() const;
    bool IsActive() const;
    bool IsLocked() const;
    void SetBlendType(EMovieSceneBlendType InBlendType);
    void SetCompletionMode(EMovieSceneCompletionMode InCompletionMode);
    void SetIsActive(bool bInIsActive);
    void SetIsLocked(bool bInIsLocked);
    void SetOverlapPriority(int32_t NewPriority);
    void SetPostRollFrames(int32_t InPostRollFrames);
    void SetPreRollFrames(int32_t InPreRollFrames);
    void SetRowIndex(int32_t NewRowIndex);
};

// Size: 0x2
struct FMovieSceneSectionEvalOptions {
    /* 0x0000 */ bool bCanEditCompletionMode;
    /* 0x0001 */ EMovieSceneCompletionMode CompletionMode;
};

// Size: 0x10
struct FMovieSceneSectionGroup {
    /* 0x0000 */ TArray<TWeakObjectPtr<UMovieSceneSection>> Sections;
};

// Size: 0x24
struct FMovieSceneSectionParameters {
    /* 0x0000 */ FFrameNumber StartFrameOffset;
    /* 0x0004 */ bool bCanLoop;
    /* 0x0008 */ FFrameNumber EndFrameOffset;
    /* 0x000c */ FFrameNumber FirstLoopStartFrameOffset;
    /* 0x0010 */ float TimeScale;
    /* 0x0014 */ int32_t HierarchicalBias;
    /* 0x0018 */ float StartOffset;
    /* 0x001c */ float PrerollTime;
    /* 0x0020 */ float PostrollTime;
};

// Size: 0x58
struct FMovieSceneSegment {
};

// Size: 0x4
struct FMovieSceneSegmentIdentifier {
    /* 0x0000 */ int32_t IdentifierIndex;
};

// Size: 0x68
class UMovieSceneSequence : public UMovieSceneSignedObject {
    /* 0x0058 */ UMovieSceneCompiledData* CompiledData;
    /* 0x0060 */ EMovieSceneCompletionMode DefaultCompletionMode;
    /* 0x0061 */ bool bParentContextsAreSignificant;
    /* 0x0062 */ bool bPlayableDirectly;
    /* 0x0063 */ EMovieSceneSequenceFlags SequenceFlags;

    FMovieSceneObjectBindingID FindBindingByTag(FName InBindingName) const;
    TArray<FMovieSceneObjectBindingID> FindBindingsByTag(FName InBindingName) const;
};

// Size: 0x30
class IMovieSceneSequenceActor : public UInterface {
};

// Size: 0x18
struct FMovieSceneSequenceActorPointers {
    /* 0x0000 */ AActor* SequenceActor;
    /* 0x0008 */ TScriptInterface<IMovieSceneSequenceActor> SequenceActorInterface;
};

// Size: 0x1
struct FMovieSceneSequenceCompilerMaskStruct {
    /* 0x0000 */ bool bHierarchy;
    /* 0x0000 */ bool bEvaluationTemplate;
    /* 0x0000 */ bool bEvaluationTemplateField;
    /* 0x0000 */ bool bEntityComponentField;
};

// Size: 0x118
struct FMovieSceneSequenceHierarchy {
    /* 0x0000 */ FMovieSceneSequenceHierarchyNode RootNode;
    /* 0x0018 */ FMovieSceneSubSequenceTree Tree;
    /* 0x0078 */ TMap<FMovieSceneSequenceID, FMovieSceneSubSequenceData> SubSequences;
    /* 0x00c8 */ TMap<FMovieSceneSequenceID, FMovieSceneSequenceHierarchyNode> Hierarchy;
};

// Size: 0x18
struct FMovieSceneSequenceHierarchyNode {
    /* 0x0000 */ FMovieSceneSequenceID ParentID;
    /* 0x0008 */ TArray<FMovieSceneSequenceID> Children;
};

// Size: 0x4
struct FMovieSceneSequenceID {
    /* 0x0000 */ uint32_t Value;
};

// Size: 0x8
struct FMovieSceneSequenceInstanceData {
};

// Size: 0x18
struct FMovieSceneSequenceInstanceDataPtr {
};

// Size: 0x4
struct FMovieSceneSequenceLoopCount {
    /* 0x0000 */ int32_t Value;
};

// Size: 0x28
struct FMovieSceneSequencePlaybackParams {
    /* 0x0000 */ FFrameTime Frame;
    /* 0x0008 */ float Time;
    /* 0x0010 */ FString MarkedFrame;
    /* 0x0020 */ EMovieScenePositionType PositionType;
    /* 0x0021 */ EUpdatePositionMethod UpdateMethod;
};

// Size: 0x14
struct FMovieSceneSequencePlaybackSettings {
    /* 0x0000 */ bool bAutoPlay;
    /* 0x0004 */ FMovieSceneSequenceLoopCount LoopCount;
    /* 0x0008 */ float PlayRate;
    /* 0x000c */ float StartTime;
    /* 0x0010 */ bool bRandomStartTime;
    /* 0x0010 */ bool bRestoreState;
    /* 0x0010 */ bool bDisableMovementInput;
    /* 0x0010 */ bool bDisableLookAtInput;
    /* 0x0010 */ bool bHidePlayer;
    /* 0x0010 */ bool bHideHud;
    /* 0x0010 */ bool bDisableCameraCuts;
    /* 0x0010 */ bool bPauseAtEnd;
};

// Size: 0x500
class UMovieSceneSequencePlayer : public UObject {
    /* 0x0270 */ FMulticastInlineDelegate OnPlay;
    /* 0x0280 */ FMulticastInlineDelegate OnPlayReverse;
    /* 0x0290 */ FMulticastInlineDelegate OnStop;
    /* 0x02a0 */ FMulticastInlineDelegate OnPause;
    /* 0x02b0 */ FMulticastInlineDelegate OnFinished;
    /* 0x02c0 */ uint8_t Status;
    /* 0x02c4 */ bool bReversePlayback;
    /* 0x02c8 */ UMovieSceneSequence* Sequence;
    /* 0x02d0 */ FFrameNumber StartTime;
    /* 0x02d4 */ int32_t DurationFrames;
    /* 0x02d8 */ float DurationSubFrames;
    /* 0x02dc */ int32_t CurrentNumLoops;
    /* 0x02e0 */ FMovieSceneSequencePlaybackSettings PlaybackSettings;
    /* 0x02f8 */ FMovieSceneRootEvaluationTemplateInstance RootTemplateInstance;
    /* 0x0450 */ FMovieSceneSequenceReplProperties NetSyncProps;
    /* 0x0460 */ TScriptInterface<IMovieScenePlaybackClient> PlaybackClient;
    /* 0x0470 */ UMovieSceneSequenceTickManager* TickManager;

    void ChangePlaybackDirection();
    TArray<UObject*> GetBoundObjects(FMovieSceneObjectBindingID ObjectBinding);
    FQualifiedFrameTime GetCurrentTime() const;
    bool GetDisableCameraCuts();
    FQualifiedFrameTime GetDuration() const;
    FQualifiedFrameTime GetEndTime() const;
    int32_t GetFrameDuration() const;
    FFrameRate GetFrameRate() const;
    TArray<FMovieSceneObjectBindingID> GetObjectBindings(UObject* InObject);
    float GetPlayRate() const;
    UMovieSceneSequence* GetSequence() const;
    FQualifiedFrameTime GetStartTime() const;
    void GoToEndAndStop();
    bool IsPaused() const;
    bool IsPlaying() const;
    bool IsReversed() const;
    void JumpToFrame(FFrameTime NewPosition);
    bool JumpToMarkedFrame(FString InLabel);
    void JumpToSeconds(float TimeInSeconds);
    void Pause();
    void Play();
    void PlayLooping(int32_t NumLoops);
    void PlayReverse();
    void PlayTo(FMovieSceneSequencePlaybackParams PlaybackParams);
    void PlayToFrame(FFrameTime NewPosition);
    bool PlayToMarkedFrame(FString InLabel);
    void PlayToSeconds(float TimeInSeconds);
    void RPC_ExplicitServerUpdateEvent(EUpdatePositionMethod Method, FFrameTime RelevantTime);
    void RPC_OnStopEvent(FFrameTime StoppedTime);
    void RestoreState();
    void Scrub();
    void ScrubToFrame(FFrameTime NewPosition);
    bool ScrubToMarkedFrame(FString InLabel);
    void ScrubToSeconds(float TimeInSeconds);
    void SetDisableCameraCuts(bool bInDisableCameraCuts);
    void SetFrameRange(int32_t StartFrame, int32_t Duration, float SubFrames);
    void SetFrameRate(FFrameRate FrameRate);
    void SetPlayRate(float PlayRate);
    void SetPlaybackPosition(FMovieSceneSequencePlaybackParams PlaybackParams);
    void SetTimeRange(float StartTime, float Duration);
    void Stop();
    void StopAtCurrentTime();
};

// Size: 0x10
struct FMovieSceneSequenceReplProperties {
    /* 0x0000 */ FFrameTime LastKnownPosition;
    /* 0x0008 */ uint8_t LastKnownStatus;
    /* 0x000c */ int32_t LastKnownNumLoops;
};

// Size: 0xd8
class UMovieSceneSequenceTickManager : public UObject {
    /* 0x0030 */ TArray<FMovieSceneSequenceActorPointers> SequenceActors;
    /* 0x0040 */ UMovieSceneEntitySystemLinker* Linker;
};

// Size: 0x20
struct FMovieSceneSequenceTransform {
    /* 0x0000 */ FMovieSceneTimeTransform LinearTransform;
    /* 0x0010 */ TArray<FMovieSceneNestedSequenceTransform> NestedTransforms;
};

// Size: 0x58
class UMovieSceneSignedObject : public UObject {
    /* 0x0030 */ FGuid Signature;
};

// Size: 0x1d0
class UMovieSceneSpawnSection : public UMovieSceneBoolSection {
};

// Size: 0xe0
class UMovieSceneSpawnTrack : public UMovieSceneTrack {
    /* 0x00c0 */ TArray<UMovieSceneSection*> Sections;
    /* 0x00d0 */ FGuid ObjectGuid;
};

// Size: 0xa0
struct FMovieSceneSpawnable {
    /* 0x0000 */ FTransform SpawnTransform;
    /* 0x0030 */ TArray<FName> Tags;
    /* 0x0040 */ bool bContinuouslyRespawn;
    /* 0x0041 */ bool bNetAddressableName;
    /* 0x0042 */ bool bEvaluateTracksWhenNotSpawned;
    /* 0x0044 */ FGuid Guid;
    /* 0x0058 */ FString Name;
    /* 0x0068 */ UObject* ObjectTemplate;
    /* 0x0070 */ TArray<FGuid> ChildPossessables;
    /* 0x0080 */ ESpawnOwnership Ownership;
    /* 0x0088 */ UClass* GeneratedClass;
    /* 0x0090 */ FName LevelName;
};

// Size: 0x50
class UMovieSceneSpawnablesSystem : public UMovieSceneEntitySystem {
};

// Size: 0x1c0
class UMovieSceneSubSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneSectionParameters Parameters;
    /* 0x014c */ float StartOffset;
    /* 0x0150 */ float TimeScale;
    /* 0x0154 */ float PrerollTime;
    /* 0x0158 */ uint8_t NetworkMask;
    /* 0x0160 */ UMovieSceneSequence* SubSequence;
    /* 0x0168 */ TLazyObjectPtr<AActor> ActorToRecord;
    /* 0x0188 */ FString TargetSequenceName;
    /* 0x0198 */ FDirectoryPath TargetPathToRecordTo;

    UMovieSceneSequence* GetSequence() const;
    void SetSequence(UMovieSceneSequence* Sequence);
};

// Size: 0x1c
struct FMovieSceneSubSectionData {
    /* 0x0000 */ TWeakObjectPtr<UMovieSceneSubSection> Section;
    /* 0x0008 */ FGuid ObjectBindingID;
    /* 0x0018 */ ESectionEvaluationFlags Flags;
};

// Size: 0x180
struct FMovieSceneSubSequenceData {
    /* 0x0000 */ FSoftObjectPath Sequence;
    /* 0x0020 */ FMovieSceneSequenceTransform OuterToInnerTransform;
    /* 0x0040 */ FMovieSceneSequenceTransform RootToSequenceTransform;
    /* 0x0060 */ FFrameRate TickResolution;
    /* 0x0068 */ FMovieSceneSequenceID DeterministicSequenceID;
    /* 0x006c */ FMovieSceneFrameRange ParentPlayRange;
    /* 0x008c */ FFrameNumber ParentStartFrameOffset;
    /* 0x0090 */ FFrameNumber ParentEndFrameOffset;
    /* 0x0094 */ FFrameNumber ParentFirstLoopStartFrameOffset;
    /* 0x0098 */ bool bCanLoop;
    /* 0x009c */ FMovieSceneFrameRange PlayRange;
    /* 0x00bc */ FMovieSceneFrameRange FullPlayRange;
    /* 0x00dc */ FMovieSceneFrameRange UnwarpedPlayRange;
    /* 0x00fc */ FMovieSceneFrameRange PreRollRange;
    /* 0x011c */ FMovieSceneFrameRange PostRollRange;
    /* 0x013c */ int16_t HierarchicalBias;
    /* 0x013e */ bool bHasHierarchicalEasing;
    /* 0x0140 */ FMovieSceneSequenceInstanceDataPtr InstanceData;
    /* 0x0158 */ FName SectionPath;
    /* 0x016c */ FGuid SubSectionSignature;
};

// Size: 0x60
struct FMovieSceneSubSequenceTree {
};

// Size: 0x18
struct FMovieSceneSubSequenceTreeEntry {
};

// Size: 0xe8
class UMovieSceneSubTrack : public UMovieSceneNameableTrack {
    /* 0x00d8 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0x14
struct FMovieSceneTangentData {
    /* 0x0000 */ float ArriveTangent;
    /* 0x0004 */ float LeaveTangent;
    /* 0x0008 */ float ArriveTangentWeight;
    /* 0x000c */ float LeaveTangentWeight;
    /* 0x0010 */ uint8_t TangentWeightMode;
};

// Size: 0xa8
struct FMovieSceneTemplateGenerationLedger {
    /* 0x0000 */ FMovieSceneTrackIdentifier LastTrackIdentifier;
    /* 0x0008 */ TMap<FGuid, FMovieSceneTrackIdentifier> TrackSignatureToTrackIdentifier;
    /* 0x0058 */ TMap<FGuid, FMovieSceneFrameRange> SubSectionRanges;
};

// Size: 0xc
struct FMovieSceneTimeTransform {
    /* 0x0000 */ float TimeScale;
    /* 0x0004 */ FFrameTime Offset;
};

// Size: 0x8
struct FMovieSceneTimeWarping {
    /* 0x0000 */ FFrameNumber Start;
    /* 0x0004 */ FFrameNumber End;
};

// Size: 0x18
struct FMovieSceneTimecodeSource {
    /* 0x0000 */ FTimecode Timecode;
    /* 0x0014 */ FFrameNumber DeltaFrame;
};

// Size: 0xc0
class UMovieSceneTrack : public UMovieSceneSignedObject {
    /* 0x0058 */ FMovieSceneTrackEvalOptions EvalOptions;
    /* 0x005c */ FMovieSceneTrackDisplayOptions DisplayOptions;
    /* 0x0061 */ bool bIsEvalDisabled;
    /* 0x0068 */ TArray<int32_t> RowsDisabled;
    /* 0x007c */ FGuid EvaluationFieldGuid;
    /* 0x008c */ int8_t EvaluationFieldVersion;
    /* 0x0090 */ FMovieSceneTrackEvaluationField EvaluationField;
    /* 0x00a0 */ FGuid ObjectBindingID;
    /* 0x00b0 */ FColor TrackTint;
    /* 0x00b4 */ int32_t SortingOrder;
    /* 0x00b8 */ bool bSupportsDefaultSections;
};

// Size: 0x4
struct FMovieSceneTrackDisplayOptions {
    /* 0x0000 */ bool bShowVerticalFrames;
};

// Size: 0x4
struct FMovieSceneTrackEvalOptions {
    /* 0x0000 */ bool bCanEvaluateNearestSection;
    /* 0x0000 */ bool bEvalNearestSection;
    /* 0x0000 */ bool bEvaluateInPreroll;
    /* 0x0000 */ bool bEvaluateInPostroll;
    /* 0x0000 */ bool bEvaluateNearestSection;
};

// Size: 0x10
struct FMovieSceneTrackEvaluationField {
    /* 0x0000 */ TArray<FMovieSceneTrackEvaluationFieldEntry> Entries;
};

// Size: 0x20
struct FMovieSceneTrackEvaluationFieldEntry {
    /* 0x0000 */ UMovieSceneSection* Section;
    /* 0x0008 */ FFrameNumberRange Range;
    /* 0x0018 */ FFrameNumber ForcedTime;
    /* 0x001c */ ESectionEvaluationFlags Flags;
    /* 0x001e */ int16_t LegacySortOrder;
};

// Size: 0x4
struct FMovieSceneTrackIdentifier {
    /* 0x0000 */ uint32_t Value;
};

// Size: 0x10
struct FMovieSceneTrackImplementation : public FMovieSceneEvalTemplateBase {
};

// Size: 0x38
struct FMovieSceneTrackImplementationPtr {
};

// Size: 0x58
class UMovieSceneTrackInstance : public UObject {
    /* 0x0030 */ UObject* AnimatedObject;
    /* 0x0038 */ bool bIsMasterTrackInstance;
    /* 0x0040 */ UMovieSceneEntitySystemLinker* Linker;
    /* 0x0048 */ TArray<FMovieSceneTrackInstanceInput> Inputs;
};

// Size: 0x10
struct FMovieSceneTrackInstanceComponent {
    /* 0x0000 */ UMovieSceneSection* Owner;
    /* 0x0008 */ UClass* TrackInstanceClass;
};

// Size: 0x10
struct FMovieSceneTrackInstanceEntry {
    /* 0x0000 */ UObject* BoundObject;
    /* 0x0008 */ UMovieSceneTrackInstance* TrackInstance;
};

// Size: 0x10
struct FMovieSceneTrackInstanceInput {
    /* 0x0000 */ UMovieSceneSection* Section;
};

// Size: 0x100
class UMovieSceneTrackInstanceInstantiator : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x58
class UMovieSceneTrackInstanceSystem : public UMovieSceneEntitySystem {
    /* 0x0050 */ UMovieSceneTrackInstanceInstantiator* Instantiator;
};

// Size: 0x10
struct FMovieSceneTrackLabels {
    /* 0x0000 */ TArray<FString> Strings;
};

// Size: 0x30
class IMovieSceneTrackTemplateProducer : public UInterface {
};

// Size: 0x10
struct FMovieSceneWarpCounter {
    /* 0x0000 */ TArray<uint32_t> WarpCounts;
};

// Size: 0x30
class INodeAndChannelMappings : public UInterface {
};

// Size: 0x2
struct FOptionalMovieSceneBlendType {
    /* 0x0000 */ EMovieSceneBlendType BlendType;
    /* 0x0001 */ bool bIsValid;
};

// Size: 0xc
struct FSectionEvaluationData {
    /* 0x0000 */ int32_t ImplIndex;
    /* 0x0004 */ FFrameNumber ForcedTime;
    /* 0x0008 */ ESectionEvaluationFlags Flags;
};

// Size: 0x158
class UTestMovieSceneEvalHookSection : public UMovieSceneHookSection {
};

// Size: 0xd0
class UTestMovieSceneEvalHookTrack : public UMovieSceneTrack {
    /* 0x00c0 */ TArray<UMovieSceneSection*> SectionArray;
};

// Size: 0x20
struct FTestMovieSceneEvalTemplate : public FMovieSceneEvalTemplate {
};

// Size: 0x128
class UTestMovieSceneSection : public UMovieSceneSection {
};

// Size: 0x70
class UTestMovieSceneSequence : public UMovieSceneSequence {
    /* 0x0068 */ UMovieScene* MovieScene;
};

// Size: 0x1c0
class UTestMovieSceneSubSection : public UMovieSceneSubSection {
};

// Size: 0xf8
class UTestMovieSceneSubTrack : public UMovieSceneSubTrack {
    /* 0x00e8 */ TArray<UMovieSceneSection*> SectionArray;
};

// Size: 0xe0
class UTestMovieSceneTrack : public UMovieSceneTrack {
    /* 0x00c8 */ bool bHighPassFilter;
    /* 0x00d0 */ TArray<UMovieSceneSection*> SectionArray;
};

// Size: 0x10
struct FTrackInstanceInputComponent {
    /* 0x0000 */ UMovieSceneSection* Section;
    /* 0x0008 */ int32_t OutputIndex;
};

// Size: 0x8
struct FCaptureResolution {
    /* 0x0000 */ int32_t ResX;
    /* 0x0004 */ int32_t ResY;
};

// Size: 0x10
struct FCapturedPixels {
};

// Size: 0x50
struct FCapturedPixelsID {
    /* 0x0000 */ TMap<FName, FName> Identifiers;
};

// Size: 0x10
struct FCompositionGraphCapturePasses {
    /* 0x0000 */ TArray<FString> Value;
};

// Size: 0xd0
class UCompositionGraphCaptureProtocol : public UMovieSceneImageCaptureProtocolBase {
    /* 0x0060 */ FCompositionGraphCapturePasses IncludeRenderPasses;
    /* 0x0070 */ bool bCaptureFramesInHDR;
    /* 0x0074 */ int32_t HDRCompressionQuality;
    /* 0x0078 */ uint8_t CaptureGamut;
    /* 0x0080 */ FSoftObjectPath PostProcessingMaterial;
    /* 0x00a0 */ bool bDisableScreenPercentage;
    /* 0x00a8 */ UMaterialInterface* PostProcessingMaterialPtr;
};

// Size: 0xe8
class UCompressedImageSequenceProtocol : public UImageSequenceProtocol {
    /* 0x00e0 */ int32_t CompressionQuality;
};

enum class EHDRCaptureGamut {
    HCGM_Rec709 = 0,
    HCGM_P3DCI = 1,
    HCGM_Rec2020 = 2,
    HCGM_ACES = 3,
    HCGM_ACEScg = 4,
    HCGM_Linear = 5,
    HCGM_MAX = 6,
};

enum class EMovieSceneCaptureProtocolState {
    Idle = 0,
    Initialized = 1,
    Capturing = 2,
    Finalizing = 3,
    EMovieSceneCaptureProtocolState_MAX = 4,
};

// Size: 0x70
class UFrameGrabberProtocol : public UMovieSceneImageCaptureProtocolBase {
};

// Size: 0x10
struct FFrameMetrics {
    /* 0x0000 */ float TotalElapsedTime;
    /* 0x0004 */ float FrameDelta;
    /* 0x0008 */ int32_t FrameNumber;
    /* 0x000c */ int32_t NumDroppedFrames;
};

// Size: 0xe0
class UImageSequenceProtocol : public UFrameGrabberProtocol {
};

// Size: 0xe0
class UImageSequenceProtocol_BMP : public UImageSequenceProtocol {
};

// Size: 0xf0
class UImageSequenceProtocol_EXR : public UImageSequenceProtocol {
    /* 0x00e0 */ bool bCompressed;
    /* 0x00e1 */ uint8_t CaptureGamut;
};

// Size: 0xe8
class UImageSequenceProtocol_JPG : public UCompressedImageSequenceProtocol {
};

// Size: 0xe8
class UImageSequenceProtocol_PNG : public UCompressedImageSequenceProtocol {
};

// Size: 0x258
class ULevelCapture : public UMovieSceneCapture {
    /* 0x0238 */ bool bAutoStartCapture;
    /* 0x0244 */ FGuid PrerequisiteActorId;
};

// Size: 0x98
class UMasterAudioSubmixCaptureProtocol : public UMovieSceneAudioCaptureProtocolBase {
    /* 0x0060 */ FString Filename;
};

// Size: 0x60
class UMovieSceneAudioCaptureProtocolBase : public UMovieSceneCaptureProtocolBase {
};

// Size: 0x238
class UMovieSceneCapture : public UObject {
    /* 0x0040 */ FSoftClassPath ImageCaptureProtocolType;
    /* 0x0060 */ FSoftClassPath AudioCaptureProtocolType;
    /* 0x0080 */ UMovieSceneImageCaptureProtocolBase* ImageCaptureProtocol;
    /* 0x0088 */ UMovieSceneAudioCaptureProtocolBase* AudioCaptureProtocol;
    /* 0x0090 */ FMovieSceneCaptureSettings Settings;
    /* 0x0100 */ bool bUseSeparateProcess;
    /* 0x0101 */ bool bCloseEditorWhenCaptureStarts;
    /* 0x0108 */ FString AdditionalCommandLineArguments;
    /* 0x0118 */ FString InheritedCommandLineArguments;

    UMovieSceneCaptureProtocolBase* GetAudioCaptureProtocol();
    UMovieSceneCaptureProtocolBase* GetImageCaptureProtocol();
    void SetAudioCaptureProtocolType(UClass* ProtocolType);
    void SetImageCaptureProtocolType(UClass* ProtocolType);
};

// Size: 0x30
class UMovieSceneCaptureEnvironment : public UObject {

    static UMovieSceneAudioCaptureProtocolBase* FindAudioCaptureProtocol();
    static UMovieSceneImageCaptureProtocolBase* FindImageCaptureProtocol();
    static float GetCaptureElapsedTime();
    static int32_t GetCaptureFrameNumber();
    static bool IsCaptureInProgress();
};

// Size: 0x30
class IMovieSceneCaptureInterface : public UInterface {
};

// Size: 0x60
class UMovieSceneCaptureProtocolBase : public UObject {
    /* 0x0058 */ EMovieSceneCaptureProtocolState State;

    EMovieSceneCaptureProtocolState GetState() const;
    bool IsCapturing() const;
};

// Size: 0x70
struct FMovieSceneCaptureSettings {
    /* 0x0000 */ FDirectoryPath OutputDirectory;
    /* 0x0010 */ UClass* GameModeOverride;
    /* 0x0018 */ FString OutputFormat;
    /* 0x0028 */ bool bOverwriteExisting;
    /* 0x0029 */ bool bUseRelativeFrameNumbers;
    /* 0x002c */ int32_t HandleFrames;
    /* 0x0030 */ FString MovieExtension;
    /* 0x0040 */ uint8_t ZeroPadFrameNumbers;
    /* 0x0044 */ FFrameRate FrameRate;
    /* 0x004c */ bool bUseCustomFrameRate;
    /* 0x0050 */ FFrameRate CustomFrameRate;
    /* 0x0058 */ FCaptureResolution Resolution;
    /* 0x0060 */ bool bEnableTextureStreaming;
    /* 0x0061 */ bool bCinematicEngineScalability;
    /* 0x0062 */ bool bCinematicMode;
    /* 0x0063 */ bool bAllowMovement;
    /* 0x0064 */ bool bAllowTurning;
    /* 0x0065 */ bool bShowPlayer;
    /* 0x0066 */ bool bShowHUD;
    /* 0x0067 */ bool bUsePathTracer;
    /* 0x0068 */ int32_t PathTracerSamplePerPixel;
};

// Size: 0x60
class UMovieSceneImageCaptureProtocolBase : public UMovieSceneCaptureProtocolBase {
};

// Size: 0x60
class UNullAudioCaptureProtocol : public UMovieSceneAudioCaptureProtocolBase {
};

// Size: 0xe0
class UUserDefinedCaptureProtocol : public UMovieSceneImageCaptureProtocolBase {
    /* 0x0060 */ UWorld* World;

    FString GenerateFilename(const FFrameMetrics& InFrameMetrics) const;
    FFrameMetrics GetCurrentFrameMetrics() const;
    void OnBeginFinalize();
    bool OnCanFinalize() const;
    void OnCaptureFrame();
    void OnFinalize();
    void OnPauseCapture();
    void OnPixelsReceived(const FCapturedPixels& Pixels, const FCapturedPixelsID& ID, FFrameMetrics FrameMetrics);
    void OnPreTick();
    bool OnSetup();
    void OnStartCapture();
    void OnTick();
    void OnWarmUp();
    void ResolveBuffer(UTexture* Buffer, const FCapturedPixelsID& BufferID);
    void StartCapturingFinalPixels(const FCapturedPixelsID& StreamID);
    void StopCapturingFinalPixels();
};

// Size: 0xe8
class UUserDefinedImageCaptureProtocol : public UUserDefinedCaptureProtocol {
    /* 0x00e0 */ EDesiredImageFormat Format;
    /* 0x00e1 */ bool bEnableCompression;
    /* 0x00e4 */ int32_t CompressionQuality;

    FString GenerateFilenameForBuffer(UTexture* Buffer, const FCapturedPixelsID& StreamID);
    FString GenerateFilenameForCurrentFrame();
    void WriteImageToDisk(const FCapturedPixels& PixelData, const FCapturedPixelsID& StreamID, const FFrameMetrics& FrameMetrics, bool bCopyImageData);
};

// Size: 0x88
class UVideoCaptureProtocol : public UFrameGrabberProtocol {
    /* 0x0070 */ bool bUseCompression;
    /* 0x0074 */ float CompressionQuality;
};

// Size: 0x3e8
class UAutomatedLevelSequenceCapture : public UMovieSceneCapture {
    /* 0x0238 */ FSoftObjectPath LevelSequenceAsset;
    /* 0x0258 */ FString ShotName;
    /* 0x0268 */ bool bUseCustomStartFrame;
    /* 0x026c */ FFrameNumber CustomStartFrame;
    /* 0x0270 */ bool bUseCustomEndFrame;
    /* 0x0274 */ FFrameNumber CustomEndFrame;
    /* 0x0278 */ int32_t WarmUpFrameCount;
    /* 0x027c */ float DelayBeforeWarmUp;
    /* 0x0280 */ float DelayBeforeShotWarmUp;
    /* 0x0284 */ float DelayEveryFrame;
    /* 0x0288 */ ULevelSequenceBurnInOptions* BurnInOptions;
    /* 0x0290 */ bool bWriteEditDecisionList;
    /* 0x0291 */ bool bWriteFinalCutProXML;
    /* 0x02a0 */ TWeakObjectPtr<ALevelSequenceActor> LevelSequenceActor;
};

// Size: 0x78
class UBoolChannelKeyProxy : public UObject {
    /* 0x0040 */ FFrameNumber Time;
    /* 0x0044 */ bool bValue;
};

// Size: 0x20
struct FControlFindReplaceString {
    /* 0x0000 */ FString Find;
    /* 0x0010 */ FString Replace;
};

// Size: 0x3
struct FControlToTransformMappings {
    /* 0x0000 */ FControlRigChannelEnum ControlChannel;
    /* 0x0001 */ FTransformChannelEnum FBXChannel;
    /* 0x0002 */ bool bNegate;
};

enum class EThumbnailQuality {
    Draft = 0,
    Normal = 1,
    Best = 2,
    EThumbnailQuality_MAX = 3,
};

enum class FControlRigChannelEnum {
    Bool = 0,
    Enum = 1,
    Integer = 2,
    Float = 3,
    Vector2DX = 4,
    Vector2DY = 5,
    PositionX = 6,
    PositionY = 7,
    PositionZ = 8,
    RotatorX = 9,
    RotatorY = 10,
    RotatorZ = 11,
    ScaleX = 12,
    ScaleY = 13,
    ScaleZ = 14,
    FControlRigChannelEnum_MAX = 15,
};

enum class FTransformChannelEnum {
    TranslateX = 0,
    TranslateY = 1,
    TranslateZ = 2,
    RotateX = 3,
    RotateY = 4,
    RotateZ = 5,
    ScaleX = 6,
    ScaleY = 7,
    ScaleZ = 8,
    FTransformChannelEnum_MAX = 9,
};

// Size: 0x90
class UFloatChannelKeyProxy : public UObject {
    /* 0x0040 */ FFrameNumber Time;
    /* 0x0044 */ FMovieSceneFloatValue Value;
};

// Size: 0x78
class UIntegerChannelKeyProxy : public UObject {
    /* 0x0040 */ FFrameNumber Time;
    /* 0x0044 */ int32_t Value;
};

// Size: 0x270
class UK2Node_GetSequenceBinding : public UK2Node {
    /* 0x00c8 */ FSoftObjectPath SourceSequence;
    /* 0x00e8 */ FMovieSceneObjectBindingID Binding;
};

// Size: 0x40
class UMovieSceneEventBlueprintExtension : public UBlueprintExtension {
    /* 0x0030 */ TArray<UMovieSceneEventSectionBase*> EventSections;
};

// Size: 0x30
struct FMovieSceneToolsFbxSettings {
    /* 0x0000 */ FString FbxPropertyName;
    /* 0x0010 */ FMovieSceneToolsPropertyTrackSettings PropertyPath;
};

// Size: 0xa0
class UMovieSceneToolsProjectSettings : public UObject {
    /* 0x0030 */ float DefaultStartTime;
    /* 0x0034 */ float DefaultDuration;
    /* 0x0038 */ FString ShotDirectory;
    /* 0x0048 */ FString ShotPrefix;
    /* 0x0058 */ uint32_t FirstShotNumber;
    /* 0x005c */ uint32_t ShotIncrement;
    /* 0x0060 */ uint32_t ShotNumDigits;
    /* 0x0064 */ uint32_t TakeNumDigits;
    /* 0x0068 */ uint32_t FirstTakeNumber;
    /* 0x0070 */ FString TakeSeparator;
    /* 0x0080 */ FString SubSequenceSeparator;
    /* 0x0090 */ TArray<FMovieSceneToolsFbxSettings> FbxSettings;
};

// Size: 0x20
struct FMovieSceneToolsPropertyTrackSettings {
    /* 0x0000 */ FString ComponentName;
    /* 0x0010 */ FString PropertyName;
};

// Size: 0xa8
class UMovieSceneUserImportFBXControlRigSettings : public UObject {
    /* 0x0030 */ FString ImportedFileName;
    /* 0x0040 */ FFrameNumber ImportedStartTime;
    /* 0x0044 */ FFrameNumber ImportedEndTime;
    /* 0x0048 */ TArray<FString> ImportedNodeNames;
    /* 0x0058 */ FString ImportedFrameRate;
    /* 0x0068 */ TArray<FControlFindReplaceString> FindAndReplaceStrings;
    /* 0x0078 */ bool bForceFrontXAxis;
    /* 0x0079 */ bool bConvertSceneUnit;
    /* 0x007c */ float ImportUniformScale;
    /* 0x0080 */ bool bImportOntoSelectedControls;
    /* 0x0084 */ FFrameNumber TimeToInsertOrReplaceAnimation;
    /* 0x0088 */ bool bInsertAnimation;
    /* 0x0089 */ bool bSpecifyTimeRange;
    /* 0x008c */ FFrameNumber StartTimeRange;
    /* 0x0090 */ FFrameNumber EndTimeRange;
    /* 0x0098 */ TArray<FControlToTransformMappings> ControlChannelMappings;
};

// Size: 0x40
class UMovieSceneUserImportFBXSettings : public UObject {
    /* 0x0030 */ bool bMatchByNameOnly;
    /* 0x0031 */ bool bForceFrontXAxis;
    /* 0x0032 */ bool bConvertSceneUnit;
    /* 0x0034 */ float ImportUniformScale;
    /* 0x0038 */ bool bCreateCameras;
    /* 0x0039 */ bool bReplaceTransformTrack;
    /* 0x003a */ bool bReduceKeys;
    /* 0x003c */ float ReduceKeysTolerance;
};

// Size: 0x58
class UMovieSceneUserThumbnailSettings : public UObject {
    /* 0x0030 */ bool bDrawThumbnails;
    /* 0x0031 */ bool bDrawSingleThumbnails;
    /* 0x0034 */ FIntPoint ThumbnailSize;
    /* 0x003c */ EThumbnailQuality Quality;
};

// Size: 0xa0
struct FBoolParameterNameAndCurve {
    /* 0x0000 */ FName ParameterName;
    /* 0x0010 */ FMovieSceneBoolChannel ParameterCurve;
};

// Size: 0x50
class UByteChannelEvaluatorSystem : public UMovieSceneEntitySystem {
};

// Size: 0x290
struct FColorParameterNameAndCurves {
    /* 0x0000 */ FName ParameterName;
    /* 0x0010 */ FMovieSceneFloatChannel RedCurve;
    /* 0x00b0 */ FMovieSceneFloatChannel GreenCurve;
    /* 0x0150 */ FMovieSceneFloatChannel BlueCurve;
    /* 0x01f0 */ FMovieSceneFloatChannel AlphaCurve;
};

enum class EFireEventsAtPosition {
    AtStartOfEvaluation = 0,
    AtEndOfEvaluation = 1,
    AfterSpawn = 2,
    EFireEventsAtPosition_MAX = 3,
};

enum class ELevelVisibility {
    Visible = 0,
    Hidden = 1,
    ELevelVisibility_MAX = 2,
};

enum class EParticleKey {
    Activate = 0,
    Deactivate = 1,
    Trigger = 2,
    EParticleKey_MAX = 3,
};

enum class EShow3DTrajectory {
    EST_OnlyWhenSelected = 0,
    EST_Always = 1,
    EST_Never = 2,
    EST_MAX = 3,
};

// Size: 0x40
struct FEventPayload {
    /* 0x0000 */ FName EventName;
    /* 0x0010 */ FMovieSceneEventParameters Parameters;
};

// Size: 0x50
class UFloatChannelEvaluatorSystem : public UMovieSceneEntitySystem {
};

// Size: 0x50
class UIntegerChannelEvaluatorSystem : public UMovieSceneEntitySystem {
};

// Size: 0x8
struct FLevelVisibilityComponentData {
    /* 0x0000 */ UMovieSceneLevelVisibilitySection* Section;
};

// Size: 0x1b8
class UMovieScene3DAttachSection : public UMovieScene3DConstraintSection {
    /* 0x0160 */ FName AttachSocketName;
    /* 0x016c */ FName AttachComponentName;
    /* 0x0178 */ bool bFullRevertOnDetach;
    /* 0x0180 */ TSoftObjectPtr<AActor> ReAttachOnDetach;
    /* 0x01b0 */ EAttachmentRule AttachmentLocationRule;
    /* 0x01b1 */ EAttachmentRule AttachmentRotationRule;
    /* 0x01b2 */ EAttachmentRule AttachmentScaleRule;
    /* 0x01b3 */ EDetachmentRule DetachmentLocationRule;
    /* 0x01b4 */ EDetachmentRule DetachmentRotationRule;
    /* 0x01b5 */ EDetachmentRule DetachmentScaleRule;
};

// Size: 0xd0
class UMovieScene3DAttachTrack : public UMovieScene3DConstraintTrack {
};

// Size: 0x158
class UMovieScene3DConstraintSection : public UMovieSceneSection {
    /* 0x0128 */ FGuid ConstraintId;
    /* 0x0138 */ FMovieSceneObjectBindingID ConstraintBindingID;

    FMovieSceneObjectBindingID GetConstraintBindingID() const;
    void SetConstraintBindingID(const FMovieSceneObjectBindingID& InConstraintBindingID);
};

// Size: 0xd0
class UMovieScene3DConstraintTrack : public UMovieSceneTrack {
    /* 0x00c0 */ TArray<UMovieSceneSection*> ConstraintSections;
};

// Size: 0x30
struct FMovieScene3DLocationKeyStruct : public FMovieSceneKeyStruct {
    /* 0x0008 */ FVector Location;
    /* 0x0014 */ FFrameNumber Time;
};

// Size: 0x200
class UMovieScene3DPathSection : public UMovieScene3DConstraintSection {
    /* 0x0158 */ FMovieSceneFloatChannel TimingCurve;
    /* 0x01f8 */ MovieScene3DPathSection_Axis FrontAxisEnum;
    /* 0x01f9 */ MovieScene3DPathSection_Axis UpAxisEnum;
    /* 0x01fc */ bool bFollow;
    /* 0x01fc */ bool bReverse;
    /* 0x01fc */ bool bForceUpright;
};

// Size: 0xe8
struct FMovieScene3DPathSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneObjectBindingID PathBindingID;
    /* 0x0040 */ FMovieSceneFloatChannel TimingCurve;
    /* 0x00e0 */ MovieScene3DPathSection_Axis FrontAxisEnum;
    /* 0x00e1 */ MovieScene3DPathSection_Axis UpAxisEnum;
    /* 0x00e4 */ bool bFollow;
    /* 0x00e4 */ bool bReverse;
    /* 0x00e4 */ bool bForceUpright;
};

enum class MovieScene3DPathSection_Axis {
    X = 0,
    Y = 1,
    Z = 2,
    NEG_X = 3,
    NEG_Y = 4,
    NEG_Z = 5,
    MovieScene3DPathSection_MAX = 6,
};

// Size: 0xd8
class UMovieScene3DPathTrack : public UMovieScene3DConstraintTrack {
};

// Size: 0x30
struct FMovieScene3DRotationKeyStruct : public FMovieSceneKeyStruct {
    /* 0x0008 */ FRotator Rotation;
    /* 0x0014 */ FFrameNumber Time;
};

// Size: 0x30
struct FMovieScene3DScaleKeyStruct : public FMovieSceneKeyStruct {
    /* 0x0008 */ FVector Scale;
    /* 0x0014 */ FFrameNumber Time;
};

// Size: 0x48
struct FMovieScene3DTransformKeyStruct : public FMovieSceneKeyStruct {
    /* 0x0008 */ FVector Location;
    /* 0x0014 */ FRotator Rotation;
    /* 0x0020 */ FVector Scale;
    /* 0x002c */ FFrameNumber Time;
};

// Size: 0x68
class UMovieScene3DTransformPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x780
class UMovieScene3DTransformSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieSceneTransformMask TransformMask;
    /* 0x0138 */ FMovieSceneFloatChannel Translation[3];
    /* 0x0318 */ FMovieSceneFloatChannel Rotation[3];
    /* 0x04f8 */ FMovieSceneFloatChannel Scale[3];
    /* 0x06d8 */ FMovieSceneFloatChannel ManualWeight;
    /* 0x0778 */ bool bUseQuaternionInterpolation;
    /* 0x0779 */ EShow3DTrajectory Show3DTrajectory;
};

// Size: 0x138
class UMovieScene3DTransformTrack : public UMovieScenePropertyTrack {
};

// Size: 0xc0
struct FMovieSceneActorReferenceData : public FMovieSceneChannel {
    /* 0x0008 */ TArray<FFrameNumber> KeyTimes;
    /* 0x0018 */ FMovieSceneActorReferenceKey DefaultValue;
    /* 0x0050 */ TArray<FMovieSceneActorReferenceKey> KeyValues;
};

// Size: 0x34
struct FMovieSceneActorReferenceKey {
    /* 0x0000 */ FMovieSceneObjectBindingID Object;
    /* 0x001c */ FName ComponentName;
    /* 0x0028 */ FName SocketName;
};

// Size: 0x278
class UMovieSceneActorReferenceSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneActorReferenceData ActorReferenceData;
    /* 0x01e8 */ FIntegralCurve ActorGuidIndexCurve;
    /* 0x0268 */ TArray<FString> ActorGuidStrings;
};

// Size: 0x100
struct FMovieSceneActorReferenceSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieScenePropertySectionData PropertyData;
    /* 0x0040 */ FMovieSceneActorReferenceData ActorReferenceData;
};

// Size: 0x140
class UMovieSceneActorReferenceTrack : public UMovieScenePropertyTrack {
};

// Size: 0x390
class UMovieSceneAudioSection : public UMovieSceneSection {
    /* 0x0128 */ USoundBase* Sound;
    /* 0x0130 */ FFrameNumber StartFrameOffset;
    /* 0x0134 */ float StartOffset;
    /* 0x0138 */ float AudioStartTime;
    /* 0x013c */ float AudioDilationFactor;
    /* 0x0140 */ float AudioVolume;
    /* 0x0148 */ FMovieSceneFloatChannel SoundVolume;
    /* 0x01e8 */ FMovieSceneFloatChannel PitchMultiplier;
    /* 0x0288 */ FMovieSceneActorReferenceData AttachActorData;
    /* 0x0348 */ bool bLooping;
    /* 0x0349 */ bool bSuppressSubtitles;
    /* 0x034a */ bool bOverrideAttenuation;
    /* 0x0350 */ USoundAttenuation* AttenuationSettings;
    /* 0x0358 */ FDelegate OnQueueSubtitles;
    /* 0x0370 */ FMulticastInlineDelegate OnAudioFinished;
    /* 0x0380 */ FMulticastInlineDelegate OnAudioPlaybackPercent;

    USoundBase* GetSound() const;
    FFrameNumber GetStartOffset() const;
    void SetSound(USoundBase* InSound);
    void SetStartOffset(FFrameNumber InStartOffset);
};

// Size: 0x28
struct FMovieSceneAudioSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ UMovieSceneAudioSection* AudioSection;
};

// Size: 0xf8
class UMovieSceneAudioTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> AudioSections;
    /* 0x00f0 */ int32_t RowHeight;
};

// Size: 0x50
class UMovieSceneBaseValueEvaluatorSystem : public UMovieSceneEntitySystem {
};

// Size: 0xd0
struct FMovieSceneBoolPropertySectionTemplate : public FMovieScenePropertySectionTemplate {
    /* 0x0040 */ FMovieSceneBoolChannel BoolCurve;
};

// Size: 0x68
class UMovieSceneBoolPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x140
class UMovieSceneBoolTrack : public UMovieScenePropertyTrack {
};

// Size: 0x68
class UMovieSceneBytePropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x1c8
class UMovieSceneByteSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieSceneByteChannel ByteCurve;
};

// Size: 0x140
class UMovieSceneByteTrack : public UMovieScenePropertyTrack {
    /* 0x0138 */ UEnum* Enum;
};

// Size: 0x168
class UMovieSceneCameraAnimSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneCameraAnimSectionData AnimData;
    /* 0x0148 */ UCameraAnim* CameraAnim;
    /* 0x0150 */ float PlayRate;
    /* 0x0154 */ float PlayScale;
    /* 0x0158 */ float BlendInTime;
    /* 0x015c */ float BlendOutTime;
    /* 0x0160 */ bool bLooping;
};

// Size: 0x20
struct FMovieSceneCameraAnimSectionData {
    /* 0x0000 */ UCameraAnim* CameraAnim;
    /* 0x0008 */ float PlayRate;
    /* 0x000c */ float PlayScale;
    /* 0x0010 */ float BlendInTime;
    /* 0x0014 */ float BlendOutTime;
    /* 0x0018 */ bool bLooping;
};

// Size: 0x48
struct FMovieSceneCameraAnimSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneCameraAnimSectionData SourceData;
    /* 0x0040 */ FFrameNumber SectionStartTime;
};

// Size: 0xf0
class UMovieSceneCameraAnimTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> CameraAnimSections;
};

// Size: 0x1a0
class UMovieSceneCameraCutSection : public UMovieSceneSection {
    /* 0x0130 */ bool bLockPreviousCamera;
    /* 0x0134 */ FGuid CameraGuid;
    /* 0x0144 */ FMovieSceneObjectBindingID CameraBindingID;
    /* 0x0160 */ FTransform InitialCameraCutTransform;
    /* 0x0190 */ bool bHasInitialCameraCutTransform;
    /* 0x0194 */ float ThumbnailReferenceOffset;

    FMovieSceneObjectBindingID GetCameraBindingID() const;
    void SetCameraBindingID(const FMovieSceneObjectBindingID& InCameraBindingID);
};

// Size: 0xf0
class UMovieSceneCameraCutTrack : public UMovieSceneNameableTrack {
    /* 0x00d8 */ bool bCanBlend;
    /* 0x00e0 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0xc0
class UMovieSceneCameraCutTrackInstance : public UMovieSceneTrackInstance {
};

// Size: 0x30
class UMovieSceneCameraShakeEvaluator : public UObject {
};

// Size: 0x168
class UMovieSceneCameraShakeSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneCameraShakeSectionData ShakeData;
    /* 0x0148 */ UClass* ShakeClass;
    /* 0x0150 */ float PlayScale;
    /* 0x0154 */ ECameraShakePlaySpace PlaySpace;
    /* 0x0158 */ FRotator UserDefinedPlaySpace;
};

// Size: 0x20
struct FMovieSceneCameraShakeSectionData {
    /* 0x0000 */ UClass* ShakeClass;
    /* 0x0008 */ float PlayScale;
    /* 0x000c */ ECameraShakePlaySpace PlaySpace;
    /* 0x0010 */ FRotator UserDefinedPlaySpace;
};

// Size: 0x48
struct FMovieSceneCameraShakeSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneCameraShakeSectionData SourceData;
    /* 0x0040 */ FFrameNumber SectionStartTime;
};

// Size: 0x148
class UMovieSceneCameraShakeSourceShakeSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneCameraShakeSectionData ShakeData;
};

// Size: 0x48
struct FMovieSceneCameraShakeSourceShakeSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneCameraShakeSectionData SourceData;
    /* 0x0040 */ FFrameNumber SectionStartTime;
    /* 0x0044 */ FFrameNumber SectionEndTime;
};

// Size: 0xf0
class UMovieSceneCameraShakeSourceShakeTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> CameraShakeSections;
};

// Size: 0x20
struct FMovieSceneCameraShakeSourceTrigger {
    /* 0x0000 */ UClass* ShakeClass;
    /* 0x0008 */ float PlayScale;
    /* 0x000c */ ECameraShakePlaySpace PlaySpace;
    /* 0x0010 */ FRotator UserDefinedPlaySpace;
};

// Size: 0x88
struct FMovieSceneCameraShakeSourceTriggerChannel : public FMovieSceneChannel {
    /* 0x0008 */ TArray<FFrameNumber> KeyTimes;
    /* 0x0018 */ TArray<FMovieSceneCameraShakeSourceTrigger> KeyValues;
};

// Size: 0x1b0
class UMovieSceneCameraShakeSourceTriggerSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneCameraShakeSourceTriggerChannel Channel;
};

// Size: 0x40
struct FMovieSceneCameraShakeSourceTriggerSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ TArray<FFrameNumber> TriggerTimes;
    /* 0x0030 */ TArray<FMovieSceneCameraShakeSourceTrigger> TriggerValues;
};

// Size: 0xd8
class UMovieSceneCameraShakeSourceTriggerTrack : public UMovieSceneTrack {
    /* 0x00c8 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0xf0
class UMovieSceneCameraShakeTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> CameraShakeSections;
};

// Size: 0x1f0
class UMovieSceneCinematicShotSection : public UMovieSceneSubSection {
    /* 0x01c0 */ FString ShotDisplayName;
    /* 0x01d0 */ FText DisplayName;
    /* 0x01e8 */ float ThumbnailReferenceOffset;

    FString GetShotDisplayName() const;
    void SetShotDisplayName(FString InShotDisplayName);
};

// Size: 0xe8
class UMovieSceneCinematicShotTrack : public UMovieSceneSubTrack {
};

// Size: 0x38
struct FMovieSceneColorKeyStruct : public FMovieSceneKeyStruct {
    /* 0x0008 */ FLinearColor Color;
    /* 0x0018 */ FFrameNumber Time;
};

// Size: 0x68
class UMovieSceneColorPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x3b0
class UMovieSceneColorSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieSceneFloatChannel RedCurve;
    /* 0x01d0 */ FMovieSceneFloatChannel GreenCurve;
    /* 0x0270 */ FMovieSceneFloatChannel BlueCurve;
    /* 0x0310 */ FMovieSceneFloatChannel AlphaCurve;
};

// Size: 0x2c8
struct FMovieSceneColorSectionTemplate : public FMovieScenePropertySectionTemplate {
    /* 0x0040 */ FMovieSceneFloatChannel Curves[4];
    /* 0x02c0 */ EMovieSceneBlendType BlendType;
};

// Size: 0x140
class UMovieSceneColorTrack : public UMovieScenePropertyTrack {
    /* 0x0138 */ bool bIsSlateColor;
};

// Size: 0x50
class UMovieSceneComponentAttachmentInvalidatorSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x1d0
class UMovieSceneComponentAttachmentSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x88
struct FMovieSceneComponentMaterialSectionTemplate : public FMovieSceneParameterSectionTemplate {
    /* 0x0080 */ int32_t MaterialIndex;
};

// Size: 0xf8
class UMovieSceneComponentMaterialTrack : public UMovieSceneMaterialTrack {
    /* 0x00f0 */ int32_t MaterialIndex;
};

// Size: 0x230
class UMovieSceneComponentMobilitySystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x68
class UMovieSceneComponentTransformSystem : public UMovieScenePropertySystem {
};

// Size: 0x68
class UMovieSceneDeferredComponentMovementSystem : public UMovieSceneEntitySystem {
};

// Size: 0x68
class UMovieSceneEnumPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x1c8
class UMovieSceneEnumSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieSceneByteChannel EnumCurve;
};

// Size: 0x140
class UMovieSceneEnumTrack : public UMovieScenePropertyTrack {
    /* 0x0138 */ UEnum* Enum;
};

// Size: 0x68
class UMovieSceneEulerTransformPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x138
class UMovieSceneEulerTransformTrack : public UMovieScenePropertyTrack {
};

// Size: 0xd0
struct FMovieSceneEvent {
    /* 0x0000 */ FMovieSceneEventPtrs Ptrs;
    /* 0x0038 */ TMap<FName, FMovieSceneEventPayloadVariable> PayloadVariables;
    /* 0x0088 */ FName CompiledFunctionName;
    /* 0x0094 */ FName BoundObjectPinName;
    /* 0x00a0 */ TWeakObjectPtr<UObject> WeakEndpoint;
    /* 0x00a8 */ FGuid GraphGuid;
    /* 0x00b8 */ FGuid NodeGuid;
    /* 0x00c8 */ TWeakObjectPtr<UObject> FunctionEntry;
};

// Size: 0x88
struct FMovieSceneEventChannel : public FMovieSceneChannel {
    /* 0x0008 */ TArray<FFrameNumber> KeyTimes;
    /* 0x0018 */ TArray<FMovieSceneEvent> KeyValues;
};

// Size: 0x30
struct FMovieSceneEventParameters {
};

// Size: 0x10
struct FMovieSceneEventPayloadVariable {
    /* 0x0000 */ FString Value;
};

// Size: 0x38
struct FMovieSceneEventPtrs {
    /* 0x0000 */ UFunction* Function;
    /* 0x0008 */ FFieldPath BoundObjectProperty;
};

// Size: 0x208
class UMovieSceneEventRepeaterSection : public UMovieSceneEventSectionBase {
    /* 0x0138 */ FMovieSceneEvent Event;
};

// Size: 0x238
class UMovieSceneEventSection : public UMovieSceneSection {
    /* 0x0128 */ FNameCurve Events;
    /* 0x01a0 */ FMovieSceneEventSectionData EventData;
};

// Size: 0x130
class UMovieSceneEventSectionBase : public UMovieSceneSection {
};

// Size: 0x98
struct FMovieSceneEventSectionData : public FMovieSceneChannel {
    /* 0x0008 */ TArray<FFrameNumber> Times;
    /* 0x0018 */ TArray<FEventPayload> KeyValues;
    /* 0x0088 */ TArray<float> KeyTimes;
};

// Size: 0xc0
struct FMovieSceneEventSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneEventSectionData EventData;
    /* 0x00b8 */ bool bFireEventsWhenForwards;
    /* 0x00b8 */ bool bFireEventsWhenBackwards;
};

// Size: 0xa0
class UMovieSceneEventSystem : public UMovieSceneEntitySystem {
};

// Size: 0x100
class UMovieSceneEventTrack : public UMovieSceneNameableTrack {
    /* 0x00e8 */ bool bFireEventsWhenForwards;
    /* 0x00e8 */ bool bFireEventsWhenBackwards;
    /* 0x00ec */ EFireEventsAtPosition EventPosition;
    /* 0x00f0 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0x58
struct FMovieSceneEventTriggerData {
    /* 0x0000 */ FMovieSceneEventPtrs Ptrs;
    /* 0x0038 */ FGuid ObjectBindingID;
};

// Size: 0x1c0
class UMovieSceneEventTriggerSection : public UMovieSceneEventSectionBase {
    /* 0x0138 */ FMovieSceneEventChannel EventChannel;
};

// Size: 0x1e0
class UMovieSceneFadeSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneFloatChannel FloatCurve;
    /* 0x01c8 */ FLinearColor FadeColor;
    /* 0x01d8 */ bool bFadeAudio;
};

// Size: 0xd8
struct FMovieSceneFadeSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneFloatChannel FadeCurve;
    /* 0x00c0 */ FLinearColor FadeColor;
    /* 0x00d0 */ bool bFadeAudio;
};

// Size: 0x140
class UMovieSceneFadeTrack : public UMovieSceneFloatTrack {
};

// Size: 0x68
class UMovieSceneFloatPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x1d0
class UMovieSceneFloatSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieSceneFloatChannel FloatCurve;
};

// Size: 0x138
class UMovieSceneFloatTrack : public UMovieScenePropertyTrack {
};

// Size: 0x50
class UMovieSceneHierarchicalBiasSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0xa0
class UMovieSceneHierarchicalEasingInstantiatorSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x50
class UMovieSceneInitialValueSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x68
class UMovieSceneIntegerPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x1c0
class UMovieSceneIntegerSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieSceneIntegerChannel IntegerCurve;
};

// Size: 0x138
class UMovieSceneIntegerTrack : public UMovieScenePropertyTrack {
};

// Size: 0x1f8
class UMovieSceneInterrogatedPropertyInstantiatorSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x148
class UMovieSceneLevelVisibilitySection : public UMovieSceneSection {
    /* 0x0130 */ ELevelVisibility Visibility;
    /* 0x0138 */ TArray<FName> LevelNames;

    TArray<FName> GetLevelNames() const;
    ELevelVisibility GetVisibility() const;
    void SetLevelNames(const TArray<FName>& InLevelNames);
    void SetVisibility(ELevelVisibility InVisibility);
};

// Size: 0x1d8
class UMovieSceneLevelVisibilitySystem : public UMovieSceneEntitySystem {
};

// Size: 0xe8
class UMovieSceneLevelVisibilityTrack : public UMovieSceneNameableTrack {
    /* 0x00d8 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0x88
struct FMovieSceneMaterialParameterCollectionTemplate : public FMovieSceneParameterSectionTemplate {
    /* 0x0080 */ UMaterialParameterCollection* MPC;
};

// Size: 0xf8
class UMovieSceneMaterialParameterCollectionTrack : public UMovieSceneMaterialTrack {
    /* 0x00f0 */ UMaterialParameterCollection* MPC;
};

// Size: 0xe8
class UMovieSceneMaterialTrack : public UMovieSceneNameableTrack {
    /* 0x00d8 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0xa8
class UMovieSceneMotionVectorSimulationSystem : public UMovieSceneEntitySystem {
};

// Size: 0x1f0
class UMovieSceneObjectPropertySection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneObjectPathChannel ObjectChannel;
};

// Size: 0x108
struct FMovieSceneObjectPropertyTemplate : public FMovieScenePropertySectionTemplate {
    /* 0x0040 */ FMovieSceneObjectPathChannel ObjectChannel;
};

// Size: 0x148
class UMovieSceneObjectPropertyTrack : public UMovieScenePropertyTrack {
    /* 0x0140 */ UClass* PropertyClass;
};

// Size: 0x188
class UMovieSceneParameterSection : public UMovieSceneSection {
    /* 0x0128 */ TArray<FBoolParameterNameAndCurve> BoolParameterNamesAndCurves;
    /* 0x0138 */ TArray<FScalarParameterNameAndCurve> ScalarParameterNamesAndCurves;
    /* 0x0148 */ TArray<FVector2DParameterNameAndCurves> Vector2DParameterNamesAndCurves;
    /* 0x0158 */ TArray<FVectorParameterNameAndCurves> VectorParameterNamesAndCurves;
    /* 0x0168 */ TArray<FColorParameterNameAndCurves> ColorParameterNamesAndCurves;
    /* 0x0178 */ TArray<FTransformParameterNameAndCurves> TransformParameterNamesAndCurves;

    void AddBoolParameterKey(FName InParameterName, FFrameNumber InTime, bool InValue);
    void AddColorParameterKey(FName InParameterName, FFrameNumber InTime, FLinearColor InValue);
    void AddScalarParameterKey(FName InParameterName, FFrameNumber InTime, float InValue);
    void AddTransformParameterKey(FName InParameterName, FFrameNumber InTime, const FTransform& InValue);
    void AddVector2DParameterKey(FName InParameterName, FFrameNumber InTime, FVector2D InValue);
    void AddVectorParameterKey(FName InParameterName, FFrameNumber InTime, FVector InValue);
    void GetParameterNames(TSet<FName>& ParameterNames) const;
    bool RemoveBoolParameter(FName InParameterName);
    bool RemoveColorParameter(FName InParameterName);
    bool RemoveScalarParameter(FName InParameterName);
    bool RemoveTransformParameter(FName InParameterName);
    bool RemoveVector2DParameter(FName InParameterName);
    bool RemoveVectorParameter(FName InParameterName);
};

// Size: 0x80
struct FMovieSceneParameterSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ TArray<FScalarParameterNameAndCurve> Scalars;
    /* 0x0030 */ TArray<FBoolParameterNameAndCurve> Bools;
    /* 0x0040 */ TArray<FVector2DParameterNameAndCurves> Vector2Ds;
    /* 0x0050 */ TArray<FVectorParameterNameAndCurves> Vectors;
    /* 0x0060 */ TArray<FColorParameterNameAndCurves> Colors;
    /* 0x0070 */ TArray<FTransformParameterNameAndCurves> Transforms;
};

// Size: 0x98
struct FMovieSceneParticleChannel : public FMovieSceneByteChannel {
};

// Size: 0x80
struct FMovieSceneParticleParameterSectionTemplate : public FMovieSceneParameterSectionTemplate {
};

// Size: 0xf0
class UMovieSceneParticleParameterTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0x1c0
class UMovieSceneParticleSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneParticleChannel ParticleKeys;
};

// Size: 0xb8
struct FMovieSceneParticleSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneParticleChannel ParticleKeys;
};

// Size: 0xf0
class UMovieSceneParticleTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> ParticleSections;
};

// Size: 0xa0
class UMovieScenePiecewiseBoolBlenderSystem : public UMovieSceneBlenderSystem {
};

// Size: 0xa0
class UMovieScenePiecewiseByteBlenderSystem : public UMovieSceneBlenderSystem {
};

// Size: 0xa0
class UMovieScenePiecewiseEnumBlenderSystem : public UMovieSceneBlenderSystem {
};

// Size: 0x138
class UMovieScenePiecewiseFloatBlenderSystem : public UMovieSceneBlenderSystem {
};

// Size: 0xc0
class UMovieScenePiecewiseIntegerBlenderSystem : public UMovieSceneBlenderSystem {
};

// Size: 0xa0
class UMovieScenePostEvalEventSystem : public UMovieSceneEventSystem {
};

// Size: 0xa0
class UMovieScenePostSpawnEventSystem : public UMovieSceneEventSystem {
};

// Size: 0xa0
class UMovieScenePreSpawnEventSystem : public UMovieSceneEventSystem {
};

// Size: 0x1f0
class UMovieScenePrimitiveMaterialSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneObjectPathChannel MaterialChannel;
};

// Size: 0xf0
struct FMovieScenePrimitiveMaterialTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ int32_t MaterialIndex;
    /* 0x0028 */ FMovieSceneObjectPathChannel MaterialChannel;
};

// Size: 0x148
class UMovieScenePrimitiveMaterialTrack : public UMovieScenePropertyTrack {
    /* 0x0140 */ int32_t MaterialIndex;
};

// Size: 0x258
class UMovieScenePropertyInstantiatorSystem : public UMovieSceneEntityInstantiatorSystem {
};

// Size: 0x68
class UMovieScenePropertySystem : public UMovieSceneEntitySystem {
    /* 0x0058 */ UMovieScenePropertyInstantiatorSystem* InstantiatorSystem;
};

// Size: 0x138
class UMovieScenePropertyTrack : public UMovieSceneNameableTrack {
    /* 0x00d8 */ FName UniqueTrackName;
    /* 0x00e4 */ FName PropertyName;
    /* 0x00f0 */ FString PropertyPath;
    /* 0x0100 */ UMovieSceneSection* SectionToKey;
    /* 0x0108 */ FMovieScenePropertyBinding PropertyBinding;
    /* 0x0128 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0x50
class UMovieSceneQuaternionInterpolationRotationSystem : public UMovieSceneEntitySystem {
};

// Size: 0x30
struct FMovieSceneSkeletalAnimRootMotionTrackParams {
};

// Size: 0xd8
struct FMovieSceneSkeletalAnimationParams {
    /* 0x0000 */ UAnimSequenceBase* Animation;
    /* 0x0008 */ FFrameNumber FirstLoopStartFrameOffset;
    /* 0x000c */ FFrameNumber StartFrameOffset;
    /* 0x0010 */ FFrameNumber EndFrameOffset;
    /* 0x0014 */ float PlayRate;
    /* 0x0018 */ bool bReverse;
    /* 0x001c */ FName SlotName;
    /* 0x0028 */ FMovieSceneFloatChannel Weight;
    /* 0x00c8 */ bool bSkipAnimNotifiers;
    /* 0x00c9 */ bool bForceCustomMode;
    /* 0x00cc */ float StartOffset;
    /* 0x00d0 */ float EndOffset;
};

// Size: 0x2c0
class UMovieSceneSkeletalAnimationSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneSkeletalAnimationParams Params;
    /* 0x0208 */ UAnimSequence* AnimSequence;
    /* 0x0210 */ UAnimSequenceBase* Animation;
    /* 0x0218 */ float StartOffset;
    /* 0x021c */ float EndOffset;
    /* 0x0220 */ float PlayRate;
    /* 0x0224 */ bool bReverse;
    /* 0x0228 */ FName SlotName;
    /* 0x0234 */ FVector StartLocationOffset;
    /* 0x0240 */ FRotator StartRotationOffset;
    /* 0x024c */ bool bMatchWithPrevious;
    /* 0x0250 */ FName MatchedBoneName;
    /* 0x025c */ FVector MatchedLocationOffset;
    /* 0x0268 */ FRotator MatchedRotationOffset;
    /* 0x0274 */ bool bMatchTranslation;
    /* 0x0275 */ bool bMatchIncludeZHeight;
    /* 0x0276 */ bool bMatchRotationYaw;
    /* 0x0277 */ bool bMatchRotationPitch;
    /* 0x0278 */ bool bMatchRotationRoll;
    /* 0x0279 */ bool bShowSkeleton;
};

// Size: 0x100
struct FMovieSceneSkeletalAnimationSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneSkeletalAnimationSectionTemplateParameters Params;
};

// Size: 0xe0
struct FMovieSceneSkeletalAnimationSectionTemplateParameters : public FMovieSceneSkeletalAnimationParams {
    /* 0x00d8 */ FFrameNumber SectionStartTime;
    /* 0x00dc */ FFrameNumber SectionEndTime;
};

// Size: 0x130
class UMovieSceneSkeletalAnimationTrack : public UMovieSceneNameableTrack {
    /* 0x00e0 */ TArray<UMovieSceneSection*> AnimationSections;
    /* 0x00f0 */ bool bUseLegacySectionIndexBlend;
    /* 0x00f8 */ FMovieSceneSkeletalAnimRootMotionTrackParams RootMotionParams;
    /* 0x0128 */ bool bBlendFirstChildOfRoot;
    /* 0x0129 */ bool bShowRootMotionTrail;
};

// Size: 0x1c8
class UMovieSceneSlomoSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneFloatChannel FloatCurve;
};

// Size: 0xc0
struct FMovieSceneSlomoSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FMovieSceneFloatChannel SlomoCurve;
};

// Size: 0x140
class UMovieSceneSlomoTrack : public UMovieSceneFloatTrack {
};

// Size: 0xa0
struct FMovieSceneStringChannel : public FMovieSceneChannel {
    /* 0x0008 */ TArray<FFrameNumber> Times;
    /* 0x0018 */ TArray<FString> Values;
    /* 0x0028 */ FString DefaultValue;
    /* 0x0038 */ bool bHasDefaultValue;
};

// Size: 0xe0
struct FMovieSceneStringPropertySectionTemplate : public FMovieScenePropertySectionTemplate {
    /* 0x0040 */ FMovieSceneStringChannel StringCurve;
};

// Size: 0x1c8
class UMovieSceneStringSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneStringChannel StringCurve;
};

// Size: 0x140
class UMovieSceneStringTrack : public UMovieScenePropertyTrack {
};

// Size: 0x4
struct FMovieSceneTransformMask {
    /* 0x0000 */ uint32_t mask;
};

// Size: 0x30
class IMovieSceneTransformOrigin : public UInterface {

    FTransform BP_GetTransformOrigin() const;
};

// Size: 0x88
class UMovieSceneTransformOriginSystem : public UMovieSceneEntitySystem {
};

// Size: 0x138
class UMovieSceneTransformTrack : public UMovieScenePropertyTrack {
};

// Size: 0x30
struct FMovieSceneVector2DKeyStruct : public FMovieSceneVectorKeyStructBase {
    /* 0x0028 */ FVector2D Vector;
};

// Size: 0x40
struct FMovieSceneVector4KeyStruct : public FMovieSceneVectorKeyStructBase {
    /* 0x0030 */ FVector4 Vector;
};

// Size: 0x38
struct FMovieSceneVectorKeyStruct : public FMovieSceneVectorKeyStructBase {
    /* 0x0028 */ FVector Vector;
};

// Size: 0x28
struct FMovieSceneVectorKeyStructBase : public FMovieSceneKeyStruct {
    /* 0x0008 */ FFrameNumber Time;
};

// Size: 0x68
class UMovieSceneVectorPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x3b8
class UMovieSceneVectorSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieSceneFloatChannel Curves[4];
    /* 0x03b0 */ int32_t ChannelsUsed;
};

// Size: 0x140
class UMovieSceneVectorTrack : public UMovieScenePropertyTrack {
    /* 0x0138 */ int32_t NumChannelsUsed;
};

// Size: 0xd0
struct FMovieSceneVisibilitySectionTemplate : public FMovieSceneBoolPropertySectionTemplate {
};

// Size: 0x140
class UMovieSceneVisibilityTrack : public UMovieSceneBoolTrack {
};

// Size: 0xb0
struct FScalarParameterNameAndCurve {
    /* 0x0000 */ FName ParameterName;
    /* 0x0010 */ FMovieSceneFloatChannel ParameterCurve;
};

// Size: 0x5b0
struct FTransformParameterNameAndCurves {
    /* 0x0000 */ FName ParameterName;
    /* 0x0010 */ FMovieSceneFloatChannel Translation[3];
    /* 0x01f0 */ FMovieSceneFloatChannel Rotation[3];
    /* 0x03d0 */ FMovieSceneFloatChannel Scale[3];
};

// Size: 0x150
struct FVector2DParameterNameAndCurves {
    /* 0x0000 */ FName ParameterName;
    /* 0x0010 */ FMovieSceneFloatChannel XCurve;
    /* 0x00b0 */ FMovieSceneFloatChannel YCurve;
};

// Size: 0x1f0
struct FVectorParameterNameAndCurves {
    /* 0x0000 */ FName ParameterName;
    /* 0x0010 */ FMovieSceneFloatChannel XCurve;
    /* 0x00b0 */ FMovieSceneFloatChannel YCurve;
    /* 0x0150 */ FMovieSceneFloatChannel ZCurve;
};

// Size: 0x88
class UWeightAndEasingEvaluatorSystem : public UMovieSceneEntitySystem {
};

// Size: 0x538
class AAbstractNavData : public ANavigationData {
};

// Size: 0x30
class UCrowdManagerBase : public UObject {
};

enum class ENavCostDisplay {
    TotalCost = 0,
    HeuristicOnly = 1,
    RealCostOnly = 2,
    ENavCostDisplay_MAX = 3,
};

enum class ENavSystemOverridePolicy {
    Override = 0,
    Append = 1,
    Skip = 2,
    ENavSystemOverridePolicy_MAX = 3,
};

enum class ERecastPartitioning {
    Monotone = 0,
    Watershed = 1,
    ChunkyMonotone = 2,
    ERecastPartitioning_MAX = 3,
};

enum class ERuntimeGenerationType {
    Static = 0,
    DynamicModifiersOnly = 1,
    Dynamic = 2,
    LegacyGeneration = 3,
    ERuntimeGenerationType_MAX = 4,
};

// Size: 0x50
class UNavArea : public UNavAreaBase {
    /* 0x0038 */ float DefaultCost;
    /* 0x003c */ float FixedAreaEnteringCost;
    /* 0x0040 */ FColor DrawColor;
    /* 0x0044 */ FNavAgentSelector SupportedAgents;
    /* 0x0048 */ bool bSupportsAgent0;
    /* 0x0048 */ bool bSupportsAgent1;
    /* 0x0048 */ bool bSupportsAgent2;
    /* 0x0048 */ bool bSupportsAgent3;
    /* 0x0048 */ bool bSupportsAgent4;
    /* 0x0048 */ bool bSupportsAgent5;
    /* 0x0048 */ bool bSupportsAgent6;
    /* 0x0048 */ bool bSupportsAgent7;
    /* 0x0049 */ bool bSupportsAgent8;
    /* 0x0049 */ bool bSupportsAgent9;
    /* 0x0049 */ bool bSupportsAgent10;
    /* 0x0049 */ bool bSupportsAgent11;
    /* 0x0049 */ bool bSupportsAgent12;
    /* 0x0049 */ bool bSupportsAgent13;
    /* 0x0049 */ bool bSupportsAgent14;
    /* 0x0049 */ bool bSupportsAgent15;
};

// Size: 0x50
class UNavAreaMeta : public UNavArea {
};

// Size: 0xd0
class UNavAreaMeta_SwitchByAgent : public UNavAreaMeta {
    /* 0x0050 */ UClass* Agent0Area;
    /* 0x0058 */ UClass* Agent1Area;
    /* 0x0060 */ UClass* Agent2Area;
    /* 0x0068 */ UClass* Agent3Area;
    /* 0x0070 */ UClass* Agent4Area;
    /* 0x0078 */ UClass* Agent5Area;
    /* 0x0080 */ UClass* Agent6Area;
    /* 0x0088 */ UClass* Agent7Area;
    /* 0x0090 */ UClass* Agent8Area;
    /* 0x0098 */ UClass* Agent9Area;
    /* 0x00a0 */ UClass* Agent10Area;
    /* 0x00a8 */ UClass* Agent11Area;
    /* 0x00b0 */ UClass* Agent12Area;
    /* 0x00b8 */ UClass* Agent13Area;
    /* 0x00c0 */ UClass* Agent14Area;
    /* 0x00c8 */ UClass* Agent15Area;
};

// Size: 0x50
class UNavArea_Default : public UNavArea {
};

// Size: 0x50
class UNavArea_LowHeight : public UNavArea {
};

// Size: 0x50
class UNavArea_Null : public UNavArea {
};

// Size: 0x50
class UNavArea_Obstacle : public UNavArea {
};

// Size: 0x108
class UNavCollision : public UNavCollisionBase {
    /* 0x00b0 */ TArray<FNavCollisionCylinder> CylinderCollision;
    /* 0x00c0 */ TArray<FNavCollisionBox> BoxCollision;
    /* 0x00d0 */ UClass* AreaClass;
    /* 0x00d8 */ bool bGatherConvexGeometry;
    /* 0x00d8 */ bool bCreateOnClient;
};

// Size: 0x18
struct FNavCollisionBox {
    /* 0x0000 */ FVector Offset;
    /* 0x000c */ FVector Extent;
};

// Size: 0x14
struct FNavCollisionCylinder {
    /* 0x0000 */ FVector Offset;
    /* 0x000c */ float Radius;
    /* 0x0010 */ float Height;
};

// Size: 0x18
struct FNavGraphEdge {
};

// Size: 0x18
struct FNavGraphNode {
    /* 0x0000 */ UObject* Owner;
};

// Size: 0x4f0
class UNavLinkComponent : public UPrimitiveComponent {
    /* 0x04e0 */ TArray<FNavigationLink> Links;
};

// Size: 0x1a0
class UNavLinkCustomComponent : public UNavRelevantComponent {
    /* 0x00f8 */ uint32_t NavLinkUserId;
    /* 0x0100 */ UClass* EnabledAreaClass;
    /* 0x0108 */ UClass* DisabledAreaClass;
    /* 0x0110 */ FNavAgentSelector SupportedAgents;
    /* 0x0114 */ FVector LinkRelativeStart;
    /* 0x0120 */ FVector LinkRelativeEnd;
    /* 0x012c */ uint8_t LinkDirection;
    /* 0x0130 */ bool bLinkEnabled;
    /* 0x0130 */ bool bNotifyWhenEnabled;
    /* 0x0130 */ bool bNotifyWhenDisabled;
    /* 0x0130 */ bool bCreateBoxObstacle;
    /* 0x0134 */ FVector ObstacleOffset;
    /* 0x0140 */ FVector ObstacleExtent;
    /* 0x0150 */ UClass* ObstacleAreaClass;
    /* 0x0158 */ float BroadcastRadius;
    /* 0x015c */ float BroadcastInterval;
    /* 0x0160 */ uint8_t BroadcastChannel;
};

// Size: 0x70
struct FNavLinkCustomInstanceData : public FActorComponentInstanceData {
    /* 0x0068 */ uint32_t NavLinkUserId;
};

// Size: 0x30
class INavLinkCustomInterface : public UInterface {
};

// Size: 0x30
class INavLinkHostInterface : public UInterface {
};

// Size: 0x4e0
class UNavLinkRenderingComponent : public UPrimitiveComponent {
};

// Size: 0x58
class UNavLinkTrivial : public UNavLinkDefinition {
};

// Size: 0x340
class ANavMeshBoundsVolume : public AVolume {
    /* 0x0338 */ FNavAgentSelector SupportedAgents;
};

// Size: 0x550
class UNavMeshRenderingComponent : public UPrimitiveComponent {
};

// Size: 0x150
class UNavModifierComponent : public UNavRelevantComponent {
    /* 0x00f0 */ UClass* AreaClass;
    /* 0x00f8 */ FVector FailsafeExtent;
    /* 0x0104 */ bool bIncludeAgentHeight;

    void SetAreaClass(UClass* NewAreaClass);
};

// Size: 0x350
class ANavModifierVolume : public AVolume {
    /* 0x0340 */ UClass* AreaClass;
    /* 0x0348 */ bool bMaskFillCollisionUnderneathForNavmesh;

    void SetAreaClass(UClass* NewAreaClass);
};

// Size: 0x30
class INavNodeInterface : public UInterface {
};

// Size: 0xf0
class UNavRelevantComponent : public UActorComponent {
    /* 0x00e4 */ bool bAttachToOwnersRoot;
    /* 0x00e8 */ UObject* CachedNavParent;

    void SetNavigationRelevancy(bool bRelevant);
};

// Size: 0x310
class ANavSystemConfigOverride : public AActor {
    /* 0x02f8 */ UBillboardComponent* SpriteComponent;
    /* 0x0300 */ UNavigationSystemConfig* NavigationSystemConfig;
    /* 0x0308 */ ENavSystemOverridePolicy OverridePolicy;
    /* 0x0309 */ bool bLoadOnClient;

    void ApplyChanges();
};

// Size: 0x5b0
class UNavTestRenderingComponent : public UPrimitiveComponent {
};

// Size: 0x538
class ANavigationData : public AActor {
    /* 0x0300 */ UPrimitiveComponent* RenderingComp;
    /* 0x0308 */ FNavDataConfig NavDataConfig;
    /* 0x03b8 */ bool bEnableDrawing;
    /* 0x03b8 */ bool bForceRebuildOnLoad;
    /* 0x03b8 */ bool bAutoDestroyWhenNoNavigation;
    /* 0x03b8 */ bool bCanBeMainNavData;
    /* 0x03b8 */ bool bCanSpawnOnRebuild;
    /* 0x03b8 */ bool bRebuildAtRuntime;
    /* 0x03bc */ ERuntimeGenerationType RuntimeGeneration;
    /* 0x03c0 */ float ObservedPathsTickInterval;
    /* 0x03c4 */ uint32_t DataVersion;
    /* 0x04d0 */ TArray<FSupportedAreaData> SupportedAreas;
};

// Size: 0x18
struct FNavigationFilterArea {
    /* 0x0000 */ UClass* AreaClass;
    /* 0x0008 */ float TravelCostOverride;
    /* 0x000c */ float EnteringCostOverride;
    /* 0x0010 */ bool bIsExcluded;
    /* 0x0010 */ bool bOverrideTravelCost;
    /* 0x0010 */ bool bOverrideEnteringCost;
};

// Size: 0x4
struct FNavigationFilterFlags {
    /* 0x0000 */ bool bNavFlag0;
    /* 0x0000 */ bool bNavFlag1;
    /* 0x0000 */ bool bNavFlag2;
    /* 0x0000 */ bool bNavFlag3;
    /* 0x0000 */ bool bNavFlag4;
    /* 0x0000 */ bool bNavFlag5;
    /* 0x0000 */ bool bNavFlag6;
    /* 0x0000 */ bool bNavFlag7;
    /* 0x0001 */ bool bNavFlag8;
    /* 0x0001 */ bool bNavFlag9;
    /* 0x0001 */ bool bNavFlag10;
    /* 0x0001 */ bool bNavFlag11;
    /* 0x0001 */ bool bNavFlag12;
    /* 0x0001 */ bool bNavFlag13;
    /* 0x0001 */ bool bNavFlag14;
    /* 0x0001 */ bool bNavFlag15;
};

// Size: 0x538
class ANavigationGraph : public ANavigationData {
};

// Size: 0x2f8
class ANavigationGraphNode : public AActor {
};

// Size: 0x250
class UNavigationGraphNodeComponent : public USceneComponent {
    /* 0x0228 */ FNavGraphNode Node;
    /* 0x0240 */ UNavigationGraphNodeComponent* NextNodeComponent;
    /* 0x0248 */ UNavigationGraphNodeComponent* PrevNodeComponent;
};

// Size: 0xc8
class UNavigationInvokerComponent : public UActorComponent {
    /* 0x00c0 */ float TileGenerationRadius;
    /* 0x00c4 */ float TileRemovalRadius;
};

// Size: 0x90
class UNavigationPath : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate PathUpdatedNotifier;
    /* 0x0040 */ TArray<FVector> PathPoints;
    /* 0x0050 */ uint8_t RecalculateOnInvalidation;

    void EnableDebugDrawing(bool bShouldDrawDebugData, FLinearColor PathColor);
    void EnableRecalculationOnInvalidation(uint8_t DoRecalculation);
    FString GetDebugString() const;
    float GetPathCost() const;
    float GetPathLength() const;
    bool IsPartial() const;
    bool IsStringPulled() const;
    bool IsValid() const;
};

// Size: 0x30
class INavigationPathGenerator : public UInterface {
};

// Size: 0x50
class UNavigationQueryFilter : public UObject {
    /* 0x0030 */ TArray<FNavigationFilterArea> Areas;
    /* 0x0040 */ FNavigationFilterFlags IncludeFlags;
    /* 0x0044 */ FNavigationFilterFlags ExcludeFlags;
};

// Size: 0x70
class UNavigationSystemModuleConfig : public UNavigationSystemConfig {
    /* 0x0068 */ bool bStrictlyStatic;
    /* 0x0068 */ bool bCreateOnClient;
    /* 0x0068 */ bool bAutoSpawnMissingNavData;
    /* 0x0068 */ bool bSpawnNavDataInNavBoundsLevel;
};

// Size: 0x1600
class UNavigationSystemV1 : public UNavigationSystemBase {
    /* 0x0030 */ ANavigationData* MainNavData;
    /* 0x0038 */ ANavigationData* AbstractNavData;
    /* 0x0040 */ FName DefaultAgentName;
    /* 0x0050 */ TSoftClassPtr<UCrowdManagerBase> CrowdManagerClass;
    /* 0x0080 */ bool bAutoCreateNavigationData;
    /* 0x0080 */ bool bSpawnNavDataInNavBoundsLevel;
    /* 0x0080 */ bool bAllowClientSideNavigation;
    /* 0x0080 */ bool bShouldDiscardSubLevelNavData;
    /* 0x0080 */ bool bTickWhilePaused;
    /* 0x0080 */ bool bSupportRebuilding;
    /* 0x0080 */ bool bInitialBuildingLocked;
    /* 0x0081 */ bool bSkipAgentHeightCheckWhenPickingNavData;
    /* 0x0081 */ bool bGenerateNavigationOnlyAroundNavigationInvokers;
    /* 0x0084 */ float ActiveTilesUpdateInterval;
    /* 0x0088 */ ENavDataGatheringModeConfig DataGatheringMode;
    /* 0x008c */ float DirtyAreaWarningSizeThreshold;
    /* 0x0090 */ TArray<FNavDataConfig> SupportedAgents;
    /* 0x00a0 */ FNavAgentSelector SupportedAgentsMask;
    /* 0x00a8 */ TArray<ANavigationData*> NavDataSet;
    /* 0x00b8 */ TArray<ANavigationData*> NavDataRegistrationQueue;
    /* 0x00d8 */ FMulticastInlineDelegate OnNavDataRegisteredEvent;
    /* 0x00e8 */ FMulticastInlineDelegate OnNavigationGenerationFinishedDelegate;
    /* 0x01d4 */ FNavigationSystemRunMode OperationMode;
    /* 0x15dc */ float DirtyAreasUpdateFreq;

    static UNavigationPath* FindPathToActorSynchronously(UObject* WorldContextObject, const FVector& PathStart, AActor* GoalActor, float TetherDistance, AActor* PathfindingContext, UClass* FilterClass);
    static UNavigationPath* FindPathToLocationSynchronously(UObject* WorldContextObject, const FVector& PathStart, const FVector& PathEnd, AActor* PathfindingContext, UClass* FilterClass);
    static UNavigationSystemV1* GetNavigationSystem(UObject* WorldContextObject);
    static uint8_t GetPathCost(UObject* WorldContextObject, const FVector& PathStart, const FVector& PathEnd, float& PathCost, ANavigationData* NavData, UClass* FilterClass);
    static uint8_t GetPathLength(UObject* WorldContextObject, const FVector& PathStart, const FVector& PathEnd, float& PathLength, ANavigationData* NavData, UClass* FilterClass);
    static FVector GetRandomPointInNavigableRadius(UObject* WorldContextObject, const FVector& Origin, float Radius, ANavigationData* NavData, UClass* FilterClass);
    static FVector GetRandomReachablePointInRadius(UObject* WorldContextObject, const FVector& Origin, float Radius, ANavigationData* NavData, UClass* FilterClass);
    static bool IsNavigationBeingBuilt(UObject* WorldContextObject);
    static bool IsNavigationBeingBuiltOrLocked(UObject* WorldContextObject);
    static bool K2_GetRandomLocationInNavigableRadius(UObject* WorldContextObject, const FVector& Origin, FVector& RandomLocation, float Radius, ANavigationData* NavData, UClass* FilterClass);
    static bool K2_GetRandomPointInNavigableRadius(UObject* WorldContextObject, const FVector& Origin, FVector& RandomLocation, float Radius, ANavigationData* NavData, UClass* FilterClass);
    static bool K2_GetRandomReachablePointInRadius(UObject* WorldContextObject, const FVector& Origin, FVector& RandomLocation, float Radius, ANavigationData* NavData, UClass* FilterClass);
    static bool K2_ProjectPointToNavigation(UObject* WorldContextObject, const FVector& Point, FVector& ProjectedLocation, ANavigationData* NavData, UClass* FilterClass, const FVector QueryExtent);
    bool K2_ReplaceAreaInOctreeData(const UObject* Object, UClass* OldArea, UClass* NewArea);
    static bool NavigationRaycast(UObject* WorldContextObject, const FVector& RayStart, const FVector& RayEnd, FVector& HitLocation, UClass* FilterClass, AController* Querier);
    void OnNavigationBoundsUpdated(ANavMeshBoundsVolume* NavVolume);
    static FVector ProjectPointToNavigation(UObject* WorldContextObject, const FVector& Point, ANavigationData* NavData, UClass* FilterClass, const FVector QueryExtent);
    void RegisterNavigationInvoker(AActor* Invoker, float TileGenerationRadius, float TileRemovalRadius);
    void ResetMaxSimultaneousTileGenerationJobsCount();
    void SetGeometryGatheringMode(ENavDataGatheringModeConfig NewMode);
    void SetMaxSimultaneousTileGenerationJobsCount(int32_t MaxNumberOfJobs);
    static void SimpleMoveToActor(AController* Controller, const AActor* Goal);
    static void SimpleMoveToLocation(AController* Controller, const FVector& Goal);
    void UnregisterNavigationInvoker(AActor* Invoker);
};

// Size: 0x410
class ANavigationTestingActor : public AActor {
    /* 0x0308 */ UCapsuleComponent* CapsuleComponent;
    /* 0x0310 */ UNavTestRenderingComponent* EdRenderComp;
    /* 0x0318 */ UNavigationInvokerComponent* InvokerComponent;
    /* 0x0320 */ bool bActAsNavigationInvoker;
    /* 0x0328 */ FNavAgentProperties NavAgentProps;
    /* 0x0360 */ FVector QueryingExtent;
    /* 0x0370 */ ANavigationData* MyNavData;
    /* 0x0378 */ FVector ProjectedLocation;
    /* 0x0384 */ bool bProjectedLocationValid;
    /* 0x0384 */ bool bSearchStart;
    /* 0x0388 */ float CostLimitFactor;
    /* 0x038c */ float MinimumCostLimit;
    /* 0x0390 */ bool bBacktracking;
    /* 0x0390 */ bool bUseHierarchicalPathfinding;
    /* 0x0390 */ bool bGatherDetailedInfo;
    /* 0x0390 */ bool bDrawDistanceToWall;
    /* 0x0390 */ bool bShowNodePool;
    /* 0x0390 */ bool bShowBestPath;
    /* 0x0390 */ bool bShowDiffWithPreviousStep;
    /* 0x0390 */ bool bShouldBeVisibleInGame;
    /* 0x0394 */ uint8_t CostDisplayMode;
    /* 0x0398 */ FVector2D TextCanvasOffset;
    /* 0x03a0 */ bool bPathExist;
    /* 0x03a0 */ bool bPathIsPartial;
    /* 0x03a0 */ bool bPathSearchOutOfNodes;
    /* 0x03a4 */ float PathfindingTime;
    /* 0x03a8 */ float PathCost;
    /* 0x03ac */ int32_t PathfindingSteps;
    /* 0x03b0 */ ANavigationTestingActor* OtherActor;
    /* 0x03b8 */ UClass* FilterClass;
    /* 0x03c0 */ int32_t ShowStepIndex;
    /* 0x03c4 */ float OffsetFromCornersDistance;
};

// Size: 0x50
class URecastFilter_UseDefaultArea : public UNavigationQueryFilter {
};

// Size: 0x5e8
class ARecastNavMesh : public ANavigationData {
    /* 0x0538 */ bool bDrawTriangleEdges;
    /* 0x0538 */ bool bDrawPolyEdges;
    /* 0x0538 */ bool bDrawFilledPolys;
    /* 0x0538 */ bool bDrawNavMeshEdges;
    /* 0x0538 */ bool bDrawTileBounds;
    /* 0x0538 */ bool bDrawPathCollidingGeometry;
    /* 0x0538 */ bool bDrawTileLabels;
    /* 0x0538 */ bool bDrawPolygonLabels;
    /* 0x0539 */ bool bDrawDefaultPolygonCost;
    /* 0x0539 */ bool bDrawPolygonFlags;
    /* 0x0539 */ bool bDrawLabelsOnPathNodes;
    /* 0x0539 */ bool bDrawNavLinks;
    /* 0x0539 */ bool bDrawFailedNavLinks;
    /* 0x0539 */ bool bDrawClusters;
    /* 0x0539 */ bool bDrawOctree;
    /* 0x0539 */ bool bDrawOctreeDetails;
    /* 0x053a */ bool bDrawMarkedForbiddenPolys;
    /* 0x053a */ bool bDistinctlyDrawTilesBeingBuilt;
    /* 0x053c */ float DrawOffset;
    /* 0x0540 */ bool bFixedTilePoolSize;
    /* 0x0544 */ int32_t TilePoolSize;
    /* 0x0548 */ float TileSizeUU;
    /* 0x054c */ float CellSize;
    /* 0x0550 */ float CellHeight;
    /* 0x0554 */ float AgentRadius;
    /* 0x0558 */ float AgentHeight;
    /* 0x055c */ float AgentMaxSlope;
    /* 0x0560 */ float AgentMaxStepHeight;
    /* 0x0564 */ float MinRegionArea;
    /* 0x0568 */ float MergeRegionSize;
    /* 0x056c */ float MaxSimplificationError;
    /* 0x0570 */ int32_t MaxSimultaneousTileGenerationJobsCount;
    /* 0x0574 */ int32_t TileNumberHardLimit;
    /* 0x0578 */ int32_t PolyRefTileBits;
    /* 0x057c */ int32_t PolyRefNavPolyBits;
    /* 0x0580 */ int32_t PolyRefSaltBits;
    /* 0x0584 */ FVector NavMeshOriginOffset;
    /* 0x0590 */ float DefaultDrawDistance;
    /* 0x0594 */ float DefaultMaxSearchNodes;
    /* 0x0598 */ float DefaultMaxHierarchicalSearchNodes;
    /* 0x059c */ uint8_t RegionPartitioning;
    /* 0x059d */ uint8_t LayerPartitioning;
    /* 0x05a0 */ int32_t RegionChunkSplits;
    /* 0x05a4 */ int32_t LayerChunkSplits;
    /* 0x05a8 */ bool bSortNavigationAreasByCost;
    /* 0x05a8 */ bool bPerformVoxelFiltering;
    /* 0x05a8 */ bool bMarkLowHeightAreas;
    /* 0x05a8 */ bool bUseExtraTopCellWhenMarkingAreas;
    /* 0x05a8 */ bool bFilterLowSpanSequences;
    /* 0x05a8 */ bool bFilterLowSpanFromTileCache;
    /* 0x05a8 */ bool bDoFullyAsyncNavDataGathering;
    /* 0x05a8 */ bool bUseBetterOffsetsFromCorners;
    /* 0x05a9 */ bool bStoreEmptyTileLayers;
    /* 0x05a9 */ bool bUseVirtualFilters;
    /* 0x05a9 */ bool bAllowNavLinkAsPathEnd;
    /* 0x05a9 */ bool bUseVoxelCache;
    /* 0x05ac */ float TileSetUpdateInterval;
    /* 0x05b0 */ float HeuristicScale;
    /* 0x05b4 */ float VerticalDeviationFromGroundCompensation;

    bool K2_ReplaceAreaInTileBounds(FBox Bounds, UClass* OldArea, UClass* NewArea, bool ReplaceLinks);
};

// Size: 0x50
class URecastNavMeshDataChunk : public UNavigationDataChunk {
};

// Size: 0x40
struct FRecastNavMeshGenerationProperties {
    /* 0x0000 */ int32_t TilePoolSize;
    /* 0x0004 */ float TileSizeUU;
    /* 0x0008 */ float CellSize;
    /* 0x000c */ float CellHeight;
    /* 0x0010 */ float AgentRadius;
    /* 0x0014 */ float AgentHeight;
    /* 0x0018 */ float AgentMaxSlope;
    /* 0x001c */ float AgentMaxStepHeight;
    /* 0x0020 */ float MinRegionArea;
    /* 0x0024 */ float MergeRegionSize;
    /* 0x0028 */ float MaxSimplificationError;
    /* 0x002c */ int32_t TileNumberHardLimit;
    /* 0x0030 */ uint8_t RegionPartitioning;
    /* 0x0031 */ uint8_t LayerPartitioning;
    /* 0x0034 */ int32_t RegionChunkSplits;
    /* 0x0038 */ int32_t LayerChunkSplits;
    /* 0x003c */ bool bSortNavigationAreasByCost;
    /* 0x003c */ bool bPerformVoxelFiltering;
    /* 0x003c */ bool bMarkLowHeightAreas;
    /* 0x003c */ bool bUseExtraTopCellWhenMarkingAreas;
    /* 0x003c */ bool bFilterLowSpanSequences;
    /* 0x003c */ bool bFilterLowSpanFromTileCache;
    /* 0x003c */ bool bFixedTilePoolSize;
};

// Size: 0x20
struct FSupportedAreaData {
    /* 0x0000 */ FString AreaClassName;
    /* 0x0010 */ int32_t AreaID;
    /* 0x0018 */ UClass* AreaClass;
};

// Size: 0x40
class UNetAnalyticsAggregatorConfig : public UObject {
    /* 0x0030 */ TArray<FNetAnalyticsDataConfig> NetAnalyticsData;
};

// Size: 0x10
struct FNetAnalyticsDataConfig {
    /* 0x0000 */ FName DataName;
    /* 0x000c */ bool bEnabled;
};

// Size: 0x1c
struct FBasicParticleData {
    /* 0x0000 */ FVector Position;
    /* 0x000c */ float Size;
    /* 0x0010 */ FVector Velocity;
};

enum class ENCPoolMethod {
    None = 0,
    AutoRelease = 1,
    ManualRelease = 2,
    ManualRelease_OnComplete = 3,
    FreeInPool = 4,
    ENCPoolMethod_MAX = 5,
};

enum class ENDIExport_GPUAllocationMode {
    FixedSize = 0,
    PerParticle = 1,
    ENDIExport_MAX = 2,
};

enum class ENDILandscape_SourceMode {
    Default = 0,
    Source = 1,
    AttachParent = 2,
    ENDILandscape_MAX = 3,
};

enum class ENDISkelMesh_AdjacencyTriangleIndexFormat {
    Full = 0,
    Half = 1,
    ENDISkelMesh_MAX = 2,
};

enum class ENDISkelMesh_GpuMaxInfluences {
    AllowMax4 = 0,
    AllowMax8 = 1,
    Unlimited = 2,
    ENDISkelMesh_MAX = 3,
};

enum class ENDISkelMesh_GpuUniformSamplingFormat {
    Full = 0,
    Limited_24_8 = 1,
    Limited_23_9 = 2,
    ENDISkelMesh_MAX = 3,
};

enum class ENDISkeletalMesh_SkinningMode {
    Invalid = 255,
    None = 0,
    SkinOnTheFly = 1,
    PreSkin = 2,
    ENDISkeletalMesh_MAX = 256,
};

enum class ENDISkeletalMesh_SourceMode {
    Default = 0,
    Source = 1,
    AttachParent = 2,
    ENDISkeletalMesh_MAX = 3,
};

enum class ENDIStaticMesh_SourceMode {
    Default = 0,
    Source = 1,
    AttachParent = 2,
    DefaultMeshOnly = 3,
    ENDIStaticMesh_MAX = 4,
};

enum class ENiagaraAgeUpdateMode {
    TickDeltaTime = 0,
    DesiredAge = 1,
    DesiredAgeNoSeek = 2,
    ENiagaraAgeUpdateMode_MAX = 3,
};

enum class ENiagaraBakerViewMode {
    Perspective = 0,
    OrthoFront = 1,
    OrthoBack = 2,
    OrthoLeft = 3,
    OrthoRight = 4,
    OrthoTop = 5,
    OrthoBottom = 6,
    Num = 7,
    ENiagaraBakerViewMode_MAX = 8,
};

enum class ENiagaraBindingSource {
    ImplicitFromSource = 0,
    ExplicitParticles = 1,
    ExplicitEmitter = 2,
    ExplicitSystem = 3,
    ExplicitUser = 4,
    MaxBindingSource = 5,
    ENiagaraBindingSource_MAX = 6,
};

enum class ENiagaraCollisionMode {
    None = 0,
    SceneGeometry = 1,
    DepthBuffer = 2,
    DistanceField = 3,
    ENiagaraCollisionMode_MAX = 4,
};

enum class ENiagaraCompileUsageStaticSwitch {
    Spawn = 0,
    Update = 1,
    Event = 2,
    SimulationStage = 3,
    Default = 4,
    ENiagaraCompileUsageStaticSwitch_MAX = 5,
};

enum class ENiagaraCoordinateSpace {
    Simulation = 0,
    World = 1,
    Local = 2,
    ENiagaraCoordinateSpace_MAX = 3,
};

enum class ENiagaraCullReaction {
    Deactivate = 0,
    DeactivateImmediate = 1,
    DeactivateResume = 2,
    DeactivateImmediateResume = 3,
    ENiagaraCullReaction_MAX = 4,
};

enum class ENiagaraDataSetType {
    ParticleData = 0,
    Shared = 1,
    Event = 2,
    ENiagaraDataSetType_MAX = 3,
};

enum class ENiagaraDebugHudFont {
    Small = 0,
    Normal = 1,
    ENiagaraDebugHudFont_MAX = 2,
};

enum class ENiagaraDebugHudHAlign {
    Left = 0,
    Center = 1,
    Right = 2,
    ENiagaraDebugHudHAlign_MAX = 3,
};

enum class ENiagaraDebugHudVAlign {
    Top = 0,
    Center = 1,
    Bottom = 2,
    ENiagaraDebugHudVAlign_MAX = 3,
};

enum class ENiagaraDebugHudVerbosity {
    None = 0,
    Basic = 1,
    Verbose = 2,
    ENiagaraDebugHudVerbosity_MAX = 3,
};

enum class ENiagaraDebugPlaybackMode {
    Play = 0,
    Loop = 1,
    Paused = 2,
    Step = 3,
    ENiagaraDebugPlaybackMode_MAX = 4,
};

enum class ENiagaraDefaultMode {
    Value = 0,
    Binding = 1,
    Custom = 2,
    FailIfPreviouslyNotSet = 3,
    ENiagaraDefaultMode_MAX = 4,
};

enum class ENiagaraDefaultRendererMotionVectorSetting {
    Precise = 0,
    Approximate = 1,
    ENiagaraDefaultRendererMotionVectorSetting_MAX = 2,
};

enum class ENiagaraExecutionState {
    Active = 0,
    Inactive = 1,
    InactiveClear = 2,
    Complete = 3,
    Disabled = 4,
    Num = 5,
    ENiagaraExecutionState_MAX = 6,
};

enum class ENiagaraExecutionStateSource {
    Scalability = 0,
    Internal = 1,
    Owner = 2,
    InternalCompletion = 3,
    ENiagaraExecutionStateSource_MAX = 4,
};

enum class ENiagaraFunctionDebugState {
    NoDebug = 0,
    Basic = 1,
    ENiagaraFunctionDebugState_MAX = 2,
};

enum class ENiagaraGpuBufferFormat {
    Float = 0,
    HalfFloat = 1,
    UnsignedNormalizedByte = 2,
    Max = 3,
    ENiagaraGpuBufferFormat_MAX = 4,
};

enum class ENiagaraInputNodeUsage {
    Undefined = 0,
    Parameter = 1,
    Attribute = 2,
    SystemConstant = 3,
    TranslatorConstant = 4,
    RapidIterationParameter = 5,
    ENiagaraInputNodeUsage_MAX = 6,
};

enum class ENiagaraIterationSource {
    Particles = 0,
    DataInterface = 1,
    ENiagaraIterationSource_MAX = 2,
};

enum class ENiagaraLegacyTrailWidthMode {
    FromCentre = 0,
    FromFirst = 1,
    FromSecond = 2,
    ENiagaraLegacyTrailWidthMode_MAX = 3,
};

enum class ENiagaraMeshFacingMode {
    Default = 0,
    Velocity = 1,
    CameraPosition = 2,
    CameraPlane = 3,
    ENiagaraMeshFacingMode_MAX = 4,
};

enum class ENiagaraMeshLockedAxisSpace {
    Simulation = 0,
    World = 1,
    Local = 2,
    ENiagaraMeshLockedAxisSpace_MAX = 3,
};

enum class ENiagaraMeshPivotOffsetSpace {
    Mesh = 0,
    Simulation = 1,
    World = 2,
    Local = 3,
    ENiagaraMeshPivotOffsetSpace_MAX = 4,
};

enum class ENiagaraMipMapGeneration {
    Disabled = 0,
    PostStage = 1,
    PostSimulate = 2,
    ENiagaraMipMapGeneration_MAX = 3,
};

enum class ENiagaraModuleDependencyScriptConstraint {
    SameScript = 0,
    AllScripts = 1,
    ENiagaraModuleDependencyScriptConstraint_MAX = 2,
};

enum class ENiagaraModuleDependencyType {
    PreDependency = 0,
    PostDependency = 1,
    ENiagaraModuleDependencyType_MAX = 2,
};

enum class ENiagaraNumericOutputTypeSelectionMode {
    None = 0,
    Largest = 1,
    Smallest = 2,
    Scalar = 3,
    ENiagaraNumericOutputTypeSelectionMode_MAX = 4,
};

enum class ENiagaraOrientationAxis {
    XAxis = 0,
    YAxis = 1,
    ZAxis = 2,
    ENiagaraOrientationAxis_MAX = 3,
};

enum class ENiagaraPlatformSelectionState {
    Default = 0,
    Enabled = 1,
    Disabled = 2,
    ENiagaraPlatformSelectionState_MAX = 3,
};

enum class ENiagaraPlatformSetState {
    Disabled = 0,
    Enabled = 1,
    Active = 2,
    Unknown = 3,
    ENiagaraPlatformSetState_MAX = 4,
};

enum class ENiagaraPreviewGridResetMode {
    Never = 0,
    Individual = 1,
    All = 2,
    ENiagaraPreviewGridResetMode_MAX = 3,
};

enum class ENiagaraPythonUpdateScriptReference {
    None = 0,
    ScriptAsset = 1,
    DirectTextEntry = 2,
    ENiagaraPythonUpdateScriptReference_MAX = 3,
};

enum class ENiagaraRendererMotionVectorSetting {
    AutoDetect = 0,
    Precise = 1,
    Approximate = 2,
    Disable = 3,
    ENiagaraRendererMotionVectorSetting_MAX = 4,
};

enum class ENiagaraRendererSourceDataMode {
    Particles = 0,
    Emitter = 1,
    ENiagaraRendererSourceDataMode_MAX = 2,
};

enum class ENiagaraRibbonAgeOffsetMode {
    Scale = 0,
    Clip = 1,
    ENiagaraRibbonAgeOffsetMode_MAX = 2,
};

enum class ENiagaraRibbonDrawDirection {
    FrontToBack = 0,
    BackToFront = 1,
    ENiagaraRibbonDrawDirection_MAX = 2,
};

enum class ENiagaraRibbonFacingMode {
    Screen = 0,
    Custom = 1,
    CustomSideVector = 2,
    ENiagaraRibbonFacingMode_MAX = 3,
};

enum class ENiagaraRibbonShapeMode {
    Plane = 0,
    MultiPlane = 1,
    Tube = 2,
    Custom = 3,
    ENiagaraRibbonShapeMode_MAX = 4,
};

enum class ENiagaraRibbonTessellationMode {
    Automatic = 0,
    Custom = 1,
    Disabled = 2,
    ENiagaraRibbonTessellationMode_MAX = 3,
};

enum class ENiagaraRibbonUVDistributionMode {
    ScaledUniformly = 0,
    ScaledUsingRibbonSegmentLength = 1,
    TiledOverRibbonLength = 2,
    TiledFromStartOverRibbonLength = 3,
    ENiagaraRibbonUVDistributionMode_MAX = 4,
};

enum class ENiagaraRibbonUVEdgeMode {
    SmoothTransition = 0,
    Locked = 1,
    ENiagaraRibbonUVEdgeMode_MAX = 2,
};

enum class ENiagaraScalabilityUpdateFrequency {
    SpawnOnly = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    Continuous = 4,
    ENiagaraScalabilityUpdateFrequency_MAX = 5,
};

enum class ENiagaraScriptCompileStatus {
    NCS_Unknown = 0,
    NCS_Dirty = 1,
    NCS_Error = 2,
    NCS_UpToDate = 3,
    NCS_BeingCreated = 4,
    NCS_UpToDateWithWarnings = 5,
    NCS_ComputeUpToDateWithWarnings = 6,
    NCS_MAX = 7,
};

enum class ENiagaraScriptContextStaticSwitch {
    System = 0,
    Emitter = 1,
    Particle = 2,
    ENiagaraScriptContextStaticSwitch_MAX = 3,
};

enum class ENiagaraScriptGroup {
    Particle = 0,
    Emitter = 1,
    System = 2,
    Max = 3,
    ENiagaraScriptGroup_MAX = 4,
};

enum class ENiagaraScriptLibraryVisibility {
    Invalid = 0,
    Unexposed = 1,
    Library = 2,
    Hidden = 3,
    ENiagaraScriptLibraryVisibility_MAX = 4,
};

enum class ENiagaraScriptTemplateSpecification {
    None = 0,
    Template = 1,
    Behavior = 2,
    ENiagaraScriptTemplateSpecification_MAX = 3,
};

enum class ENiagaraScriptUsage {
    Function = 0,
    Module = 1,
    DynamicInput = 2,
    ParticleSpawnScript = 3,
    ParticleSpawnScriptInterpolated = 4,
    ParticleUpdateScript = 5,
    ParticleEventScript = 6,
    ParticleSimulationStageScript = 7,
    ParticleGPUComputeScript = 8,
    EmitterSpawnScript = 9,
    EmitterUpdateScript = 10,
    SystemSpawnScript = 11,
    SystemUpdateScript = 12,
    ENiagaraScriptUsage_MAX = 13,
};

enum class ENiagaraSimTarget {
    CPUSim = 0,
    GPUComputeSim = 1,
    ENiagaraSimTarget_MAX = 2,
};

enum class ENiagaraSortMode {
    None = 0,
    ViewDepth = 1,
    ViewDistance = 2,
    CustomAscending = 3,
    CustomDecending = 4,
    ENiagaraSortMode_MAX = 5,
};

enum class ENiagaraSpriteAlignment {
    Unaligned = 0,
    VelocityAligned = 1,
    CustomAlignment = 2,
    ENiagaraSpriteAlignment_MAX = 3,
};

enum class ENiagaraSpriteFacingMode {
    FaceCamera = 0,
    FaceCameraPlane = 1,
    CustomFacingVector = 2,
    FaceCameraPosition = 3,
    FaceCameraDistanceBlend = 4,
    ENiagaraSpriteFacingMode_MAX = 5,
};

enum class ENiagaraStatDisplayMode {
    Percent = 0,
    Absolute = 1,
    ENiagaraStatDisplayMode_MAX = 2,
};

enum class ENiagaraStatEvaluationType {
    Average = 0,
    Maximum = 1,
    ENiagaraStatEvaluationType_MAX = 2,
};

enum class ENiagaraSystemInstanceState {
    None = 0,
    PendingSpawn = 1,
    PendingSpawnPaused = 2,
    Spawning = 3,
    Running = 4,
    Paused = 5,
    Num = 6,
    ENiagaraSystemInstanceState_MAX = 7,
};

enum class ENiagaraSystemSpawnSectionEndBehavior {
    SetSystemInactive = 0,
    Deactivate = 1,
    None = 2,
    ENiagaraSystemSpawnSectionEndBehavior_MAX = 3,
};

enum class ENiagaraSystemSpawnSectionEvaluateBehavior {
    ActivateIfInactive = 0,
    None = 1,
    ENiagaraSystemSpawnSectionEvaluateBehavior_MAX = 2,
};

enum class ENiagaraSystemSpawnSectionStartBehavior {
    Activate = 0,
    ENiagaraSystemSpawnSectionStartBehavior_MAX = 1,
};

enum class ENiagaraTickBehavior {
    UsePrereqs = 0,
    UseComponentTickGroup = 1,
    ForceTickFirst = 2,
    ForceTickLast = 3,
    ENiagaraTickBehavior_MAX = 4,
};

enum class ENiagaraVariantMode {
    None = 0,
    Object = 1,
    DataInterface = 2,
    Bytes = 3,
    ENiagaraVariantMode_MAX = 4,
};

enum class EParticleAllocationMode {
    AutomaticEstimate = 0,
    ManualEstimate = 1,
    EParticleAllocationMode_MAX = 2,
};

enum class EScriptExecutionMode {
    EveryParticle = 0,
    SpawnedParticles = 1,
    SingleParticle = 2,
    EScriptExecutionMode_MAX = 3,
};

enum class ESetResolutionMethod {
    Independent = 0,
    MaxAxis = 1,
    CellSize = 2,
    ESetResolutionMethod_MAX = 3,
};

enum class EUnusedAttributeBehaviour {
    Copy = 0,
    Zero = 1,
    None = 2,
    MarkInvalid = 3,
    PassThrough = 4,
    EUnusedAttributeBehaviour_MAX = 5,
};

// Size: 0xd8
struct FEmitterCompiledScriptPair {
};

// Size: 0x10
struct FMeshTriCoordinate {
    /* 0x0000 */ int32_t Tri;
    /* 0x0004 */ FVector BaryCoord;
};

// Size: 0xf0
struct FMovieSceneNiagaraBoolParameterSectionTemplate : public FMovieSceneNiagaraParameterSectionTemplate {
    /* 0x0060 */ FMovieSceneBoolChannel BoolChannel;
};

// Size: 0x130
class UMovieSceneNiagaraBoolParameterTrack : public UMovieSceneNiagaraParameterTrack {
};

// Size: 0x2e0
struct FMovieSceneNiagaraColorParameterSectionTemplate : public FMovieSceneNiagaraParameterSectionTemplate {
    /* 0x0060 */ FMovieSceneFloatChannel RedChannel;
    /* 0x0100 */ FMovieSceneFloatChannel GreenChannel;
    /* 0x01a0 */ FMovieSceneFloatChannel BlueChannel;
    /* 0x0240 */ FMovieSceneFloatChannel AlphaChannel;
};

// Size: 0x130
class UMovieSceneNiagaraColorParameterTrack : public UMovieSceneNiagaraParameterTrack {
};

// Size: 0x100
struct FMovieSceneNiagaraFloatParameterSectionTemplate : public FMovieSceneNiagaraParameterSectionTemplate {
    /* 0x0060 */ FMovieSceneFloatChannel FloatChannel;
};

// Size: 0x130
class UMovieSceneNiagaraFloatParameterTrack : public UMovieSceneNiagaraParameterTrack {
};

// Size: 0xf0
struct FMovieSceneNiagaraIntegerParameterSectionTemplate : public FMovieSceneNiagaraParameterSectionTemplate {
    /* 0x0060 */ FMovieSceneIntegerChannel IntegerChannel;
};

// Size: 0x130
class UMovieSceneNiagaraIntegerParameterTrack : public UMovieSceneNiagaraParameterTrack {
};

// Size: 0x60
struct FMovieSceneNiagaraParameterSectionTemplate : public FMovieSceneEvalTemplate {
    /* 0x0020 */ FNiagaraVariable Parameter;
};

// Size: 0x128
class UMovieSceneNiagaraParameterTrack : public UMovieSceneNiagaraTrack {
    /* 0x00e8 */ FNiagaraVariable Parameter;
};

// Size: 0x138
class UMovieSceneNiagaraSystemSpawnSection : public UMovieSceneSection {
    /* 0x0128 */ ENiagaraSystemSpawnSectionStartBehavior SectionStartBehavior;
    /* 0x012c */ ENiagaraSystemSpawnSectionEvaluateBehavior SectionEvaluateBehavior;
    /* 0x0130 */ ENiagaraSystemSpawnSectionEndBehavior SectionEndBehavior;
    /* 0x0134 */ ENiagaraAgeUpdateMode AgeUpdateMode;
};

// Size: 0xf0
class UMovieSceneNiagaraSystemTrack : public UMovieSceneNiagaraTrack {
};

// Size: 0x28
struct FMovieSceneNiagaraSystemTrackImplementation : public FMovieSceneTrackImplementation {
    /* 0x0010 */ FFrameNumber SpawnSectionStartFrame;
    /* 0x0014 */ FFrameNumber SpawnSectionEndFrame;
    /* 0x0018 */ ENiagaraSystemSpawnSectionStartBehavior SpawnSectionStartBehavior;
    /* 0x001c */ ENiagaraSystemSpawnSectionEvaluateBehavior SpawnSectionEvaluateBehavior;
    /* 0x0020 */ ENiagaraSystemSpawnSectionEndBehavior SpawnSectionEndBehavior;
    /* 0x0024 */ ENiagaraAgeUpdateMode AgeUpdateMode;
};

// Size: 0x20
struct FMovieSceneNiagaraSystemTrackTemplate : public FMovieSceneEvalTemplate {
};

// Size: 0xe8
class UMovieSceneNiagaraTrack : public UMovieSceneNameableTrack {
    /* 0x00d8 */ TArray<UMovieSceneSection*> Sections;
};

// Size: 0x2e8
struct FMovieSceneNiagaraVectorParameterSectionTemplate : public FMovieSceneNiagaraParameterSectionTemplate {
    /* 0x0060 */ FMovieSceneFloatChannel VectorChannels[4];
    /* 0x02e0 */ int32_t ChannelsUsed;
};

// Size: 0x138
class UMovieSceneNiagaraVectorParameterTrack : public UMovieSceneNiagaraParameterTrack {
    /* 0x0130 */ int32_t ChannelsUsed;
};

// Size: 0x38
struct FNCPool {
    /* 0x0000 */ TArray<FNCPoolElement> FreeElements;
};

// Size: 0x10
struct FNCPoolElement {
    /* 0x0000 */ UNiagaraComponent* Component;
};

// Size: 0x10
struct FNDIStaticMeshSectionFilter {
    /* 0x0000 */ TArray<int32_t> AllowedMaterialSlots;
};

// Size: 0x318
class ANiagaraActor : public AActor {
    /* 0x02f8 */ UNiagaraComponent* NiagaraComponent;
    /* 0x0300 */ UBillboardComponent* SpriteComponent;
    /* 0x0308 */ UArrowComponent* ArrowComponent;
    /* 0x0310 */ bool bDestroyOnSystemFinish;

    void OnNiagaraSystemFinished(UNiagaraComponent* FinishedComponent);
    void SetDestroyOnSystemFinish(bool bShouldDestroyOnSystemFinish);
};

// Size: 0x1c
struct FNiagaraAssetVersion {
    /* 0x0000 */ int32_t MajorVersion;
    /* 0x0004 */ int32_t MinorVersion;
    /* 0x0008 */ FGuid VersionGuid;
    /* 0x0018 */ bool bIsVisibleInVersionSelector;
};

// Size: 0x120
class UNiagaraBakerSettings : public UObject {
    /* 0x0030 */ float StartSeconds;
    /* 0x0034 */ float DurationSeconds;
    /* 0x0038 */ int32_t FramesPerSecond;
    /* 0x003c */ bool bPreviewLooping;
    /* 0x0040 */ FIntPoint FramesPerDimension;
    /* 0x0048 */ TArray<FNiagaraBakerTextureSettings> OutputTextures;
    /* 0x0058 */ ENiagaraBakerViewMode CameraViewportMode;
    /* 0x005c */ FVector CameraViewportLocation[7];
    /* 0x00b0 */ FRotator CameraViewportRotation[7];
    /* 0x0104 */ float CameraOrbitDistance;
    /* 0x0108 */ float CameraFOV;
    /* 0x010c */ float CameraOrthoWidth;
    /* 0x0110 */ bool bUseCameraAspectRatio;
    /* 0x0114 */ float CameraAspectRatio;
    /* 0x0118 */ bool bRenderComponentOnly;
};

// Size: 0x38
struct FNiagaraBakerTextureSettings {
    /* 0x0000 */ FName OutputName;
    /* 0x000c */ FNiagaraBakerTextureSource SourceBinding;
    /* 0x0018 */ bool bUseFrameSize;
    /* 0x001c */ FIntPoint FrameSize;
    /* 0x0024 */ FIntPoint TextureSize;
    /* 0x0030 */ UTexture2D* GeneratedTexture;
};

// Size: 0xc
struct FNiagaraBakerTextureSource {
    /* 0x0000 */ FName SourceName;
};

// Size: 0x78
class UNiagaraBaselineController : public UObject {
    /* 0x0030 */ float TestDuration;
    /* 0x0038 */ UNiagaraEffectType* EffectType;
    /* 0x0040 */ ANiagaraPerfBaselineActor* Owner;
    /* 0x0048 */ TSoftObjectPtr<UNiagaraSystem> System;

    UNiagaraSystem* GetSystem();
    void OnBeginTest();
    void OnEndTest(FNiagaraPerfBaselineStats Stats);
    void OnOwnerTick(float DeltaTime);
    bool OnTickTest();
};

// Size: 0x90
class UNiagaraBaselineController_Basic : public UNiagaraBaselineController {
    /* 0x0078 */ int32_t NumInstances;
    /* 0x0080 */ TArray<UNiagaraComponent*> SpawnedComponents;
};

// Size: 0x4
struct FNiagaraBool {
    /* 0x0000 */ int32_t Value;
};

// Size: 0x48
struct FNiagaraBoundParameter {
    /* 0x0000 */ FNiagaraVariable Parameter;
    /* 0x0040 */ int32_t SrcOffset;
    /* 0x0044 */ int32_t DestOffset;
};

// Size: 0x2c
struct FNiagaraCollisionEventPayload {
    /* 0x0000 */ FVector CollisionPos;
    /* 0x000c */ FVector CollisionNormal;
    /* 0x0018 */ FVector CollisionVelocity;
    /* 0x0024 */ int32_t ParticleIndex;
    /* 0x0028 */ int32_t PhysicalMaterialIndex;
};

// Size: 0x70
struct FNiagaraCompileDependency {
    /* 0x0000 */ FString LinkerErrorMessage;
    /* 0x0010 */ FGuid NodeGuid;
    /* 0x0020 */ FGuid PinGuid;
    /* 0x0030 */ TArray<FGuid> StackGuids;
    /* 0x0040 */ FNiagaraVariableBase DependentVariable;
};

// Size: 0x30
struct FNiagaraCompileHashVisitorDebugInfo {
    /* 0x0000 */ FString Object;
    /* 0x0010 */ TArray<FString> PropertyKeys;
    /* 0x0020 */ TArray<FString> PropertyValues;
};

// Size: 0x50
struct FNiagaraCompilerTag {
    /* 0x0000 */ FNiagaraVariable Variable;
    /* 0x0040 */ FString StringValue;
};

// Size: 0x880
class UNiagaraComponent : public UFXSystemComponent {
    /* 0x04e0 */ UNiagaraSystem* Asset;
    /* 0x04e8 */ ENiagaraTickBehavior TickBehavior;
    /* 0x04ec */ int32_t RandomSeedOffset;
    /* 0x04f0 */ FNiagaraUserRedirectionParameterStore OverrideParameters;
    /* 0x0680 */ TMap<FName, bool> EditorOverridesValue;
    /* 0x06d0 */ TMap<FNiagaraVariableBase, FNiagaraVariant> TemplateParameterOverrides;
    /* 0x0720 */ TMap<FNiagaraVariableBase, FNiagaraVariant> InstanceParameterOverrides;
    /* 0x07a0 */ bool bForceSolo;
    /* 0x07a0 */ bool bEnableGpuComputeDebug;
    /* 0x07d0 */ bool bAutoDestroy;
    /* 0x07d0 */ bool bRenderingEnabled;
    /* 0x07d0 */ bool bAutoManageAttachment;
    /* 0x07d0 */ bool bAutoAttachWeldSimulatedBodies;
    /* 0x07d4 */ float MaxTimeBeforeForceUpdateTransform;
    /* 0x07d8 */ TArray<FNiagaraMaterialOverride> EmitterMaterials;
    /* 0x07f0 */ FMulticastInlineDelegate OnSystemFinished;
    /* 0x0800 */ TWeakObjectPtr<USceneComponent> AutoAttachParent;
    /* 0x0808 */ FName AutoAttachSocketName;
    /* 0x0814 */ EAttachmentRule AutoAttachLocationRule;
    /* 0x0815 */ EAttachmentRule AutoAttachRotationRule;
    /* 0x0816 */ EAttachmentRule AutoAttachScaleRule;
    /* 0x081c */ bool bWaitForCompilationOnActivate;

    void AdvanceSimulation(int32_t TickCount, float TickDeltaSeconds);
    void AdvanceSimulationByTime(float SimulateTime, float TickDeltaSeconds);
    ENiagaraAgeUpdateMode GetAgeUpdateMode() const;
    UNiagaraSystem* GetAsset() const;
    UNiagaraDataInterface* GetDataInterface(FString Name);
    float GetDesiredAge() const;
    bool GetForceSolo() const;
    bool GetLockDesiredAgeDeltaTimeToSeekDelta() const;
    float GetMaxSimTime() const;
    TArray<FVector> GetNiagaraParticlePositions_DebugOnly(FString InEmitterName);
    TArray<FVector> GetNiagaraParticleValueVec3_DebugOnly(FString InEmitterName, FString InValueName);
    TArray<float> GetNiagaraParticleValues_DebugOnly(FString InEmitterName, FString InValueName);
    float GetPreviewLODDistance() const;
    bool GetPreviewLODDistanceEnabled() const;
    int32_t GetRandomSeedOffset() const;
    float GetSeekDelta() const;
    ENiagaraTickBehavior GetTickBehavior() const;
    void InitForPerformanceBaseline();
    bool IsPaused() const;
    void ReinitializeSystem();
    void ResetSystem();
    void SeekToDesiredAge(float InDesiredAge);
    void SetAgeUpdateMode(ENiagaraAgeUpdateMode InAgeUpdateMode);
    void SetAllowScalability(bool bAllow);
    void SetAsset(UNiagaraSystem* InAsset, bool bResetExistingOverrideParameters);
    void SetAutoDestroy(bool bInAutoDestroy);
    void SetCanRenderWhileSeeking(bool bInCanRenderWhileSeeking);
    void SetDesiredAge(float InDesiredAge);
    void SetForceSolo(bool bInForceSolo);
    void SetGpuComputeDebug(bool bEnableDebug);
    void SetLockDesiredAgeDeltaTimeToSeekDelta(bool bLock);
    void SetMaxSimTime(float InMaxTime);
    void SetNiagaraVariableActor(FString InVariableName, AActor* Actor);
    void SetNiagaraVariableBool(FString InVariableName, bool InValue);
    void SetNiagaraVariableFloat(FString InVariableName, float InValue);
    void SetNiagaraVariableInt(FString InVariableName, int32_t InValue);
    void SetNiagaraVariableLinearColor(FString InVariableName, const FLinearColor& InValue);
    void SetNiagaraVariableObject(FString InVariableName, UObject* Object);
    void SetNiagaraVariableQuat(FString InVariableName, const FQuat& InValue);
    void SetNiagaraVariableVec2(FString InVariableName, FVector2D InValue);
    void SetNiagaraVariableVec3(FString InVariableName, FVector InValue);
    void SetNiagaraVariableVec4(FString InVariableName, const FVector4& InValue);
    void SetPaused(bool bInPaused);
    void SetPreviewLODDistance(bool bEnablePreviewLODDistance, float PreviewLODDistance);
    void SetRandomSeedOffset(int32_t NewRandomSeedOffset);
    void SetRenderingEnabled(bool bInRenderingEnabled);
    void SetSeekDelta(float InSeekDelta);
    void SetTickBehavior(ENiagaraTickBehavior NewTickBehavior);
    void SetVariableActor(FName InVariableName, AActor* Actor);
    void SetVariableBool(FName InVariableName, bool InValue);
    void SetVariableFloat(FName InVariableName, float InValue);
    void SetVariableInt(FName InVariableName, int32_t InValue);
    void SetVariableLinearColor(FName InVariableName, const FLinearColor& InValue);
    void SetVariableMaterial(FName InVariableName, UMaterialInterface* Object);
    void SetVariableObject(FName InVariableName, UObject* Object);
    void SetVariableQuat(FName InVariableName, const FQuat& InValue);
    void SetVariableTextureRenderTarget(FName InVariableName, UTextureRenderTarget* TextureRenderTarget);
    void SetVariableVec2(FName InVariableName, FVector2D InValue);
    void SetVariableVec3(FName InVariableName, FVector InValue);
    void SetVariableVec4(FName InVariableName, const FVector4& InValue);
};

// Size: 0x88
class UNiagaraComponentPool : public UObject {
    /* 0x0030 */ TMap<UNiagaraSystem*, FNCPool> WorldParticleSystemPools;
};

// Size: 0x1d8
struct FNiagaraComponentPropertyBinding {
    /* 0x0000 */ FNiagaraVariableAttributeBinding AttributeBinding;
    /* 0x0108 */ FName PropertyName;
    /* 0x0118 */ FNiagaraTypeDefinition PropertyType;
    /* 0x0138 */ FName MetadataSetterName;
    /* 0x0148 */ TMap<FString, FString> PropertySetterParameterDefaults;
    /* 0x0198 */ FNiagaraVariable WritableValue;
};

// Size: 0x340
class UNiagaraComponentRendererProperties : public UNiagaraRendererProperties {
    /* 0x00a8 */ UClass* ComponentType;
    /* 0x00b0 */ uint32_t ComponentCountLimit;
    /* 0x00b8 */ FNiagaraVariableAttributeBinding EnabledBinding;
    /* 0x01c0 */ FNiagaraVariableAttributeBinding RendererVisibilityTagBinding;
    /* 0x02c8 */ bool bAssignComponentsOnParticleID;
    /* 0x02c9 */ bool bOnlyCreateComponentsOnParticleSpawn;
    /* 0x02ca */ bool bVisualizeComponents;
    /* 0x02cc */ int32_t RendererVisibility;
    /* 0x02d0 */ USceneComponent* TemplateComponent;
    /* 0x02d8 */ TArray<FNiagaraComponentPropertyBinding> PropertyBindings;
};

// Size: 0x120
class UNiagaraComponentSettings : public UObject {
    /* 0x0030 */ TSet<FName> SuppressActivationList;
    /* 0x0080 */ TSet<FName> ForceAutoPooolingList;
    /* 0x00d0 */ TSet<FNiagaraEmitterNameSettingsRef> SuppressEmitterList;
};

// Size: 0x30
class UNiagaraConvertInPlaceUtilityBase : public UObject {
};

// Size: 0x80
class UNiagaraDataInterface : public UNiagaraDataInterfaceBase {
};

// Size: 0x98
class UNiagaraDataInterface2DArrayTexture : public UNiagaraDataInterface {
    /* 0x0080 */ UTexture2DArray* Texture;
};

// Size: 0x98
class UNiagaraDataInterfaceArray : public UNiagaraDataInterface {
    /* 0x0088 */ int32_t MaxElements;
};

// Size: 0xa8
class UNiagaraDataInterfaceArrayBool : public UNiagaraDataInterfaceArray {
    /* 0x0098 */ TArray<bool> BoolData;
};

// Size: 0xa8
class UNiagaraDataInterfaceArrayColor : public UNiagaraDataInterfaceArray {
    /* 0x0098 */ TArray<FLinearColor> ColorData;
};

// Size: 0xa8
class UNiagaraDataInterfaceArrayFloat : public UNiagaraDataInterfaceArray {
    /* 0x0098 */ TArray<float> FloatData;
};

// Size: 0xa8
class UNiagaraDataInterfaceArrayFloat2 : public UNiagaraDataInterfaceArray {
    /* 0x0098 */ TArray<FVector2D> FloatData;
};

// Size: 0xa8
class UNiagaraDataInterfaceArrayFloat3 : public UNiagaraDataInterfaceArray {
    /* 0x0098 */ TArray<FVector> FloatData;
};

// Size: 0xa8
class UNiagaraDataInterfaceArrayFloat4 : public UNiagaraDataInterfaceArray {
    /* 0x0098 */ TArray<FVector4> FloatData;
};

// Size: 0x30
class UNiagaraDataInterfaceArrayFunctionLibrary : public UBlueprintFunctionLibrary {

    static TArray<bool> GetNiagaraArrayBool(UNiagaraComponent* NiagaraSystem, FName OverrideName);
    static bool GetNiagaraArrayBoolValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index);
    static TArray<FLinearColor> GetNiagaraArrayColor(UNiagaraComponent* NiagaraSystem, FName OverrideName);
    static FLinearColor GetNiagaraArrayColorValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index);
    static TArray<float> GetNiagaraArrayFloat(UNiagaraComponent* NiagaraSystem, FName OverrideName);
    static float GetNiagaraArrayFloatValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index);
    static TArray<int32_t> GetNiagaraArrayInt32(UNiagaraComponent* NiagaraSystem, FName OverrideName);
    static int32_t GetNiagaraArrayInt32Value(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index);
    static TArray<FQuat> GetNiagaraArrayQuat(UNiagaraComponent* NiagaraSystem, FName OverrideName);
    static FQuat GetNiagaraArrayQuatValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index);
    static TArray<FVector> GetNiagaraArrayVector(UNiagaraComponent* NiagaraSystem, FName OverrideName);
    static TArray<FVector2D> GetNiagaraArrayVector2D(UNiagaraComponent* NiagaraSystem, FName OverrideName);
    static FVector2D GetNiagaraArrayVector2DValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index);
    static TArray<FVector4> GetNiagaraArrayVector4(UNiagaraComponent* NiagaraSystem, FName OverrideName);
    static FVector4 GetNiagaraArrayVector4Value(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index);
    static FVector GetNiagaraArrayVectorValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index);
    static void SetNiagaraArrayBool(UNiagaraComponent* NiagaraSystem, FName OverrideName, const TArray<bool>& ArrayData);
    static void SetNiagaraArrayBoolValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index, const bool& Value, bool bSizeToFit);
    static void SetNiagaraArrayColor(UNiagaraComponent* NiagaraSystem, FName OverrideName, const TArray<FLinearColor>& ArrayData);
    static void SetNiagaraArrayColorValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index, const FLinearColor& Value, bool bSizeToFit);
    static void SetNiagaraArrayFloat(UNiagaraComponent* NiagaraSystem, FName OverrideName, const TArray<float>& ArrayData);
    static void SetNiagaraArrayFloatValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index, float Value, bool bSizeToFit);
    static void SetNiagaraArrayInt32(UNiagaraComponent* NiagaraSystem, FName OverrideName, const TArray<int32_t>& ArrayData);
    static void SetNiagaraArrayInt32Value(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index, int32_t Value, bool bSizeToFit);
    static void SetNiagaraArrayQuat(UNiagaraComponent* NiagaraSystem, FName OverrideName, const TArray<FQuat>& ArrayData);
    static void SetNiagaraArrayQuatValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index, const FQuat& Value, bool bSizeToFit);
    static void SetNiagaraArrayVector(UNiagaraComponent* NiagaraSystem, FName OverrideName, const TArray<FVector>& ArrayData);
    static void SetNiagaraArrayVector2D(UNiagaraComponent* NiagaraSystem, FName OverrideName, const TArray<FVector2D>& ArrayData);
    static void SetNiagaraArrayVector2DValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index, const FVector2D& Value, bool bSizeToFit);
    static void SetNiagaraArrayVector4(UNiagaraComponent* NiagaraSystem, FName OverrideName, const TArray<FVector4>& ArrayData);
    static void SetNiagaraArrayVector4Value(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index, const FVector4& Value, bool bSizeToFit);
    static void SetNiagaraArrayVectorValue(UNiagaraComponent* NiagaraSystem, FName OverrideName, int32_t index, const FVector& Value, bool bSizeToFit);
};

// Size: 0xa8
class UNiagaraDataInterfaceArrayInt32 : public UNiagaraDataInterfaceArray {
    /* 0x0098 */ TArray<int32_t> IntData;
};

// Size: 0xa8
class UNiagaraDataInterfaceArrayQuat : public UNiagaraDataInterfaceArray {
    /* 0x0098 */ TArray<FQuat> QuatData;
};

// Size: 0x90
class UNiagaraDataInterfaceAudioOscilloscope : public UNiagaraDataInterface {
    /* 0x0080 */ USoundSubmix* Submix;
    /* 0x0088 */ int32_t Resolution;
    /* 0x008c */ float ScopeInMilliseconds;
};

// Size: 0xb8
class UNiagaraDataInterfaceAudioPlayer : public UNiagaraDataInterface {
    /* 0x0080 */ USoundBase* SoundToPlay;
    /* 0x0088 */ USoundAttenuation* Attenuation;
    /* 0x0090 */ USoundConcurrency* Concurrency;
    /* 0x0098 */ TArray<FName> ParameterNames;
    /* 0x00a8 */ bool bLimitPlaysPerTick;
    /* 0x00ac */ int32_t MaxPlaysPerTick;
    /* 0x00b0 */ bool bStopWhenComponentIsDestroyed;
};

// Size: 0x98
class UNiagaraDataInterfaceAudioSpectrum : public UNiagaraDataInterfaceAudioSubmix {
    /* 0x0088 */ int32_t Resolution;
    /* 0x008c */ float MinimumFrequency;
    /* 0x0090 */ float MaximumFrequency;
    /* 0x0094 */ float NoiseFloorDb;
};

// Size: 0x88
class UNiagaraDataInterfaceAudioSubmix : public UNiagaraDataInterface {
    /* 0x0080 */ USoundSubmix* Submix;
};

// Size: 0x88
class UNiagaraDataInterfaceCamera : public UNiagaraDataInterface {
    /* 0x0080 */ int32_t PlayerControllerIndex;
    /* 0x0084 */ bool bRequireCurrentFrameData;
};

// Size: 0x90
class UNiagaraDataInterfaceCollisionQuery : public UNiagaraDataInterface {
};

// Size: 0x2c0
class UNiagaraDataInterfaceColorCurve : public UNiagaraDataInterfaceCurveBase {
    /* 0x00c0 */ FRichCurve RedCurve;
    /* 0x0140 */ FRichCurve GreenCurve;
    /* 0x01c0 */ FRichCurve BlueCurve;
    /* 0x0240 */ FRichCurve AlphaCurve;
};

// Size: 0x90
class UNiagaraDataInterfaceCubeTexture : public UNiagaraDataInterface {
    /* 0x0080 */ UTextureCube* Texture;
};

// Size: 0x90
class UNiagaraDataInterfaceCurlNoise : public UNiagaraDataInterface {
    /* 0x0080 */ uint32_t Seed;
};

// Size: 0x140
class UNiagaraDataInterfaceCurve : public UNiagaraDataInterfaceCurveBase {
    /* 0x00c0 */ FRichCurve Curve;
};

// Size: 0xc0
class UNiagaraDataInterfaceCurveBase : public UNiagaraDataInterface {
    /* 0x0080 */ TArray<float> ShaderLUT;
    /* 0x0090 */ float LUTMinTime;
    /* 0x0094 */ float LUTMaxTime;
    /* 0x0098 */ float LUTInvTimeRange;
    /* 0x009c */ float LUTNumSamplesMinusOne;
    /* 0x00a0 */ bool bUseLUT;
    /* 0x00a0 */ bool bExposeCurve;
    /* 0x00a0 */ bool bOptimizeLUT;
    /* 0x00a0 */ bool bOverrideOptimizeThreshold;
    /* 0x00a0 */ bool HasEditorData;
    /* 0x00a4 */ float OptimizeThreshold;
    /* 0x00a8 */ FName ExposedName;
    /* 0x00b8 */ UTexture2D* ExposedTexture;
};

// Size: 0x80
class UNiagaraDataInterfaceDebugDraw : public UNiagaraDataInterface {
};

// Size: 0xd0
class UNiagaraDataInterfaceExport : public UNiagaraDataInterface {
    /* 0x0080 */ FNiagaraUserParameterBinding CallbackHandlerParameter;
    /* 0x00c0 */ ENDIExport_GPUAllocationMode GPUAllocationMode;
    /* 0x00c4 */ int32_t GPUAllocationFixedSize;
    /* 0x00c8 */ float GPUAllocationPerParticleSize;
};

// Size: 0x80
class UNiagaraDataInterfaceGBuffer : public UNiagaraDataInterface {
};

// Size: 0x140
class UNiagaraDataInterfaceGrid2D : public UNiagaraDataInterfaceRWBase {
    /* 0x0120 */ int32_t NumCellsX;
    /* 0x0124 */ int32_t NumCellsY;
    /* 0x0128 */ int32_t NumCellsMaxAxis;
    /* 0x012c */ int32_t NumAttributes;
    /* 0x0130 */ bool SetGridFromMaxAxis;
    /* 0x0134 */ FVector2D WorldBBoxSize;
};

// Size: 0x230
class UNiagaraDataInterfaceGrid2DCollection : public UNiagaraDataInterfaceGrid2D {
    /* 0x0140 */ FNiagaraUserParameterBinding RenderTargetUserParameter;
    /* 0x0180 */ ENiagaraGpuBufferFormat OverrideBufferFormat;
    /* 0x0181 */ bool bOverrideFormat;
    /* 0x0181 */ bool bPreviewGrid;
    /* 0x0184 */ FName PreviewAttribute;
    /* 0x01e0 */ TMap<uint64_t, UTextureRenderTarget2DArray*> ManagedRenderTargets;

    bool FillRawTexture2D(const UNiagaraComponent* Component, UTextureRenderTarget2D* Dest, int32_t& TilesX, int32_t& TilesY);
    bool FillTexture2D(const UNiagaraComponent* Component, UTextureRenderTarget2D* Dest, int32_t AttributeIndex);
    void GetRawTextureSize(const UNiagaraComponent* Component, int32_t& SizeX, int32_t& SizeY);
    void GetTextureSize(const UNiagaraComponent* Component, int32_t& SizeX, int32_t& SizeY);
};

// Size: 0x1b0
class UNiagaraDataInterfaceGrid2DCollectionReader : public UNiagaraDataInterfaceGrid2D {
    /* 0x0140 */ FString EmitterName;
    /* 0x0150 */ FString DIName;
};

// Size: 0x148
class UNiagaraDataInterfaceGrid3D : public UNiagaraDataInterfaceRWBase {
    /* 0x0120 */ FIntVector NumCells;
    /* 0x012c */ float CellSize;
    /* 0x0130 */ int32_t NumCellsMaxAxis;
    /* 0x0134 */ ESetResolutionMethod SetResolutionMethod;
    /* 0x0138 */ FVector WorldBBoxSize;
};

// Size: 0x1f0
class UNiagaraDataInterfaceGrid3DCollection : public UNiagaraDataInterfaceGrid3D {
    /* 0x0148 */ int32_t NumAttributes;
    /* 0x0150 */ FNiagaraUserParameterBinding RenderTargetUserParameter;
    /* 0x0190 */ ENiagaraGpuBufferFormat OverrideBufferFormat;
    /* 0x0191 */ bool bOverrideFormat;
    /* 0x0191 */ bool bPreviewGrid;
    /* 0x0194 */ FName PreviewAttribute;

    bool FillRawVolumeTexture(const UNiagaraComponent* Component, UVolumeTexture* Dest, int32_t& TilesX, int32_t& TilesY, int32_t& TileZ);
    bool FillVolumeTexture(const UNiagaraComponent* Component, UVolumeTexture* Dest, int32_t AttributeIndex);
    void GetRawTextureSize(const UNiagaraComponent* Component, int32_t& SizeX, int32_t& SizeY, int32_t& SizeZ);
    void GetTextureSize(const UNiagaraComponent* Component, int32_t& SizeX, int32_t& SizeY, int32_t& SizeZ);
};

// Size: 0x1c8
class UNiagaraDataInterfaceIntRenderTarget2D : public UNiagaraDataInterfaceRWBase {
    /* 0x0120 */ FIntPoint Size;
    /* 0x0128 */ bool bPreviewRenderTarget;
    /* 0x012c */ FVector2D PreviewDisplayRange;
    /* 0x0138 */ FNiagaraUserParameterBinding RenderTargetUserParameter;
    /* 0x0178 */ TMap<uint64_t, UTextureRenderTarget2D*> ManagedRenderTargets;
};

// Size: 0xa0
class UNiagaraDataInterfaceLandscape : public UNiagaraDataInterface {
    /* 0x0080 */ AActor* SourceLandscape;
    /* 0x0088 */ ENDILandscape_SourceMode SourceMode;
    /* 0x0090 */ TArray<UPhysicalMaterial*> PhysicalMaterials;
};

// Size: 0x98
class UNiagaraDataInterfaceMeshRendererInfo : public UNiagaraDataInterface {
    /* 0x0080 */ UNiagaraMeshRendererProperties* MeshRenderer;
};

// Size: 0x150
class UNiagaraDataInterfaceNeighborGrid3D : public UNiagaraDataInterfaceGrid3D {
    /* 0x0148 */ uint32_t MaxNeighborsPerCell;
};

// Size: 0x80
class UNiagaraDataInterfaceOcclusion : public UNiagaraDataInterface {
};

// Size: 0x130
class UNiagaraDataInterfaceParticleRead : public UNiagaraDataInterfaceRWBase {
    /* 0x0120 */ FString EmitterName;
};

// Size: 0xb0
class UNiagaraDataInterfacePlatformSet : public UNiagaraDataInterface {
    /* 0x0080 */ FNiagaraPlatformSet Platforms;
};

// Size: 0x120
class UNiagaraDataInterfaceRWBase : public UNiagaraDataInterface {
    /* 0x0080 */ TSet<int32_t> OutputShaderStages;
    /* 0x00d0 */ TSet<int32_t> IterationShaderStages;
};

// Size: 0x210
class UNiagaraDataInterfaceRenderTarget2D : public UNiagaraDataInterfaceRWBase {
    /* 0x0120 */ FIntPoint Size;
    /* 0x0128 */ ENiagaraMipMapGeneration MipMapGeneration;
    /* 0x0129 */ uint8_t OverrideRenderTargetFormat;
    /* 0x012a */ bool bInheritUserParameterSettings;
    /* 0x012a */ bool bOverrideFormat;
    /* 0x012a */ bool bPreviewRenderTarget;
    /* 0x0130 */ FNiagaraUserParameterBinding RenderTargetUserParameter;
    /* 0x01c0 */ TMap<uint64_t, UTextureRenderTarget2D*> ManagedRenderTargets;
};

// Size: 0x1c0
class UNiagaraDataInterfaceRenderTarget2DArray : public UNiagaraDataInterfaceRWBase {
    /* 0x0120 */ FIntVector Size;
    /* 0x012c */ uint8_t OverrideRenderTargetFormat;
    /* 0x012d */ bool bInheritUserParameterSettings;
    /* 0x012d */ bool bOverrideFormat;
    /* 0x012d */ bool bPreviewRenderTarget;
    /* 0x0130 */ FNiagaraUserParameterBinding RenderTargetUserParameter;
    /* 0x0170 */ TMap<uint64_t, UTextureRenderTarget2DArray*> ManagedRenderTargets;
};

// Size: 0x1b8
class UNiagaraDataInterfaceRenderTargetCube : public UNiagaraDataInterfaceRWBase {
    /* 0x0120 */ int32_t Size;
    /* 0x0124 */ uint8_t OverrideRenderTargetFormat;
    /* 0x0125 */ bool bInheritUserParameterSettings;
    /* 0x0125 */ bool bOverrideFormat;
    /* 0x0125 */ bool bPreviewRenderTarget;
    /* 0x0128 */ FNiagaraUserParameterBinding RenderTargetUserParameter;
    /* 0x0168 */ TMap<uint64_t, UTextureRenderTargetCube*> ManagedRenderTargets;
};

// Size: 0x1c0
class UNiagaraDataInterfaceRenderTargetVolume : public UNiagaraDataInterfaceRWBase {
    /* 0x0120 */ FIntVector Size;
    /* 0x012c */ uint8_t OverrideRenderTargetFormat;
    /* 0x012d */ bool bInheritUserParameterSettings;
    /* 0x012d */ bool bOverrideFormat;
    /* 0x012d */ bool bPreviewRenderTarget;
    /* 0x0130 */ FNiagaraUserParameterBinding RenderTargetUserParameter;
    /* 0x0170 */ TMap<uint64_t, UTextureRenderTargetVolume*> ManagedRenderTargets;
};

// Size: 0x80
class UNiagaraDataInterfaceSimpleCounter : public UNiagaraDataInterface {
};

// Size: 0x168
class UNiagaraDataInterfaceSkeletalMesh : public UNiagaraDataInterface {
    /* 0x0080 */ ENDISkeletalMesh_SourceMode SourceMode;
    /* 0x0088 */ TSoftObjectPtr<USkeletalMesh> PreviewMesh;
    /* 0x00b8 */ AActor* Source;
    /* 0x00c0 */ FNiagaraUserParameterBinding MeshUserParameter;
    /* 0x0100 */ USkeletalMeshComponent* SourceComponent;
    /* 0x0108 */ ENDISkeletalMesh_SkinningMode SkinningMode;
    /* 0x0110 */ TArray<FName> SamplingRegions;
    /* 0x0120 */ int32_t WholeMeshLOD;
    /* 0x0128 */ TArray<FName> FilteredBones;
    /* 0x0138 */ TArray<FName> FilteredSockets;
    /* 0x0148 */ FName ExcludeBoneName;
    /* 0x0154 */ bool bExcludeBone;
    /* 0x0158 */ int32_t UvSetIndex;
    /* 0x015c */ bool bRequireCurrentFrameData;
};

// Size: 0xc8
class UNiagaraDataInterfaceSpline : public UNiagaraDataInterface {
    /* 0x0080 */ AActor* Source;
    /* 0x0088 */ FNiagaraUserParameterBinding SplineUserParameter;
};

// Size: 0x100
class UNiagaraDataInterfaceStaticMesh : public UNiagaraDataInterface {
    /* 0x0080 */ ENDIStaticMesh_SourceMode SourceMode;
    /* 0x0088 */ TSoftObjectPtr<UStaticMesh> PreviewMesh;
    /* 0x00b8 */ UStaticMesh* DefaultMesh;
    /* 0x00c0 */ AActor* Source;
    /* 0x00c8 */ UStaticMeshComponent* SourceComponent;
    /* 0x00d0 */ FNDIStaticMeshSectionFilter SectionFilter;
    /* 0x00e0 */ bool bUsePhysicsBodyVelocity;
    /* 0x00e8 */ TArray<FName> FilteredSockets;
};

// Size: 0x90
class UNiagaraDataInterfaceTexture : public UNiagaraDataInterface {
    /* 0x0080 */ UTexture* Texture;
};

// Size: 0x1c0
class UNiagaraDataInterfaceVector2DCurve : public UNiagaraDataInterfaceCurveBase {
    /* 0x00c0 */ FRichCurve XCurve;
    /* 0x0140 */ FRichCurve YCurve;
};

// Size: 0x2c0
class UNiagaraDataInterfaceVector4Curve : public UNiagaraDataInterfaceCurveBase {
    /* 0x00c0 */ FRichCurve XCurve;
    /* 0x0140 */ FRichCurve YCurve;
    /* 0x01c0 */ FRichCurve ZCurve;
    /* 0x0240 */ FRichCurve WCurve;
};

// Size: 0x240
class UNiagaraDataInterfaceVectorCurve : public UNiagaraDataInterfaceCurveBase {
    /* 0x00c0 */ FRichCurve XCurve;
    /* 0x0140 */ FRichCurve YCurve;
    /* 0x01c0 */ FRichCurve ZCurve;
};

// Size: 0x90
class UNiagaraDataInterfaceVectorField : public UNiagaraDataInterface {
    /* 0x0080 */ UVectorField* Field;
    /* 0x0088 */ bool bTileX;
    /* 0x0089 */ bool bTileY;
    /* 0x008a */ bool bTileZ;
};

// Size: 0x98
class UNiagaraDataInterfaceVolumeTexture : public UNiagaraDataInterface {
    /* 0x0080 */ UVolumeTexture* Texture;
};

// Size: 0x48
struct FNiagaraDataSetCompiledData {
    /* 0x0000 */ TArray<FNiagaraVariable> Variables;
    /* 0x0010 */ TArray<FNiagaraVariableLayoutInfo> VariableLayouts;
    /* 0x0020 */ FNiagaraDataSetID ID;
    /* 0x0030 */ uint32_t TotalFloatComponents;
    /* 0x0034 */ uint32_t TotalInt32Components;
    /* 0x0038 */ uint32_t TotalHalfComponents;
    /* 0x003c */ bool bRequiresPersistentIDs;
    /* 0x0040 */ ENiagaraSimTarget SimTarget;
};

// Size: 0x10
struct FNiagaraDataSetID {
    /* 0x0000 */ FName Name;
    /* 0x000c */ ENiagaraDataSetType Type;
};

// Size: 0x20
struct FNiagaraDataSetProperties {
    /* 0x0000 */ FNiagaraDataSetID ID;
    /* 0x0010 */ TArray<FNiagaraVariable> Variables;
};

// Size: 0x130
class UNiagaraDebugHUDSettings : public UObject {
    /* 0x0050 */ FNiagaraDebugHUDSettingsData Data;
};

// Size: 0xe0
struct FNiagaraDebugHUDSettingsData {
    /* 0x0000 */ bool bEnabled;
    /* 0x0001 */ bool bValidateSystemSimulationDataBuffers;
    /* 0x0002 */ bool bValidateParticleDataBuffers;
    /* 0x0003 */ bool bOverviewEnabled;
    /* 0x0004 */ ENiagaraDebugHudFont OverviewFont;
    /* 0x0008 */ FVector2D OverviewLocation;
    /* 0x0010 */ FString ActorFilter;
    /* 0x0020 */ bool bComponentFilterEnabled;
    /* 0x0028 */ FString ComponentFilter;
    /* 0x0038 */ bool bSystemFilterEnabled;
    /* 0x0040 */ FString SystemFilter;
    /* 0x0050 */ bool bEmitterFilterEnabled;
    /* 0x0058 */ FString EmitterFilter;
    /* 0x0068 */ bool bActorFilterEnabled;
    /* 0x006c */ ENiagaraDebugHudVerbosity SystemDebugVerbosity;
    /* 0x0070 */ ENiagaraDebugHudVerbosity SystemEmitterVerbosity;
    /* 0x0074 */ bool bSystemShowBounds;
    /* 0x0075 */ bool bSystemShowActiveOnlyInWorld;
    /* 0x0076 */ bool bShowSystemVariables;
    /* 0x0078 */ TArray<FNiagaraDebugHUDVariable> SystemVariables;
    /* 0x0088 */ FNiagaraDebugHudTextOptions SystemTextOptions;
    /* 0x0098 */ bool bShowParticleVariables;
    /* 0x0099 */ bool bEnableGpuParticleReadback;
    /* 0x00a0 */ TArray<FNiagaraDebugHUDVariable> ParticlesVariables;
    /* 0x00b0 */ FNiagaraDebugHudTextOptions ParticleTextOptions;
    /* 0x00c0 */ bool bShowParticlesVariablesWithSystem;
    /* 0x00c1 */ bool bUseMaxParticlesToDisplay;
    /* 0x00c4 */ int32_t MaxParticlesToDisplay;
    /* 0x00c8 */ ENiagaraDebugPlaybackMode PlaybackMode;
    /* 0x00c9 */ bool bPlaybackRateEnabled;
    /* 0x00cc */ float PlaybackRate;
    /* 0x00d0 */ bool bLoopTimeEnabled;
    /* 0x00d4 */ float LoopTime;
    /* 0x00d8 */ bool bShowGlobalBudgetInfo;
};

// Size: 0x18
struct FNiagaraDebugHUDVariable {
    /* 0x0000 */ bool bEnabled;
    /* 0x0008 */ FString Name;
};

// Size: 0x10
struct FNiagaraDebugHudTextOptions {
    /* 0x0000 */ ENiagaraDebugHudFont Font;
    /* 0x0004 */ ENiagaraDebugHudHAlign HorizontalAlignment;
    /* 0x0005 */ ENiagaraDebugHudVAlign VerticalAlignment;
    /* 0x0008 */ FVector2D ScreenOffset;
};

// Size: 0x20
struct FNiagaraDebuggerAcceptConnection {
    /* 0x0000 */ FGuid SessionId;
    /* 0x0010 */ FGuid InstanceId;
};

// Size: 0x20
struct FNiagaraDebuggerConnectionClosed {
    /* 0x0000 */ FGuid SessionId;
    /* 0x0010 */ FGuid InstanceId;
};

// Size: 0x18
struct FNiagaraDebuggerExecuteConsoleCommand {
    /* 0x0000 */ FString Command;
    /* 0x0010 */ bool bRequiresWorld;
};

// Size: 0x50
struct FNiagaraDebuggerOutlinerUpdate {
    /* 0x0000 */ FNiagaraOutlinerData OutlinerData;
};

// Size: 0x20
struct FNiagaraDebuggerRequestConnection {
    /* 0x0000 */ FGuid SessionId;
    /* 0x0010 */ FGuid InstanceId;
};

// Size: 0x14
struct FNiagaraDetailsLevelScaleOverrides {
    /* 0x0000 */ float Low;
    /* 0x0004 */ float Medium;
    /* 0x0008 */ float High;
    /* 0x000c */ float Epic;
    /* 0x0010 */ float Cine;
};

// Size: 0x14
struct FNiagaraDeviceProfileStateEntry {
    /* 0x0000 */ FName ProfileName;
    /* 0x000c */ uint32_t QualityLevelMask;
    /* 0x0010 */ uint32_t SetQualityLevelMask;
};

// Size: 0x48
class UNiagaraEditorDataBase : public UObject {
};

// Size: 0x30
class UNiagaraEditorParametersAdapterBase : public UObject {
};

// Size: 0xa0
class UNiagaraEffectType : public UObject {
    /* 0x0030 */ ENiagaraScalabilityUpdateFrequency UpdateFrequency;
    /* 0x0034 */ ENiagaraCullReaction CullReaction;
    /* 0x0038 */ UNiagaraSignificanceHandler* SignificanceHandler;
    /* 0x0040 */ TArray<FNiagaraSystemScalabilitySettings> DetailLevelScalabilitySettings;
    /* 0x0050 */ FNiagaraSystemScalabilitySettingsArray SystemScalabilitySettings;
    /* 0x0060 */ FNiagaraEmitterScalabilitySettingsArray EmitterScalabilitySettings;
    /* 0x0078 */ UNiagaraBaselineController* PerformanceBaselineController;
    /* 0x0080 */ FNiagaraPerfBaselineStats PerfBaselineStats;
    /* 0x0090 */ FGuid PerfBaselineVersion;
};

// Size: 0x538
class UNiagaraEmitter : public UObject {
    /* 0x0050 */ bool bLocalSpace;
    /* 0x0051 */ bool bDeterminism;
    /* 0x0054 */ int32_t RandomSeed;
    /* 0x0058 */ EParticleAllocationMode AllocationMode;
    /* 0x005c */ int32_t PreAllocationCount;
    /* 0x0060 */ FNiagaraEmitterScriptProperties UpdateScriptProps;
    /* 0x0088 */ FNiagaraEmitterScriptProperties SpawnScriptProps;
    /* 0x00b0 */ FNiagaraEmitterScriptProperties EmitterSpawnScriptProps;
    /* 0x00d8 */ FNiagaraEmitterScriptProperties EmitterUpdateScriptProps;
    /* 0x0100 */ TArray<FString> AttributesToPreserve;
    /* 0x0110 */ ENiagaraSimTarget SimTarget;
    /* 0x0114 */ FBox FixedBounds;
    /* 0x0130 */ int32_t MinDetailLevel;
    /* 0x0134 */ int32_t MaxDetailLevel;
    /* 0x0138 */ FNiagaraDetailsLevelScaleOverrides GlobalSpawnCountScaleOverrides;
    /* 0x0150 */ FNiagaraPlatformSet Platforms;
    /* 0x0180 */ FNiagaraEmitterScalabilityOverrides ScalabilityOverrides;
    /* 0x0190 */ bool bInterpolatedSpawning;
    /* 0x0190 */ bool bFixedBounds;
    /* 0x0190 */ bool bUseMinDetailLevel;
    /* 0x0190 */ bool bUseMaxDetailLevel;
    /* 0x0190 */ bool bOverrideGlobalSpawnCountScale;
    /* 0x0190 */ bool bRequiresPersistentIDs;
    /* 0x0190 */ bool bCombineEventSpawn;
    /* 0x0194 */ float MaxDeltaTimePerTick;
    /* 0x0198 */ uint32_t DefaultShaderStageIndex;
    /* 0x019c */ uint32_t MaxUpdateIterations;
    /* 0x01a0 */ TSet<uint32_t> SpawnStages;
    /* 0x01f0 */ bool bSimulationStagesEnabled;
    /* 0x01f0 */ bool bDeprecatedShaderStagesEnabled;
    /* 0x01f0 */ bool bLimitDeltaTime;
    /* 0x01f8 */ UNiagaraScriptSourceBase* GraphSource;
    /* 0x0200 */ bool bBakeOutRapidIteration;
    /* 0x0208 */ UTexture2D* ThumbnailImage;
    /* 0x0210 */ bool ThumbnailImageOutOfDate;
    /* 0x0214 */ bool bExposeToLibrary;
    /* 0x0215 */ bool bIsTemplateAsset;
    /* 0x0216 */ ENiagaraScriptTemplateSpecification TemplateSpecification;
    /* 0x0218 */ FText TemplateAssetDescription;
    /* 0x0230 */ FText Category;
    /* 0x0248 */ TArray<UNiagaraScript*> ScratchPadScripts;
    /* 0x0258 */ TArray<UNiagaraScript*> ParentScratchPadScripts;
    /* 0x0268 */ FGuid ChangeId;
    /* 0x0278 */ UNiagaraEditorDataBase* EditorData;
    /* 0x0280 */ UNiagaraEditorParametersAdapterBase* EditorParameters;
    /* 0x02d0 */ FString UniqueEmitterName;
    /* 0x02e0 */ TArray<UNiagaraRendererProperties*> RendererProperties;
    /* 0x02f0 */ TArray<FNiagaraEventScriptProperties> EventHandlerScriptProps;
    /* 0x0300 */ TArray<UNiagaraSimulationStageBase*> SimulationStages;
    /* 0x0310 */ UNiagaraScript* GPUComputeScript;
    /* 0x0318 */ TArray<FName> SharedEventGeneratorIds;
    /* 0x0328 */ UNiagaraEmitter* Parent;
    /* 0x0330 */ UNiagaraEmitter* ParentAtLastMerge;
    /* 0x0338 */ TArray<FParameterDefinitionsSubscription> ParameterDefinitionsSubscriptions;
    /* 0x04e8 */ TMap<FGuid, UNiagaraMessageDataBase*> MessageKeyToMessageMap;
};

// Size: 0x260
struct FNiagaraEmitterCompiledData {
    /* 0x0000 */ TArray<FName> SpawnAttributes;
    /* 0x0010 */ FNiagaraVariable EmitterSpawnIntervalVar;
    /* 0x0050 */ FNiagaraVariable EmitterInterpSpawnStartDTVar;
    /* 0x0090 */ FNiagaraVariable EmitterSpawnGroupVar;
    /* 0x00d0 */ FNiagaraVariable EmitterAgeVar;
    /* 0x0110 */ FNiagaraVariable EmitterRandomSeedVar;
    /* 0x0150 */ FNiagaraVariable EmitterInstanceSeedVar;
    /* 0x0190 */ FNiagaraVariable EmitterTotalSpawnedParticlesVar;
    /* 0x01d0 */ FNiagaraDataSetCompiledData DataSetCompiledData;
    /* 0x0218 */ FNiagaraDataSetCompiledData GPUCaptureDataSetCompiledData;
};

// Size: 0x50
struct FNiagaraEmitterHandle {
    /* 0x0000 */ FGuid ID;
    /* 0x0010 */ FName IdName;
    /* 0x001c */ bool bIsEnabled;
    /* 0x0020 */ FName Name;
    /* 0x0030 */ UNiagaraEmitter* Source;
    /* 0x0038 */ UNiagaraEmitter* LastMergedSource;
    /* 0x0040 */ bool bIsolated;
    /* 0x0048 */ UNiagaraEmitter* Instance;
};

// Size: 0x20
struct FNiagaraEmitterNameSettingsRef {
    /* 0x0000 */ FName SystemName;
    /* 0x0010 */ FString EmitterName;
};

// Size: 0x40
struct FNiagaraEmitterScalabilityOverride : public FNiagaraEmitterScalabilitySettings {
    /* 0x0038 */ bool bOverrideSpawnCountScale;
};

// Size: 0x10
struct FNiagaraEmitterScalabilityOverrides {
    /* 0x0000 */ TArray<FNiagaraEmitterScalabilityOverride> Overrides;
};

// Size: 0x38
struct FNiagaraEmitterScalabilitySettings {
    /* 0x0000 */ FNiagaraPlatformSet Platforms;
    /* 0x0030 */ bool bScaleSpawnCount;
    /* 0x0034 */ float SpawnCountScale;
};

// Size: 0x10
struct FNiagaraEmitterScalabilitySettingsArray {
    /* 0x0000 */ TArray<FNiagaraEmitterScalabilitySettings> Settings;
};

// Size: 0x28
struct FNiagaraEmitterScriptProperties {
    /* 0x0000 */ UNiagaraScript* Script;
    /* 0x0008 */ TArray<FNiagaraEventReceiverProperties> EventReceivers;
    /* 0x0018 */ TArray<FNiagaraEventGeneratorProperties> EventGenerators;
};

// Size: 0x58
struct FNiagaraEventGeneratorProperties {
    /* 0x0000 */ int32_t MaxEventsPerFrame;
    /* 0x0004 */ FName ID;
    /* 0x0010 */ FNiagaraDataSetCompiledData DataSetCompiledData;
};

// Size: 0x30
class UNiagaraEventReceiverEmitterAction : public UObject {
};

// Size: 0x38
class UNiagaraEventReceiverEmitterAction_SpawnParticles : public UNiagaraEventReceiverEmitterAction {
    /* 0x0030 */ uint32_t NumParticles;
};

// Size: 0x24
struct FNiagaraEventReceiverProperties {
    /* 0x0000 */ FName Name;
    /* 0x000c */ FName SourceEventGenerator;
    /* 0x0018 */ FName SourceEmitter;
};

// Size: 0x58
struct FNiagaraEventScriptProperties : public FNiagaraEmitterScriptProperties {
    /* 0x0028 */ EScriptExecutionMode ExecutionMode;
    /* 0x002c */ uint32_t SpawnNumber;
    /* 0x0030 */ uint32_t MaxEventsPerFrame;
    /* 0x0034 */ FGuid SourceEmitterID;
    /* 0x0044 */ FName SourceEventName;
    /* 0x0050 */ bool bRandomSpawnNumber;
    /* 0x0054 */ uint32_t MinSpawnNumber;
};

// Size: 0x4
struct FNiagaraFloat {
    /* 0x0000 */ float Value;
};

// Size: 0x30
class UNiagaraFunctionLibrary : public UBlueprintFunctionLibrary {

    static UNiagaraParameterCollectionInstance* GetNiagaraParameterCollection(UObject* WorldContextObject, UNiagaraParameterCollection* Collection);
    static void OverrideSystemUserVariableSkeletalMeshComponent(UNiagaraComponent* NiagaraSystem, FString OverrideName, USkeletalMeshComponent* SkeletalMeshComponent);
    static void OverrideSystemUserVariableStaticMesh(UNiagaraComponent* NiagaraSystem, FString OverrideName, UStaticMesh* StaticMesh);
    static void OverrideSystemUserVariableStaticMeshComponent(UNiagaraComponent* NiagaraSystem, FString OverrideName, UStaticMeshComponent* StaticMeshComponent);
    static void SetSkeletalMeshDataInterfaceSamplingRegions(UNiagaraComponent* NiagaraSystem, FString OverrideName, const TArray<FName>& SamplingRegions);
    static void SetTexture2DArrayObject(UNiagaraComponent* NiagaraSystem, FString OverrideName, UTexture2DArray* Texture);
    static void SetTextureObject(UNiagaraComponent* NiagaraSystem, FString OverrideName, UTexture* Texture);
    static void SetVolumeTextureObject(UNiagaraComponent* NiagaraSystem, FString OverrideName, UVolumeTexture* Texture);
    static UNiagaraComponent* SpawnSystemAtLocation(const UObject* WorldContextObject, UNiagaraSystem* SystemTemplate, FVector Location, FRotator Rotation, FVector Scale, bool bAutoDestroy, bool bAutoActivate, ENCPoolMethod PoolingMethod, bool bPreCullCheck);
    static UNiagaraComponent* SpawnSystemAttached(UNiagaraSystem* SystemTemplate, USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, uint8_t LocationType, bool bAutoDestroy, bool bAutoActivate, ENCPoolMethod PoolingMethod, bool bPreCullCheck);
};

// Size: 0x178
struct FNiagaraFunctionSignature {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ TArray<FNiagaraVariable> Inputs;
    /* 0x0020 */ TArray<FNiagaraVariable> Outputs;
    /* 0x0030 */ FName OwnerName;
    /* 0x003c */ bool bRequiresContext;
    /* 0x003c */ bool bRequiresExecPin;
    /* 0x003c */ bool bMemberFunction;
    /* 0x003c */ bool bExperimental;
    /* 0x0040 */ FText ExperimentalMessage;
    /* 0x0058 */ uint32_t FunctionVersion;
    /* 0x005c */ bool bSupportsCPU;
    /* 0x005c */ bool bSupportsGPU;
    /* 0x005c */ bool bWriteFunction;
    /* 0x005c */ bool bSoftDeprecatedFunction;
    /* 0x005c */ bool bIsCompileTagGenerator;
    /* 0x005c */ bool bHidden;
    /* 0x0060 */ int32_t ModuleUsageBitmask;
    /* 0x0064 */ int32_t ContextStageMinIndex;
    /* 0x0068 */ int32_t ContextStageMaxIndex;
    /* 0x0070 */ TMap<FName, FName> FunctionSpecifiers;
    /* 0x00c0 */ FText Description;
    /* 0x00d8 */ TMap<FNiagaraVariableBase, FText> InputDescriptions;
    /* 0x0128 */ TMap<FNiagaraVariableBase, FText> OutputDescriptions;
};

// Size: 0x10
struct FNiagaraGraphViewSettings {
    /* 0x0000 */ FVector2D Location;
    /* 0x0008 */ float Zoom;
    /* 0x000c */ bool bIsValid;
};

// Size: 0x2
struct FNiagaraHalf {
    /* 0x0000 */ uint16_t Value;
};

// Size: 0x4
struct FNiagaraHalfVector2 {
    /* 0x0000 */ uint16_t X;
    /* 0x0002 */ uint16_t Y;
};

// Size: 0x6
struct FNiagaraHalfVector3 {
    /* 0x0000 */ uint16_t X;
    /* 0x0002 */ uint16_t Y;
    /* 0x0004 */ uint16_t Z;
};

// Size: 0x8
struct FNiagaraHalfVector4 {
    /* 0x0000 */ uint16_t X;
    /* 0x0002 */ uint16_t Y;
    /* 0x0004 */ uint16_t Z;
    /* 0x0006 */ uint16_t W;
};

// Size: 0x8
struct FNiagaraID {
    /* 0x0000 */ int32_t index;
    /* 0x0004 */ int32_t AcquireTag;
};

// Size: 0x20
struct FNiagaraInputConditionMetadata {
    /* 0x0000 */ FName InputName;
    /* 0x0010 */ TArray<FString> TargetValues;
};

// Size: 0x4
struct FNiagaraInt32 {
    /* 0x0000 */ int32_t Value;
};

// Size: 0x830
class UNiagaraLightRendererProperties : public UNiagaraRendererProperties {
    /* 0x00a8 */ bool bUseInverseSquaredFalloff;
    /* 0x00a8 */ bool bAffectsTranslucency;
    /* 0x00a8 */ bool bAlphaScalesBrightness;
    /* 0x00ac */ float RadiusScale;
    /* 0x00b0 */ float DefaultExponent;
    /* 0x00b4 */ FVector ColorAdd;
    /* 0x00c0 */ int32_t RendererVisibility;
    /* 0x00c8 */ FNiagaraVariableAttributeBinding LightRenderingEnabledBinding;
    /* 0x01d0 */ FNiagaraVariableAttributeBinding LightExponentBinding;
    /* 0x02d8 */ FNiagaraVariableAttributeBinding PositionBinding;
    /* 0x03e0 */ FNiagaraVariableAttributeBinding ColorBinding;
    /* 0x04e8 */ FNiagaraVariableAttributeBinding RadiusBinding;
    /* 0x05f0 */ FNiagaraVariableAttributeBinding VolumetricScatteringBinding;
    /* 0x06f8 */ FNiagaraVariableAttributeBinding RendererVisibilityTagBinding;
};

// Size: 0xa0
struct FNiagaraMaterialAttributeBinding {
    /* 0x0000 */ FName MaterialParameterName;
    /* 0x0010 */ FNiagaraVariableBase NiagaraVariable;
    /* 0x0040 */ FNiagaraVariableBase ResolvedNiagaraVariable;
    /* 0x0070 */ FNiagaraVariableBase NiagaraChildVariable;
};

// Size: 0x18
struct FNiagaraMaterialOverride {
    /* 0x0000 */ UMaterialInterface* Material;
    /* 0x0008 */ uint32_t MaterialSubIndex;
    /* 0x0010 */ UNiagaraRendererProperties* EmitterRendererProperty;
};

// Size: 0x40
struct FNiagaraMatrix {
    /* 0x0000 */ FVector4 Row0;
    /* 0x0010 */ FVector4 Row1;
    /* 0x0020 */ FVector4 Row2;
    /* 0x0030 */ FVector4 Row3;
};

// Size: 0x48
struct FNiagaraMeshMaterialOverride {
    /* 0x0000 */ UMaterialInterface* ExplicitMat;
    /* 0x0008 */ FNiagaraUserParameterBinding UserParamBinding;
};

// Size: 0x28
struct FNiagaraMeshRendererMeshProperties {
    /* 0x0000 */ UStaticMesh* Mesh;
    /* 0x0008 */ FVector Scale;
    /* 0x0014 */ FVector PivotOffset;
    /* 0x0020 */ ENiagaraMeshPivotOffsetSpace PivotOffsetSpace;
};

// Size: 0x1758
class UNiagaraMeshRendererProperties : public UNiagaraRendererProperties {
    /* 0x00a8 */ TArray<FNiagaraMeshRendererMeshProperties> Meshes;
    /* 0x00b8 */ ENiagaraRendererSourceDataMode SourceMode;
    /* 0x00b9 */ ENiagaraSortMode SortMode;
    /* 0x00bc */ bool bOverrideMaterials;
    /* 0x00bc */ bool bSortOnlyWhenTranslucent;
    /* 0x00bc */ bool bGpuLowLatencyTranslucency;
    /* 0x00bc */ bool bSubImageBlend;
    /* 0x00bc */ bool bEnableFrustumCulling;
    /* 0x00bc */ bool bEnableCameraDistanceCulling;
    /* 0x00bc */ bool bEnableMeshFlipbook;
    /* 0x00c0 */ TArray<FNiagaraMeshMaterialOverride> OverrideMaterials;
    /* 0x00d0 */ FVector2D SubImageSize;
    /* 0x00d8 */ ENiagaraMeshFacingMode FacingMode;
    /* 0x00dc */ bool bLockedAxisEnable;
    /* 0x00e0 */ FVector LockedAxis;
    /* 0x00ec */ ENiagaraMeshLockedAxisSpace LockedAxisSpace;
    /* 0x00f0 */ float MinCameraDistance;
    /* 0x00f4 */ float MaxCameraDistance;
    /* 0x00f8 */ uint32_t RendererVisibility;
    /* 0x0100 */ FNiagaraVariableAttributeBinding PositionBinding;
    /* 0x0208 */ FNiagaraVariableAttributeBinding ColorBinding;
    /* 0x0310 */ FNiagaraVariableAttributeBinding VelocityBinding;
    /* 0x0418 */ FNiagaraVariableAttributeBinding MeshOrientationBinding;
    /* 0x0520 */ FNiagaraVariableAttributeBinding ScaleBinding;
    /* 0x0628 */ FNiagaraVariableAttributeBinding SubImageIndexBinding;
    /* 0x0730 */ FNiagaraVariableAttributeBinding DynamicMaterialBinding;
    /* 0x0838 */ FNiagaraVariableAttributeBinding DynamicMaterial1Binding;
    /* 0x0940 */ FNiagaraVariableAttributeBinding DynamicMaterial2Binding;
    /* 0x0a48 */ FNiagaraVariableAttributeBinding DynamicMaterial3Binding;
    /* 0x0b50 */ FNiagaraVariableAttributeBinding MaterialRandomBinding;
    /* 0x0c58 */ FNiagaraVariableAttributeBinding CustomSortingBinding;
    /* 0x0d60 */ FNiagaraVariableAttributeBinding NormalizedAgeBinding;
    /* 0x0e68 */ FNiagaraVariableAttributeBinding CameraOffsetBinding;
    /* 0x0f70 */ FNiagaraVariableAttributeBinding RendererVisibilityTagBinding;
    /* 0x1078 */ FNiagaraVariableAttributeBinding MeshIndexBinding;
    /* 0x1180 */ TArray<FNiagaraMaterialAttributeBinding> MaterialParameterBindings;
    /* 0x1190 */ FNiagaraVariableAttributeBinding PrevPositionBinding;
    /* 0x1298 */ FNiagaraVariableAttributeBinding PrevScaleBinding;
    /* 0x13a0 */ FNiagaraVariableAttributeBinding PrevMeshOrientationBinding;
    /* 0x14a8 */ FNiagaraVariableAttributeBinding PrevCameraOffsetBinding;
    /* 0x15b0 */ FNiagaraVariableAttributeBinding PrevVelocityBinding;
    /* 0x16b8 */ UStaticMesh* FirstFlipbookFrame;
    /* 0x16c0 */ FString FlipbookSuffixFormat;
    /* 0x16d0 */ uint32_t FlipbookSuffixNumDigits;
    /* 0x16d4 */ uint32_t NumFlipbookFrames;
    /* 0x1740 */ UStaticMesh* ParticleMesh;
    /* 0x1748 */ FVector PivotOffset;
    /* 0x1754 */ ENiagaraMeshPivotOffsetSpace PivotOffsetSpace;
};

// Size: 0x30
class UNiagaraMessageDataBase : public UObject {
};

// Size: 0x28
struct FNiagaraModuleDependency {
    /* 0x0000 */ FName ID;
    /* 0x000c */ ENiagaraModuleDependencyType Type;
    /* 0x000d */ ENiagaraModuleDependencyScriptConstraint ScriptConstraint;
    /* 0x0010 */ FText Description;
};

// Size: 0x1
struct FNiagaraNumeric {
};

// Size: 0xc
struct FNiagaraOutlinerCaptureSettings {
    /* 0x0000 */ bool bTriggerCapture;
    /* 0x0004 */ uint32_t CaptureDelayFrames;
    /* 0x0008 */ bool bGatherPerfData;
};

// Size: 0x50
struct FNiagaraOutlinerData {
    /* 0x0000 */ TMap<FString, FNiagaraOutlinerWorldData> WorldData;
};

// Size: 0x20
struct FNiagaraOutlinerEmitterInstanceData {
    /* 0x0000 */ FString EmitterName;
    /* 0x0010 */ ENiagaraSimTarget SimTarget;
    /* 0x0014 */ ENiagaraExecutionState ExecState;
    /* 0x0018 */ int32_t NumParticles;
};

// Size: 0x30
struct FNiagaraOutlinerSystemData {
    /* 0x0000 */ TArray<FNiagaraOutlinerSystemInstanceData> SystemInstances;
    /* 0x0010 */ FNiagaraOutlinerTimingData AveragePerFrameTime;
    /* 0x0018 */ FNiagaraOutlinerTimingData MaxPerFrameTime;
    /* 0x0020 */ FNiagaraOutlinerTimingData AveragePerInstanceTime;
    /* 0x0028 */ FNiagaraOutlinerTimingData MaxPerInstanceTime;
};

// Size: 0x48
struct FNiagaraOutlinerSystemInstanceData {
    /* 0x0000 */ FString ComponentName;
    /* 0x0010 */ TArray<FNiagaraOutlinerEmitterInstanceData> Emitters;
    /* 0x0020 */ ENiagaraExecutionState ActualExecutionState;
    /* 0x0024 */ ENiagaraExecutionState RequestedExecutionState;
    /* 0x0028 */ FNiagaraScalabilityState ScalabilityState;
    /* 0x0030 */ bool bPendingKill;
    /* 0x0034 */ ENCPoolMethod PoolMethod;
    /* 0x0038 */ FNiagaraOutlinerTimingData AverageTime;
    /* 0x0040 */ FNiagaraOutlinerTimingData MaxTime;
};

// Size: 0x8
struct FNiagaraOutlinerTimingData {
    /* 0x0000 */ float GameThread;
    /* 0x0004 */ float RenderThread;
};

// Size: 0x68
struct FNiagaraOutlinerWorldData {
    /* 0x0000 */ TMap<FString, FNiagaraOutlinerSystemData> Systems;
    /* 0x0050 */ bool bHasBegunPlay;
    /* 0x0051 */ uint8_t WorldType;
    /* 0x0052 */ uint8_t NetMode;
    /* 0x0054 */ FNiagaraOutlinerTimingData AveragePerFrameTime;
    /* 0x005c */ FNiagaraOutlinerTimingData MaxPerFrameTime;
};

// Size: 0x88
class UNiagaraParameterCollection : public UObject {
    /* 0x0048 */ FName Namespace;
    /* 0x0058 */ TArray<FNiagaraVariable> Parameters;
    /* 0x0068 */ UMaterialParameterCollection* SourceMaterialCollection;
    /* 0x0070 */ UNiagaraParameterCollectionInstance* DefaultInstance;
    /* 0x0078 */ FGuid CompileId;
};

// Size: 0x1b0
class UNiagaraParameterCollectionInstance : public UObject {
    /* 0x0030 */ UNiagaraParameterCollection* Collection;
    /* 0x0038 */ TArray<FNiagaraVariable> OverridenParameters;
    /* 0x0048 */ FNiagaraParameterStore ParameterStorage;

    bool GetBoolParameter(FString InVariableName);
    FLinearColor GetColorParameter(FString InVariableName);
    float GetFloatParameter(FString InVariableName);
    int32_t GetIntParameter(FString InVariableName);
    FQuat GetQuatParameter(FString InVariableName);
    FVector2D GetVector2DParameter(FString InVariableName);
    FVector4 GetVector4Parameter(FString InVariableName);
    FVector GetVectorParameter(FString InVariableName);
    void SetBoolParameter(FString InVariableName, bool InValue);
    void SetColorParameter(FString InVariableName, FLinearColor InValue);
    void SetFloatParameter(FString InVariableName, float InValue);
    void SetIntParameter(FString InVariableName, int32_t InValue);
    void SetQuatParameter(FString InVariableName, const FQuat& InValue);
    void SetVector2DParameter(FString InVariableName, FVector2D InValue);
    void SetVector4Parameter(FString InVariableName, const FVector4& InValue);
    void SetVectorParameter(FString InVariableName, FVector InValue);
};

// Size: 0x8
struct FNiagaraParameterDataSetBinding {
    /* 0x0000 */ int32_t ParameterOffset;
    /* 0x0004 */ int32_t DataSetComponentOffset;
};

// Size: 0x20
struct FNiagaraParameterDataSetBindingCollection {
    /* 0x0000 */ TArray<FNiagaraParameterDataSetBinding> FloatOffsets;
    /* 0x0010 */ TArray<FNiagaraParameterDataSetBinding> Int32Offsets;
};

// Size: 0x58
class UNiagaraParameterDefinitionsBase : public UObject {
    /* 0x0030 */ FGuid UniqueId;
};

// Size: 0x1
struct FNiagaraParameterMap {
};

// Size: 0x140
struct FNiagaraParameterStore {
    /* 0x0008 */ UObject* Owner;
    /* 0x0010 */ TMap<FNiagaraVariable, int32_t> ParameterOffsets;
    /* 0x0060 */ TArray<FNiagaraVariableWithOffset> SortedParameterOffsets;
    /* 0x0070 */ TArray<uint8_t> ParameterData;
    /* 0x0080 */ TArray<UNiagaraDataInterface*> DataInterfaces;
    /* 0x0090 */ TArray<UObject*> UObjects;
    /* 0x00e0 */ FString DebugName;
    /* 0x00f0 */ TMap<FNiagaraVariable, FGuid> ParameterGuidMapping;
};

// Size: 0x10
struct FNiagaraParameters {
    /* 0x0000 */ TArray<FNiagaraVariable> Parameters;
};

// Size: 0x30
class INiagaraParticleCallbackHandler : public UInterface {

    void ReceiveParticleData(const TArray<FBasicParticleData>& Data, UNiagaraSystem* NiagaraSystem);
};

// Size: 0x310
class ANiagaraPerfBaselineActor : public AActor {
    /* 0x02f8 */ UNiagaraBaselineController* Controller;
    /* 0x0300 */ UTextRenderComponent* Label;
};

// Size: 0x10
struct FNiagaraPerfBaselineStats {
    /* 0x0000 */ float PerInstanceAvg_GT;
    /* 0x0004 */ float PerInstanceAvg_RT;
    /* 0x0008 */ float PerInstanceMax_GT;
    /* 0x000c */ float PerInstanceMax_RT;
};

// Size: 0x30
struct FNiagaraPlatformSet {
    /* 0x0000 */ int32_t QualityLevelMask;
    /* 0x0008 */ TArray<FNiagaraDeviceProfileStateEntry> DeviceProfileStates;
    /* 0x0018 */ TArray<FNiagaraPlatformSetCVarCondition> CVarConditions;
};

// Size: 0x30
struct FNiagaraPlatformSetCVarCondition {
    /* 0x0000 */ FName CVarName;
    /* 0x000c */ bool Value;
    /* 0x0010 */ int32_t MinInt;
    /* 0x0014 */ int32_t MaxInt;
    /* 0x0018 */ float MinFloat;
    /* 0x001c */ float MaxFloat;
    /* 0x0020 */ bool bUseMinInt;
    /* 0x0020 */ bool bUseMaxInt;
    /* 0x0020 */ bool bUseMinFloat;
    /* 0x0020 */ bool bUseMaxFloat;
};

// Size: 0x10
struct FNiagaraPlatformSetConflictEntry {
    /* 0x0000 */ FName ProfileName;
    /* 0x000c */ int32_t QualityLevelMask;
};

// Size: 0x18
struct FNiagaraPlatformSetConflictInfo {
    /* 0x0000 */ int32_t SetAIndex;
    /* 0x0004 */ int32_t SetBIndex;
    /* 0x0008 */ TArray<FNiagaraPlatformSetConflictEntry> Conflicts;
};

// Size: 0x48
class UNiagaraPrecompileContainer : public UObject {
    /* 0x0030 */ TArray<UNiagaraScript*> Scripts;
    /* 0x0040 */ UNiagaraSystem* System;
};

// Size: 0x30
class UNiagaraPreviewAxis : public UObject {

    void ApplyToPreview(UNiagaraComponent* PreviewComponent, int32_t PreviewIndex, bool bIsXAxis, FString& OutLabelText);
    int32_t Num();
};

// Size: 0x40
class UNiagaraPreviewAxis_InterpParamBase : public UNiagaraPreviewAxis {
    /* 0x0030 */ FName Param;
    /* 0x003c */ int32_t Count;
};

// Size: 0x48
class UNiagaraPreviewAxis_InterpParamFloat : public UNiagaraPreviewAxis_InterpParamBase {
    /* 0x0040 */ float Min;
    /* 0x0044 */ float Max;
};

// Size: 0x48
class UNiagaraPreviewAxis_InterpParamInt32 : public UNiagaraPreviewAxis_InterpParamBase {
    /* 0x0040 */ int32_t Min;
    /* 0x0044 */ int32_t Max;
};

// Size: 0x60
class UNiagaraPreviewAxis_InterpParamLinearColor : public UNiagaraPreviewAxis_InterpParamBase {
    /* 0x0040 */ FLinearColor Min;
    /* 0x0050 */ FLinearColor Max;
};

// Size: 0x58
class UNiagaraPreviewAxis_InterpParamVector : public UNiagaraPreviewAxis_InterpParamBase {
    /* 0x0040 */ FVector Min;
    /* 0x004c */ FVector Max;
};

// Size: 0x50
class UNiagaraPreviewAxis_InterpParamVector2D : public UNiagaraPreviewAxis_InterpParamBase {
    /* 0x0040 */ FVector2D Min;
    /* 0x0048 */ FVector2D Max;
};

// Size: 0x60
class UNiagaraPreviewAxis_InterpParamVector4 : public UNiagaraPreviewAxis_InterpParamBase {
    /* 0x0040 */ FVector4 Min;
    /* 0x0050 */ FVector4 Max;
};

// Size: 0x2f8
class ANiagaraPreviewBase : public AActor {

    void SetLabelText(const FText& InXAxisText, const FText& InYAxisText);
    void SetSystem(UNiagaraSystem* InSystem);
};

// Size: 0x358
class ANiagaraPreviewGrid : public AActor {
    /* 0x02f8 */ UNiagaraSystem* System;
    /* 0x0300 */ ENiagaraPreviewGridResetMode ResetMode;
    /* 0x0308 */ UNiagaraPreviewAxis* PreviewAxisX;
    /* 0x0310 */ UNiagaraPreviewAxis* PreviewAxisY;
    /* 0x0318 */ UClass* PreviewClass;
    /* 0x0320 */ float SpacingX;
    /* 0x0324 */ float SpacingY;
    /* 0x0328 */ int32_t NumX;
    /* 0x032c */ int32_t NumY;
    /* 0x0330 */ TArray<UChildActorComponent*> PreviewComponents;
    /* 0x0340 */ UBillboardComponent* SpriteComponent;
    /* 0x0348 */ UArrowComponent* ArrowComponent;

    void ActivatePreviews(bool bReset);
    void DeactivatePreviews();
    void GetPreviews(TArray<UNiagaraComponent*>& OutPreviews);
    void SetPaused(bool bPaused);
};

// Size: 0xc
struct FNiagaraRandInfo {
    /* 0x0000 */ int32_t Seed1;
    /* 0x0004 */ int32_t Seed2;
    /* 0x0008 */ int32_t Seed3;
};

// Size: 0xa8
class UNiagaraRendererProperties : public UNiagaraMergeable {
    /* 0x0058 */ FNiagaraPlatformSet Platforms;
    /* 0x0088 */ int32_t SortOrderHint;
    /* 0x008c */ ENiagaraRendererMotionVectorSetting MotionVectorSetting;
    /* 0x0090 */ bool bIsEnabled;
    /* 0x0091 */ bool bMotionBlurEnabled;
};

// Size: 0x1
struct FNiagaraRequestSimpleClientInfoMessage {
};

// Size: 0x15e8
class UNiagaraRibbonRendererProperties : public UNiagaraRendererProperties {
    /* 0x00a8 */ UMaterialInterface* Material;
    /* 0x00b0 */ FNiagaraUserParameterBinding MaterialUserParamBinding;
    /* 0x00f0 */ ENiagaraRibbonFacingMode FacingMode;
    /* 0x00f4 */ FNiagaraRibbonUVSettings UV0Settings;
    /* 0x0118 */ FNiagaraRibbonUVSettings UV1Settings;
    /* 0x013c */ float UV0TilingDistance;
    /* 0x0140 */ FVector2D UV0Scale;
    /* 0x0148 */ FVector2D UV0Offset;
    /* 0x0150 */ ENiagaraRibbonAgeOffsetMode UV0AgeOffsetMode;
    /* 0x0154 */ float UV1TilingDistance;
    /* 0x0158 */ FVector2D UV1Scale;
    /* 0x0160 */ FVector2D UV1Offset;
    /* 0x0168 */ ENiagaraRibbonAgeOffsetMode UV1AgeOffsetMode;
    /* 0x0169 */ ENiagaraRibbonDrawDirection DrawDirection;
    /* 0x016a */ ENiagaraRibbonShapeMode Shape;
    /* 0x016b */ bool bEnableAccurateGeometry;
    /* 0x016c */ int32_t WidthSegmentationCount;
    /* 0x0170 */ int32_t MultiPlaneCount;
    /* 0x0174 */ int32_t TubeSubdivisions;
    /* 0x0178 */ TArray<FNiagaraRibbonShapeCustomVertex> CustomVertices;
    /* 0x0188 */ float CurveTension;
    /* 0x018c */ ENiagaraRibbonTessellationMode TessellationMode;
    /* 0x0190 */ int32_t TessellationFactor;
    /* 0x0194 */ bool bUseConstantFactor;
    /* 0x0198 */ float TessellationAngle;
    /* 0x019c */ bool bScreenSpaceTessellation;
    /* 0x01a0 */ FNiagaraVariableAttributeBinding PositionBinding;
    /* 0x02a8 */ FNiagaraVariableAttributeBinding ColorBinding;
    /* 0x03b0 */ FNiagaraVariableAttributeBinding VelocityBinding;
    /* 0x04b8 */ FNiagaraVariableAttributeBinding NormalizedAgeBinding;
    /* 0x05c0 */ FNiagaraVariableAttributeBinding RibbonTwistBinding;
    /* 0x06c8 */ FNiagaraVariableAttributeBinding RibbonWidthBinding;
    /* 0x07d0 */ FNiagaraVariableAttributeBinding RibbonFacingBinding;
    /* 0x08d8 */ FNiagaraVariableAttributeBinding RibbonIdBinding;
    /* 0x09e0 */ FNiagaraVariableAttributeBinding RibbonLinkOrderBinding;
    /* 0x0ae8 */ FNiagaraVariableAttributeBinding MaterialRandomBinding;
    /* 0x0bf0 */ FNiagaraVariableAttributeBinding DynamicMaterialBinding;
    /* 0x0cf8 */ FNiagaraVariableAttributeBinding DynamicMaterial1Binding;
    /* 0x0e00 */ FNiagaraVariableAttributeBinding DynamicMaterial2Binding;
    /* 0x0f08 */ FNiagaraVariableAttributeBinding DynamicMaterial3Binding;
    /* 0x1010 */ FNiagaraVariableAttributeBinding RibbonUVDistance;
    /* 0x1118 */ FNiagaraVariableAttributeBinding U0OverrideBinding;
    /* 0x1220 */ FNiagaraVariableAttributeBinding V0RangeOverrideBinding;
    /* 0x1328 */ FNiagaraVariableAttributeBinding U1OverrideBinding;
    /* 0x1430 */ FNiagaraVariableAttributeBinding V1RangeOverrideBinding;
    /* 0x1538 */ TArray<FNiagaraMaterialAttributeBinding> MaterialParameterBindings;
};

// Size: 0x14
struct FNiagaraRibbonShapeCustomVertex {
    /* 0x0000 */ FVector2D Position;
    /* 0x0008 */ FVector2D Normal;
    /* 0x0010 */ float TextureV;
};

// Size: 0x24
struct FNiagaraRibbonUVSettings {
    /* 0x0000 */ ENiagaraRibbonUVDistributionMode DistributionMode;
    /* 0x0004 */ ENiagaraRibbonUVEdgeMode LeadingEdgeMode;
    /* 0x0008 */ ENiagaraRibbonUVEdgeMode TrailingEdgeMode;
    /* 0x000c */ float TilingLength;
    /* 0x0010 */ FVector2D Offset;
    /* 0x0018 */ FVector2D Scale;
    /* 0x0020 */ bool bEnablePerParticleUOverride;
    /* 0x0021 */ bool bEnablePerParticleVRangeOverride;
};

// Size: 0x70
struct FNiagaraScalabilityManager {
    /* 0x0000 */ UNiagaraEffectType* EffectType;
    /* 0x0008 */ TArray<UNiagaraComponent*> ManagedComponents;
};

// Size: 0x8
struct FNiagaraScalabilityState {
    /* 0x0000 */ float Significance;
    /* 0x0004 */ bool bCulled;
    /* 0x0004 */ bool bPreviousCulled;
    /* 0x0004 */ bool bCulledByDistance;
    /* 0x0004 */ bool bCulledByInstanceCount;
    /* 0x0004 */ bool bCulledByVisibility;
    /* 0x0004 */ bool bCulledByGlobalBudget;
};

// Size: 0xc50
class UNiagaraScript : public UNiagaraScriptBase {
    /* 0x0030 */ ENiagaraScriptUsage Usage;
    /* 0x0034 */ FGuid UsageId;
    /* 0x0044 */ FGuid ExposedVersion;
    /* 0x0054 */ bool bVersioningEnabled;
    /* 0x0058 */ TArray<FVersionedNiagaraScriptData> VersionData;
    /* 0x0078 */ FNiagaraParameterStore RapidIterationParameters;
    /* 0x01b8 */ FGuid VersionToOpenInEditor;
    /* 0x01c8 */ int32_t UsageIndex;
    /* 0x01cc */ int32_t ModuleUsageBitmask;
    /* 0x01d0 */ FText Category;
    /* 0x01e8 */ TArray<FName> ProvidedDependencies;
    /* 0x01f8 */ TArray<FNiagaraModuleDependency> RequiredDependencies;
    /* 0x0208 */ bool bDeprecated;
    /* 0x0210 */ FText DeprecationMessage;
    /* 0x0228 */ UNiagaraScript* DeprecationRecommendation;
    /* 0x0230 */ UClass* ConversionUtility;
    /* 0x0238 */ bool bExperimental;
    /* 0x0240 */ FText ExperimentalMessage;
    /* 0x0258 */ FText NoteMessage;
    /* 0x0270 */ bool bExposeToLibrary;
    /* 0x0274 */ ENiagaraScriptLibraryVisibility LibraryVisibility;
    /* 0x0275 */ ENiagaraNumericOutputTypeSelectionMode NumericOutputTypeSelectionMode;
    /* 0x0278 */ FText Description;
    /* 0x0290 */ FText Keywords;
    /* 0x02a8 */ FText CollapsedViewFormat;
    /* 0x02c0 */ TArray<FNiagaraScriptHighlight> Highlights;
    /* 0x02d0 */ TMap<FName, FString> ScriptMetaData;
    /* 0x0320 */ UNiagaraScriptSourceBase* Source;
    /* 0x0328 */ FNiagaraScriptExecutionParameterStore ScriptExecutionParamStoreCPU;
    /* 0x0498 */ FNiagaraScriptExecutionParameterStore ScriptExecutionParamStoreGPU;
    /* 0x0608 */ FNiagaraScriptExecutionParameterStore ScriptExecutionParamStore;
    /* 0x0778 */ TArray<FNiagaraBoundParameter> ScriptExecutionBoundParameters;
    /* 0x08c8 */ FNiagaraVMExecutableDataId CachedScriptVMId;
    /* 0x0a08 */ TArray<UObject*> ActiveCompileRoots;
    /* 0x0a20 */ FNiagaraVMExecutableData CachedScriptVM;
    /* 0x0c28 */ TArray<UNiagaraParameterCollection*> CachedParameterCollectionReferences;
    /* 0x0c38 */ TArray<FNiagaraScriptDataInterfaceInfo> CachedDefaultDataInterfaces;

    void RaiseOnGPUCompilationComplete();
};

// Size: 0x60
struct FNiagaraScriptDataInterfaceCompileInfo {
    /* 0x0000 */ FName Name;
    /* 0x000c */ int32_t UserPtrIdx;
    /* 0x0010 */ FNiagaraTypeDefinition Type;
    /* 0x0030 */ TArray<FNiagaraFunctionSignature> RegisteredFunctions;
    /* 0x0040 */ FName RegisteredParameterMapRead;
    /* 0x004c */ FName RegisteredParameterMapWrite;
    /* 0x0058 */ bool bIsPlaceholder;
};

// Size: 0x50
struct FNiagaraScriptDataInterfaceInfo {
    /* 0x0000 */ UNiagaraDataInterface* DataInterface;
    /* 0x0008 */ FName Name;
    /* 0x0014 */ int32_t UserPtrIdx;
    /* 0x0018 */ FNiagaraTypeDefinition Type;
    /* 0x0038 */ FName RegisteredParameterMapRead;
    /* 0x0044 */ FName RegisteredParameterMapWrite;
};

// Size: 0x1
struct FNiagaraScriptDataUsageInfo {
    /* 0x0000 */ bool bReadsAttributeData;
};

// Size: 0x8
struct FNiagaraScriptExecutionPaddingInfo {
    /* 0x0000 */ uint16_t SrcOffset;
    /* 0x0002 */ uint16_t DestOffset;
    /* 0x0004 */ uint16_t SrcSize;
    /* 0x0006 */ uint16_t DestSize;
};

// Size: 0x170
struct FNiagaraScriptExecutionParameterStore : public FNiagaraParameterStore {
    /* 0x0140 */ int32_t ParameterSize;
    /* 0x0144 */ uint32_t PaddedParameterSize;
    /* 0x0148 */ TArray<FNiagaraScriptExecutionPaddingInfo> PaddingInfo;
    /* 0x0158 */ bool bInitialized;
};

// Size: 0x28
struct FNiagaraScriptHighlight {
    /* 0x0000 */ FLinearColor Color;
    /* 0x0010 */ FText DisplayName;
};

// Size: 0x2c0
struct FNiagaraScriptInstanceParameterStore : public FNiagaraParameterStore {
};

// Size: 0x68
class UNiagaraScriptSourceBase : public UObject {
};

// Size: 0xc
struct FNiagaraScriptVariableBinding {
    /* 0x0000 */ FName Name;
};

// Size: 0x130
class UNiagaraSettings : public UDeveloperSettings {
    /* 0x0060 */ TArray<FSoftObjectPath> AdditionalParameterTypes;
    /* 0x0070 */ TArray<FSoftObjectPath> AdditionalPayloadTypes;
    /* 0x0080 */ TArray<FSoftObjectPath> AdditionalParameterEnums;
    /* 0x0090 */ bool bSystemViewportInOrbitMode;
    /* 0x0098 */ FSoftObjectPath DefaultEffectType;
    /* 0x00b8 */ TArray<FText> QualityLevels;
    /* 0x00c8 */ TMap<FString, FText> ComponentRendererWarningsPerClass;
    /* 0x0118 */ uint8_t DefaultRenderTargetFormat;
    /* 0x0119 */ ENiagaraGpuBufferFormat DefaultGridFormat;
    /* 0x011c */ ENiagaraDefaultRendererMotionVectorSetting DefaultRendererMotionVectorSetting;
    /* 0x0120 */ uint8_t NDISkelMesh_GpuMaxInfluences;
    /* 0x0121 */ uint8_t NDISkelMesh_GpuUniformSamplingFormat;
    /* 0x0122 */ uint8_t NDISkelMesh_AdjacencyTriangleIndexFormat;
    /* 0x0128 */ UNiagaraEffectType* DefaultEffectTypePtr;
};

// Size: 0x30
class UNiagaraSignificanceHandler : public UObject {
};

// Size: 0x30
class UNiagaraSignificanceHandlerAge : public UNiagaraSignificanceHandler {
};

// Size: 0x30
class UNiagaraSignificanceHandlerDistance : public UNiagaraSignificanceHandler {
};

// Size: 0x40
struct FNiagaraSimpleClientInfo {
    /* 0x0000 */ TArray<FString> Systems;
    /* 0x0010 */ TArray<FString> Actors;
    /* 0x0020 */ TArray<FString> Components;
    /* 0x0030 */ TArray<FString> Emitters;
};

// Size: 0x70
class UNiagaraSimulationStageBase : public UNiagaraMergeable {
    /* 0x0058 */ UNiagaraScript* Script;
    /* 0x0060 */ FName SimulationStageName;
    /* 0x006c */ bool bEnabled;
};

// Size: 0xc0
class UNiagaraSimulationStageGeneric : public UNiagaraSimulationStageBase {
    /* 0x0070 */ ENiagaraIterationSource IterationSource;
    /* 0x0074 */ int32_t Iterations;
    /* 0x0078 */ bool bSpawnOnly;
    /* 0x0078 */ bool bDisablePartialParticleUpdate;
    /* 0x0080 */ FNiagaraVariableDataInterfaceBinding DataInterface;
};

// Size: 0x10
struct FNiagaraSpawnInfo {
    /* 0x0000 */ int32_t Count;
    /* 0x0004 */ float InterpStartDt;
    /* 0x0008 */ float IntervalDt;
    /* 0x000c */ int32_t SpawnGroup;
};

// Size: 0x1da8
class UNiagaraSpriteRendererProperties : public UNiagaraRendererProperties {
    /* 0x00a8 */ UMaterialInterface* Material;
    /* 0x00b0 */ ENiagaraRendererSourceDataMode SourceMode;
    /* 0x00b8 */ FNiagaraUserParameterBinding MaterialUserParamBinding;
    /* 0x00f8 */ ENiagaraSpriteAlignment Alignment;
    /* 0x00f9 */ ENiagaraSpriteFacingMode FacingMode;
    /* 0x00fc */ FVector2D PivotInUVSpace;
    /* 0x0104 */ ENiagaraSortMode SortMode;
    /* 0x0108 */ FVector2D SubImageSize;
    /* 0x0110 */ bool bSubImageBlend;
    /* 0x0110 */ bool bRemoveHMDRollInVR;
    /* 0x0110 */ bool bSortOnlyWhenTranslucent;
    /* 0x0110 */ bool bGpuLowLatencyTranslucency;
    /* 0x0114 */ float MinFacingCameraBlendDistance;
    /* 0x0118 */ float MaxFacingCameraBlendDistance;
    /* 0x011c */ bool bEnableCameraDistanceCulling;
    /* 0x0120 */ float MinCameraDistance;
    /* 0x0124 */ float MaxCameraDistance;
    /* 0x0128 */ uint32_t RendererVisibility;
    /* 0x0130 */ FNiagaraVariableAttributeBinding PositionBinding;
    /* 0x0238 */ FNiagaraVariableAttributeBinding ColorBinding;
    /* 0x0340 */ FNiagaraVariableAttributeBinding VelocityBinding;
    /* 0x0448 */ FNiagaraVariableAttributeBinding SpriteRotationBinding;
    /* 0x0550 */ FNiagaraVariableAttributeBinding SpriteSizeBinding;
    /* 0x0658 */ FNiagaraVariableAttributeBinding SpriteFacingBinding;
    /* 0x0760 */ FNiagaraVariableAttributeBinding SpriteAlignmentBinding;
    /* 0x0868 */ FNiagaraVariableAttributeBinding SubImageIndexBinding;
    /* 0x0970 */ FNiagaraVariableAttributeBinding DynamicMaterialBinding;
    /* 0x0a78 */ FNiagaraVariableAttributeBinding DynamicMaterial1Binding;
    /* 0x0b80 */ FNiagaraVariableAttributeBinding DynamicMaterial2Binding;
    /* 0x0c88 */ FNiagaraVariableAttributeBinding DynamicMaterial3Binding;
    /* 0x0d90 */ FNiagaraVariableAttributeBinding CameraOffsetBinding;
    /* 0x0e98 */ FNiagaraVariableAttributeBinding UVScaleBinding;
    /* 0x0fa0 */ FNiagaraVariableAttributeBinding PivotOffsetBinding;
    /* 0x10a8 */ FNiagaraVariableAttributeBinding MaterialRandomBinding;
    /* 0x11b0 */ FNiagaraVariableAttributeBinding CustomSortingBinding;
    /* 0x12b8 */ FNiagaraVariableAttributeBinding NormalizedAgeBinding;
    /* 0x13c0 */ FNiagaraVariableAttributeBinding RendererVisibilityTagBinding;
    /* 0x14c8 */ TArray<FNiagaraMaterialAttributeBinding> MaterialParameterBindings;
    /* 0x14d8 */ FNiagaraVariableAttributeBinding PrevPositionBinding;
    /* 0x15e0 */ FNiagaraVariableAttributeBinding PrevVelocityBinding;
    /* 0x16e8 */ FNiagaraVariableAttributeBinding PrevSpriteRotationBinding;
    /* 0x17f0 */ FNiagaraVariableAttributeBinding PrevSpriteSizeBinding;
    /* 0x18f8 */ FNiagaraVariableAttributeBinding PrevSpriteFacingBinding;
    /* 0x1a00 */ FNiagaraVariableAttributeBinding PrevSpriteAlignmentBinding;
    /* 0x1b08 */ FNiagaraVariableAttributeBinding PrevCameraOffsetBinding;
    /* 0x1c10 */ FNiagaraVariableAttributeBinding PrevPivotOffsetBinding;
    /* 0x1d18 */ bool bUseMaterialCutoutTexture;
    /* 0x1d20 */ UTexture2D* CutoutTexture;
    /* 0x1d28 */ uint8_t BoundingMode;
    /* 0x1d29 */ uint8_t OpacitySourceMode;
    /* 0x1d2c */ float AlphaThreshold;
};

// Size: 0x18
struct FNiagaraStatScope {
    /* 0x0000 */ FName FullName;
    /* 0x000c */ FName FriendlyName;
};

// Size: 0x9e8
class UNiagaraSystem : public UFXSystemAsset {
    /* 0x0060 */ UTexture2D* ThumbnailImage;
    /* 0x0068 */ bool ThumbnailImageOutOfDate;
    /* 0x006c */ bool bExposeToLibrary;
    /* 0x006d */ bool bIsTemplateAsset;
    /* 0x006e */ ENiagaraScriptTemplateSpecification TemplateSpecification;
    /* 0x0070 */ FText TemplateAssetDescription;
    /* 0x0088 */ TArray<UNiagaraScript*> ScratchPadScripts;
    /* 0x0098 */ FNiagaraParameterStore EditorOnlyAddedParameters;
    /* 0x01d8 */ FNiagaraSystemUpdateContext UpdateContext;
    /* 0x0240 */ bool bBakeOutRapidIteration;
    /* 0x0240 */ bool bBakeOutRapidIterationOnCook;
    /* 0x0240 */ bool bCompressAttributes;
    /* 0x0240 */ bool bTrimAttributes;
    /* 0x0240 */ bool bTrimAttributesOnCook;
    /* 0x0240 */ bool bDisableAllDebugSwitches;
    /* 0x0248 */ TArray<FParameterDefinitionsSubscription> ParameterDefinitionsSubscriptions;
    /* 0x0258 */ bool bDumpDebugSystemInfo;
    /* 0x0259 */ bool bDumpDebugEmitterInfo;
    /* 0x025b */ bool bRequireCurrentFrameData;
    /* 0x025c */ bool bFixedBounds;
    /* 0x0260 */ UNiagaraEffectType* EffectType;
    /* 0x0268 */ bool bOverrideScalabilitySettings;
    /* 0x0270 */ TArray<FNiagaraSystemScalabilityOverride> ScalabilityOverrides;
    /* 0x0280 */ FNiagaraSystemScalabilityOverrides SystemScalabilityOverrides;
    /* 0x0290 */ TArray<FNiagaraEmitterHandle> EmitterHandles;
    /* 0x02a0 */ TArray<UNiagaraParameterCollectionInstance*> ParameterCollectionOverrides;
    /* 0x02b0 */ TArray<FNiagaraSystemCompileRequest> ActiveCompilations;
    /* 0x02c0 */ UNiagaraScript* SystemSpawnScript;
    /* 0x02c8 */ UNiagaraScript* SystemUpdateScript;
    /* 0x02e0 */ FNiagaraSystemCompiledData SystemCompiledData;
    /* 0x05d8 */ FNiagaraUserRedirectionParameterStore ExposedParameters;
    /* 0x0768 */ UNiagaraEditorDataBase* EditorData;
    /* 0x0770 */ UNiagaraEditorParametersAdapterBase* EditorParameters;
    /* 0x07b0 */ FBox FixedBounds;
    /* 0x07cc */ bool bAutoDeactivate;
    /* 0x07d0 */ float WarmupTime;
    /* 0x07d4 */ int32_t WarmupTickCount;
    /* 0x07d8 */ float WarmupTickDelta;
    /* 0x07e0 */ UNiagaraBakerSettings* BakerSettings;
    /* 0x07e8 */ UNiagaraBakerSettings* BakerGeneratedSettings;
    /* 0x07f0 */ bool bHasSystemScriptDIsWithPerInstanceData;
    /* 0x07f1 */ bool bNeedsGPUContextInitForDataInterfaces;
    /* 0x07f8 */ TArray<FName> UserDINamesReadInSystemScripts;
    /* 0x0980 */ TMap<FGuid, UNiagaraMessageDataBase*> MessageKeyToMessageMap;
};

// Size: 0x80
struct FNiagaraSystemCompileRequest {
    /* 0x0008 */ TArray<UObject*> RootObjects;
};

// Size: 0x2f8
struct FNiagaraSystemCompiledData {
    /* 0x0000 */ FNiagaraParameterStore InstanceParamStore;
    /* 0x0140 */ FNiagaraDataSetCompiledData DataSetCompiledData;
    /* 0x0188 */ FNiagaraDataSetCompiledData SpawnInstanceParamsDataSetCompiledData;
    /* 0x01d0 */ FNiagaraDataSetCompiledData UpdateInstanceParamsDataSetCompiledData;
    /* 0x0218 */ FNiagaraParameterDataSetBindingCollection SpawnInstanceGlobalBinding;
    /* 0x0238 */ FNiagaraParameterDataSetBindingCollection SpawnInstanceSystemBinding;
    /* 0x0258 */ FNiagaraParameterDataSetBindingCollection SpawnInstanceOwnerBinding;
    /* 0x0278 */ TArray<FNiagaraParameterDataSetBindingCollection> SpawnInstanceEmitterBindings;
    /* 0x0288 */ FNiagaraParameterDataSetBindingCollection UpdateInstanceGlobalBinding;
    /* 0x02a8 */ FNiagaraParameterDataSetBindingCollection UpdateInstanceSystemBinding;
    /* 0x02c8 */ FNiagaraParameterDataSetBindingCollection UpdateInstanceOwnerBinding;
    /* 0x02e8 */ TArray<FNiagaraParameterDataSetBindingCollection> UpdateInstanceEmitterBindings;
};

// Size: 0x50
struct FNiagaraSystemScalabilityOverride : public FNiagaraSystemScalabilitySettings {
    /* 0x0048 */ bool bOverrideDistanceSettings;
    /* 0x0048 */ bool bOverrideInstanceCountSettings;
    /* 0x0048 */ bool bOverridePerSystemInstanceCountSettings;
    /* 0x0048 */ bool bOverrideTimeSinceRendererSettings;
    /* 0x0048 */ bool bOverrideGlobalBudgetCullingSettings;
};

// Size: 0x10
struct FNiagaraSystemScalabilityOverrides {
    /* 0x0000 */ TArray<FNiagaraSystemScalabilityOverride> Overrides;
};

// Size: 0x48
struct FNiagaraSystemScalabilitySettings {
    /* 0x0000 */ FNiagaraPlatformSet Platforms;
    /* 0x0030 */ bool bCullByDistance;
    /* 0x0030 */ bool bCullMaxInstanceCount;
    /* 0x0030 */ bool bCullPerSystemMaxInstanceCount;
    /* 0x0030 */ bool bCullByMaxTimeWithoutRender;
    /* 0x0030 */ bool bCullByGlobalBudget;
    /* 0x0034 */ float MaxDistance;
    /* 0x0038 */ int32_t MaxInstances;
    /* 0x003c */ int32_t MaxSystemInstances;
    /* 0x0040 */ float MaxTimeWithoutRender;
    /* 0x0044 */ float MaxGlobalBudgetUsage;
};

// Size: 0x10
struct FNiagaraSystemScalabilitySettingsArray {
    /* 0x0000 */ TArray<FNiagaraSystemScalabilitySettings> Settings;
};

// Size: 0x68
struct FNiagaraSystemUpdateContext {
    /* 0x0000 */ TArray<UNiagaraComponent*> ComponentsToReset;
    /* 0x0010 */ TArray<UNiagaraComponent*> ComponentsToReInit;
    /* 0x0020 */ TArray<UNiagaraComponent*> ComponentsToNotifySimDestroy;
    /* 0x0030 */ TArray<UNiagaraSystem*> SystemSimsToDestroy;
};

// Size: 0x20
struct FNiagaraTypeDefinition {
    /* 0x0000 */ UObject* ClassStructOrEnum;
    /* 0x0008 */ uint16_t UnderlyingType;
    /* 0x0010 */ Ustruct* struct;
    /* 0x0018 */ UEnum* Enum;
};

// Size: 0x4
struct FNiagaraTypeDefinitionHandle {
    /* 0x0000 */ int32_t RegisteredTypeIndex;
};

// Size: 0x60
struct FNiagaraTypeLayoutInfo {
    /* 0x0000 */ TArray<uint32_t> FloatComponentByteOffsets;
    /* 0x0010 */ TArray<uint32_t> FloatComponentRegisterOffsets;
    /* 0x0020 */ TArray<uint32_t> Int32ComponentByteOffsets;
    /* 0x0030 */ TArray<uint32_t> Int32ComponentRegisterOffsets;
    /* 0x0040 */ TArray<uint32_t> HalfComponentByteOffsets;
    /* 0x0050 */ TArray<uint32_t> HalfComponentRegisterOffsets;
};

// Size: 0x40
struct FNiagaraUserParameterBinding {
    /* 0x0000 */ FNiagaraVariable Parameter;
};

// Size: 0x190
struct FNiagaraUserRedirectionParameterStore : public FNiagaraParameterStore {
    /* 0x0140 */ TMap<FNiagaraVariable, FNiagaraVariable> UserParameterRedirects;
};

// Size: 0x208
struct FNiagaraVMExecutableData {
    /* 0x0000 */ TArray<uint8_t> ByteCode;
    /* 0x0010 */ TArray<uint8_t> OptimizedByteCode;
    /* 0x0020 */ int32_t NumTempRegisters;
    /* 0x0024 */ int32_t NumUserPtrs;
    /* 0x0028 */ FNiagaraParameters Parameters;
    /* 0x0038 */ FNiagaraParameters InternalParameters;
    /* 0x0048 */ TArray<FNiagaraCompileDependency> ExternalDependencies;
    /* 0x0058 */ TArray<FNiagaraCompilerTag> CompileTags;
    /* 0x0068 */ TArray<uint8_t> ScriptLiterals;
    /* 0x0078 */ TArray<FNiagaraVariable> Attributes;
    /* 0x0088 */ FNiagaraScriptDataUsageInfo DataUsage;
    /* 0x0090 */ TMap<FName, FNiagaraParameters> DataSetToParameters;
    /* 0x00e0 */ TArray<FNiagaraFunctionSignature> AdditionalExternalFunctions;
    /* 0x00f0 */ TArray<FNiagaraScriptDataInterfaceCompileInfo> DataInterfaceInfo;
    /* 0x0100 */ TArray<FVMExternalFunctionBindingInfo> CalledVMExternalFunctions;
    /* 0x0120 */ TArray<FNiagaraDataSetID> ReadDataSets;
    /* 0x0130 */ TArray<FNiagaraDataSetProperties> WriteDataSets;
    /* 0x0140 */ TArray<FNiagaraStatScope> StatScopes;
    /* 0x0150 */ FString LastHlslTranslation;
    /* 0x0160 */ FString LastHlslTranslationGPU;
    /* 0x0170 */ FString LastAssemblyTranslation;
    /* 0x0180 */ uint32_t LastOpCount;
    /* 0x0188 */ TArray<FNiagaraDataInterfaceGPUParamInfo> DIParamInfo;
    /* 0x0198 */ TArray<FString> ParameterCollectionPaths;
    /* 0x01a8 */ ENiagaraScriptCompileStatus LastCompileStatus;
    /* 0x01b0 */ TArray<FSimulationStageMetaData> SimulationStageMetaData;
    /* 0x01c0 */ bool bReadsAttributeData;
    /* 0x01c8 */ TArray<FNiagaraVariableBase> AttributesWritten;
    /* 0x01d8 */ FString ErrorMsg;
    /* 0x01e8 */ float CompileTime;
    /* 0x01f0 */ TArray<FNiagaraCompileEvent> LastCompileEvents;
    /* 0x0200 */ bool bReadsSignificanceIndex;
    /* 0x0200 */ bool bNeedsGPUContextInit;
};

// Size: 0xa0
struct FNiagaraVMExecutableDataId {
    /* 0x0000 */ FGuid CompilerVersionID;
    /* 0x0010 */ ENiagaraScriptUsage ScriptUsageType;
    /* 0x0014 */ FGuid ScriptUsageTypeID;
    /* 0x0028 */ TArray<FString> AdditionalDefines;
    /* 0x0038 */ TArray<FNiagaraVariableBase> AdditionalVariables;
    /* 0x0048 */ bool bUsesRapidIterationParams;
    /* 0x0048 */ bool bInterpolatedSpawn;
    /* 0x0048 */ bool bRequiresPersistentIDs;
    /* 0x004c */ FGuid BaseScriptID;
    /* 0x0060 */ FNiagaraCompileHash BaseScriptCompileHash;
    /* 0x0070 */ TArray<FNiagaraCompileHash> ReferencedCompileHashes;
    /* 0x0090 */ FGuid ScriptVersionID;
};

// Size: 0x40
struct FNiagaraVariable : public FNiagaraVariableBase {
    /* 0x0030 */ TArray<uint8_t> VarData;
};

// Size: 0x108
struct FNiagaraVariableAttributeBinding {
    /* 0x0000 */ FNiagaraVariableBase ParamMapVariable;
    /* 0x0030 */ FNiagaraVariable DataSetVariable;
    /* 0x0070 */ FNiagaraVariable RootVariable;
    /* 0x00b0 */ FNiagaraVariable BoundVariable;
    /* 0x00f0 */ FName CachedDisplayName;
    /* 0x00fc */ uint8_t BindingSourceMode;
    /* 0x0100 */ bool bBindingExistsOnSource;
    /* 0x0100 */ bool bIsCachedParticleValue;
};

// Size: 0x30
struct FNiagaraVariableBase {
    /* 0x0000 */ FName Name;
    /* 0x000c */ FNiagaraTypeDefinitionHandle TypeDefHandle;
    /* 0x0010 */ FNiagaraTypeDefinition TypeDef;
};

// Size: 0x40
struct FNiagaraVariableDataInterfaceBinding {
    /* 0x0000 */ FNiagaraVariable BoundVariable;
};

// Size: 0x60
struct FNiagaraVariableInfo {
    /* 0x0000 */ FNiagaraVariable Variable;
    /* 0x0040 */ FText Definition;
    /* 0x0058 */ UNiagaraDataInterface* DataInterface;
};

// Size: 0x70
struct FNiagaraVariableLayoutInfo {
    /* 0x0000 */ uint32_t FloatComponentStart;
    /* 0x0004 */ uint32_t Int32ComponentStart;
    /* 0x0008 */ uint32_t HalfComponentStart;
    /* 0x0010 */ FNiagaraTypeLayoutInfo LayoutInfo;
};

// Size: 0xf8
struct FNiagaraVariableMetaData {
    /* 0x0000 */ FText Description;
    /* 0x0018 */ FText CategoryName;
    /* 0x0030 */ bool bAdvancedDisplay;
    /* 0x0034 */ int32_t EditorSortPriority;
    /* 0x0038 */ bool bInlineEditConditionToggle;
    /* 0x0040 */ FNiagaraInputConditionMetadata editcondition;
    /* 0x0060 */ FNiagaraInputConditionMetadata VisibleCondition;
    /* 0x0080 */ TMap<FName, FString> PropertyMetaData;
    /* 0x00d0 */ FName ParentAttribute;
    /* 0x00dc */ FGuid VariableGuid;
    /* 0x00ec */ bool bIsStaticSwitch;
    /* 0x00f0 */ int32_t StaticSwitchDefaultValue;
};

// Size: 0x38
struct FNiagaraVariableWithOffset : public FNiagaraVariableBase {
    /* 0x0030 */ int32_t Offset;
};

// Size: 0x28
struct FNiagaraVariant {
    /* 0x0000 */ UObject* Object;
    /* 0x0008 */ UNiagaraDataInterface* DataInterface;
    /* 0x0010 */ TArray<uint8_t> Bytes;
    /* 0x0020 */ ENiagaraVariantMode CurrentMode;
};

// Size: 0x1
struct FNiagaraWildcard {
};

// Size: 0x30
struct FNiagaraWorldManagerTickFunction : public FTickFunction {
};

// Size: 0x20
struct FParameterDefinitionsSubscription {
    /* 0x0000 */ UNiagaraParameterDefinitionsBase* ParameterDefinitions;
    /* 0x0008 */ FGuid DefinitionsId;
    /* 0x0018 */ int32_t CachedChangeIdHash;
};

// Size: 0x90
struct FVMExternalFunctionBindingInfo {
    /* 0x0000 */ FName Name;
    /* 0x000c */ FName OwnerName;
    /* 0x0018 */ TArray<bool> InputParamLocations;
    /* 0x0028 */ int32_t NumOutputs;
    /* 0x0030 */ TArray<FVMFunctionSpecifier> FunctionSpecifiers;
    /* 0x0040 */ TMap<FName, FName> Specifiers;
};

// Size: 0x18
struct FVMFunctionSpecifier {
    /* 0x0000 */ FName Key;
    /* 0x000c */ FName Value;
};

// Size: 0x278
struct FVersionedNiagaraScriptData {
    /* 0x0000 */ FNiagaraAssetVersion Version;
    /* 0x0020 */ FText VersionChangeDescription;
    /* 0x0038 */ int32_t ModuleUsageBitmask;
    /* 0x0040 */ FText Category;
    /* 0x0058 */ bool bSuggested;
    /* 0x0060 */ TArray<FName> ProvidedDependencies;
    /* 0x0070 */ TArray<FNiagaraModuleDependency> RequiredDependencies;
    /* 0x0080 */ bool bDeprecated;
    /* 0x0088 */ FText DeprecationMessage;
    /* 0x00a0 */ UNiagaraScript* DeprecationRecommendation;
    /* 0x00a8 */ UClass* ConversionUtility;
    /* 0x00b0 */ bool bExperimental;
    /* 0x00b8 */ FText ExperimentalMessage;
    /* 0x00d0 */ FText NoteMessage;
    /* 0x00e8 */ ENiagaraScriptLibraryVisibility LibraryVisibility;
    /* 0x00e9 */ ENiagaraNumericOutputTypeSelectionMode NumericOutputTypeSelectionMode;
    /* 0x00f0 */ FText Description;
    /* 0x0108 */ FText Keywords;
    /* 0x0120 */ FText CollapsedViewFormat;
    /* 0x0138 */ TArray<FNiagaraScriptHighlight> Highlights;
    /* 0x0148 */ TMap<FName, FString> ScriptMetaData;
    /* 0x0198 */ FNiagaraVMExecutableDataId LastGeneratedVMId;
    /* 0x0238 */ ENiagaraPythonUpdateScriptReference UpdateScriptExecution;
    /* 0x0240 */ FString PythonUpdateScript;
    /* 0x0250 */ FFilePath ScriptAsset;
    /* 0x0260 */ TArray<FParameterDefinitionsSubscription> ParameterDefinitionsSubscriptions;
    /* 0x0270 */ UNiagaraScriptSourceBase* Source;
};

// Size: 0x68
class UAnimNotifyState_TimedNiagaraEffect : public UAnimNotifyState {
    /* 0x0038 */ UNiagaraSystem* Template;
    /* 0x0040 */ FName SocketName;
    /* 0x004c */ FVector LocationOffset;
    /* 0x0058 */ FRotator RotationOffset;
    /* 0x0064 */ bool bDestroyAtEnd;

    UFXSystemComponent* GetSpawnedEffect(UMeshComponent* MeshComp) const;
};

// Size: 0xb8
class UAnimNotifyState_TimedNiagaraEffectAdvanced : public UAnimNotifyState_TimedNiagaraEffect {

    float GetNotifyProgress(UMeshComponent* MeshComp) const;
};

// Size: 0xa0
class UAnimNotify_PlayNiagaraEffect : public UAnimNotify {
    /* 0x0040 */ UNiagaraSystem* Template;
    /* 0x0048 */ FVector LocationOffset;
    /* 0x0054 */ FRotator RotationOffset;
    /* 0x0060 */ FVector Scale;
    /* 0x006c */ bool bAbsoluteScale;
    /* 0x0090 */ bool Attached;
    /* 0x0094 */ FName SocketName;

    UFXSystemComponent* GetSpawnedEffect() const;
};

// Size: 0x10
struct FNiagaraCompileHash {
    /* 0x0000 */ TArray<uint8_t> DataHash;
};

// Size: 0x58
class UNiagaraDataInterfaceBase : public UNiagaraMergeable {
};

// Size: 0x58
class UNiagaraMergeable : public UObject {
    /* 0x0048 */ FGuid MergeId;
};

// Size: 0x78
class UActorFactoryNiagara : public UActorFactory {
};

// Size: 0x80
struct FAddedPinData {
    /* 0x0000 */ FEdGraphPinType PinType;
    /* 0x0070 */ FName PinName;
};

enum class ENiagaraClipboardFunctionInputValueMode {
    Local = 0,
    Linked = 1,
    Data = 2,
    Expression = 3,
    Dynamic = 4,
    ENiagaraClipboardFunctionInputValueMode_MAX = 5,
};

enum class ENiagaraClipboardFunctionScriptMode {
    ScriptAsset = 0,
    Assignment = 1,
    ENiagaraClipboardFunctionScriptMode_MAX = 2,
};

enum class ENiagaraDataSetAccessMode {
    AppendConsume = 0,
    Direct = 1,
    Num = 2,
    ENiagaraDataSetAccessMode_MAX = 3,
};

enum class ENiagaraLibrarySourceDefaultMode {
    Value = 0,
    Binding = 1,
    FailIfPreviouslyNotSet = 2,
    ENiagaraLibrarySourceDefaultMode_MAX = 3,
};

enum class ENiagaraLibrarySynchronizedDefaultMode {
    Definition = 0,
    Value = 1,
    Binding = 2,
    Custom = 3,
    FailIfPreviouslyNotSet = 4,
    ENiagaraLibrarySynchronizedDefaultMode_MAX = 5,
};

enum class ENiagaraMenuSections {
    Suggested = 0,
    General = 1,
    ENiagaraMenuSections_MAX = 2,
};

enum class ENiagaraMessageSeverity {
    CriticalError = 0,
    Error = 1,
    PerformanceWarning = 2,
    Warning = 3,
    Info = 4,
    CustomNote = 5,
    ENiagaraMessageSeverity_MAX = 6,
};

enum class ENiagaraNamespaceMetadataOptions {
    HideInScript = 0,
    HideInSystem = 1,
    AdvancedInScript = 2,
    AdvancedInSystem = 3,
    PreventEditingNamespace = 4,
    PreventEditingNamespaceModifier = 5,
    PreventEditingName = 6,
    PreventCreatingInSystemEditor = 7,
    ENiagaraNamespaceMetadataOptions_MAX = 8,
};

enum class ENiagaraOutlinerSortMode {
    Auto = 0,
    FilterMatches = 1,
    AverageTime = 2,
    MaxTime = 3,
    ENiagaraOutlinerSortMode_MAX = 4,
};

enum class ENiagaraOutlinerTimeUnits {
    Microseconds = 0,
    Milliseconds = 1,
    Seconds = 2,
    ENiagaraOutlinerTimeUnits_MAX = 3,
};

enum class ENiagaraOutlinerViewModes {
    State = 0,
    Performance = 1,
    ENiagaraOutlinerViewModes_MAX = 2,
};

enum class ENiagaraPythonScriptInputSource {
    Input = 0,
    Output = 1,
    Local = 2,
    InputOutput = 3,
    InitialValueInput = 4,
    None = 5,
    Num = 6,
    ENiagaraPythonScriptInputSource_MAX = 7,
};

enum class ENiagaraStaticSwitchType {
    Bool = 0,
    Integer = 1,
    Enum = 2,
    ENiagaraStaticSwitchType_MAX = 3,
};

enum class EScriptSource {
    Niagara = 0,
    Game = 1,
    Plugins = 2,
    Developer = 3,
    Unknown = 4,
    EScriptSource_MAX = 5,
};

enum class EStackIssueSeverity {
    Error = 0,
    Warning = 1,
    Info = 2,
    CustomNote = 3,
    None = 4,
    EStackIssueSeverity_MAX = 5,
};

enum class EStackParameterBehavior {
    Dynamic = 0,
    Static = 1,
    EStackParameterBehavior_MAX = 2,
};

// Size: 0x30
class UEdGraphSchema_Niagara : public UEdGraphSchema {
};

// Size: 0x30
class UEdGraphSchema_NiagaraSystemOverview : public UEdGraphSchema {
};

// Size: 0x88
struct FMovieSceneNiagaraEmitterChannel : public FMovieSceneChannel {
};

// Size: 0x648
class UMovieSceneNiagaraEmitterSection : public UMovieSceneNiagaraEmitterSectionBase {
    /* 0x0150 */ int32_t NumLoops;
    /* 0x0154 */ bool bStartTimeIncludedInFirstLoopOnly;
};

// Size: 0x150
class UMovieSceneNiagaraEmitterSectionBase : public UMovieSceneSection {
};

// Size: 0x138
class UMovieSceneNiagaraEmitterTrack : public UMovieSceneNameableTrack {
    /* 0x00f0 */ TArray<UMovieSceneSection*> Sections;
    /* 0x0100 */ bool bSectionsWereModified;
    /* 0x0104 */ FGuid EmitterHandleId;
    /* 0x0118 */ FString SystemPath;
};

// Size: 0x40
struct FNiagaraActionColors {
    /* 0x0000 */ FLinearColor NiagaraColor;
    /* 0x0010 */ FLinearColor GameColor;
    /* 0x0020 */ FLinearColor PluginColor;
    /* 0x0030 */ FLinearColor DeveloperColor;
};

// Size: 0x28
struct FNiagaraActionSourceData {
};

// Size: 0x110
struct FNiagaraAction_NewNode : public FNiagaraMenuAction_Generic {
    /* 0x0108 */ UEdGraphNode* NodeTemplate;
};

// Size: 0x110
struct FNiagaraBakerTextureSourceAction : public FEdGraphSchemaAction {
};

// Size: 0x80
class UNiagaraClipboardContent : public UObject {
    /* 0x0030 */ TArray<UNiagaraClipboardFunction*> Functions;
    /* 0x0040 */ TArray<UNiagaraClipboardFunctionInput*> FunctionInputs;
    /* 0x0050 */ TArray<UNiagaraRendererProperties*> Renderers;
    /* 0x0060 */ TArray<UNiagaraScript*> Scripts;
    /* 0x0070 */ TArray<UNiagaraScriptVariable*> ScriptVariables;
};

// Size: 0x30
class UNiagaraClipboardEditorScriptingUtilities : public UObject {

    static UNiagaraClipboardFunctionInput* CreateBoolLocalValueInput(UObject* InOuter, FName InInputName, bool bInHasEditCondition, bool bInEditConditionValue, bool InBoolValue);
    static UNiagaraClipboardFunctionInput* CreateDataValueInput(UObject* InOuter, FName InInputName, bool bInHasEditCondition, bool bInEditConditionValue, UNiagaraDataInterface* InDataValue);
    static UNiagaraClipboardFunctionInput* CreateDynamicValueInput(UObject* InOuter, FName InInputName, FName InInputTypeName, bool bInHasEditCondition, bool bInEditConditionValue, FString InDynamicValueName, UNiagaraScript* InDynamicValue);
    static UNiagaraClipboardFunctionInput* CreateEnumLocalValueInput(UObject* InOuter, FName InInputName, bool bInHasEditCondition, bool bInEditCoditionValue, UUserDefinedEnum* InEnumType, int32_t InEnumValue);
    static UNiagaraClipboardFunctionInput* CreateExpressionValueInput(UObject* InOuter, FName InInputName, FName InInputTypeName, bool bInHasEditCondition, bool bInEditConditionValue, FString InExpressionValue);
    static UNiagaraClipboardFunctionInput* CreateFloatLocalValueInput(UObject* InOuter, FName InInputName, bool bInHasEditCondition, bool bInEditConditionValue, float InLocalValue);
    static UNiagaraClipboardFunctionInput* CreateIntLocalValueInput(UObject* InOuter, FName InInputName, bool bInHasEditCondition, bool bInEditConditionValue, int32_t InLocalValue);
    static UNiagaraClipboardFunctionInput* CreateLinkedValueInput(UObject* InOuter, FName InInputName, FName InInputTypeName, bool bInHasEditCondition, bool bInEditConditionValue, FName InLinkedValue);
    static UNiagaraClipboardFunctionInput* CreateStructLocalValueInput(UObject* InOuter, FName InInputName, bool bInHasEditCondition, bool bInEditConditionValue, UUserDefinedStruct* InStructValue);
    static UNiagaraClipboardFunctionInput* CreateVec2LocalValueInput(UObject* InOuter, FName InInputName, bool bInHasEditCondition, bool bInEditConditionValue, FVector2D InVec2Value);
    static UNiagaraClipboardFunctionInput* CreateVec3LocalValueInput(UObject* InOuter, FName InInputName, bool bInHasEditCondition, bool bInEditConditionValue, FVector InVec3Value);
    static FName GetTypeName(const UNiagaraClipboardFunctionInput* InInput);
    static void TryGetInputByName(const TArray<UNiagaraClipboardFunctionInput*>& InInputs, FName InInputName, bool& bOutSucceeded, UNiagaraClipboardFunctionInput*& OutInput);
    static void TryGetLocalValueAsFloat(const UNiagaraClipboardFunctionInput* InInput, bool& bOutSucceeded, float& OutValue);
    static void TryGetLocalValueAsInt(const UNiagaraClipboardFunctionInput* InInput, bool& bOutSucceeded, int32_t& OutValue);
    static void TrySetLocalValueAsInt(UNiagaraClipboardFunctionInput* InInput, bool& bOutSucceeded, int32_t InValue, bool bLooseTyping);
};

// Size: 0xf8
class UNiagaraClipboardFunction : public UObject {
    /* 0x0030 */ FString FunctionName;
    /* 0x0040 */ FText DisplayName;
    /* 0x0058 */ ENiagaraClipboardFunctionScriptMode ScriptMode;
    /* 0x0060 */ TSoftObjectPtr<UNiagaraScript> Script;
    /* 0x0090 */ TArray<FNiagaraVariable> AssignmentTargets;
    /* 0x00a0 */ TArray<FString> AssignmentDefaults;
    /* 0x00b0 */ TArray<UNiagaraClipboardFunctionInput*> Inputs;
    /* 0x00c0 */ FDelegate OnPastedFunctionCallNodeDelegate;
    /* 0x00d4 */ FGuid ScriptVersion;
    /* 0x00e8 */ TArray<FNiagaraStackMessage> Messages;

    void OnPastedFunctionCallNode__DelegateSignature(UNiagaraNodeFunctionCall* PastedFunctionCall);
};

// Size: 0xa8
class UNiagaraClipboardFunctionInput : public UObject {
    /* 0x0030 */ FName InputName;
    /* 0x0040 */ FNiagaraTypeDefinition InputType;
    /* 0x0060 */ bool bHasEditCondition;
    /* 0x0061 */ bool bEditConditionValue;
    /* 0x0064 */ ENiagaraClipboardFunctionInputValueMode ValueMode;
    /* 0x0068 */ TArray<uint8_t> Local;
    /* 0x0078 */ FName Linked;
    /* 0x0088 */ UNiagaraDataInterface* Data;
    /* 0x0090 */ FString Expression;
    /* 0x00a0 */ UNiagaraClipboardFunction* Dynamic;
};

// Size: 0x40
struct FNiagaraConvertConnection {
    /* 0x0000 */ FGuid SourcePinId;
    /* 0x0010 */ TArray<FName> SourcePath;
    /* 0x0020 */ FGuid DestinationPinId;
    /* 0x0030 */ TArray<FName> DestinationPath;
};

// Size: 0x30
class UNiagaraConvertInPlaceEmitterAndSystemState : public UNiagaraConvertInPlaceUtilityBase {
};

// Size: 0x20
struct FNiagaraConvertPinRecord {
    /* 0x0000 */ FGuid PinId;
    /* 0x0010 */ TArray<FName> Path;
};

// Size: 0x88
class UNiagaraCurveSelectionViewModel : public UObject {
};

// Size: 0x30
struct FNiagaraCurveTemplate {
    /* 0x0000 */ FString DisplayNameOverride;
    /* 0x0010 */ FSoftObjectPath CurveAsset;
};

// Size: 0x88
class UNiagaraDynamicInputScriptFactory : public UNiagaraScriptFactoryNew {
};

// Size: 0x40
class UNiagaraEditorParametersAdapter : public UNiagaraEditorParametersAdapterBase {
    /* 0x0030 */ TArray<UNiagaraScriptVariable*> EditorOnlyScriptVars;
};

// Size: 0x3e0
class UNiagaraEditorSettings : public UDeveloperSettings {
    /* 0x0060 */ FSoftObjectPath DefaultScript;
    /* 0x0080 */ FSoftObjectPath DefaultDynamicInputScript;
    /* 0x00a0 */ FSoftObjectPath DefaultFunctionScript;
    /* 0x00c0 */ FSoftObjectPath DefaultModuleScript;
    /* 0x00e0 */ FSoftObjectPath RequiredSystemUpdateScript;
    /* 0x0100 */ TArray<FNiagaraSpawnShortcut> GraphCreationShortcuts;
    /* 0x0110 */ bool bEnableBaker;
    /* 0x0130 */ bool bAutoCompile;
    /* 0x0131 */ bool bAutoPlay;
    /* 0x0132 */ bool bResetSimulationOnChange;
    /* 0x0133 */ bool bResimulateOnChangeWhilePaused;
    /* 0x0134 */ bool bResetDependentSystemsWhenEditingEmitters;
    /* 0x0135 */ bool bDisplayAdvancedParameterPanelCategories;
    /* 0x0138 */ TArray<float> PlaybackSpeeds;
    /* 0x0148 */ FNiagaraActionColors ActionColors;
    /* 0x01a0 */ TMap<FName, FNiagaraNewAssetDialogConfig> NewAssetDialogConfigMap;
    /* 0x01f0 */ TMap<FString, FString> HLSLKeywordReplacements;
    /* 0x0240 */ TArray<FNiagaraNamespaceMetadata> NamespaceMetadata;
    /* 0x0250 */ TArray<FNiagaraNamespaceMetadata> NamespaceModifierMetadata;
    /* 0x0260 */ FNiagaraNamespaceMetadata DefaultNamespaceMetadata;
    /* 0x0318 */ FNiagaraNamespaceMetadata DefaultNamespaceModifierMetadata;
    /* 0x03d0 */ TArray<FNiagaraCurveTemplate> CurveTemplates;
};

// Size: 0x88
class UNiagaraEffectTypeFactoryNew : public UFactory {
};

// Size: 0x58
class UNiagaraEmitterEditorData : public UNiagaraEditorDataBase {
    /* 0x0048 */ UNiagaraStackEditorData* StackEditorData;
    /* 0x0050 */ float PlaybackRangeMin;
    /* 0x0054 */ float PlaybackRangeMax;
};

// Size: 0x98
class UNiagaraEmitterFactoryNew : public UFactory {
};

// Size: 0x50
struct FNiagaraEmitterSectionKey {
    /* 0x0000 */ FGuid ModuleId;
    /* 0x0010 */ FNiagaraVariable Value;
};

// Size: 0x30
class UNiagaraEmitterThumbnailRenderer : public UNiagaraThumbnailRendererBase {
};

// Size: 0x88
class UNiagaraFunctionScriptFactory : public UNiagaraScriptFactoryNew {
};

// Size: 0x298
class UNiagaraGraph : public UEdGraph {
    /* 0x0120 */ FGuid ChangeId;
    /* 0x0130 */ FGuid ForceRebuildId;
    /* 0x0140 */ FGuid LastBuiltTraversalDataChangeId;
    /* 0x0150 */ TArray<FNiagaraGraphScriptUsageInfo> CachedUsageInfo;
    /* 0x0160 */ TMap<FNiagaraVariable, FNiagaraVariableMetaData> VariableToMetaData;
    /* 0x01b0 */ TMap<FNiagaraVariable, UNiagaraScriptVariable*> VariableToScriptVariable;
    /* 0x0200 */ TMap<FNiagaraVariable, FNiagaraGraphParameterReferenceCollection> ParameterToReferencesMap;
};

// Size: 0x1c
struct FNiagaraGraphParameterReference {
    /* 0x0000 */ FGuid Key;
    /* 0x0010 */ TWeakObjectPtr<UObject> Value;
    /* 0x0018 */ bool bIsUserFacing;
};

// Size: 0x20
struct FNiagaraGraphParameterReferenceCollection {
    /* 0x0000 */ TArray<FNiagaraGraphParameterReference> ParameterReferences;
    /* 0x0010 */ UNiagaraGraph* Graph;
    /* 0x0018 */ bool bCreatedByUser;
};

// Size: 0x88
struct FNiagaraGraphScriptUsageInfo {
    /* 0x0000 */ FGuid BaseId;
    /* 0x0010 */ ENiagaraScriptUsage UsageType;
    /* 0x0014 */ FGuid UsageId;
    /* 0x0028 */ FNiagaraCompileHash CompileHash;
    /* 0x0038 */ FNiagaraCompileHash CompileHashFromGraph;
    /* 0x0048 */ TArray<FNiagaraCompileHashVisitorDebugInfo> CompileLastObjects;
    /* 0x0058 */ TArray<UNiagaraNode*> Traversal;
    /* 0x0068 */ TArray<uint8_t> DataHash;
    /* 0x0078 */ FGuid GeneratedCompileId;
};

// Size: 0x4
struct FNiagaraInputExposureOptions {
    /* 0x0000 */ bool bExposed;
    /* 0x0000 */ bool bRequired;
    /* 0x0000 */ bool bCanAutoBind;
    /* 0x0000 */ bool bHidden;
};

// Size: 0x170
struct FNiagaraMenuAction : public FEdGraphSchemaAction {
};

// Size: 0xa0
struct FNiagaraMenuAction_Base {
};

// Size: 0x108
struct FNiagaraMenuAction_Generic : public FNiagaraMenuAction_Base {
};

// Size: 0x30
class UNiagaraMessageData : public UNiagaraMessageDataBase {
};

// Size: 0x70
class UNiagaraMessageDataText : public UNiagaraMessageData {
    /* 0x0030 */ FText MessageText;
    /* 0x0048 */ FText ShortDescription;
    /* 0x0060 */ ENiagaraMessageSeverity MessageSeverity;
    /* 0x0061 */ bool bAllowDismissal;
    /* 0x0064 */ FName TopicName;
};

// Size: 0x88
class UNiagaraModuleScriptFactory : public UNiagaraScriptFactoryNew {
};

// Size: 0xb8
struct FNiagaraNamespaceMetadata {
    /* 0x0000 */ TArray<FName> Namespaces;
    /* 0x0010 */ FName RequiredNamespaceModifier;
    /* 0x0020 */ FText DisplayName;
    /* 0x0038 */ FText DisplayNameLong;
    /* 0x0050 */ FText Description;
    /* 0x0068 */ FLinearColor BackgroundColor;
    /* 0x0078 */ FName ForegroundStyle;
    /* 0x0084 */ int32_t SortId;
    /* 0x0088 */ TArray<FName> OptionalNamespaceModifiers;
    /* 0x0098 */ TArray<ENiagaraNamespaceMetadataOptions> Options;
    /* 0x00a8 */ FGuid Guid;
};

// Size: 0xc
struct FNiagaraNewAssetDialogConfig {
    /* 0x0000 */ int32_t SelectedOptionIndex;
    /* 0x0004 */ FVector2D WindowSize;
};

// Size: 0x100
class UNiagaraNode : public UEdGraphNode {
    /* 0x00c8 */ FGuid ChangeId;
};

// Size: 0x4e0
class UNiagaraNodeAssignment : public UNiagaraNodeFunctionCall {
    /* 0x0430 */ FNiagaraVariable AssignmentTarget;
    /* 0x0470 */ FString AssignmentDefaultValue;
    /* 0x0480 */ TArray<FNiagaraVariable> AssignmentTargets;
    /* 0x0490 */ TArray<FString> AssignmentDefaultValues;
    /* 0x04a0 */ FString OldFunctionCallName;
};

// Size: 0x178
class UNiagaraNodeConvert : public UNiagaraNodeWithDynamicPins {
    /* 0x0100 */ FString AutowireSwizzle;
    /* 0x0110 */ FNiagaraTypeDefinition AutowireMakeType;
    /* 0x0130 */ FNiagaraTypeDefinition AutowireBreakType;
    /* 0x0150 */ TArray<FNiagaraConvertConnection> Connections;
    /* 0x0160 */ bool bIsWiringShown;
    /* 0x0168 */ TArray<FNiagaraConvertPinRecord> ExpandedItems;
};

// Size: 0x450
class UNiagaraNodeCustomHlsl : public UNiagaraNodeFunctionCall {
    /* 0x0430 */ ENiagaraScriptUsage ScriptUsage;
    /* 0x0440 */ FString CustomHlsl;
};

// Size: 0x138
class UNiagaraNodeDataSetBase : public UNiagaraNode {
    /* 0x0100 */ FNiagaraDataSetID DataSet;
    /* 0x0110 */ TArray<FNiagaraVariable> Variables;
    /* 0x0120 */ TArray<FString> VariableFriendlyNames;
    /* 0x0130 */ Ustruct* ExternalStructAsset;
};

// Size: 0x158
class UNiagaraNodeEmitter : public UNiagaraNodeWithDynamicPins {
    /* 0x0108 */ UNiagaraSystem* OwnerSystem;
    /* 0x0110 */ FGuid EmitterHandleId;
    /* 0x0120 */ FText DisplayName;
    /* 0x0138 */ ENiagaraScriptUsage ScriptType;
};

// Size: 0x430
class UNiagaraNodeFunctionCall : public UNiagaraNodeWithDynamicPins {
    /* 0x0100 */ UNiagaraScript* FunctionScript;
    /* 0x0108 */ FGuid SelectedScriptVersion;
    /* 0x0118 */ FName FunctionScriptAssetObjectPath;
    /* 0x0128 */ FNiagaraFunctionSignature Signature;
    /* 0x02a0 */ TMap<FName, FName> FunctionSpecifiers;
    /* 0x02f0 */ TArray<FNiagaraPropagatedVariable> PropagatedStaticSwitchParameters;
    /* 0x0300 */ FGuid PreviousScriptVersion;
    /* 0x0310 */ FString PythonUpgradeScriptWarnings;
    /* 0x0320 */ ENiagaraFunctionDebugState DebugState;
    /* 0x0321 */ bool bInheritDebugStatus;
    /* 0x0324 */ FGuid CachedChangeId;
    /* 0x0334 */ FGuid InvalidScriptVersionReference;
    /* 0x0348 */ FString FunctionDisplayName;
    /* 0x0358 */ TMap<FGuid, UNiagaraMessageData*> MessageKeyToMessageMap;
    /* 0x03a8 */ TArray<FNiagaraStackMessage> StackMessages;
    /* 0x03b8 */ TMap<FGuid, FName> BoundPinNames;
};

// Size: 0x130
class UNiagaraNodeIf : public UNiagaraNodeWithDynamicPins {
    /* 0x0100 */ TArray<FNiagaraVariable> OutputVars;
    /* 0x0110 */ TArray<FPinGuidsForPath> PathAssociatedPinGuids;
    /* 0x0120 */ FGuid ConditionPinGuid;
};

// Size: 0x158
class UNiagaraNodeInput : public UNiagaraNode {
    /* 0x0100 */ FNiagaraVariable Input;
    /* 0x0140 */ ENiagaraInputNodeUsage Usage;
    /* 0x0144 */ int32_t CallSortPriority;
    /* 0x0148 */ FNiagaraInputExposureOptions ExposureOptions;
    /* 0x0150 */ UNiagaraDataInterface* DataInterface;
};

// Size: 0x120
class UNiagaraNodeOp : public UNiagaraNodeWithDynamicPins {
    /* 0x0100 */ FName OpName;
    /* 0x0110 */ TArray<FAddedPinData> AddedPins;
};

// Size: 0x128
class UNiagaraNodeOutput : public UNiagaraNode {
    /* 0x0100 */ TArray<FNiagaraVariable> Outputs;
    /* 0x0110 */ ENiagaraScriptUsage ScriptType;
    /* 0x0114 */ FGuid ScriptTypeId;
    /* 0x0124 */ int32_t ScriptTypeIndex;
};

// Size: 0x110
class UNiagaraNodeOutputTag : public UNiagaraNodeWithDynamicPins {
    /* 0x0100 */ bool bEmitMessageOnFailure;
    /* 0x0101 */ FNiagaraCompileEventSeverity FailureSeverity;
};

// Size: 0x118
class UNiagaraNodeParameterMapBase : public UNiagaraNodeWithDynamicPins {
};

// Size: 0x118
class UNiagaraNodeParameterMapFor : public UNiagaraNodeParameterMapSet {
};

// Size: 0x168
class UNiagaraNodeParameterMapGet : public UNiagaraNodeParameterMapBase {
    /* 0x0118 */ TMap<FGuid, FGuid> PinOutputToPinDefaultPersistentId;
};

// Size: 0x118
class UNiagaraNodeParameterMapSet : public UNiagaraNodeParameterMapBase {
};

// Size: 0x138
class UNiagaraNodeReadDataSet : public UNiagaraNodeDataSetBase {
};

// Size: 0x108
class UNiagaraNodeReroute : public UNiagaraNode {
};

// Size: 0x160
class UNiagaraNodeSelect : public UNiagaraNodeUsageSelector {
    /* 0x0130 */ FNiagaraTypeDefinition SelectorPinType;
    /* 0x0150 */ FGuid SelectorPinGuid;
};

// Size: 0x128
class UNiagaraNodeSimTargetSelector : public UNiagaraNodeUsageSelector {
};

// Size: 0x168
class UNiagaraNodeStaticSwitch : public UNiagaraNodeUsageSelector {
    /* 0x0130 */ FName InputParameterName;
    /* 0x0140 */ FStaticSwitchTypeData SwitchTypeData;
};

// Size: 0x128
class UNiagaraNodeUsageSelector : public UNiagaraNodeWithDynamicPins {
    /* 0x0100 */ TArray<FNiagaraVariable> OutputVars;
    /* 0x0110 */ TArray<FGuid> OutputVarGuids;
    /* 0x0120 */ int32_t NumOptionsPerVariable;
};

// Size: 0x100
class UNiagaraNodeWithDynamicPins : public UNiagaraNode {
};

// Size: 0x148
class UNiagaraNodeWriteDataSet : public UNiagaraNodeDataSetBase {
    /* 0x0138 */ FName EventName;
};

// Size: 0xc8
class UNiagaraOutliner : public UObject {
    /* 0x0050 */ FNiagaraOutlinerCaptureSettings CaptureSettings;
    /* 0x005c */ FNiagaraOutlinerViewSettings ViewSettings;
    /* 0x0078 */ FNiagaraOutlinerData Data;
};

// Size: 0x20
struct FNiagaraOutlinerEmitterInstanceDataCustomizationWrapper {
    /* 0x0000 */ FNiagaraOutlinerEmitterInstanceData Data;
};

// Size: 0x10
struct FNiagaraOutlinerFilterSettings {
    /* 0x0000 */ bool bFilterBySystemExecutionState;
    /* 0x0000 */ bool bFilterByEmitterExecutionState;
    /* 0x0000 */ bool bFilterByEmitterSimTarget;
    /* 0x0000 */ bool bFilterBySystemCullState;
    /* 0x0004 */ ENiagaraExecutionState SystemExecutionState;
    /* 0x0008 */ ENiagaraExecutionState EmitterExecutionState;
    /* 0x000c */ ENiagaraSimTarget EmitterSimTarget;
    /* 0x000d */ bool bSystemCullState;
};

// Size: 0x30
struct FNiagaraOutlinerSystemDataCustomizationWrapper {
    /* 0x0000 */ FNiagaraOutlinerSystemData Data;
};

// Size: 0x48
struct FNiagaraOutlinerSystemInstanceDataCustomizationWrapper {
    /* 0x0000 */ FNiagaraOutlinerSystemInstanceData Data;
};

// Size: 0x18
struct FNiagaraOutlinerViewSettings {
    /* 0x0000 */ ENiagaraOutlinerViewModes ViewMode;
    /* 0x0004 */ FNiagaraOutlinerFilterSettings FilterSettings;
    /* 0x0014 */ bool bSortDescending;
    /* 0x0015 */ ENiagaraOutlinerSortMode SortMode;
    /* 0x0016 */ ENiagaraOutlinerTimeUnits TimeUnits;
};

// Size: 0x68
struct FNiagaraOutlinerWorldDataCustomizationWrapper {
    /* 0x0000 */ FNiagaraOutlinerWorldData Data;
};

// Size: 0xe8
class UNiagaraOverviewNode : public UEdGraphNode {
    /* 0x00c8 */ UNiagaraSystem* OwningSystem;
    /* 0x00d0 */ FGuid EmitterHandleGuid;
};

// Size: 0x88
class UNiagaraParameterCollectionFactoryNew : public UFactory {
};

// Size: 0x90
class UNiagaraParameterCollectionInstanceFactoryNew : public UFactory {
};

// Size: 0x80
class UNiagaraParameterDefinitions : public UNiagaraParameterDefinitionsBase {
    /* 0x0058 */ bool bPromoteToTopInAddMenus;
    /* 0x005c */ int32_t MenuSortOrder;
    /* 0x0060 */ TArray<UNiagaraScriptVariable*> ScriptVariables;
    /* 0x0070 */ TArray<FParameterDefinitionsBindingNameSubscription> ExternalParameterDefinitionsSubscriptions;
};

// Size: 0x88
class UNiagaraParameterDefinitionsFactory : public UFactory {
};

// Size: 0x50
struct FNiagaraPropagatedVariable {
    /* 0x0000 */ FNiagaraVariable SwitchParameter;
    /* 0x0040 */ FString PropagatedName;
};

// Size: 0x38
class UNiagaraPythonScriptModuleInput : public UObject {
    /* 0x0030 */ UNiagaraClipboardFunctionInput* Input;

    bool AsBool() const;
    FLinearColor AsColor() const;
    FString AsEnum() const;
    float AsFloat() const;
    int32_t AsInt() const;
    FQuat AsQuat() const;
    FVector2D AsVec2() const;
    FVector AsVec3() const;
    FVector4 AsVec4() const;
    bool IsLocalValue() const;
    bool IsSet() const;
};

// Size: 0x80
class UNiagaraReservedParametersManager : public UObject {
    /* 0x0030 */ TMap<FName, FReservedParameterArray> ReservedParameters;
};

// Size: 0x110
struct FNiagaraSchemaAction_NewComment : public FEdGraphSchemaAction {
};

// Size: 0x118
struct FNiagaraSchemaAction_NewNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UEdGraphNode* NodeTemplate;
    /* 0x0108 */ FName InternalName;
};

// Size: 0x120
class UNiagaraScratchPadViewModel : public UObject {
};

// Size: 0x40
class UNiagaraScripStatsViewModelSettings : public UObject {
    /* 0x0030 */ TArray<int32_t> EnabledPlatforms;
};

// Size: 0x88
class UNiagaraScriptFactoryNew : public UFactory {
};

// Size: 0x70
class UNiagaraScriptSource : public UNiagaraScriptSourceBase {
    /* 0x0068 */ UNiagaraGraph* NodeGraph;
};

// Size: 0x1c0
class UNiagaraScriptVariable : public UObject {
    /* 0x0030 */ ENiagaraDefaultMode DefaultMode;
    /* 0x0034 */ FNiagaraScriptVariableBinding DefaultBinding;
    /* 0x0040 */ FNiagaraVariable Variable;
    /* 0x0080 */ FNiagaraVariableMetaData MetaData;
    /* 0x0178 */ FNiagaraVariant DefaultValueVariant;
    /* 0x01a0 */ int32_t StaticSwitchDefaultValue;
    /* 0x01a4 */ bool bIsStaticSwitch;
    /* 0x01a5 */ bool bSubscribedToParameterDefinitions;
    /* 0x01a8 */ FGuid ChangeId;
    /* 0x01b8 */ bool bOverrideParameterDefinitionsDefaultValue;
};

// Size: 0x78
class UNiagaraSequence : public UMovieSceneSequence {
    /* 0x0068 */ UMovieScene* MovieScene;
};

// Size: 0x30
class UNiagaraSequencerTrackFilter : public USequencerTrackFilterExtension {
};

// Size: 0x38
struct FNiagaraSpawnShortcut {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FInputChord Input;
};

// Size: 0x138
struct FNiagaraStackAssetAction_EventSource : public FEdGraphSchemaAction {
};

// Size: 0x190
struct FNiagaraStackAssetAction_VarBind : public FEdGraphSchemaAction {
};

// Size: 0x1f8
class UNiagaraStackEditorData : public UNiagaraEditorDataBase {
    /* 0x0188 */ TMap<FString, FText> StackEntryKeyToDisplayName;
    /* 0x01e8 */ TArray<FString> DismissedStackIssueIds;
};

// Size: 0x238
class UNiagaraStackEmitterPropertiesItem : public UNiagaraStackItem {
    /* 0x0230 */ UNiagaraStackObject* EmitterObject;
};

// Size: 0x248
class UNiagaraStackEmitterSettingsGroup : public UNiagaraStackItemGroup {
    /* 0x0240 */ UNiagaraStackEmitterPropertiesItem* PropertiesItem;
};

// Size: 0x1e0
class UNiagaraStackEntry : public UObject {
    /* 0x0050 */ UNiagaraStackEditorData* StackEditorData;
    /* 0x0108 */ TArray<UNiagaraStackEntry*> Children;
    /* 0x0130 */ TArray<UNiagaraStackErrorItem*> ErrorChildren;
};

// Size: 0x270
class UNiagaraStackErrorItem : public UNiagaraStackEntry {
};

// Size: 0x298
class UNiagaraStackErrorItemDismiss : public UNiagaraStackErrorItemFix {
};

// Size: 0x298
class UNiagaraStackErrorItemFix : public UNiagaraStackEntry {
};

// Size: 0x240
class UNiagaraStackErrorItemLongDescription : public UNiagaraStackEntry {
};

// Size: 0x260
class UNiagaraStackEventHandlerGroup : public UNiagaraStackItemGroup {
};

// Size: 0x248
class UNiagaraStackEventHandlerPropertiesItem : public UNiagaraStackItem {
    /* 0x0240 */ UNiagaraStackObject* EmitterObject;
};

// Size: 0x2b8
class UNiagaraStackEventScriptItemGroup : public UNiagaraStackScriptItemGroup {
    /* 0x02b0 */ UNiagaraStackEventHandlerPropertiesItem* EventHandlerProperties;
};

// Size: 0x8e0
class UNiagaraStackFunctionInput : public UNiagaraStackItemContent {
};

// Size: 0x210
class UNiagaraStackFunctionInputCollection : public UNiagaraStackItemContent {
};

// Size: 0x238
class UNiagaraStackInputCategory : public UNiagaraStackItemContent {
};

// Size: 0x220
class UNiagaraStackItem : public UNiagaraStackEntry {
    /* 0x0218 */ UNiagaraStackItemFooter* ItemFooter;
};

// Size: 0x1f8
class UNiagaraStackItemContent : public UNiagaraStackEntry {
};

// Size: 0x208
class UNiagaraStackItemFooter : public UNiagaraStackEntry {
};

// Size: 0x240
class UNiagaraStackItemGroup : public UNiagaraStackEntry {
    /* 0x01e0 */ UNiagaraStackItemGroupFooter* GroupFooter;
};

// Size: 0x1e0
class UNiagaraStackItemGroupFooter : public UNiagaraStackEntry {
};

// Size: 0x210
class UNiagaraStackItemTextContent : public UNiagaraStackItemContent {
};

// Size: 0x48
struct FNiagaraStackMessage {
    /* 0x0000 */ FText MessageText;
    /* 0x0018 */ FText ShortDescription;
    /* 0x0030 */ ENiagaraMessageSeverity MessageSeverity;
    /* 0x0031 */ bool bAllowDismissal;
    /* 0x0034 */ FGuid Guid;
};

// Size: 0x2d8
class UNiagaraStackModuleItem : public UNiagaraStackItem {
    /* 0x0270 */ UNiagaraStackModuleItemLinkedInputCollection* LinkedInputCollection;
    /* 0x0278 */ UNiagaraStackFunctionInputCollection* InputCollection;
    /* 0x0280 */ UNiagaraStackModuleItemOutputCollection* OutputCollection;
};

// Size: 0x1e8
class UNiagaraStackModuleItemLinkedInputCollection : public UNiagaraStackEntry {
};

// Size: 0x258
class UNiagaraStackModuleItemOutput : public UNiagaraStackEntry {
};

// Size: 0x1e8
class UNiagaraStackModuleItemOutputCollection : public UNiagaraStackEntry {
};

// Size: 0x258
class UNiagaraStackObject : public UNiagaraStackItemContent {
};

// Size: 0x288
class UNiagaraStackParameterStoreEntry : public UNiagaraStackItemContent {
    /* 0x0280 */ UNiagaraStackObject* ValueObjectEntry;
};

// Size: 0x238
class UNiagaraStackParameterStoreItem : public UNiagaraStackItem {
};

// Size: 0x218
class UNiagaraStackPropertyRow : public UNiagaraStackItemContent {
};

// Size: 0x258
class UNiagaraStackRenderItemGroup : public UNiagaraStackItemGroup {
};

// Size: 0x268
class UNiagaraStackRendererItem : public UNiagaraStackItem {
    /* 0x0260 */ UNiagaraStackObject* RendererObject;
};

// Size: 0x240
class UNiagaraStackRoot : public UNiagaraStackEntry {
    /* 0x01e0 */ UNiagaraStackSystemSettingsGroup* SystemSettingsGroup;
    /* 0x01e8 */ UNiagaraStackScriptItemGroup* SystemSpawnGroup;
    /* 0x01f0 */ UNiagaraStackScriptItemGroup* SystemUpdateGroup;
    /* 0x01f8 */ UNiagaraStackEmitterSettingsGroup* EmitterSettingsGroup;
    /* 0x0200 */ UNiagaraStackScriptItemGroup* EmitterSpawnGroup;
    /* 0x0208 */ UNiagaraStackScriptItemGroup* EmitterUpdateGroup;
    /* 0x0210 */ UNiagaraStackScriptItemGroup* ParticleSpawnGroup;
    /* 0x0218 */ UNiagaraStackScriptItemGroup* ParticleUpdateGroup;
    /* 0x0220 */ UNiagaraStackEventHandlerGroup* AddEventHandlerGroup;
    /* 0x0228 */ UNiagaraStackSimulationStagesGroup* AddSimulationStageGroup;
    /* 0x0230 */ UNiagaraStackRenderItemGroup* RenderGroup;
};

// Size: 0x288
class UNiagaraStackScriptItemGroup : public UNiagaraStackItemGroup {
};

// Size: 0x1f0
class UNiagaraStackSelection : public UNiagaraStackEntry {
};

// Size: 0x2b0
class UNiagaraStackSimulationStageGroup : public UNiagaraStackScriptItemGroup {
    /* 0x02a8 */ UNiagaraStackSimulationStagePropertiesItem* SimulationStageProperties;
};

// Size: 0x238
class UNiagaraStackSimulationStagePropertiesItem : public UNiagaraStackItem {
    /* 0x0230 */ UNiagaraStackObject* SimulationStageObject;
};

// Size: 0x260
class UNiagaraStackSimulationStagesGroup : public UNiagaraStackItemGroup {
};

// Size: 0x238
class UNiagaraStackSystemPropertiesItem : public UNiagaraStackItem {
    /* 0x0230 */ UNiagaraStackObject* SystemObject;
};

// Size: 0x268
class UNiagaraStackSystemSettingsGroup : public UNiagaraStackItemGroup {
};

// Size: 0x148
class UNiagaraStackViewModel : public UObject {
    /* 0x0060 */ UNiagaraStackEntry* RootEntry;
};

// Size: 0x2e8
class UNiagaraSystemAuditCommandlet : public UCommandlet {
};

// Size: 0xc0
class UNiagaraSystemEditorData : public UNiagaraEditorDataBase {
    /* 0x0048 */ bool bSetOrbitModeByAsset;
    /* 0x0049 */ bool bSystemViewportInOrbitMode;
    /* 0x0050 */ UNiagaraSystemEditorFolder* RootFolder;
    /* 0x0058 */ UNiagaraStackEditorData* StackEditorData;
    /* 0x0060 */ FTransform OwnerTransform;
    /* 0x0090 */ float PlaybackRangeMin;
    /* 0x0094 */ float PlaybackRangeMax;
    /* 0x0098 */ UEdGraph* SystemOverviewGraph;
    /* 0x00a0 */ FNiagaraGraphViewSettings OverviewGraphViewSettings;
    /* 0x00b0 */ bool bSystemIsPlaceholder;
};

// Size: 0x60
class UNiagaraSystemEditorFolder : public UObject {
    /* 0x0030 */ FName FolderName;
    /* 0x0040 */ TArray<UNiagaraSystemEditorFolder*> ChildFolders;
    /* 0x0050 */ TArray<FGuid> ChildEmitterHandleIds;
};

// Size: 0xa0
class UNiagaraSystemFactoryNew : public UFactory {
};

// Size: 0xd8
class UNiagaraSystemSelectionViewModel : public UObject {
    /* 0x0068 */ UNiagaraStackSelection* StackSelection;
    /* 0x0070 */ UNiagaraStackViewModel* SelectionStackViewModel;
};

// Size: 0x30
class UNiagaraSystemThumbnailRenderer : public UNiagaraThumbnailRendererBase {
};

// Size: 0x30
class UNiagaraThumbnailRendererBase : public UTextureThumbnailRenderer {
};

// Size: 0xf8
struct FNiagaraVariableMetaDataContainer {
    /* 0x0000 */ FNiagaraVariableMetaData MetaData;
};

// Size: 0x88
class UNiagaraVersionMetaData : public UObject {
    /* 0x0030 */ bool bIsExposedVersion;
    /* 0x0038 */ FText ChangeDescription;
    /* 0x0050 */ bool bIsVisibleInVersionSelector;
    /* 0x0054 */ FGuid VersionGuid;
    /* 0x0064 */ ENiagaraPythonUpdateScriptReference UpdateScriptExecution;
    /* 0x0068 */ FString PythonUpdateScript;
    /* 0x0078 */ FFilePath ScriptAsset;
};

// Size: 0x18
struct FParameterDefinitionsBindingNameSubscription {
    /* 0x0000 */ UNiagaraParameterDefinitions* SubscribedParameterDefinitions;
    /* 0x0008 */ TArray<FScriptVarBindingNameSubscription> BindingNameSubscriptions;
};

// Size: 0x30
struct FPinGuidsForPath {
    /* 0x0000 */ FGuid OutputPinGuid;
    /* 0x0010 */ FGuid InputTruePinGuid;
    /* 0x0020 */ FGuid InputFalsePinGuid;
};

// Size: 0x38
struct FReservedParameter {
    /* 0x0000 */ FNiagaraVariableBase Parameter;
    /* 0x0030 */ UNiagaraParameterDefinitions* ReservingDefinitionsAsset;
};

// Size: 0x10
struct FReservedParameterArray {
    /* 0x0000 */ TArray<FReservedParameter> Arr;
};

// Size: 0x20
struct FScriptVarBindingNameSubscription {
    /* 0x0000 */ FGuid ExternalScriptVarId;
    /* 0x0010 */ TArray<FGuid> InternalScriptVarIds;
};

// Size: 0x20
struct FStaticSwitchTypeData {
    /* 0x0000 */ ENiagaraStaticSwitchType SwitchType;
    /* 0x0008 */ UEnum* Enum;
    /* 0x0010 */ FName SwitchConstant;
    /* 0x001c */ bool bAutoRefreshEnabled;
};

// Size: 0x60
class UUpgradeNiagaraScriptResults : public UObject {
    /* 0x0030 */ bool bCancelledByPythonError;
    /* 0x0038 */ TArray<UNiagaraPythonScriptModuleInput*> OldInputs;
    /* 0x0048 */ TArray<UNiagaraPythonScriptModuleInput*> NewInputs;
    /* 0x0058 */ UNiagaraPythonScriptModuleInput* DummyInput;

    UNiagaraPythonScriptModuleInput* GetOldInput(FString InputName);
    void SetBoolInput(FString InputName, bool Value);
    void SetColorInput(FString InputName, FLinearColor Value);
    void SetEnumInput(FString InputName, FString Value);
    void SetFloatInput(FString InputName, float Value);
    void SetIntInput(FString InputName, int32_t Value);
    void SetQuatInput(FString InputName, FQuat Value);
    void SetVec2Input(FString InputName, FVector2D Value);
    void SetVec3Input(FString InputName, FVector Value);
    void SetVec4Input(FString InputName, FVector4 Value);
};

enum class FNiagaraCompileEventSeverity {
    Log = 0,
    Warning = 1,
    Error = 2,
    FNiagaraCompileEventSeverity_MAX = 3,
};

// Size: 0x60
struct FNiagaraCompileEvent {
    /* 0x0000 */ FNiagaraCompileEventSeverity Severity;
    /* 0x0008 */ FString Message;
    /* 0x0018 */ FString ShortDescription;
    /* 0x0028 */ bool bDismissable;
    /* 0x002c */ FGuid NodeGuid;
    /* 0x003c */ FGuid PinGuid;
    /* 0x0050 */ TArray<FGuid> StackGuids;
};

// Size: 0x30
struct FNiagaraDataInterfaceGPUParamInfo {
    /* 0x0000 */ FString DataInterfaceHLSLSymbol;
    /* 0x0010 */ FString DIClassName;
    /* 0x0020 */ TArray<FNiagaraDataInterfaceGeneratedFunction> GeneratedFunctions;
};

// Size: 0x30
struct FNiagaraDataInterfaceGeneratedFunction {
};

// Size: 0x30
class UNiagaraScriptBase : public UObject {
};

// Size: 0x38
struct FSimulationStageMetaData {
    /* 0x0000 */ FName SimulationStageName;
    /* 0x000c */ FName IterationSource;
    /* 0x0018 */ bool bSpawnOnly;
    /* 0x0018 */ bool bWritesParticles;
    /* 0x0018 */ bool bPartialParticleUpdate;
    /* 0x0020 */ TArray<FName> OutputDestinations;
    /* 0x0030 */ int32_t MinStage;
    /* 0x0034 */ int32_t MaxStage;
};

// Size: 0x28
struct FAssetConfig {
    /* 0x0000 */ EOculusAssetType AssetType;
    /* 0x0001 */ bool required;
    /* 0x0008 */ FString Name;
    /* 0x0018 */ FString Sku;
};

// Size: 0x10
struct FAssetConfigArray {
    /* 0x0000 */ TArray<FAssetConfig> ConfigArray;
};

enum class EOculusAssetType {
    Default = 0,
    Store = 1,
    Language_Pack = 2,
    Length = 3,
    EOculusAssetType_MAX = 4,
};

enum class EOculusGamepadEmulation {
    Off = 0,
    Twinstick = 1,
    RightDPad = 2,
    LeftDPad = 3,
    Length = 4,
    EOculusGamepadEmulation_MAX = 5,
};

enum class EOculusPlatform {
    PC = 0,
    Mobile = 1,
    Length = 2,
    EOculusPlatform_MAX = 3,
};

enum class EOculusPlatformTarget {
    Rift = 0,
    Quest = 1,
    Length = 2,
    EOculusPlatformTarget_MAX = 3,
};

// Size: 0x88
class UOculusEditorSettings : public UObject {
    /* 0x0030 */ TMap<FName, bool> PerfToolIgnoreList;
    /* 0x0080 */ EOculusPlatform PerfToolTargetPlatform;
    /* 0x0081 */ bool bAddMenuOption;
};

// Size: 0x150
class UOculusPlatformToolSettings : public UObject {
    /* 0x0030 */ FString OculusRiftBuildDirectory;
    /* 0x0040 */ FString OculusRiftBuildVersion;
    /* 0x0050 */ FString OculusRiftLaunchParams;
    /* 0x0060 */ bool OculusRiftFireWallException;
    /* 0x0068 */ FString OculusRift2DLaunchPath;
    /* 0x0078 */ FString OculusRift2DLaunchParams;
    /* 0x0088 */ TArray<FRedistPackage> OculusRedistPackages;
    /* 0x0098 */ bool UploadDebugSymbols;
    /* 0x0099 */ bool DebugSymbolsOnly;
    /* 0x00a0 */ FString BuildID;
    /* 0x00b0 */ EOculusPlatformTarget OculusTargetPlatform;
    /* 0x00b8 */ TArray<FString> OculusApplicationID;
    /* 0x00c8 */ TArray<FString> OculusApplicationToken;
    /* 0x00d8 */ TArray<FString> OculusReleaseChannel;
    /* 0x00e8 */ TArray<FString> OculusReleaseNote;
    /* 0x00f8 */ TArray<FString> OculusLaunchFilePath;
    /* 0x0108 */ EOculusGamepadEmulation OculusRiftGamepadEmulation;
    /* 0x0110 */ TArray<FString> OculusLanguagePacksPath;
    /* 0x0120 */ TArray<FString> OculusExpansionFilesPath;
    /* 0x0130 */ TArray<FString> OculusSymbolDirPath;
    /* 0x0140 */ TArray<FAssetConfigArray> OculusAssetConfigs;
};

// Size: 0x28
struct FRedistPackage {
    /* 0x0000 */ bool Included;
    /* 0x0008 */ FString Name;
    /* 0x0018 */ FString ID;
};

enum class EBoundaryType {
    Boundary_Outer = 0,
    Boundary_PlayArea = 1,
    Boundary_MAX = 2,
};

enum class EColorSpace {
    Unknown = 0,
    Unmanaged = 1,
    Rec_2020 = 2,
    Rec_709 = 3,
    Rift_CV1 = 4,
    Rift_S = 5,
    Quest = 6,
    P3 = 7,
    Adobe_RGB = 8,
    EColorSpace_MAX = 9,
};

enum class EFixedFoveatedRenderingLevel {
    FFR_Off = 0,
    FFR_Low = 1,
    FFR_Medium = 2,
    FFR_High = 3,
    FFR_HighTop = 4,
    FFR_MAX = 5,
};

enum class EHandTrackingSupport {
    ControllersOnly = 0,
    ControllersAndHands = 1,
    HandsOnly = 2,
    EHandTrackingSupport_MAX = 3,
};

enum class EOculusDeviceType {
    OculusMobile_Deprecated0 = 0,
    OculusQuest = 1,
    OculusQuest2 = 2,
    Rift = 100,
    Rift_S = 101,
    Quest_Link = 102,
    Quest2_Link = 103,
    OculusUnknown = 200,
    EOculusDeviceType_MAX = 201,
};

enum class ETrackedDeviceType {
    None = 0,
    HMD = 1,
    LTouch = 2,
    RTouch = 3,
    Touch = 4,
    DeviceObjectZero = 5,
    All = 6,
    ETrackedDeviceType_MAX = 7,
};

// Size: 0x20
struct FGuardianTestResult {
    /* 0x0000 */ bool IsTriggering;
    /* 0x0001 */ ETrackedDeviceType DeviceType;
    /* 0x0004 */ float ClosestDistance;
    /* 0x0008 */ FVector ClosestPoint;
    /* 0x0014 */ FVector ClosestPointNormal;
};

// Size: 0x48
struct FHmdUserProfile {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ FString Gender;
    /* 0x0020 */ float PlayerHeight;
    /* 0x0024 */ float EyeHeight;
    /* 0x0028 */ float IPD;
    /* 0x002c */ FVector2D NeckToEyeDistance;
    /* 0x0038 */ TArray<FHmdUserProfileField> ExtraFields;
};

// Size: 0x20
struct FHmdUserProfileField {
    /* 0x0000 */ FString FieldName;
    /* 0x0010 */ FString FieldValue;
};

// Size: 0x30
class UOculusFunctionLibrary : public UBlueprintFunctionLibrary {

    static void AddLoadingSplashScreen(UTexture2D* Texture, FVector TranslationInMeters, FRotator Rotation, FVector2D SizeInMeters, FRotator DeltaRotation, bool bClearBeforeAdd);
    static void ClearLoadingSplashScreens();
    static void EnableOrientationTracking(bool bOrientationTracking);
    static void EnablePositionTracking(bool bPositionTracking);
    static TArray<float> GetAvailableDisplayFrequencies();
    static void GetBaseRotationAndBaseOffsetInMeters(FRotator& OutRotation, FVector& OutBaseOffsetInMeters);
    static void GetBaseRotationAndPositionOffset(FRotator& OutRot, FVector& OutPosOffset);
    static float GetCurrentDisplayFrequency();
    static FString GetDeviceName();
    static EOculusDeviceType GetDeviceType();
    static EFixedFoveatedRenderingLevel GetFixedFoveatedRenderingLevel();
    static float GetGPUFrameTime();
    static void GetGPUUtilization(bool& IsGPUAvailable, float& GPUUtilization);
    static FVector GetGuardianDimensions(EBoundaryType BoundaryType);
    static TArray<FVector> GetGuardianPoints(EBoundaryType BoundaryType, bool UsePawnSpace);
    static EColorSpace GetHmdColorDesc();
    static FGuardianTestResult GetNodeGuardianIntersection(ETrackedDeviceType DeviceType, EBoundaryType BoundaryType);
    static FTransform GetPlayAreaTransform();
    static FGuardianTestResult GetPointGuardianIntersection(const FVector Point, EBoundaryType BoundaryType);
    static void GetPose(FRotator& DeviceRotation, FVector& DevicePosition, FVector& NeckPosition, bool bUseOrienationForPlayerCamera, bool bUsePositionForPlayerCamera, const FVector PositionScale);
    static void GetRawSensorData(FVector& AngularAcceleration, FVector& LinearAcceleration, FVector& AngularVelocity, FVector& LinearVelocity, float& TimeInSeconds, ETrackedDeviceType DeviceType);
    static bool GetSystemHmd3DofModeEnabled();
    static bool GetUserProfile(FHmdUserProfile& Profile);
    static bool HasInputFocus();
    static bool HasSystemOverlayPresent();
    static bool IsDeviceTracked(ETrackedDeviceType DeviceType);
    static bool IsGuardianConfigured();
    static bool IsGuardianDisplayed();
    static void SetBaseRotationAndBaseOffsetInMeters(FRotator Rotation, FVector BaseOffsetInMeters, uint8_t Options);
    static void SetBaseRotationAndPositionOffset(FRotator BaseRot, FVector PosOffset, uint8_t Options);
    static void SetCPUAndGPULevels(int32_t CPULevel, int32_t GPULevel);
    static void SetClientColorDesc(EColorSpace ColorSpace);
    static void SetColorScaleAndOffset(FLinearColor ColorScale, FLinearColor ColorOffset, bool bApplyToAllLayers);
    static void SetDisplayFrequency(float RequestedFrequency);
    static void SetFixedFoveatedRenderingLevel(EFixedFoveatedRenderingLevel Level, bool isDynamic);
    static void SetGuardianVisibility(bool GuardianVisible);
    static void SetPositionScale3D(FVector PosScale3D);
    static void SetReorientHMDOnControllerRecenter(bool recenterMode);
};

// Size: 0x70
class UOculusHMDRuntimeSettings : public UObject {
    /* 0x0030 */ bool bAutoEnabled;
    /* 0x0038 */ TArray<FOculusSplashDesc> SplashDescs;
    /* 0x0048 */ bool bEnableSpecificColorGamut;
    /* 0x0049 */ EColorSpace ColorSpace;
    /* 0x004a */ bool bSupportsDash;
    /* 0x004b */ bool bCompositesDepth;
    /* 0x004c */ bool bHQDistortion;
    /* 0x0050 */ float PixelDensityMin;
    /* 0x0054 */ float PixelDensityMax;
    /* 0x0058 */ int32_t CPULevel;
    /* 0x005c */ int32_t GPULevel;
    /* 0x0060 */ EFixedFoveatedRenderingLevel FFRLevel;
    /* 0x0061 */ bool FFRDynamic;
    /* 0x0062 */ bool bChromaCorrection;
    /* 0x0063 */ bool bRecenterHMDWithController;
    /* 0x0064 */ bool bFocusAware;
    /* 0x0065 */ bool bLateLatching;
    /* 0x0066 */ bool bRequiresSystemKeyboard;
    /* 0x0067 */ EHandTrackingSupport HandTrackingSupport;
    /* 0x0068 */ bool bPhaseSync;
};

// Size: 0x38
class UOculusResourceHolder : public UObject {
    /* 0x0030 */ UMaterial* PokeAHoleMaterial;
};

// Size: 0xa0
class UOculusSceneCaptureCubemap : public UObject {
    /* 0x0040 */ TArray<USceneCaptureComponent2D*> CaptureComponents;
};

// Size: 0xa0
struct FOculusSplashDesc {
    /* 0x0000 */ FSoftObjectPath TexturePath;
    /* 0x0020 */ FTransform TransformInMeters;
    /* 0x0050 */ FVector2D QuadSizeInMeters;
    /* 0x0060 */ FQuat DeltaRotation;
    /* 0x0070 */ FVector2D TextureOffset;
    /* 0x0078 */ FVector2D TextureScale;
    /* 0x0080 */ bool bNoAlphaChannel;
};

enum class EBone {
    Wrist_Root = 0,
    Hand_Start = 0,
    Forearm_Stub = 1,
    Thumb_0 = 2,
    Thumb_1 = 3,
    Thumb_2 = 4,
    Thumb_3 = 5,
    Index_1 = 6,
    Index_2 = 7,
    Index_3 = 8,
    Middle_1 = 9,
    Middle_2 = 10,
    Middle_3 = 11,
    Ring_1 = 12,
    Ring_2 = 13,
    Ring_3 = 14,
    Pinky_0 = 15,
    Pinky_1 = 16,
    Pinky_2 = 17,
    Pinky_3 = 18,
    Thumb_Tip = 19,
    Max_Skinnable = 19,
    Index_Tip = 20,
    Middle_Tip = 21,
    Ring_Tip = 22,
    Pinky_Tip = 23,
    Hand_End = 24,
    Bone_Max = 24,
    Invalid = 25,
    EBone_MAX = 26,
};

enum class EConfidenceBehavior {
    None = 0,
    HideActor = 1,
    EConfidenceBehavior_MAX = 2,
};

enum class EOculusHandType {
    None = 0,
    HandLeft = 1,
    HandRight = 2,
    EOculusHandType_MAX = 3,
};

enum class ESystemGestureBehavior {
    None = 0,
    SwapMaterial = 1,
    ESystemGestureBehavior_MAX = 2,
};

enum class ETrackingConfidence {
    Low = 0,
    High = 1,
    ETrackingConfidence_MAX = 2,
};

// Size: 0x10
struct FOculusCapsuleCollider {
    /* 0x0000 */ UCapsuleComponent* Capsule;
    /* 0x0008 */ EBone BoneId;
};

// Size: 0x960
class UOculusHandComponent : public UPoseableMeshComponent {
    /* 0x08c0 */ EOculusHandType SkeletonType;
    /* 0x08c1 */ EOculusHandType MeshType;
    /* 0x08c2 */ EConfidenceBehavior ConfidenceBehavior;
    /* 0x08c3 */ ESystemGestureBehavior SystemGestureBehavior;
    /* 0x08c8 */ UMaterialInterface* SystemGestureMaterial;
    /* 0x08d0 */ bool bInitializePhysics;
    /* 0x08d1 */ bool bUpdateHandScale;
    /* 0x08d8 */ UMaterialInterface* MaterialOverride;
    /* 0x08e0 */ TMap<EBone, FName> BoneNameMappings;
    /* 0x0930 */ TArray<FOculusCapsuleCollider> CollisionCapsules;
    /* 0x0940 */ bool bSkeletalMeshInitialized;
};

// Size: 0x30
class UOculusInputFunctionLibrary : public UBlueprintFunctionLibrary {

    static FString GetBoneName(EBone BoneId);
    static FQuat GetBoneRotation(const EOculusHandType DeviceHand, const EBone BoneId, const int32_t ControllerIndex);
    static EOculusHandType GetDominantHand(const int32_t ControllerIndex);
    static float GetHandScale(const EOculusHandType DeviceHand, const int32_t ControllerIndex);
    static bool GetHandSkeletalMesh(USkeletalMesh* HandSkeletalMesh, EOculusHandType SkeletonType, EOculusHandType MeshType, const float WorldToMeters);
    static FTransform GetPointerPose(const EOculusHandType DeviceHand, const int32_t ControllerIndex);
    static ETrackingConfidence GetTrackingConfidence(const EOculusHandType DeviceHand, const int32_t ControllerIndex);
    static TArray<FOculusCapsuleCollider> InitializeHandPhysics(EOculusHandType SkeletonType, USkinnedMeshComponent* HandComponent, const float WorldToMeters);
    static bool IsHandTrackingEnabled();
    static bool IsPointerPoseValid(const EOculusHandType DeviceHand, const int32_t ControllerIndex);
};

enum class EOculusMR_CameraDeviceEnum {
    CD_None = 0,
    CD_WebCamera0 = 1,
    CD_WebCamera1 = 2,
    CD_MAX = 3,
};

enum class EOculusMR_ClippingReference {
    CR_TrackingReference = 0,
    CR_Head = 1,
    CR_MAX = 2,
};

enum class EOculusMR_CompositionMethod {
    ExternalComposition = 0,
    DirectComposition = 1,
    EOculusMR_MAX = 2,
};

enum class EOculusMR_PostProcessEffects {
    PPE_Off = 0,
    PPE_On = 1,
    PPE_MAX = 2,
};

// Size: 0x30
class UOculusMRFunctionLibrary : public UBlueprintFunctionLibrary {

    static float GetMrcScalingFactor();
    static UOculusMR_Settings* GetOculusMRSettings();
    static USceneComponent* GetTrackingReferenceComponent();
    static bool IsMrcActive();
    static bool IsMrcEnabled();
    static bool SetMrcScalingFactor(float ScalingFactor);
    static bool SetTrackingReferenceComponent(USceneComponent* Component);
};

// Size: 0x400
class AOculusMR_CastingCameraActor : public ASceneCapture2D {
    /* 0x0310 */ UVRNotificationsComponent* VRNotificationComponent;
    /* 0x0318 */ UTexture2D* CameraColorTexture;
    /* 0x0320 */ UTexture2D* CameraDepthTexture;
    /* 0x0328 */ UOculusMR_PlaneMeshComponent* PlaneMeshComponent;
    /* 0x0330 */ UMaterial* ChromaKeyMaterial;
    /* 0x0338 */ UMaterial* OpaqueColoredMaterial;
    /* 0x0340 */ UMaterialInstanceDynamic* ChromaKeyMaterialInstance;
    /* 0x0348 */ UMaterialInstanceDynamic* CameraFrameMaterialInstance;
    /* 0x0350 */ UMaterialInstanceDynamic* BackdropMaterialInstance;
    /* 0x0358 */ UTexture2D* DefaultTexture_White;
    /* 0x03b8 */ TArray<UTextureRenderTarget2D*> BackgroundRenderTargets;
    /* 0x03c8 */ ASceneCapture2D* ForegroundCaptureActor;
    /* 0x03d0 */ TArray<UTextureRenderTarget2D*> ForegroundRenderTargets;
    /* 0x03e0 */ TArray<double> PoseTimes;
    /* 0x03f0 */ UOculusMR_Settings* MRSettings;
    /* 0x03f8 */ UOculusMR_State* MRState;
};

// Size: 0x520
class UOculusMR_PlaneMeshComponent : public UMeshComponent {

    void AddCustomMeshTriangles(const TArray<FOculusMR_PlaneMeshTriangle>& Triangles);
    void ClearCustomMeshTriangles();
    bool SetCustomMeshTriangles(const TArray<FOculusMR_PlaneMeshTriangle>& Triangles);
};

// Size: 0x3c
struct FOculusMR_PlaneMeshTriangle {
    /* 0x0000 */ FVector Vertex0;
    /* 0x000c */ FVector2D UV0;
    /* 0x0014 */ FVector Vertex1;
    /* 0x0020 */ FVector2D UV1;
    /* 0x0028 */ FVector Vertex2;
    /* 0x0034 */ FVector2D UV2;
};

// Size: 0xa0
class UOculusMR_Settings : public UObject {
    /* 0x0030 */ EOculusMR_ClippingReference ClippingReference;
    /* 0x0031 */ bool bUseTrackedCameraResolution;
    /* 0x0034 */ int32_t WidthPerView;
    /* 0x0038 */ int32_t HeightPerView;
    /* 0x003c */ float CastingLatency;
    /* 0x0040 */ FColor BackdropColor;
    /* 0x0044 */ float HandPoseStateLatency;
    /* 0x0048 */ FColor ChromaKeyColor;
    /* 0x004c */ float ChromaKeySimilarity;
    /* 0x0050 */ float ChromaKeySmoothRange;
    /* 0x0054 */ float ChromaKeySpillRange;
    /* 0x0058 */ EOculusMR_PostProcessEffects ExternalCompositionPostProcessEffects;
    /* 0x0059 */ bool bIsCasting;
    /* 0x005a */ EOculusMR_CompositionMethod CompositionMethod;
    /* 0x005b */ EOculusMR_CameraDeviceEnum CapturingCamera;

    void BindToTrackedCameraIndexIfAvailable(int32_t InTrackedCameraIndex);
    int32_t GetBindToTrackedCameraIndex();
    EOculusMR_CameraDeviceEnum GetCapturingCamera();
    EOculusMR_CompositionMethod GetCompositionMethod();
    bool GetIsCasting();
    void LoadFromIni();
    void SaveToIni() const;
    void SetCapturingCamera(EOculusMR_CameraDeviceEnum Val);
    void SetCompositionMethod(EOculusMR_CompositionMethod Val);
    void SetIsCasting(bool Val);
};

// Size: 0xc0
class UOculusMR_State : public UObject {
    /* 0x0030 */ FTrackedCamera TrackedCamera;
    /* 0x00a8 */ USceneComponent* TrackingReferenceComponent;
    /* 0x00b0 */ double ScalingFactor;
    /* 0x00bc */ bool ChangeCameraStateRequested;
    /* 0x00bd */ bool BindToTrackedCameraIndexRequested;
};

// Size: 0x78
struct FTrackedCamera {
    /* 0x0000 */ int32_t index;
    /* 0x0008 */ FString Name;
    /* 0x0018 */ double UpdateTime;
    /* 0x0020 */ float FieldOfView;
    /* 0x0024 */ int32_t SizeX;
    /* 0x0028 */ int32_t SizeY;
    /* 0x002c */ ETrackedDeviceType AttachedTrackedDevice;
    /* 0x0030 */ FRotator CalibratedRotation;
    /* 0x003c */ FVector CalibratedOffset;
    /* 0x0048 */ FRotator UserRotation;
    /* 0x0054 */ FVector UserOffset;
    /* 0x0060 */ FRotator RawRotation;
    /* 0x006c */ FVector RawOffset;
};

// Size: 0xf8
class UK2Node_InAppPurchase : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_InAppPurchase2 : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_InAppPurchaseQuery : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_InAppPurchaseQuery2 : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_InAppPurchaseQueryOwned2 : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_InAppPurchaseRestore : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_InAppPurchaseRestore2 : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_InAppPurchaseUnprocessed2 : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_LeaderboardFlush : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_LeaderboardQuery : public UK2Node_BaseAsyncTask {
};

enum class EInAppPurchaseState {
    Unknown = 0,
    Success = 1,
    Failed = 2,
    Cancelled = 3,
    Invalid = 4,
    NotAllowed = 5,
    Restored = 6,
    AlreadyOwned = 7,
    EInAppPurchaseState_MAX = 8,
};

enum class EMPMatchOutcome {
    None = 0,
    Quit = 1,
    Won = 2,
    Lost = 3,
    Tied = 4,
    TimeExpired = 5,
    First = 6,
    Second = 7,
    Third = 8,
    Fourth = 9,
    EMPMatchOutcome_MAX = 10,
};

// Size: 0xa8
struct FInAppPurchaseProductInfo {
    /* 0x0000 */ FString Identifier;
    /* 0x0010 */ FString TransactionIdentifier;
    /* 0x0020 */ FString DisplayName;
    /* 0x0030 */ FString DisplayDescription;
    /* 0x0040 */ FString DisplayPrice;
    /* 0x0050 */ float RawPrice;
    /* 0x0058 */ FString CurrencyCode;
    /* 0x0068 */ FString CurrencySymbol;
    /* 0x0078 */ FString DecimalSeparator;
    /* 0x0088 */ FString GroupingSeparator;
    /* 0x0098 */ FString ReceiptData;
};

// Size: 0x18
struct FInAppPurchaseProductRequest {
    /* 0x0000 */ FString ProductIdentifier;
    /* 0x0010 */ bool bIsConsumable;
};

// Size: 0x30
struct FInAppPurchaseRestoreInfo {
    /* 0x0000 */ FString Identifier;
    /* 0x0010 */ FString ReceiptData;
    /* 0x0020 */ FString TransactionIdentifier;
};

// Size: 0x18
struct FNamedInterface {
    /* 0x0000 */ FName InterfaceName;
    /* 0x0010 */ UObject* InterfaceObject;
};

// Size: 0x20
struct FNamedInterfaceDef {
    /* 0x0000 */ FName InterfaceName;
    /* 0x0010 */ FString InterfaceClassName;
};

// Size: 0x68
class UNamedInterfaces : public UObject {
    /* 0x0030 */ TArray<FNamedInterface> NamedInterfaces;
    /* 0x0040 */ TArray<FNamedInterfaceDef> NamedInterfaceDefs;
};

// Size: 0x30
class ITurnBasedMatchInterface : public UInterface {

    void OnMatchEnded(FString Match);
    void OnMatchReceivedTurn(FString Match, bool bDidBecomeActive);
};

// Size: 0x30
class UAchievementBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void GetCachedAchievementDescription(UObject* WorldContextObject, APlayerController* PlayerController, FName AchievementID, bool& bFoundID, FText& Title, FText& LockedDescription, FText& UnlockedDescription, bool& bHidden);
    static void GetCachedAchievementProgress(UObject* WorldContextObject, APlayerController* PlayerController, FName AchievementID, bool& bFoundID, float& Progress);
};

// Size: 0x70
class UAchievementQueryCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UAchievementQueryCallbackProxy* CacheAchievementDescriptions(UObject* WorldContextObject, APlayerController* PlayerController);
    static UAchievementQueryCallbackProxy* CacheAchievements(UObject* WorldContextObject, APlayerController* PlayerController);
};

// Size: 0x90
class UAchievementWriteCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UAchievementWriteCallbackProxy* WriteAchievementProgress(UObject* WorldContextObject, APlayerController* PlayerController, FName AchievementName, float Progress, int32_t UserTag);
};

// Size: 0x108
struct FBlueprintSessionResult {
};

// Size: 0x80
class UConnectionCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UConnectionCallbackProxy* ConnectToService(UObject* WorldContextObject, APlayerController* PlayerController);
};

// Size: 0xa0
class UCreateSessionCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UCreateSessionCallbackProxy* CreateSession(UObject* WorldContextObject, APlayerController* PlayerController, int32_t PublicConnections, bool bUseLAN);
};

// Size: 0x80
class UDestroySessionCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UDestroySessionCallbackProxy* DestroySession(UObject* WorldContextObject, APlayerController* PlayerController);
};

enum class EBeaconConnectionState {
    Invalid = 0,
    Closed = 1,
    Pending = 2,
    Open = 3,
    EBeaconConnectionState_MAX = 4,
};

enum class EClientRequestType {
    NonePending = 0,
    ExistingSessionReservation = 1,
    ReservationUpdate = 2,
    EmptyServerReservation = 3,
    Reconnect = 4,
    Abandon = 5,
    ReservationRemoveMembers = 6,
    AddOrUpdateReservation = 7,
    EClientRequestType_MAX = 8,
};

enum class EInAppPurchaseStatus {
    Invalid = 0,
    Failed = 1,
    Deferred = 2,
    Canceled = 3,
    Purchased = 4,
    Restored = 5,
    EInAppPurchaseStatus_MAX = 6,
};

enum class EOnlineProxyStoreOfferDiscountType {
    NotOnSale = 0,
    Percentage = 1,
    DiscountAmount = 2,
    PayAmount = 3,
    EOnlineProxyStoreOfferDiscountType_MAX = 4,
};

enum class EPartyReservationResult {
    NoResult = 0,
    RequestPending = 1,
    GeneralError = 2,
    PartyLimitReached = 3,
    IncorrectPlayerCount = 4,
    RequestTimedOut = 5,
    ReservationDuplicate = 6,
    ReservationNotFound = 7,
    ReservationAccepted = 8,
    ReservationDenied = 9,
    ReservationDenied_CrossPlayRestriction = 10,
    ReservationDenied_Banned = 11,
    ReservationRequestCanceled = 12,
    ReservationInvalid = 13,
    BadSessionId = 14,
    ReservationDenied_ContainsExistingPlayers = 15,
    EPartyReservationResult_MAX = 16,
};

enum class ESpectatorClientRequestType {
    NonePending = 0,
    ExistingSessionReservation = 1,
    ReservationUpdate = 2,
    EmptyServerReservation = 3,
    Reconnect = 4,
    Abandon = 5,
    ESpectatorClientRequestType_MAX = 6,
};

enum class ESpectatorReservationResult {
    NoResult = 0,
    RequestPending = 1,
    GeneralError = 2,
    SpectatorLimitReached = 3,
    IncorrectPlayerCount = 4,
    RequestTimedOut = 5,
    ReservationDuplicate = 6,
    ReservationNotFound = 7,
    ReservationAccepted = 8,
    ReservationDenied = 9,
    ReservationDenied_CrossPlayRestriction = 10,
    ReservationDenied_Banned = 11,
    ReservationRequestCanceled = 12,
    ReservationInvalid = 13,
    BadSessionId = 14,
    ReservationDenied_ContainsExistingPlayers = 15,
    ESpectatorReservationResult_MAX = 16,
};

// Size: 0x88
class UEndMatchCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UEndMatchCallbackProxy* EndMatch(UObject* WorldContextObject, APlayerController* PlayerController, TScriptInterface<ITurnBasedMatchInterface> MatchActor, FString MatchID, uint8_t LocalPlayerOutcome, uint8_t OtherPlayersOutcome);
};

// Size: 0x80
class UEndTurnCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UEndTurnCallbackProxy* EndTurn(UObject* WorldContextObject, APlayerController* PlayerController, FString MatchID, TScriptInterface<ITurnBasedMatchInterface> TurnBasedMatchInterface);
};

// Size: 0x98
class UFindSessionsCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UFindSessionsCallbackProxy* FindSessions(UObject* WorldContextObject, APlayerController* PlayerController, int32_t MaxResults, bool bUseLAN);
    static int32_t GetCurrentPlayers(const FBlueprintSessionResult& Result);
    static int32_t GetMaxPlayers(const FBlueprintSessionResult& Result);
    static int32_t GetPingInMs(const FBlueprintSessionResult& Result);
    static FString GetServerName(const FBlueprintSessionResult& Result);
};

// Size: 0x90
class UFindTurnBasedMatchCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UFindTurnBasedMatchCallbackProxy* FindTurnBasedMatch(UObject* WorldContextObject, APlayerController* PlayerController, TScriptInterface<ITurnBasedMatchInterface> MatchActor, int32_t MinPlayers, int32_t MaxPlayers, int32_t PlayerGroup, bool ShowExistingMatches);
};

// Size: 0x88
class UInAppPurchaseCallbackProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFailure;

    static UInAppPurchaseCallbackProxy* CreateProxyObjectForInAppPurchase(APlayerController* PlayerController, const FInAppPurchaseProductRequest& ProductRequest);
};

// Size: 0xb0
class UInAppPurchaseCallbackProxy2 : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFailure;

    static UInAppPurchaseCallbackProxy2* CreateProxyObjectForInAppPurchase(APlayerController* PlayerController, const FInAppPurchaseProductRequest2& ProductRequest);
    static UInAppPurchaseCallbackProxy2* CreateProxyObjectForInAppPurchaseQueryOwned(APlayerController* PlayerController);
    static UInAppPurchaseCallbackProxy2* CreateProxyObjectForInAppPurchaseUnprocessedPurchases(APlayerController* PlayerController);
};

// Size: 0xf8
struct FInAppPurchaseProductInfo2 {
    /* 0x0000 */ FString Identifier;
    /* 0x0010 */ FString TransactionIdentifier;
    /* 0x0020 */ FString DisplayName;
    /* 0x0030 */ FString DisplayDescription;
    /* 0x0040 */ FString DisplayPrice;
    /* 0x0050 */ float RawPrice;
    /* 0x0058 */ FString CurrencyCode;
    /* 0x0068 */ FString CurrencySymbol;
    /* 0x0078 */ FString DecimalSeparator;
    /* 0x0088 */ FString GroupingSeparator;
    /* 0x0098 */ FString ReceiptData;
    /* 0x00a8 */ TMap<FString, FString> DynamicFields;
};

// Size: 0x18
struct FInAppPurchaseProductRequest2 {
    /* 0x0000 */ FString ProductIdentifier;
    /* 0x0010 */ bool bIsConsumable;
};

// Size: 0x98
class UInAppPurchaseQueryCallbackProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFailure;

    static UInAppPurchaseQueryCallbackProxy* CreateProxyObjectForInAppPurchaseQuery(APlayerController* PlayerController, const TArray<FString>& ProductIdentifiers);
};

// Size: 0x70
class UInAppPurchaseQueryCallbackProxy2 : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFailure;

    static UInAppPurchaseQueryCallbackProxy2* CreateProxyObjectForInAppPurchaseQuery(APlayerController* PlayerController, const TArray<FString>& ProductIdentifiers);
};

// Size: 0x30
struct FInAppPurchaseReceiptInfo {
    /* 0x0000 */ FString ItemName;
    /* 0x0010 */ FString ItemId;
    /* 0x0020 */ FString ValidationInfo;
};

// Size: 0x30
struct FInAppPurchaseReceiptInfo2 {
    /* 0x0000 */ FString ItemName;
    /* 0x0010 */ FString ItemId;
    /* 0x0020 */ FString ValidationInfo;
};

// Size: 0x98
class UInAppPurchaseRestoreCallbackProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFailure;

    static UInAppPurchaseRestoreCallbackProxy* CreateProxyObjectForInAppPurchaseRestore(const TArray<FInAppPurchaseProductRequest>& ConsumableProductFlags, APlayerController* PlayerController);
};

// Size: 0xb0
class UInAppPurchaseRestoreCallbackProxy2 : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFailure;

    static UInAppPurchaseRestoreCallbackProxy2* CreateProxyObjectForInAppPurchaseRestore(const TArray<FInAppPurchaseProductRequest2>& ConsumableProductFlags, APlayerController* PlayerController);
};

// Size: 0x30
struct FInAppPurchaseRestoreInfo2 {
    /* 0x0000 */ FString ItemName;
    /* 0x0010 */ FString ItemId;
    /* 0x0020 */ FString ValidationInfo;
};

// Size: 0x1cd8
class UIpConnection : public UNetConnection {
    /* 0x1c88 */ float SocketErrorDisconnectDelay;
};

// Size: 0x838
class UIpNetDriver : public UNetDriver {
    /* 0x07c8 */ bool LogPortUnreach;
    /* 0x07c8 */ bool AllowPlayerPortUnreach;
    /* 0x07cc */ uint32_t MaxPortCountToTry;
    /* 0x07dc */ uint32_t ServerDesiredSocketReceiveBufferBytes;
    /* 0x07e0 */ uint32_t ServerDesiredSocketSendBufferBytes;
    /* 0x07e4 */ uint32_t ClientDesiredSocketReceiveBufferBytes;
    /* 0x07e8 */ uint32_t ClientDesiredSocketSendBufferBytes;
    /* 0x07f0 */ double MaxSecondsInReceive;
    /* 0x07f8 */ int32_t NbPacketsBetweenReceiveTimeTest;
    /* 0x07fc */ float ResolutionConnectionTimeout;
};

// Size: 0x188
class UJoinSessionCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UJoinSessionCallbackProxy* JoinSession(UObject* WorldContextObject, APlayerController* PlayerController, const FBlueprintSessionResult& SearchResult);
};

// Size: 0x30
class ULeaderboardBlueprintLibrary : public UBlueprintFunctionLibrary {

    static bool WriteLeaderboardInteger(APlayerController* PlayerController, FName StatName, int32_t StatValue);
};

// Size: 0x70
class ULeaderboardFlushCallbackProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFailure;

    static ULeaderboardFlushCallbackProxy* CreateProxyObjectForFlush(APlayerController* PlayerController, FName SessionName);
};

// Size: 0xa0
class ULeaderboardQueryCallbackProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0040 */ FMulticastInlineDelegate OnFailure;

    static ULeaderboardQueryCallbackProxy* CreateProxyObjectForIntQuery(APlayerController* PlayerController, FName StatName);
};

// Size: 0x70
class ULogoutCallbackProxy : public UBlueprintAsyncActionBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static ULogoutCallbackProxy* Logout(UObject* WorldContextObject, APlayerController* PlayerController);
};

// Size: 0x330
class AOnlineBeacon : public AActor {
    /* 0x0300 */ float BeaconConnectionInitialTimeout;
    /* 0x0304 */ float BeaconConnectionTimeout;
    /* 0x0308 */ UNetDriver* NetDriver;
};

// Size: 0x390
class AOnlineBeaconClient : public AOnlineBeacon {
    /* 0x0330 */ AOnlineBeaconHostObject* BeaconOwner;
    /* 0x0338 */ UNetConnection* BeaconConnection;
    /* 0x0340 */ EBeaconConnectionState ConnectionState;

    void ClientOnConnected();
};

// Size: 0x3e8
class AOnlineBeaconHost : public AOnlineBeacon {
    /* 0x0330 */ int32_t ListenPort;
    /* 0x0338 */ TArray<AOnlineBeaconClient*> ClientActors;
};

// Size: 0x320
class AOnlineBeaconHostObject : public AActor {
    /* 0x02f8 */ FString BeaconTypeName;
    /* 0x0308 */ UClass* ClientBeaconActorClass;
    /* 0x0310 */ TArray<AOnlineBeaconClient*> ClientActors;
};

// Size: 0x198
class UOnlineEngineInterfaceImpl : public UOnlineEngineInterface {
    /* 0x0030 */ TMap<FName, FName> MappedUniqueNetIdTypes;
    /* 0x0080 */ TArray<FName> CompatibleUniqueNetIdTypes;
    /* 0x0090 */ FName VoiceSubsystemNameOverride;
};

// Size: 0x78
class UOnlinePIESettings : public UDeveloperSettings {
    /* 0x0060 */ bool bOnlinePIEEnabled;
    /* 0x0068 */ TArray<FPIELoginSettingsInternal> Logins;
};

// Size: 0x110
struct FOnlineProxyStoreOffer {
    /* 0x0000 */ FString OfferId;
    /* 0x0010 */ FText Title;
    /* 0x0028 */ FText Description;
    /* 0x0040 */ FText LongDescription;
    /* 0x0058 */ FText RegularPriceText;
    /* 0x0070 */ int32_t RegularPrice;
    /* 0x0078 */ FText PriceText;
    /* 0x0090 */ int32_t NumericPrice;
    /* 0x0098 */ FString CurrencyCode;
    /* 0x00a8 */ FDateTime ReleaseDate;
    /* 0x00b0 */ FDateTime ExpirationDate;
    /* 0x00b8 */ EOnlineProxyStoreOfferDiscountType DiscountType;
    /* 0x00c0 */ TMap<FString, FString> DynamicFields;
};

// Size: 0x1d0
class UOnlineSessionClient : public UOnlineSession {
    /* 0x01c8 */ bool bIsFromInvite;
    /* 0x01c9 */ bool bHandlingDisconnect;
};

// Size: 0x40
struct FPIELoginSettingsInternal {
    /* 0x0000 */ FString ID;
    /* 0x0010 */ FString Token;
    /* 0x0020 */ FString Type;
    /* 0x0030 */ TArray<uint8_t> TokenBytes;
};

// Size: 0x450
class APartyBeaconClient : public AOnlineBeaconClient {
    /* 0x03c0 */ FString DestSessionId;
    /* 0x03d0 */ FPartyReservation PendingReservation;
    /* 0x0420 */ EClientRequestType RequestType;
    /* 0x0421 */ bool bPendingReservationSent;
    /* 0x0422 */ bool bCancelReservation;

    void ClientCancelReservationResponse(uint8_t ReservationResponse);
    void ClientReservationResponse(uint8_t ReservationResponse);
    void ClientSendReservationFull();
    void ClientSendReservationUpdates(int32_t NumRemainingReservations);
    void ServerAddOrUpdateReservationRequest(FString SessionId, const FPartyReservation Reservation);
    void ServerCancelReservationRequest(const FUniqueNetIdRepl PartyLeader);
    void ServerRemoveMemberFromReservationRequest(FString SessionId, const FPartyReservation ReservationUpdate);
    void ServerReservationRequest(FString SessionId, const FPartyReservation Reservation);
    void ServerUpdateReservationRequest(FString SessionId, const FPartyReservation ReservationUpdate);
};

// Size: 0x20
struct FPartyBeaconCrossplayPlatformMapping {
    /* 0x0000 */ FString PlatformName;
    /* 0x0010 */ FString PlatformType;
};

// Size: 0x398
class APartyBeaconHost : public AOnlineBeaconHostObject {
    /* 0x0320 */ UPartyBeaconState* State;
    /* 0x0388 */ bool bLogoutOnSessionTimeout;
    /* 0x038c */ float SessionTimeoutSecs;
    /* 0x0390 */ float TravelSessionTimeoutSecs;
};

// Size: 0xb0
class UPartyBeaconState : public UObject {
    /* 0x0030 */ FName SessionName;
    /* 0x003c */ int32_t NumConsumedReservations;
    /* 0x0040 */ int32_t MaxReservations;
    /* 0x0044 */ int32_t NumTeams;
    /* 0x0048 */ int32_t NumPlayersPerTeam;
    /* 0x004c */ FName TeamAssignmentMethod;
    /* 0x0058 */ int32_t ReservedHostTeamNum;
    /* 0x005c */ int32_t ForceTeamNum;
    /* 0x0060 */ bool bRestrictCrossConsole;
    /* 0x0068 */ TArray<FString> PlatformCrossplayRestrictions;
    /* 0x0078 */ TArray<FPartyBeaconCrossplayPlatformMapping> PlatformTypeMapping;
    /* 0x0088 */ bool bEnableRemovalRequests;
    /* 0x0090 */ TArray<FPartyReservation> Reservations;
};

// Size: 0x50
struct FPartyReservation {
    /* 0x0000 */ int32_t TeamNum;
    /* 0x0008 */ FUniqueNetIdRepl PartyLeader;
    /* 0x0030 */ TArray<FPlayerReservation> PartyMembers;
    /* 0x0040 */ TArray<FPlayerReservation> RemovedPartyMembers;
};

// Size: 0x50
struct FPlayerReservation {
    /* 0x0000 */ FUniqueNetIdRepl UniqueId;
    /* 0x0028 */ FString ValidationStr;
    /* 0x0038 */ FString Platform;
    /* 0x0048 */ bool bAllowCrossplay;
    /* 0x004c */ float ElapsedTime;
};

// Size: 0x80
class UQuitMatchCallbackProxy : public UOnlineBlueprintCallProxyBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UQuitMatchCallbackProxy* QuitMatch(UObject* WorldContextObject, APlayerController* PlayerController, FString MatchID, uint8_t Outcome, int32_t TurnTimeoutInSeconds);
};

// Size: 0x68
class UShowLoginUICallbackProxy : public UBlueprintAsyncActionBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFailure;

    static UShowLoginUICallbackProxy* ShowExternalLoginUI(UObject* WorldContextObject, APlayerController* InPlayerController);
};

// Size: 0x478
class ASpectatorBeaconClient : public AOnlineBeaconClient {
    /* 0x03c0 */ FString DestSessionId;
    /* 0x03d0 */ FSpectatorReservation PendingReservation;
    /* 0x0448 */ ESpectatorClientRequestType RequestType;
    /* 0x0449 */ bool bPendingReservationSent;
    /* 0x044a */ bool bCancelReservation;

    void ClientCancelReservationResponse(uint8_t ReservationResponse);
    void ClientReservationResponse(uint8_t ReservationResponse);
    void ClientSendReservationFull();
    void ClientSendReservationUpdates(int32_t NumRemainingReservations);
    void ServerCancelReservationRequest(const FUniqueNetIdRepl Spectator);
    void ServerReservationRequest(FString SessionId, const FSpectatorReservation Reservation);
};

// Size: 0x398
class ASpectatorBeaconHost : public AOnlineBeaconHostObject {
    /* 0x0320 */ USpectatorBeaconState* State;
    /* 0x0388 */ bool bLogoutOnSessionTimeout;
    /* 0x038c */ float SessionTimeoutSecs;
    /* 0x0390 */ float TravelSessionTimeoutSecs;
};

// Size: 0x68
class USpectatorBeaconState : public UObject {
    /* 0x0030 */ FName SessionName;
    /* 0x003c */ int32_t NumConsumedReservations;
    /* 0x0040 */ int32_t MaxReservations;
    /* 0x0044 */ bool bRestrictCrossConsole;
    /* 0x0048 */ TArray<FSpectatorReservation> Reservations;
};

// Size: 0x78
struct FSpectatorReservation {
    /* 0x0000 */ FUniqueNetIdRepl SpectatorId;
    /* 0x0028 */ FPlayerReservation Spectator;
};

// Size: 0x390
class ATestBeaconClient : public AOnlineBeaconClient {

    void ClientPing();
    void ServerPong();
};

// Size: 0x320
class ATestBeaconHost : public AOnlineBeaconHostObject {
};

// Size: 0x30
class UTurnBasedBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void GetIsMyTurn(UObject* WorldContextObject, APlayerController* PlayerController, FString MatchID, bool& bIsMyTurn);
    static void GetMyPlayerIndex(UObject* WorldContextObject, APlayerController* PlayerController, FString MatchID, int32_t& PlayerIndex);
    static void GetPlayerDisplayName(UObject* WorldContextObject, APlayerController* PlayerController, FString MatchID, int32_t PlayerIndex, FString& PlayerDisplayName);
    static void RegisterTurnBasedMatchInterfaceObject(UObject* WorldContextObject, APlayerController* PlayerController, UObject* Object);
};

// Size: 0x780
class UVoipListenerSynthComponent : public USynthComponent {

    bool IsIdling();
};

enum class EOodleEnableMode {
    AlwaysEnabled = 0,
    WhenCompressedPacketReceived = 1,
    EOodleEnableMode_MAX = 2,
};

// Size: 0xa8
class UOodleNetworkTrainerCommandlet : public UCommandlet {
    /* 0x0088 */ bool bCompressionTest;
    /* 0x008c */ int32_t HashTableSize;
    /* 0x0090 */ int32_t DictionarySize;
    /* 0x0094 */ int32_t DictionaryTrials;
    /* 0x0098 */ int32_t TrialRandomness;
    /* 0x009c */ int32_t TrialGenerations;
    /* 0x00a0 */ bool bNoTrials;
};

enum class EQuatSwizzleAxisB {
    X = 0,
    Y = 1,
    Z = 2,
    W = 3,
    MinusX = 4,
    MinusY = 5,
    MinusZ = 6,
    MinusW = 7,
    EQuatSwizzleAxisB_MAX = 8,
};

// Size: 0x40
class ULiveLinkOpenXRHandTrackingSourceFactory : public ULiveLinkSourceFactory {
};

// Size: 0x88
class UOpenXRHandTrackingLiveLinkRemapAsset : public ULiveLinkRetargetAsset {
    /* 0x0030 */ bool bHasMetacarpals;
    /* 0x0031 */ bool bRetargetRotationOnly;
    /* 0x0032 */ EQuatSwizzleAxisB SwizzleX;
    /* 0x0033 */ EQuatSwizzleAxisB SwizzleY;
    /* 0x0034 */ EQuatSwizzleAxisB SwizzleZ;
    /* 0x0035 */ EQuatSwizzleAxisB SwizzleW;
    /* 0x0038 */ TMap<FName, FName> HandTrackingBoneNameMap;
};

// Size: 0x48
class UBasicOverlays : public UOverlays {
    /* 0x0030 */ TArray<FOverlayItem> Overlays;
    /* 0x0040 */ UAssetImportData* AssetImportData;
};

// Size: 0x90
class ULocalizedOverlays : public UOverlays {
    /* 0x0030 */ UBasicOverlays* DefaultOverlays;
    /* 0x0038 */ TMap<FString, UBasicOverlays*> LocaleToOverlaysMap;
    /* 0x0088 */ UAssetImportData* AssetImportData;
};

// Size: 0x28
struct FOverlayItem {
    /* 0x0000 */ FTimespan StartTime;
    /* 0x0008 */ FTimespan EndTime;
    /* 0x0010 */ FString text;
    /* 0x0020 */ FVector2D Position;
};

// Size: 0x30
class UOverlays : public UObject {
};

// Size: 0x88
class UBasicOverlaysFactory : public UFactory {
};

// Size: 0x88
class UBasicOverlaysFactoryNew : public UFactory {
};

// Size: 0x88
class ULocalizedOverlaysFactoryNew : public UFactory {
};

// Size: 0xa8
class UReimportBasicOverlaysFactory : public UBasicOverlaysFactory {
};

// Size: 0x40
class UPIEPreviewSettings : public UObject {
    /* 0x0030 */ int32_t WindowPosX;
    /* 0x0034 */ int32_t WindowPosY;
    /* 0x0038 */ float WindowScalingFactor;
};

// Size: 0xc08
struct FPIEPreviewWindowStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FButtonStyle ScreenRotationButtonStyle;
    /* 0x0308 */ FButtonStyle QuarterMobileContentScaleFactorButtonStyle;
    /* 0x0608 */ FButtonStyle HalfMobileContentScaleFactorButtonStyle;
    /* 0x0908 */ FButtonStyle FullMobileContentScaleFactorButtonStyle;
};

enum class EPIEPreviewDeviceType {
    Unset = 0,
    Android = 1,
    IOS = 2,
    TVOS = 3,
    Switch = 4,
    MAX = 5,
};

// Size: 0xb0
struct FPIEAndroidDeviceProperties {
    /* 0x0000 */ FString GPUFamily;
    /* 0x0010 */ FString GLVersion;
    /* 0x0020 */ FString VulkanVersion;
    /* 0x0030 */ FString AndroidVersion;
    /* 0x0040 */ FString DeviceMake;
    /* 0x0050 */ FString DeviceModel;
    /* 0x0060 */ FString DeviceBuildNumber;
    /* 0x0070 */ bool VulkanAvailable;
    /* 0x0071 */ bool UsingHoudini;
    /* 0x0078 */ FString Hardware;
    /* 0x0088 */ FString Chipset;
    /* 0x0098 */ FPIERHIOverrideState GLES31RHIState;
};

// Size: 0x20
struct FPIEBezelProperties {
    /* 0x0000 */ FString DeviceBezelFile;
    /* 0x0010 */ FPIEPreviewDeviceBezelViewportRect BezelViewportRect;
};

// Size: 0x28
struct FPIEIOSDeviceProperties {
    /* 0x0000 */ FString DeviceModel;
    /* 0x0010 */ float NativeScaleFactor;
    /* 0x0014 */ FPIERHIOverrideState MetalRHIState;
};

// Size: 0x10
struct FPIEPreviewDeviceBezelViewportRect {
    /* 0x0000 */ int32_t X;
    /* 0x0004 */ int32_t Y;
    /* 0x0008 */ int32_t Width;
    /* 0x000c */ int32_t Height;
};

// Size: 0xd0
class UPIEPreviewDeviceSpecification : public UObject {
    /* 0x0030 */ EPIEPreviewDeviceType PreviewDeviceType;
    /* 0x0038 */ FString GPUFamily;
    /* 0x0048 */ FString GLVersion;
    /* 0x0058 */ FString VulkanVersion;
    /* 0x0068 */ FString AndroidVersion;
    /* 0x0078 */ FString DeviceMake;
    /* 0x0088 */ FString DeviceModel;
    /* 0x0098 */ FString DeviceBuildNumber;
    /* 0x00a8 */ bool UsingHoudini;
    /* 0x00b0 */ FString Hardware;
    /* 0x00c0 */ FString Chipset;
};

// Size: 0x128
struct FPIEPreviewDeviceSpecifications {
    /* 0x0000 */ EPIEPreviewDeviceType DevicePlatform;
    /* 0x0004 */ int32_t ResolutionX;
    /* 0x0008 */ int32_t ResolutionY;
    /* 0x000c */ int32_t ResolutionYImmersiveMode;
    /* 0x0010 */ int32_t PPI;
    /* 0x0018 */ TArray<float> ScaleFactors;
    /* 0x0028 */ FPIEBezelProperties BezelProperties;
    /* 0x0048 */ FPIEAndroidDeviceProperties AndroidProperties;
    /* 0x00f8 */ FPIEIOSDeviceProperties IOSProperties;
    /* 0x0120 */ FPIESwitchDeviceProperties SwitchProperties;
};

// Size: 0x14
struct FPIERHIOverrideState {
    /* 0x0000 */ int32_t MaxShadowDepthBufferSizeX;
    /* 0x0004 */ int32_t MaxShadowDepthBufferSizeY;
    /* 0x0008 */ int32_t MaxTextureDimensions;
    /* 0x000c */ int32_t MaxCubeTextureDimensions;
    /* 0x0010 */ bool SupportsRenderTargetFormat_PF_G8;
    /* 0x0011 */ bool SupportsRenderTargetFormat_PF_FloatRGBA;
    /* 0x0012 */ bool SupportsMultipleRenderTargets;
};

// Size: 0x1
struct FPIESwitchDeviceProperties {
    /* 0x0000 */ bool Docked;
};

// Size: 0x30
class UHandlerComponentFactory : public UObject {
};

// Size: 0x40
class UPacketHandlerProfileConfig : public UObject {
    /* 0x0030 */ TArray<FString> Components;
};

enum class EFlipbookCollisionMode {
    NoCollision = 0,
    FirstFrameCollision = 1,
    EachFrameCollision = 2,
    EFlipbookCollisionMode_MAX = 3,
};

enum class EPaperSpriteAtlasPadding {
    DilateBorder = 0,
    PadWithZero = 1,
    EPaperSpriteAtlasPadding_MAX = 2,
};

enum class ESpriteCollisionMode {
    None = 0,
    Use2DPhysics = 1,
    Use3DPhysics = 2,
    ESpriteCollisionMode_MAX = 3,
};

enum class ESpritePivotMode {
    Top_Left = 0,
    Top_Center = 1,
    Top_Right = 2,
    Center_Left = 3,
    Center_Center = 4,
    Center_Right = 5,
    Bottom_Left = 6,
    Bottom_Center = 7,
    Bottom_Right = 8,
    Custom = 9,
    ESpritePivotMode_MAX = 10,
};

enum class ESpritePolygonMode {
    SourceBoundingBox = 0,
    TightBoundingBox = 1,
    ShrinkWrapped = 2,
    FullyCustom = 3,
    Diced = 4,
    ESpritePolygonMode_MAX = 5,
};

enum class ESpriteShapeType {
    Box = 0,
    Circle = 1,
    Polygon = 2,
    ESpriteShapeType_MAX = 3,
};

enum class ETileMapProjectionMode {
    Orthogonal = 0,
    IsometricDiamond = 1,
    IsometricStaggered = 2,
    HexagonalStaggered = 3,
    ETileMapProjectionMode_MAX = 4,
};

// Size: 0x10
struct FIntMargin {
    /* 0x0000 */ int32_t Left;
    /* 0x0004 */ int32_t Top;
    /* 0x0008 */ int32_t Right;
    /* 0x000c */ int32_t Bottom;
};

// Size: 0x2c8
class UMaterialExpressionSpriteTextureSampler : public UMaterialExpressionTextureSampleParameter2D {
    /* 0x02a8 */ bool bSampleAdditionalTextures;
    /* 0x02ac */ int32_t AdditionalSlotIndex;
    /* 0x02b0 */ FText SlotDisplayName;
};

// Size: 0x5a0
class APaperCharacter : public ACharacter {
    /* 0x0598 */ UPaperFlipbookComponent* Sprite;
};

// Size: 0x58
class UPaperFlipbook : public UObject {
    /* 0x0030 */ float FramesPerSecond;
    /* 0x0038 */ TArray<FPaperFlipbookKeyFrame> KeyFrames;
    /* 0x0048 */ UMaterialInterface* DefaultMaterial;
    /* 0x0050 */ uint8_t CollisionSource;

    int32_t GetKeyFrameIndexAtTime(float Time, bool bClampToEnds) const;
    int32_t GetNumFrames() const;
    int32_t GetNumKeyFrames() const;
    UPaperSprite* GetSpriteAtFrame(int32_t FrameIndex) const;
    UPaperSprite* GetSpriteAtTime(float Time, bool bClampToEnds) const;
    float GetTotalDuration() const;
    bool IsValidKeyFrameIndex(int32_t index) const;
};

// Size: 0x300
class APaperFlipbookActor : public AActor {
    /* 0x02f8 */ UPaperFlipbookComponent* RenderComponent;
};

// Size: 0x550
class UPaperFlipbookComponent : public UMeshComponent {
    /* 0x0500 */ UPaperFlipbook* SourceFlipbook;
    /* 0x0508 */ UMaterialInterface* Material;
    /* 0x0510 */ float PlayRate;
    /* 0x0514 */ bool bLooping;
    /* 0x0514 */ bool bReversePlayback;
    /* 0x0514 */ bool bPlaying;
    /* 0x0518 */ float AccumulatedTime;
    /* 0x051c */ int32_t CachedFrameIndex;
    /* 0x0520 */ FLinearColor SpriteColor;
    /* 0x0530 */ UBodySetup* CachedBodySetup;
    /* 0x0538 */ FMulticastInlineDelegate OnFinishedPlaying;

    UPaperFlipbook* GetFlipbook();
    float GetFlipbookFramerate() const;
    float GetFlipbookLength() const;
    int32_t GetFlipbookLengthInFrames() const;
    float GetPlayRate() const;
    float GetPlaybackPosition() const;
    int32_t GetPlaybackPositionInFrames() const;
    FLinearColor GetSpriteColor() const;
    bool IsLooping() const;
    bool IsPlaying() const;
    bool IsReversing() const;
    void OnRep_SourceFlipbook(UPaperFlipbook* OldFlipbook);
    void Play();
    void PlayFromStart();
    void Reverse();
    void ReverseFromEnd();
    bool SetFlipbook(UPaperFlipbook* NewFlipbook);
    void SetLooping(bool bNewLooping);
    void SetNewTime(float NewTime);
    void SetPlayRate(float NewRate);
    void SetPlaybackPosition(float NewPosition, bool bFireEvents);
    void SetPlaybackPositionInFrames(int32_t NewFramePosition, bool bFireEvents);
    void SetSpriteColor(FLinearColor NewColor);
    void Stop();
};

// Size: 0x10
struct FPaperFlipbookKeyFrame {
    /* 0x0000 */ UPaperSprite* Sprite;
    /* 0x0008 */ int32_t FrameRun;
};

// Size: 0x300
class APaperGroupedSpriteActor : public AActor {
    /* 0x02f8 */ UPaperGroupedSpriteComponent* RenderComponent;
};

// Size: 0x530
class UPaperGroupedSpriteComponent : public UMeshComponent {
    /* 0x0500 */ TArray<UMaterialInterface*> InstanceMaterials;
    /* 0x0510 */ TArray<FSpriteInstanceData> PerInstanceSpriteData;

    int32_t AddInstance(const FTransform& Transform, UPaperSprite* Sprite, bool bWorldSpace, FLinearColor Color);
    void ClearInstances();
    int32_t GetInstanceCount() const;
    bool GetInstanceTransform(int32_t InstanceIndex, FTransform& OutInstanceTransform, bool bWorldSpace) const;
    bool RemoveInstance(int32_t InstanceIndex);
    void SortInstancesAlongAxis(FVector WorldSpaceSortAxis);
    bool UpdateInstanceColor(int32_t InstanceIndex, FLinearColor NewInstanceColor, bool bMarkRenderStateDirty);
    bool UpdateInstanceTransform(int32_t InstanceIndex, const FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
};

// Size: 0x38
class UPaperRuntimeSettings : public UObject {
    /* 0x0030 */ bool bEnableSpriteAtlasGroups;
    /* 0x0031 */ bool bEnableTerrainSplineEditing;
    /* 0x0032 */ bool bResizeSpriteDataToMatchTextures;
};

// Size: 0x1c8
class UPaperSprite : public UObject {
    /* 0x0040 */ FVector2D OriginInSourceImageBeforeTrimming;
    /* 0x0048 */ FVector2D SourceImageDimensionBeforeTrimming;
    /* 0x0050 */ bool bTrimmedInSourceImage;
    /* 0x0051 */ bool bRotatedInSourceImage;
    /* 0x0054 */ FVector2D SourceTextureDimension;
    /* 0x005c */ FVector2D SourceUV;
    /* 0x0064 */ FVector2D SourceDimension;
    /* 0x0070 */ TSoftObjectPtr<UTexture2D> SourceTexture;
    /* 0x00a0 */ UTexture2D* SourceTextureCacheNeverSerialized;
    /* 0x00a8 */ TArray<UTexture*> AdditionalSourceTextures;
    /* 0x00b8 */ FVector2D BakedSourceUV;
    /* 0x00c0 */ FVector2D BakedSourceDimension;
    /* 0x00c8 */ UTexture2D* BakedSourceTexture;
    /* 0x00d0 */ UMaterialInterface* DefaultMaterial;
    /* 0x00d8 */ UMaterialInterface* AlternateMaterial;
    /* 0x00e0 */ TArray<FPaperSpriteSocket> Sockets;
    /* 0x00f0 */ uint8_t SpriteCollisionDomain;
    /* 0x00f4 */ float PixelsPerUnrealUnit;
    /* 0x00f8 */ UBodySetup* BodySetup;
    /* 0x0100 */ uint8_t PivotMode;
    /* 0x0104 */ FVector2D CustomPivotPoint;
    /* 0x010c */ bool bSnapPivotToPixelGrid;
    /* 0x0110 */ FSpriteGeometryCollection CollisionGeometry;
    /* 0x0140 */ float CollisionThickness;
    /* 0x0148 */ FSpriteGeometryCollection RenderGeometry;
    /* 0x0178 */ UPaperSpriteAtlas* AtlasGroup;
    /* 0x01b0 */ int32_t AlternateMaterialSplitIndex;
    /* 0x01b8 */ TArray<FVector4> BakedRenderData;
};

// Size: 0x300
class APaperSpriteActor : public AActor {
    /* 0x02f8 */ UPaperSpriteComponent* RenderComponent;
};

// Size: 0xa0
class UPaperSpriteAtlas : public UObject {
    /* 0x0030 */ FString AtlasDescription;
    /* 0x0040 */ int32_t MaxWidth;
    /* 0x0044 */ int32_t MaxHeight;
    /* 0x0048 */ int32_t MipCount;
    /* 0x004c */ EPaperSpriteAtlasPadding PaddingType;
    /* 0x0050 */ int32_t Padding;
    /* 0x0054 */ uint8_t CompressionSettings;
    /* 0x0055 */ uint8_t Filter;
    /* 0x0058 */ TArray<UTexture*> GeneratedTextures;
    /* 0x0068 */ FGuid AtlasGUID;
    /* 0x0078 */ bool bRebuildAtlas;
    /* 0x0080 */ TArray<FPaperSpriteAtlasSlot> AtlasSlots;
    /* 0x0090 */ int32_t NumIncrementalBuilds;
    /* 0x0094 */ int32_t BuiltWidth;
    /* 0x0098 */ int32_t BuiltHeight;
    /* 0x009c */ int32_t BuiltPadding;
};

// Size: 0x48
struct FPaperSpriteAtlasSlot {
    /* 0x0000 */ TSoftObjectPtr<UPaperSprite> SpriteRef;
    /* 0x0030 */ int32_t AtlasIndex;
    /* 0x0034 */ int32_t X;
    /* 0x0038 */ int32_t Y;
    /* 0x003c */ int32_t Width;
    /* 0x0040 */ int32_t Height;
};

// Size: 0x30
class UPaperSpriteBlueprintLibrary : public UBlueprintFunctionLibrary {

    static FSlateBrush MakeBrushFromSprite(UPaperSprite* Sprite, int32_t Width, int32_t Height);
};

// Size: 0x520
class UPaperSpriteComponent : public UMeshComponent {
    /* 0x0500 */ UPaperSprite* SourceSprite;
    /* 0x0508 */ UMaterialInterface* MaterialOverride;
    /* 0x0510 */ FLinearColor SpriteColor;

    UPaperSprite* GetSprite();
    bool SetSprite(UPaperSprite* NewSprite);
    void SetSpriteColor(FLinearColor NewColor);
};

// Size: 0x40
struct FPaperSpriteSocket {
    /* 0x0000 */ FTransform LocalTransform;
    /* 0x0030 */ FName SocketName;
};

// Size: 0x310
class APaperTerrainActor : public AActor {
    /* 0x02f8 */ USceneComponent* DummyRoot;
    /* 0x0300 */ UPaperTerrainSplineComponent* SplineComponent;
    /* 0x0308 */ UPaperTerrainComponent* RenderComponent;
};

// Size: 0x530
class UPaperTerrainComponent : public UPrimitiveComponent {
    /* 0x04d8 */ UPaperTerrainMaterial* TerrainMaterial;
    /* 0x04e0 */ bool bClosedSpline;
    /* 0x04e1 */ bool bFilledSpline;
    /* 0x04e8 */ UPaperTerrainSplineComponent* AssociatedSpline;
    /* 0x04f0 */ int32_t RandomSeed;
    /* 0x04f4 */ float SegmentOverlapAmount;
    /* 0x04f8 */ FLinearColor TerrainColor;
    /* 0x0508 */ int32_t ReparamStepsPerSegment;
    /* 0x050c */ uint8_t SpriteCollisionDomain;
    /* 0x0510 */ float CollisionThickness;
    /* 0x0518 */ UBodySetup* CachedBodySetup;

    void SetTerrainColor(FLinearColor NewColor);
};

// Size: 0x50
class UPaperTerrainMaterial : public UDataAsset {
    /* 0x0038 */ TArray<FPaperTerrainMaterialRule> Rules;
    /* 0x0048 */ UPaperSprite* InteriorFill;
};

// Size: 0x50
struct FPaperTerrainMaterialRule {
    /* 0x0000 */ UPaperSprite* StartCap;
    /* 0x0008 */ TArray<UPaperSprite*> Body;
    /* 0x0018 */ UPaperSprite* EndCap;
    /* 0x0020 */ float MinimumAngle;
    /* 0x0024 */ float MaximumAngle;
    /* 0x0028 */ bool bEnableCollision;
    /* 0x002c */ float CollisionOffset;
    /* 0x0030 */ int32_t DrawOrder;
    /* 0x0038 */ FText Description;
};

// Size: 0x620
class UPaperTerrainSplineComponent : public USplineComponent {
};

// Size: 0x10
struct FPaperTileInfo {
    /* 0x0000 */ UPaperTileSet* TileSet;
    /* 0x0008 */ int32_t PackedTileIndex;
};

// Size: 0xa0
class UPaperTileLayer : public UObject {
    /* 0x0030 */ FText LayerName;
    /* 0x0048 */ int32_t LayerWidth;
    /* 0x004c */ int32_t LayerHeight;
    /* 0x0050 */ bool bHiddenInEditor;
    /* 0x0050 */ bool bHiddenInGame;
    /* 0x0050 */ bool bLayerCollides;
    /* 0x0050 */ bool bOverrideCollisionThickness;
    /* 0x0050 */ bool bOverrideCollisionOffset;
    /* 0x0054 */ float CollisionThicknessOverride;
    /* 0x0058 */ float CollisionOffsetOverride;
    /* 0x005c */ FLinearColor LayerColor;
    /* 0x006c */ int32_t AllocatedWidth;
    /* 0x0070 */ int32_t AllocatedHeight;
    /* 0x0078 */ TArray<FPaperTileInfo> AllocatedCells;
    /* 0x0088 */ UPaperTileSet* TileSet;
    /* 0x0090 */ TArray<int32_t> AllocatedGrid;
};

// Size: 0x110
class UPaperTileMap : public UObject {
    /* 0x0030 */ int32_t MapWidth;
    /* 0x0034 */ int32_t MapHeight;
    /* 0x0038 */ int32_t TileWidth;
    /* 0x003c */ int32_t TileHeight;
    /* 0x0040 */ float PixelsPerUnrealUnit;
    /* 0x0044 */ float SeparationPerTileX;
    /* 0x0048 */ float SeparationPerTileY;
    /* 0x004c */ float SeparationPerLayer;
    /* 0x0050 */ TSoftObjectPtr<UPaperTileSet> SelectedTileSet;
    /* 0x0080 */ UMaterialInterface* Material;
    /* 0x0088 */ TArray<UPaperTileLayer*> TileLayers;
    /* 0x0098 */ float CollisionThickness;
    /* 0x009c */ uint8_t SpriteCollisionDomain;
    /* 0x009d */ uint8_t ProjectionMode;
    /* 0x00a0 */ int32_t HexSideLength;
    /* 0x00a8 */ UBodySetup* BodySetup;
    /* 0x00b0 */ UAssetImportData* AssetImportData;
    /* 0x00b8 */ int32_t SelectedLayerIndex;
    /* 0x00bc */ FLinearColor BackgroundColor;
    /* 0x00cc */ FLinearColor TileGridColor;
    /* 0x00dc */ FLinearColor MultiTileGridColor;
    /* 0x00ec */ int32_t MultiTileGridWidth;
    /* 0x00f0 */ int32_t MultiTileGridHeight;
    /* 0x00f4 */ int32_t MultiTileGridOffsetX;
    /* 0x00f8 */ int32_t MultiTileGridOffsetY;
    /* 0x00fc */ FLinearColor LayerGridColor;
    /* 0x010c */ int32_t LayerNameIndex;
};

// Size: 0x300
class APaperTileMapActor : public AActor {
    /* 0x02f8 */ UPaperTileMapComponent* RenderComponent;
};

// Size: 0x560
class UPaperTileMapComponent : public UMeshComponent {
    /* 0x0500 */ int32_t MapWidth;
    /* 0x0504 */ int32_t MapHeight;
    /* 0x0508 */ int32_t TileWidth;
    /* 0x050c */ int32_t TileHeight;
    /* 0x0510 */ UPaperTileSet* DefaultLayerTileSet;
    /* 0x0518 */ UMaterialInterface* Material;
    /* 0x0520 */ TArray<UPaperTileLayer*> TileLayers;
    /* 0x0530 */ FLinearColor TileMapColor;
    /* 0x0540 */ int32_t UseSingleLayerIndex;
    /* 0x0544 */ bool bUseSingleLayer;
    /* 0x0550 */ UPaperTileMap* TileMap;
    /* 0x0558 */ bool bShowPerTileGridWhenSelected;
    /* 0x0559 */ bool bShowPerLayerGridWhenSelected;
    /* 0x055a */ bool bShowOutlineWhenUnselected;
    /* 0x055b */ bool bShowPerTileGridWhenUnselected;
    /* 0x055c */ bool bShowPerLayerGridWhenUnselected;

    UPaperTileLayer* AddNewLayer();
    void CreateNewTileMap(int32_t MapWidth, int32_t MapHeight, int32_t TileWidth, int32_t TileHeight, float PixelsPerUnrealUnit, bool bCreateLayer);
    FLinearColor GetLayerColor(int32_t Layer) const;
    void GetMapSize(int32_t& MapWidth, int32_t& MapHeight, int32_t& NumLayers);
    FPaperTileInfo GetTile(int32_t X, int32_t Y, int32_t Layer) const;
    FVector GetTileCenterPosition(int32_t TileX, int32_t TileY, int32_t LayerIndex, bool bWorldSpace) const;
    FVector GetTileCornerPosition(int32_t TileX, int32_t TileY, int32_t LayerIndex, bool bWorldSpace) const;
    FLinearColor GetTileMapColor() const;
    void GetTilePolygon(int32_t TileX, int32_t TileY, TArray<FVector>& Points, int32_t LayerIndex, bool bWorldSpace) const;
    void MakeTileMapEditable();
    bool OwnsTileMap() const;
    void RebuildCollision();
    void ResizeMap(int32_t NewWidthInTiles, int32_t NewHeightInTiles);
    void SetDefaultCollisionThickness(float Thickness, bool bRebuildCollision);
    void SetLayerCollision(int32_t Layer, bool bHasCollision, bool bOverrideThickness, float CustomThickness, bool bOverrideOffset, float CustomOffset, bool bRebuildCollision);
    void SetLayerColor(FLinearColor NewColor, int32_t Layer);
    void SetTile(int32_t X, int32_t Y, int32_t Layer, FPaperTileInfo NewValue);
    bool SetTileMap(UPaperTileMap* NewTileMap);
    void SetTileMapColor(FLinearColor NewColor);
};

// Size: 0x48
struct FPaperTileMetadata {
    /* 0x0000 */ FName UserDataName;
    /* 0x0010 */ FSpriteGeometryCollection CollisionData;
    /* 0x0040 */ uint8_t TerrainMembership[4];
};

// Size: 0xc0
class UPaperTileSet : public UObject {
    /* 0x0030 */ FIntPoint TileSize;
    /* 0x0038 */ UTexture2D* TileSheet;
    /* 0x0040 */ TArray<UTexture*> AdditionalSourceTextures;
    /* 0x0050 */ FIntMargin BorderMargin;
    /* 0x0060 */ FIntPoint PerTileSpacing;
    /* 0x0068 */ FIntPoint DrawingOffset;
    /* 0x0070 */ FLinearColor BackgroundColor;
    /* 0x0080 */ int32_t WidthInTiles;
    /* 0x0084 */ int32_t HeightInTiles;
    /* 0x0088 */ int32_t AllocatedWidth;
    /* 0x008c */ int32_t AllocatedHeight;
    /* 0x0090 */ TArray<FPaperTileMetadata> PerTileData;
    /* 0x00a0 */ TArray<FPaperTileSetTerrain> Terrains;
    /* 0x00b0 */ int32_t TileWidth;
    /* 0x00b4 */ int32_t TileHeight;
    /* 0x00b8 */ int32_t Margin;
    /* 0x00bc */ int32_t Spacing;
};

// Size: 0x18
struct FPaperTileSetTerrain {
    /* 0x0000 */ FString TerrainName;
    /* 0x0010 */ int32_t CenterTileIndex;
};

// Size: 0x40
struct FSpriteAssetInitParameters {
};

// Size: 0xd0
struct FSpriteDrawCallRecord {
    /* 0x0000 */ FVector Destination;
    /* 0x0010 */ UTexture* BaseTexture;
    /* 0x0048 */ FColor Color;
};

// Size: 0x30
struct FSpriteGeometryCollection {
    /* 0x0000 */ TArray<FSpriteGeometryShape> Shapes;
    /* 0x0010 */ uint8_t GeometryType;
    /* 0x0014 */ int32_t PixelsPerSubdivisionX;
    /* 0x0018 */ int32_t PixelsPerSubdivisionY;
    /* 0x001c */ bool bAvoidVertexMerging;
    /* 0x0020 */ float AlphaThreshold;
    /* 0x0024 */ float DetailAmount;
    /* 0x0028 */ float SimplifyEpsilon;
};

// Size: 0x30
struct FSpriteGeometryShape {
    /* 0x0000 */ ESpriteShapeType ShapeType;
    /* 0x0008 */ TArray<FVector2D> Vertices;
    /* 0x0018 */ FVector2D BoxSize;
    /* 0x0020 */ FVector2D BoxPosition;
    /* 0x0028 */ float Rotation;
    /* 0x002c */ bool bNegativeWinding;
};

// Size: 0x50
struct FSpriteInstanceData {
    /* 0x0000 */ FMatrix Transform;
    /* 0x0040 */ UPaperSprite* SourceSprite;
    /* 0x0048 */ FColor VertexColor;
    /* 0x004c */ int32_t MaterialIndex;
};

// Size: 0x30
class UTileMapBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void BreakTile(FPaperTileInfo Tile, int32_t& TileIndex, UPaperTileSet*& TileSet, bool& bFlipH, bool& bFlipV, bool& bFlipD);
    static FTransform GetTileTransform(FPaperTileInfo Tile);
    static FName GetTileUserData(FPaperTileInfo Tile);
    static FPaperTileInfo MakeTile(int32_t TileIndex, UPaperTileSet* TileSet, bool bFlipH, bool bFlipV, bool bFlipD);
};

enum class ESpriteExtractMode {
    Auto = 0,
    Grid = 1,
    ESpriteExtractMode_MAX = 2,
};

// Size: 0x38
class UFlipbookEditorSettings : public UObject {
    /* 0x0030 */ FColor BackgroundColor;
    /* 0x0034 */ bool bShowGridByDefault;
};

// Size: 0x50
class UPaperExtractSpriteGridSettings : public UObject {
    /* 0x0030 */ int32_t CellWidth;
    /* 0x0034 */ int32_t CellHeight;
    /* 0x0038 */ int32_t NumCellsX;
    /* 0x003c */ int32_t NumCellsY;
    /* 0x0040 */ int32_t MarginX;
    /* 0x0044 */ int32_t MarginY;
    /* 0x0048 */ int32_t SpacingX;
    /* 0x004c */ int32_t SpacingY;
};

// Size: 0x80
class UPaperExtractSpritesSettings : public UObject {
    /* 0x0030 */ ESpriteExtractMode SpriteExtractMode;
    /* 0x0034 */ FLinearColor OutlineColor;
    /* 0x0044 */ FLinearColor ViewportTextureTint;
    /* 0x0054 */ FLinearColor BackgroundColor;
    /* 0x0068 */ FString NamingTemplate;
    /* 0x0078 */ int32_t NamingStartIndex;
};

// Size: 0x78
class UPaperFlipbookActorFactory : public UActorFactory {
};

// Size: 0x98
class UPaperFlipbookFactory : public UFactory {
};

// Size: 0x38
class UPaperFlipbookThumbnailRenderer : public UPaperSpriteThumbnailRenderer {
};

// Size: 0x120
class UPaperImporterSettings : public UObject {
    /* 0x0030 */ bool bPickBestMaterialWhenCreatingSprites;
    /* 0x0031 */ bool bPickBestMaterialWhenCreatingTileMaps;
    /* 0x0032 */ bool bAnalysisCanUseOpaque;
    /* 0x0034 */ float DefaultPixelsPerUnrealUnit;
    /* 0x0038 */ TArray<FString> NormalMapTextureSuffixes;
    /* 0x0048 */ TArray<FString> BaseMapTextureSuffixes;
    /* 0x0058 */ uint8_t DefaultSpriteTextureGroup;
    /* 0x0059 */ bool bOverrideTextureCompression;
    /* 0x005a */ uint8_t DefaultSpriteTextureCompression;
    /* 0x0060 */ FSoftObjectPath UnlitDefaultMaskedMaterialName;
    /* 0x0080 */ FSoftObjectPath UnlitDefaultTranslucentMaterialName;
    /* 0x00a0 */ FSoftObjectPath UnlitDefaultOpaqueMaterialName;
    /* 0x00c0 */ FSoftObjectPath LitDefaultMaskedMaterialName;
    /* 0x00e0 */ FSoftObjectPath LitDefaultTranslucentMaterialName;
    /* 0x0100 */ FSoftObjectPath LitDefaultOpaqueMaterialName;
};

// Size: 0x78
class UPaperSpriteActorFactory : public UActorFactory {
};

// Size: 0x88
class UPaperSpriteAtlasFactory : public UFactory {
};

// Size: 0xa8
class UPaperSpriteFactory : public UFactory {
};

// Size: 0x38
class UPaperSpriteThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x90
class UPaperTileMapFactory : public UFactory {
};

// Size: 0x90
class UPaperTileMapPromotionFactory : public UFactory {
    /* 0x0088 */ UPaperTileMap* AssetToRename;
};

// Size: 0x90
class UPaperTileSetFactory : public UFactory {
};

// Size: 0x38
class UPaperTileSetThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x38
class USpriteEditorSettings : public UObject {
    /* 0x0030 */ FColor BackgroundColor;
    /* 0x0034 */ bool bShowGridByDefault;
};

// Size: 0x78
class UTerrainSplineActorFactory : public UActorFactory {
};

// Size: 0x78
class UTileMapActorFactory : public UActorFactory {
};

// Size: 0x70
class UTileMapAssetImportData : public UAssetImportData {
    /* 0x0060 */ TArray<FTileSetImportMapping> TileSetMap;
};

// Size: 0x58
class UTileMapEditorSettings : public UObject {
    /* 0x0030 */ FColor DefaultBackgroundColor;
    /* 0x0034 */ bool bShowGridByDefault;
    /* 0x0038 */ FColor DefaultTileGridColor;
    /* 0x003c */ FColor DefaultMultiTileGridColor;
    /* 0x0040 */ int32_t DefaultMultiTileGridWidth;
    /* 0x0044 */ int32_t DefaultMultiTileGridHeight;
    /* 0x0048 */ int32_t DefaultMultiTileGridOffsetX;
    /* 0x004c */ int32_t DefaultMultiTileGridOffsetY;
    /* 0x0050 */ FColor DefaultLayerGridColor;
};

// Size: 0x40
class UTileSetEditorSettings : public UObject {
    /* 0x0030 */ FColor DefaultBackgroundColor;
    /* 0x0034 */ bool bShowGridByDefault;
    /* 0x0038 */ int32_t ExtrusionAmount;
    /* 0x003c */ bool bPadToPowerOf2;
    /* 0x003d */ bool bFillWithTransparentBlack;
};

// Size: 0x20
struct FTileSetImportMapping {
    /* 0x0000 */ FString SourceName;
    /* 0x0010 */ TWeakObjectPtr<UPaperTileSet> ImportedTileSet;
    /* 0x0018 */ TWeakObjectPtr<UTexture> ImportedTexture;
};

// Size: 0x98
class UTileSheetPaddingFactory : public UFactory {
    /* 0x0088 */ UPaperTileSet* SourceTileSet;
    /* 0x0090 */ int32_t ExtrusionAmount;
    /* 0x0094 */ bool bPadToPowerOf2;
    /* 0x0095 */ bool bFillWithTransparentBlack;
};

// Size: 0x88
class UPaperSpriteSheet : public UObject {
    /* 0x0030 */ TArray<FString> SpriteNames;
    /* 0x0040 */ TArray<TSoftObjectPtr<UPaperSprite>> Sprites;
    /* 0x0050 */ FString TextureName;
    /* 0x0060 */ UTexture2D* Texture;
    /* 0x0068 */ FString NormalMapTextureName;
    /* 0x0078 */ UTexture2D* NormalMapTexture;
    /* 0x0080 */ UAssetImportData* AssetImportData;
};

// Size: 0x150
class UPaperSpriteSheetImportFactory : public UFactory {
};

// Size: 0x170
class UPaperSpriteSheetReimportFactory : public UPaperSpriteSheetImportFactory {
};

// Size: 0xa8
class UPaperTiledImporterFactory : public UFactory {
};

// Size: 0x2f8
class AAnimationEditorPreviewActor : public AActor {
};

// Size: 0x1c0
class ULODInfoUILayout : public UObject {
    /* 0x0030 */ FSkeletalMeshLODInfo LODInfo;
};

// Size: 0x60
class UPersonaPreviewSceneAnimationController : public UPersonaPreviewSceneController {
    /* 0x0030 */ TSoftObjectPtr<UAnimationAsset> Animation;
};

// Size: 0x30
class UPersonaPreviewSceneController : public UObject {
};

// Size: 0x30
class UPersonaPreviewSceneDefaultController : public UPersonaPreviewSceneController {
};

// Size: 0xf8
class UPersonaPreviewSceneDescription : public UObject {
    /* 0x0030 */ UClass* PreviewController;
    /* 0x0038 */ UPersonaPreviewSceneController* PreviewControllerInstance;
    /* 0x0040 */ TArray<UPersonaPreviewSceneController*> PreviewControllerInstances;
    /* 0x0050 */ TSoftObjectPtr<USkeletalMesh> PreviewMesh;
    /* 0x0080 */ TSoftObjectPtr<UAnimBlueprint> PreviewAnimationBlueprint;
    /* 0x00b0 */ EPreviewAnimationBlueprintApplicationMethod ApplicationMethod;
    /* 0x00b4 */ FName LinkedAnimGraphTag;
    /* 0x00c0 */ TSoftObjectPtr<UDataAsset> AdditionalMeshes;
    /* 0x00f0 */ UPreviewMeshCollection* DefaultAdditionalMeshes;
};

// Size: 0x38
class UPersonaPreviewSceneRefPoseController : public UPersonaPreviewSceneController {
    /* 0x0030 */ bool bResetBoneTransforms;
};

// Size: 0x58
class USkinWeightImportOptions : public UObject {
    /* 0x0030 */ FString ProfileName;
    /* 0x0040 */ FString FilePath;
    /* 0x0050 */ int32_t LODIndex;
};

// Size: 0x138
struct FAnimNode_WheelHandler : public FAnimNode_SkeletalControlBase {
};

enum class EVehicleDifferential4W {
    LimitedSlip_4W = 0,
    LimitedSlip_FrontDrive = 1,
    LimitedSlip_RearDrive = 2,
    Open_4W = 3,
    Open_FrontDrive = 4,
    Open_RearDrive = 5,
    EVehicleDifferential4W_MAX = 6,
};

enum class EWheelSweepType {
    SimpleAndComplex = 0,
    Simple = 1,
    Complex = 2,
    EWheelSweepType_MAX = 3,
};

// Size: 0x14
struct FReplicatedVehicleState {
    /* 0x0000 */ float SteeringInput;
    /* 0x0004 */ float ThrottleInput;
    /* 0x0008 */ float BrakeInput;
    /* 0x000c */ float HandbrakeInput;
    /* 0x0010 */ int32_t CurrentGear;
};

// Size: 0x2a8
class USimpleWheeledVehicleMovementComponent : public UWheeledVehicleMovementComponent {

    void SetBrakeTorque(float BrakeTorque, int32_t WheelIndex);
    void SetDriveTorque(float DriveTorque, int32_t WheelIndex);
    void SetSteerAngle(float SteerAngle, int32_t WheelIndex);
};

// Size: 0x58
class UTireConfig : public UDataAsset {
    /* 0x0038 */ float FrictionScale;
    /* 0x0040 */ TArray<FTireConfigMaterialFriction> TireFrictionScales;
};

// Size: 0x10
struct FTireConfigMaterialFriction {
    /* 0x0000 */ UPhysicalMaterial* PhysicalMaterial;
    /* 0x0008 */ float FrictionScale;
};

// Size: 0xb40
class UVehicleAnimInstance : public UAnimInstance {
    /* 0x0b30 */ UWheeledVehicleMovementComponent* WheeledVehicleMovementComponent;

    AWheeledVehicle* GetVehicle();
};

// Size: 0x820
struct FVehicleAnimInstanceProxy : public FAnimInstanceProxy {
};

// Size: 0x1c
struct FVehicleDifferential4WData {
    /* 0x0000 */ uint8_t DifferentialType;
    /* 0x0004 */ float FrontRearSplit;
    /* 0x0008 */ float FrontLeftRightSplit;
    /* 0x000c */ float RearLeftRightSplit;
    /* 0x0010 */ float CentreBias;
    /* 0x0014 */ float FrontBias;
    /* 0x0018 */ float RearBias;
};

// Size: 0xa0
struct FVehicleEngineData {
    /* 0x0000 */ FRuntimeFloatCurve TorqueCurve;
    /* 0x0088 */ float MaxRPM;
    /* 0x008c */ float MOI;
    /* 0x0090 */ float DampingRateFullThrottle;
    /* 0x0094 */ float DampingRateZeroThrottleClutchEngaged;
    /* 0x0098 */ float DampingRateZeroThrottleClutchDisengaged;
};

// Size: 0xc
struct FVehicleGearData {
    /* 0x0000 */ float Ratio;
    /* 0x0004 */ float DownRatio;
    /* 0x0008 */ float UpRatio;
};

// Size: 0x8
struct FVehicleInputRate {
    /* 0x0000 */ float RiseRate;
    /* 0x0004 */ float FallRate;
};

// Size: 0x30
struct FVehicleTransmissionData {
    /* 0x0000 */ bool bUseGearAutoBox;
    /* 0x0004 */ float GearSwitchTime;
    /* 0x0008 */ float GearAutoBoxLatency;
    /* 0x000c */ float FinalRatio;
    /* 0x0010 */ TArray<FVehicleGearData> ForwardGears;
    /* 0x0020 */ float ReverseGearRatio;
    /* 0x0024 */ float NeutralGearUpRatio;
    /* 0x0028 */ float ClutchStrength;
};

// Size: 0xf8
class UVehicleWheel : public UObject {
    /* 0x0030 */ UStaticMesh* CollisionMesh;
    /* 0x0038 */ bool bDontCreateShape;
    /* 0x0039 */ bool bAutoAdjustCollisionSize;
    /* 0x003c */ FVector Offset;
    /* 0x0048 */ float ShapeRadius;
    /* 0x004c */ float ShapeWidth;
    /* 0x0050 */ float Mass;
    /* 0x0054 */ float DampingRate;
    /* 0x0058 */ float SteerAngle;
    /* 0x005c */ bool bAffectedByHandbrake;
    /* 0x0060 */ UTireType* TireType;
    /* 0x0068 */ UTireConfig* TireConfig;
    /* 0x0070 */ float LatStiffMaxLoad;
    /* 0x0074 */ float LatStiffValue;
    /* 0x0078 */ float LongStiffValue;
    /* 0x007c */ float SuspensionForceOffset;
    /* 0x0080 */ float SuspensionMaxRaise;
    /* 0x0084 */ float SuspensionMaxDrop;
    /* 0x0088 */ float SuspensionNaturalFrequency;
    /* 0x008c */ float SuspensionDampingRatio;
    /* 0x0090 */ uint8_t SweepType;
    /* 0x0094 */ float MaxBrakeTorque;
    /* 0x0098 */ float MaxHandBrakeTorque;
    /* 0x00a0 */ UWheeledVehicleMovementComponent* VehicleSim;
    /* 0x00a8 */ int32_t WheelIndex;
    /* 0x00ac */ float DebugLongSlip;
    /* 0x00b0 */ float DebugLatSlip;
    /* 0x00b4 */ float DebugNormalizedTireLoad;
    /* 0x00bc */ float DebugWheelTorque;
    /* 0x00c0 */ float DebugLongForce;
    /* 0x00c4 */ float DebugLatForce;
    /* 0x00c8 */ FVector Location;
    /* 0x00d4 */ FVector OldLocation;
    /* 0x00e0 */ FVector Velocity;

    float GetRotationAngle() const;
    float GetSteerAngle() const;
    float GetSuspensionOffset() const;
    bool IsInAir() const;
};

// Size: 0x28
struct FWheelSetup {
    /* 0x0000 */ UClass* WheelClass;
    /* 0x0008 */ FName BoneName;
    /* 0x0014 */ FVector AdditionalOffset;
    /* 0x0020 */ bool bDisableSteering;
};

// Size: 0x368
class AWheeledVehicle : public APawn {
    /* 0x0358 */ USkeletalMeshComponent* Mesh;
    /* 0x0360 */ UWheeledVehicleMovementComponent* VehicleMovement;
};

// Size: 0x2a8
class UWheeledVehicleMovementComponent : public UPawnMovementComponent {
    /* 0x0158 */ bool bDeprecatedSpringOffsetMode;
    /* 0x0158 */ bool bReverseAsBrake;
    /* 0x0158 */ bool bUseRVOAvoidance;
    /* 0x0158 */ bool bRawHandbrakeInput;
    /* 0x0158 */ bool bRawGearUpInput;
    /* 0x0158 */ bool bRawGearDownInput;
    /* 0x015c */ bool bWasAvoidanceUpdated;
    /* 0x0160 */ float Mass;
    /* 0x0168 */ TArray<FWheelSetup> WheelSetups;
    /* 0x0178 */ float DragCoefficient;
    /* 0x017c */ float ChassisWidth;
    /* 0x0180 */ float ChassisHeight;
    /* 0x0184 */ float DragArea;
    /* 0x0188 */ float EstimatedMaxEngineSpeed;
    /* 0x018c */ float MaxEngineRPM;
    /* 0x0190 */ float DebugDragMagnitude;
    /* 0x0194 */ FVector InertiaTensorScale;
    /* 0x01a0 */ float MinNormalizedTireLoad;
    /* 0x01a4 */ float MinNormalizedTireLoadFiltered;
    /* 0x01a8 */ float MaxNormalizedTireLoad;
    /* 0x01ac */ float MaxNormalizedTireLoadFiltered;
    /* 0x01b0 */ float ThresholdLongitudinalSpeed;
    /* 0x01b4 */ int32_t LowForwardSpeedSubStepCount;
    /* 0x01b8 */ int32_t HighForwardSpeedSubStepCount;
    /* 0x01c0 */ TArray<UVehicleWheel*> Wheels;
    /* 0x01e8 */ float RVOAvoidanceRadius;
    /* 0x01ec */ float RVOAvoidanceHeight;
    /* 0x01f0 */ float AvoidanceConsiderationRadius;
    /* 0x01f4 */ float RVOSteeringStep;
    /* 0x01f8 */ float RVOThrottleStep;
    /* 0x01fc */ int32_t AvoidanceUID;
    /* 0x0200 */ FNavAvoidanceMask AvoidanceGroup;
    /* 0x0204 */ FNavAvoidanceMask GroupsToAvoid;
    /* 0x0208 */ FNavAvoidanceMask GroupsToIgnore;
    /* 0x020c */ float AvoidanceWeight;
    /* 0x0210 */ FVector PendingLaunchVelocity;
    /* 0x021c */ FReplicatedVehicleState ReplicatedState;
    /* 0x0234 */ float RawSteeringInput;
    /* 0x0238 */ float RawThrottleInput;
    /* 0x023c */ float RawBrakeInput;
    /* 0x0240 */ float SteeringInput;
    /* 0x0244 */ float ThrottleInput;
    /* 0x0248 */ float BrakeInput;
    /* 0x024c */ float HandbrakeInput;
    /* 0x0250 */ float IdleBrakeInput;
    /* 0x0254 */ float StopThreshold;
    /* 0x0258 */ float WrongDirectionThreshold;
    /* 0x025c */ FVehicleInputRate ThrottleInputRate;
    /* 0x0264 */ FVehicleInputRate BrakeInputRate;
    /* 0x026c */ FVehicleInputRate HandbrakeInputRate;
    /* 0x0274 */ FVehicleInputRate SteeringInputRate;
    /* 0x02a0 */ AController* OverrideController;

    int32_t GetCurrentGear() const;
    float GetEngineMaxRotationSpeed() const;
    float GetEngineRotationSpeed() const;
    float GetForwardSpeed() const;
    int32_t GetTargetGear() const;
    bool GetUseAutoGears() const;
    void ServerUpdateState(float InSteeringInput, float InThrottleInput, float InBrakeInput, float InHandbrakeInput, int32_t CurrentGear);
    void SetAvoidanceEnabled(bool bEnable);
    void SetAvoidanceGroup(int32_t GroupFlags);
    void SetAvoidanceGroupMask(const FNavAvoidanceMask& GroupMask);
    void SetBrakeInput(float Brake);
    void SetGearDown(bool bNewGearDown);
    void SetGearUp(bool bNewGearUp);
    void SetGroupsToAvoid(int32_t GroupFlags);
    void SetGroupsToAvoidMask(const FNavAvoidanceMask& GroupMask);
    void SetGroupsToIgnore(int32_t GroupFlags);
    void SetGroupsToIgnoreMask(const FNavAvoidanceMask& GroupMask);
    void SetHandbrakeInput(bool bNewHandbrake);
    void SetSteeringInput(float Steering);
    void SetTargetGear(int32_t GearNum, bool bImmediate);
    void SetThrottleInput(float Throttle);
    void SetUseAutoGears(bool bUseAuto);
};

// Size: 0x420
class UWheeledVehicleMovementComponent4W : public UWheeledVehicleMovementComponent {
    /* 0x02a8 */ FVehicleEngineData EngineSetup;
    /* 0x0348 */ FVehicleDifferential4WData DifferentialSetup;
    /* 0x0364 */ float AckermannAccuracy;
    /* 0x0368 */ FVehicleTransmissionData TransmissionSetup;
    /* 0x0398 */ FRuntimeFloatCurve SteeringCurve;
};

// Size: 0x2a8
class UAnimGraphNode_WheelHandler : public UAnimGraphNode_SkeletalControlBase {
    /* 0x0170 */ FAnimNode_WheelHandler Node;
};

// Size: 0x18
struct FBodyInstanceCore {
    /* 0x0010 */ bool bSimulatePhysics;
    /* 0x0010 */ bool bOverrideMass;
    /* 0x0010 */ bool bEnableGravity;
    /* 0x0010 */ bool bAutoWeld;
    /* 0x0010 */ bool bStartAwake;
    /* 0x0010 */ bool bGenerateWakeEvents;
    /* 0x0010 */ bool bUpdateMassWhenScaleChanges;
};

// Size: 0x50
class UBodySetupCore : public UObject {
    /* 0x0030 */ FName BoneName;
    /* 0x003c */ uint8_t PhysicsType;
    /* 0x003d */ uint8_t CollisionTraceFlag;
    /* 0x003e */ uint8_t CollisionReponse;
};

// Size: 0x50
class UChaosPhysicalMaterial : public UObject {
    /* 0x0030 */ float Friction;
    /* 0x0034 */ float StaticFriction;
    /* 0x0038 */ float Restitution;
    /* 0x003c */ float LinearEtherDrag;
    /* 0x0040 */ float AngularEtherDrag;
    /* 0x0044 */ float SleepingLinearVelocityThreshold;
    /* 0x0048 */ float SleepingAngularVelocityThreshold;
};

enum class EAngularConstraintMotion {
    ACM_Free = 0,
    ACM_Limited = 1,
    ACM_Locked = 2,
    ACM_MAX = 3,
};

enum class EBodyCollisionResponse {
    BodyCollision_Enabled = 0,
    BodyCollision_Disabled = 1,
    BodyCollision_MAX = 2,
};

enum class ECollisionTraceFlag {
    CTF_UseDefault = 0,
    CTF_UseSimpleAndComplex = 1,
    CTF_UseSimpleAsComplex = 2,
    CTF_UseComplexAsSimple = 3,
    CTF_MAX = 4,
};

enum class EConstraintFrame {
    Frame1 = 0,
    Frame2 = 1,
    EConstraintFrame_MAX = 2,
};

enum class EFrictionCombineMode {
    Average = 0,
    Min = 1,
    Multiply = 2,
    Max = 3,
    EFrictionCombineMode_MAX = 4,
};

enum class ELinearConstraintMotion {
    LCM_Free = 0,
    LCM_Limited = 1,
    LCM_Locked = 2,
    LCM_MAX = 3,
};

enum class EPhysicalSurface {
    SurfaceType_Default = 0,
    SurfaceType1 = 1,
    SurfaceType2 = 2,
    SurfaceType3 = 3,
    SurfaceType4 = 4,
    SurfaceType5 = 5,
    SurfaceType6 = 6,
    SurfaceType7 = 7,
    SurfaceType8 = 8,
    SurfaceType9 = 9,
    SurfaceType10 = 10,
    SurfaceType11 = 11,
    SurfaceType12 = 12,
    SurfaceType13 = 13,
    SurfaceType14 = 14,
    SurfaceType15 = 15,
    SurfaceType16 = 16,
    SurfaceType17 = 17,
    SurfaceType18 = 18,
    SurfaceType19 = 19,
    SurfaceType20 = 20,
    SurfaceType21 = 21,
    SurfaceType22 = 22,
    SurfaceType23 = 23,
    SurfaceType24 = 24,
    SurfaceType25 = 25,
    SurfaceType26 = 26,
    SurfaceType27 = 27,
    SurfaceType28 = 28,
    SurfaceType29 = 29,
    SurfaceType30 = 30,
    SurfaceType31 = 31,
    SurfaceType32 = 32,
    SurfaceType33 = 33,
    SurfaceType34 = 34,
    SurfaceType35 = 35,
    SurfaceType36 = 36,
    SurfaceType37 = 37,
    SurfaceType38 = 38,
    SurfaceType39 = 39,
    SurfaceType40 = 40,
    SurfaceType41 = 41,
    SurfaceType42 = 42,
    SurfaceType43 = 43,
    SurfaceType44 = 44,
    SurfaceType45 = 45,
    SurfaceType46 = 46,
    SurfaceType47 = 47,
    SurfaceType48 = 48,
    SurfaceType49 = 49,
    SurfaceType50 = 50,
    SurfaceType51 = 51,
    SurfaceType52 = 52,
    SurfaceType53 = 53,
    SurfaceType54 = 54,
    SurfaceType55 = 55,
    SurfaceType56 = 56,
    SurfaceType57 = 57,
    SurfaceType58 = 58,
    SurfaceType59 = 59,
    SurfaceType60 = 60,
    SurfaceType61 = 61,
    SurfaceType62 = 62,
    SurfaceType_Max = 63,
    EPhysicalSurface_MAX = 64,
};

enum class EPhysicsType {
    PhysType_Default = 0,
    PhysType_Kinematic = 1,
    PhysType_Simulated = 2,
    PhysType_MAX = 3,
};

enum class ERadialImpulseFalloff {
    RIF_Constant = 0,
    RIF_Linear = 1,
    RIF_MAX = 2,
};

enum class ESleepFamily {
    Normal = 0,
    Sensitive = 1,
    Custom = 2,
    ESleepFamily_MAX = 3,
};

// Size: 0x88
class UPhysicalMaterial : public UObject {
    /* 0x0030 */ float Friction;
    /* 0x0034 */ float StaticFriction;
    /* 0x0038 */ uint8_t FrictionCombineMode;
    /* 0x0039 */ bool bOverrideFrictionCombineMode;
    /* 0x003c */ float Restitution;
    /* 0x0040 */ uint8_t RestitutionCombineMode;
    /* 0x0041 */ bool bOverrideRestitutionCombineMode;
    /* 0x0044 */ float Density;
    /* 0x0048 */ float SleepLinearVelocityThreshold;
    /* 0x004c */ float SleepAngularVelocityThreshold;
    /* 0x0050 */ int32_t SleepCounterThreshold;
    /* 0x0054 */ float RaiseMassToPower;
    /* 0x0058 */ float DestructibleDamageThresholdScale;
    /* 0x0060 */ UPhysicalMaterialPropertyBase* PhysicalMaterialProperty;
    /* 0x0068 */ uint8_t SurfaceType;
};

// Size: 0x30
class UPhysicalMaterialPropertyBase : public UObject {
};

// Size: 0x108
class UPhysicsSettingsCore : public UDeveloperSettings {
    /* 0x0060 */ float DefaultGravityZ;
    /* 0x0064 */ float DefaultTerminalVelocity;
    /* 0x0068 */ float DefaultFluidFriction;
    /* 0x006c */ int32_t SimulateScratchMemorySize;
    /* 0x0070 */ int32_t RagdollAggregateThreshold;
    /* 0x0074 */ float TriangleMeshTriangleMinAreaThreshold;
    /* 0x0078 */ bool bEnableShapeSharing;
    /* 0x0079 */ bool bEnablePCM;
    /* 0x007a */ bool bEnableStabilization;
    /* 0x007b */ bool bWarnMissingLocks;
    /* 0x007c */ bool bEnable2DPhysics;
    /* 0x007d */ bool bDefaultHasComplexCollision;
    /* 0x0080 */ float BounceThresholdVelocity;
    /* 0x0084 */ uint8_t FrictionCombineMode;
    /* 0x0085 */ uint8_t RestitutionCombineMode;
    /* 0x0088 */ float MaxAngularVelocity;
    /* 0x008c */ float MaxDepenetrationVelocity;
    /* 0x0090 */ float ContactOffsetMultiplier;
    /* 0x0094 */ float MinContactOffset;
    /* 0x0098 */ float MaxContactOffset;
    /* 0x009c */ bool bSimulateSkeletalMeshOnDedicatedServer;
    /* 0x009d */ uint8_t DefaultShapeComplexity;
    /* 0x00a0 */ FChaosSolverConfiguration SolverOptions;
};

enum class EPinnedCommandListType {
    Command = 0,
    CustomWidget = 1,
    EPinnedCommandListType_MAX = 2,
};

// Size: 0x1c
struct FPinnedCommandListCommand {
    /* 0x0000 */ FName Name;
    /* 0x000c */ FName Binding;
    /* 0x0018 */ EPinnedCommandListType Type;
};

// Size: 0x20
struct FPinnedCommandListContext {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ TArray<FPinnedCommandListCommand> Commands;
};

// Size: 0x40
class UPinnedCommandListSettings : public UObject {
    /* 0x0030 */ TArray<FPinnedCommandListContext> Contexts;
};

// Size: 0x408
class UPixelInspectorView : public UObject {
    /* 0x0340 */ FLinearColor FinalColor;
    /* 0x0350 */ FLinearColor SceneColor;
    /* 0x0360 */ float PreExposure;
    /* 0x0364 */ float Luminance;
    /* 0x0368 */ FLinearColor HdrColor;
    /* 0x0378 */ FVector Normal;
    /* 0x0384 */ float PerObjectGBufferData;
    /* 0x0388 */ float Metallic;
    /* 0x038c */ float Specular;
    /* 0x0390 */ float Roughness;
    /* 0x0394 */ uint8_t MaterialShadingModel;
    /* 0x0398 */ int32_t SelectiveOutputMask;
    /* 0x039c */ FLinearColor BaseColor;
    /* 0x03ac */ float IndirectIrradiance;
    /* 0x03b0 */ float AmbientOcclusion;
    /* 0x03b4 */ FLinearColor SubsurfaceColor;
    /* 0x03c4 */ FVector SubsurfaceProfile;
    /* 0x03d0 */ float Opacity;
    /* 0x03d4 */ float ClearCoat;
    /* 0x03d8 */ float ClearCoatRoughness;
    /* 0x03dc */ FVector WorldNormal;
    /* 0x03e8 */ float BackLit;
    /* 0x03ec */ float Cloth;
    /* 0x03f0 */ FVector EyeTangent;
    /* 0x03fc */ float IrisMask;
    /* 0x0400 */ float IrisDistance;
};

// Size: 0x68
class UNewPluginDescriptorData : public UObject {
    /* 0x0030 */ FString CreatedBy;
    /* 0x0040 */ FString CreatedByURL;
    /* 0x0050 */ FString Description;
    /* 0x0060 */ bool bIsBetaVersion;
};

// Size: 0xf0
class UPluginMetadataObject : public UObject {
    /* 0x0040 */ int32_t Version;
    /* 0x0048 */ FString VersionName;
    /* 0x0058 */ FString FriendlyName;
    /* 0x0068 */ FString Description;
    /* 0x0078 */ FString Category;
    /* 0x0088 */ FString CreatedBy;
    /* 0x0098 */ FString CreatedByURL;
    /* 0x00a8 */ FString DocsURL;
    /* 0x00b8 */ FString MarketplaceURL;
    /* 0x00c8 */ FString SupportURL;
    /* 0x00d8 */ bool bCanContainContent;
    /* 0x00d9 */ bool bIsBetaVersion;
    /* 0x00e0 */ TArray<FPluginReferenceMetadata> Plugins;
};

// Size: 0x18
struct FPluginReferenceMetadata {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ bool bOptional;
    /* 0x0011 */ bool bEnabled;
};

// Size: 0x40
struct FPortalRpcLocateServer {
    /* 0x0000 */ FGuid ProductId;
    /* 0x0010 */ FString ProductVersion;
    /* 0x0020 */ FString HostMacAddress;
    /* 0x0030 */ FString HostUserId;
};

// Size: 0x10
struct FPortalRpcServer {
    /* 0x0000 */ FString ServerAddress;
};

enum class EEntitlementCacheLevelRequest {
    Memory = 1,
    Disk = 2,
    EEntitlementCacheLevelRequest_MAX = 3,
};

enum class EEntitlementCacheLevelRetrieved {
    None = 0,
    Memory = 1,
    Disk = 2,
    EEntitlementCacheLevelRetrieved_MAX = 3,
};

// Size: 0x50
struct FPortalUserDetails {
    /* 0x0000 */ FText DisplayName;
    /* 0x0018 */ FText Email;
    /* 0x0030 */ FText RealName;
    /* 0x0048 */ bool IsSignedIn;
};

// Size: 0x18
struct FPortalUserIsEntitledToItemResult {
    /* 0x0000 */ FString ItemId;
    /* 0x0010 */ bool IsEntitled;
    /* 0x0011 */ EEntitlementCacheLevelRetrieved RetrievedFromCacheLevel;
};

enum class EProcMeshSliceCapOption {
    NoCap = 0,
    CreateNewSectionForCap = 1,
    UseLastSectionForCap = 2,
    EProcMeshSliceCapOption_MAX = 3,
};

// Size: 0x30
class UKismetProceduralMeshLibrary : public UBlueprintFunctionLibrary {

    static void CalculateTangentsForMesh(const TArray<FVector>& Vertices, const TArray<int32_t>& Triangles, const TArray<FVector2D>& UVs, TArray<FVector>& Normals, TArray<FProcMeshTangent>& Tangents);
    static void ConvertQuadToTriangles(TArray<int32_t>& Triangles, int32_t Vert0, int32_t Vert1, int32_t Vert2, int32_t Vert3);
    static void CopyProceduralMeshFromStaticMeshComponent(UStaticMeshComponent* StaticMeshComponent, int32_t LODIndex, UProceduralMeshComponent* ProcMeshComponent, bool bCreateCollision);
    static void CreateGridMeshSplit(int32_t NumX, int32_t NumY, TArray<int32_t>& Triangles, TArray<FVector>& Vertices, TArray<FVector2D>& UVs, TArray<FVector2D>& UV1s, float GridSpacing);
    static void CreateGridMeshTriangles(int32_t NumX, int32_t NumY, bool bWinding, TArray<int32_t>& Triangles);
    static void CreateGridMeshWelded(int32_t NumX, int32_t NumY, TArray<int32_t>& Triangles, TArray<FVector>& Vertices, TArray<FVector2D>& UVs, float GridSpacing);
    static void GenerateBoxMesh(FVector BoxRadius, TArray<FVector>& Vertices, TArray<int32_t>& Triangles, TArray<FVector>& Normals, TArray<FVector2D>& UVs, TArray<FProcMeshTangent>& Tangents);
    static void GetSectionFromProceduralMesh(UProceduralMeshComponent* InProcMesh, int32_t SectionIndex, TArray<FVector>& Vertices, TArray<int32_t>& Triangles, TArray<FVector>& Normals, TArray<FVector2D>& UVs, TArray<FProcMeshTangent>& Tangents);
    static void GetSectionFromStaticMesh(UStaticMesh* InMesh, int32_t LODIndex, int32_t SectionIndex, TArray<FVector>& Vertices, TArray<int32_t>& Triangles, TArray<FVector>& Normals, TArray<FVector2D>& UVs, TArray<FProcMeshTangent>& Tangents);
    static void SliceProceduralMesh(UProceduralMeshComponent* InProcMesh, FVector PlanePosition, FVector PlaneNormal, bool bCreateOtherHalf, UProceduralMeshComponent*& OutOtherHalfProcMesh, EProcMeshSliceCapOption CapOption, UMaterialInterface* CapMaterial);
};

// Size: 0x40
struct FProcMeshSection {
    /* 0x0000 */ TArray<FProcMeshVertex> ProcVertexBuffer;
    /* 0x0010 */ TArray<uint32_t> ProcIndexBuffer;
    /* 0x0020 */ FBox SectionLocalBox;
    /* 0x003c */ bool bEnableCollision;
    /* 0x003d */ bool bSectionVisible;
};

// Size: 0x10
struct FProcMeshTangent {
    /* 0x0000 */ FVector TangentX;
    /* 0x000c */ bool bFlipTangentY;
};

// Size: 0x4c
struct FProcMeshVertex {
    /* 0x0000 */ FVector Position;
    /* 0x000c */ FVector Normal;
    /* 0x0018 */ FProcMeshTangent Tangent;
    /* 0x0028 */ FColor Color;
    /* 0x002c */ FVector2D UV0;
    /* 0x0034 */ FVector2D UV1;
    /* 0x003c */ FVector2D UV2;
    /* 0x0044 */ FVector2D UV3;
};

// Size: 0x570
class UProceduralMeshComponent : public UMeshComponent {
    /* 0x0508 */ bool bUseComplexAsSimpleCollision;
    /* 0x0509 */ bool bUseAsyncCooking;
    /* 0x0510 */ UBodySetup* ProcMeshBodySetup;
    /* 0x0518 */ TArray<FProcMeshSection> ProcMeshSections;
    /* 0x0528 */ TArray<FKConvexElem> CollisionConvexElems;
    /* 0x0538 */ FBoxSphereBounds LocalBounds;
    /* 0x0558 */ TArray<UBodySetup*> AsyncBodySetupQueue;

    void AddCollisionConvexMesh(TArray<FVector> ConvexVerts);
    void ClearAllMeshSections();
    void ClearCollisionConvexMeshes();
    void ClearMeshSection(int32_t SectionIndex);
    void CreateMeshSection(int32_t SectionIndex, const TArray<FVector>& Vertices, const TArray<int32_t>& Triangles, const TArray<FVector>& Normals, const TArray<FVector2D>& UV0, const TArray<FColor>& VertexColors, const TArray<FProcMeshTangent>& Tangents, bool bCreateCollision);
    void CreateMeshSection_LinearColor(int32_t SectionIndex, const TArray<FVector>& Vertices, const TArray<int32_t>& Triangles, const TArray<FVector>& Normals, const TArray<FVector2D>& UV0, const TArray<FVector2D>& UV1, const TArray<FVector2D>& UV2, const TArray<FVector2D>& UV3, const TArray<FLinearColor>& VertexColors, const TArray<FProcMeshTangent>& Tangents, bool bCreateCollision);
    int32_t GetNumSections() const;
    bool IsMeshSectionVisible(int32_t SectionIndex) const;
    void SetMeshSectionVisible(int32_t SectionIndex, bool bNewVisibility);
    void UpdateMeshSection(int32_t SectionIndex, const TArray<FVector>& Vertices, const TArray<FVector>& Normals, const TArray<FVector2D>& UV0, const TArray<FColor>& VertexColors, const TArray<FProcMeshTangent>& Tangents);
    void UpdateMeshSection_LinearColor(int32_t SectionIndex, const TArray<FVector>& Vertices, const TArray<FVector>& Normals, const TArray<FVector2D>& UV0, const TArray<FVector2D>& UV1, const TArray<FVector2D>& UV2, const TArray<FVector2D>& UV3, const TArray<FLinearColor>& VertexColors, const TArray<FProcMeshTangent>& Tangents);
};

// Size: 0x20
struct FProfilerServiceAuthorize {
    /* 0x0000 */ FGuid SessionId;
    /* 0x0010 */ FGuid InstanceId;
};

// Size: 0x1
struct FProfilerServiceCapture {
    /* 0x0000 */ bool bRequestedCaptureState;
};

// Size: 0x30
struct FProfilerServiceData2 {
    /* 0x0000 */ FGuid InstanceId;
    /* 0x0010 */ int64_t Frame;
    /* 0x0018 */ int32_t CompressedSize;
    /* 0x001c */ int32_t UncompressedSize;
    /* 0x0020 */ FString HexData;
};

// Size: 0x50
struct FProfilerServiceFileChunk {
    /* 0x0000 */ FGuid InstanceId;
    /* 0x0010 */ FString Filename;
    /* 0x0020 */ FString HexData;
    /* 0x0030 */ TArray<uint8_t> Header;
    /* 0x0040 */ TArray<uint8_t> ChunkHash;
};

// Size: 0x1
struct FProfilerServicePing {
};

// Size: 0x1
struct FProfilerServicePong {
};

// Size: 0x1
struct FProfilerServicePreview {
    /* 0x0000 */ bool bRequestedPreviewState;
};

// Size: 0x10
struct FProfilerServicePreviewAck {
    /* 0x0000 */ FGuid InstanceId;
};

// Size: 0x4
struct FProfilerServiceRequest {
    /* 0x0000 */ uint32_t Request;
};

// Size: 0x20
struct FProfilerServiceSubscribe {
    /* 0x0000 */ FGuid SessionId;
    /* 0x0010 */ FGuid InstanceId;
};

// Size: 0x20
struct FProfilerServiceUnsubscribe {
    /* 0x0000 */ FGuid SessionId;
    /* 0x0010 */ FGuid InstanceId;
};

enum class EPropertyAccessCopyBatch {
    InternalUnbatched = 0,
    ExternalUnbatched = 1,
    InternalBatched = 2,
    ExternalBatched = 3,
    Count = 4,
    EPropertyAccessCopyBatch_MAX = 5,
};

enum class EPropertyAccessCopyType {
    None = 0,
    Plain = 1,
    Complex = 2,
    Bool = 3,
    Struct = 4,
    Object = 5,
    Name = 6,
    Array = 7,
    PromoteBoolToByte = 8,
    PromoteBoolToInt32 = 9,
    PromoteBoolToInt64 = 10,
    PromoteBoolToFloat = 11,
    PromoteByteToInt32 = 12,
    PromoteByteToInt64 = 13,
    PromoteByteToFloat = 14,
    PromoteInt32ToInt64 = 15,
    PromoteInt32ToFloat = 16,
    EPropertyAccessCopyType_MAX = 17,
};

enum class EPropertyAccessIndirectionType {
    Offset = 0,
    Object = 1,
    Array = 2,
    ScriptFunction = 3,
    NativeFunction = 4,
    EPropertyAccessIndirectionType_MAX = 5,
};

enum class EPropertyAccessObjectType {
    None = 0,
    Object = 1,
    WeakObject = 2,
    SoftObject = 3,
    EPropertyAccessObjectType_MAX = 4,
};

// Size: 0x30
class IPropertyAccess : public UInterface {
};

// Size: 0x10
struct FPropertyAccessCopy {
    /* 0x0000 */ int32_t AccessIndex;
    /* 0x0004 */ int32_t DestAccessStartIndex;
    /* 0x0008 */ int32_t DestAccessEndIndex;
    /* 0x000c */ EPropertyAccessCopyType Type;
};

// Size: 0x10
struct FPropertyAccessCopyBatch {
    /* 0x0000 */ TArray<FPropertyAccessCopy> Copies;
};

// Size: 0x50
struct FPropertyAccessIndirection {
    /* 0x0000 */ FFieldPath ArrayProperty;
    /* 0x0030 */ UFunction* Function;
    /* 0x0038 */ int32_t ReturnBufferSize;
    /* 0x003c */ int32_t ReturnBufferAlignment;
    /* 0x0040 */ int32_t ArrayIndex;
    /* 0x0044 */ uint32_t Offset;
    /* 0x0048 */ EPropertyAccessObjectType ObjectType;
    /* 0x0049 */ EPropertyAccessIndirectionType Type;
};

// Size: 0x40
struct FPropertyAccessIndirectionChain {
    /* 0x0000 */ FFieldPath Property;
    /* 0x0030 */ int32_t IndirectionStartIndex;
    /* 0x0034 */ int32_t IndirectionEndIndex;
    /* 0x0038 */ int32_t EventId;
};

// Size: 0xc8
struct FPropertyAccessLibrary {
    /* 0x0000 */ TArray<FPropertyAccessSegment> PathSegments;
    /* 0x0010 */ TArray<FPropertyAccessPath> SrcPaths;
    /* 0x0020 */ TArray<FPropertyAccessPath> DestPaths;
    /* 0x0030 */ FPropertyAccessCopyBatch CopyBatches[4];
    /* 0x0070 */ TArray<FPropertyAccessIndirectionChain> SrcAccesses;
    /* 0x0080 */ TArray<FPropertyAccessIndirectionChain> DestAccesses;
    /* 0x0090 */ TArray<FPropertyAccessIndirection> Indirections;
    /* 0x00a0 */ TArray<int32_t> EventAccessIndices;
};

// Size: 0xc
struct FPropertyAccessPath {
    /* 0x0000 */ int32_t PathSegmentStartIndex;
    /* 0x0004 */ int32_t PathSegmentCount;
    /* 0x0008 */ bool bHasEvents;
};

// Size: 0x58
struct FPropertyAccessSegment {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ Ustruct* struct;
    /* 0x0018 */ FFieldPath Property;
    /* 0x0048 */ UFunction* Function;
    /* 0x0050 */ int32_t ArrayIndex;
    /* 0x0054 */ uint16_t Flags;
};

// Size: 0x30
class IPropertyEventBroadcaster : public UInterface {
};

// Size: 0x30
class IPropertyEventSubscriber : public UInterface {
};

// Size: 0x1b0
class UK2Node_PropertyAccess : public UK2Node {
    /* 0x00d0 */ TArray<FString> Path;
    /* 0x00e0 */ FText TextPath;
    /* 0x00f8 */ FEdGraphPinType ResolvedPinType;
    /* 0x0168 */ FName GeneratedPropertyName;
};

enum class EditConditionByteEnum {
    First = 15,
    Second = 31,
    EditConditionByteEnum_MAX = 32,
};

enum class EditConditionTestEnum {
    First = 15,
    Second = 31,
    EditConditionTestEnum_MAX = 32,
};

// Size: 0x90
class UEditConditionTestObject : public UObject {
    /* 0x0030 */ bool BoolProperty;
    /* 0x0034 */ EditConditionTestEnum EnumProperty;
    /* 0x0038 */ uint8_t ByteEnumProperty;
    /* 0x0040 */ double DoubleProperty;
    /* 0x0048 */ int32_t IntegerProperty;
    /* 0x004c */ bool UintBitfieldProperty;
    /* 0x0050 */ UObject* UObjectPtr;
    /* 0x0058 */ TSoftClassPtr<UObject> SoftClassPtr;
    /* 0x0088 */ TWeakObjectPtr<UObject> WeakObjectPtr;
};

// Size: 0x30
struct FCachedPropertyPath {
    /* 0x0000 */ TArray<FPropertyPathSegment> Segments;
    /* 0x0018 */ UFunction* CachedFunction;
};

// Size: 0x28
struct FPropertyPathSegment {
    /* 0x0000 */ FName Name;
    /* 0x000c */ int32_t ArrayIndex;
    /* 0x0010 */ Ustruct* struct;
};

enum class EPyTestEnum {
    One = 0,
    Two = 1,
    EPyTestEnum_MAX = 2,
};

enum class EPythonCommandExecutionMode {
    ExecuteFile = 0,
    ExecuteStatement = 1,
    EvaluateStatement = 2,
    EPythonCommandExecutionMode_MAX = 3,
};

enum class EPythonCommandFlags {
    None = 0,
    Unattended = 1,
    EPythonCommandFlags_MAX = 2,
};

enum class EPythonFileExecutionScope {
    Private = 0,
    Public = 1,
    EPythonFileExecutionScope_MAX = 2,
};

enum class EPythonLogOutputType {
    Info = 0,
    Warning = 1,
    Error = 2,
    EPythonLogOutputType_MAX = 3,
};

// Size: 0x178
class UK2Node_ExecutePythonScript : public UK2Node_CallFunction {
    /* 0x0158 */ TArray<FName> Inputs;
    /* 0x0168 */ TArray<FName> Outputs;
};

// Size: 0x368
class ULegacyPyTestObject : public UPyTestObject {
};

// Size: 0x368
class UPyTestChildObject : public UPyTestObject {
};

// Size: 0x100
struct FPyTestChildStruct : public FPyTestStruct {
};

// Size: 0x368
class UPyTestObject : public UObject {
    /* 0x0030 */ bool bool;
    /* 0x0034 */ int32_t int;
    /* 0x0038 */ float float;
    /* 0x003c */ EPyTestEnum Enum;
    /* 0x0040 */ FString string;
    /* 0x0050 */ FName Name;
    /* 0x0060 */ FText text;
    /* 0x0078 */ TArray<FString> StringArray;
    /* 0x0088 */ TSet<FString> StringSet;
    /* 0x00d8 */ TMap<FString, int32_t> StringIntMap;
    /* 0x0128 */ FDelegate delegate;
    /* 0x0140 */ FMulticastInlineDelegate MulticastDelegate;
    /* 0x0150 */ FPyTestStruct struct;
    /* 0x0250 */ TArray<FPyTestStruct> StructArray;
    /* 0x0260 */ FPyTestChildStruct ChildStruct;
    /* 0x0360 */ bool BoolInstanceOnly;
    /* 0x0361 */ bool BoolDefaultsOnly;

    int32_t CallFuncBlueprintImplementable(const int32_t InValue) const;
    int32_t CallFuncBlueprintNative(const int32_t InValue) const;
    void CallFuncBlueprintNativeRef(FPyTestStruct& InOutStruct) const;
    int32_t DelegatePropertyCallback(const int32_t InValue) const;
    static void EmitScriptError();
    static void EmitScriptWarning();
    int32_t FuncBlueprintImplementable(const int32_t InValue) const;
    int32_t FuncBlueprintNative(const int32_t InValue) const;
    void FuncBlueprintNativeRef(FPyTestStruct& InOutStruct) const;
    void FuncTakingPyTestChildStruct(const FPyTestChildStruct& InStruct) const;
    int32_t FuncTakingPyTestDelegate(const FDelegate& InDelegate, const int32_t InValue) const;
    void FuncTakingPyTestStruct(const FPyTestStruct& InStruct) const;
    static int32_t GetConstantValue();
    void LegacyFuncTakingPyTestStruct(const FPyTestStruct& InStruct) const;
    void MulticastDelegatePropertyCallback(FString InStr) const;
    static TArray<int32_t> ReturnArray();
    static TMap<int32_t, bool> ReturnMap();
    static TSet<int32_t> ReturnSet();
};

// Size: 0x30
class UPyTestObjectLibrary : public UBlueprintFunctionLibrary {

    static int32_t GetOtherConstantValue();
    static bool IsBoolSet(const UPyTestObject* InObj);
};

// Size: 0x100
struct FPyTestStruct {
    /* 0x0000 */ bool bool;
    /* 0x0004 */ int32_t int;
    /* 0x0008 */ float float;
    /* 0x000c */ EPyTestEnum Enum;
    /* 0x0010 */ FString string;
    /* 0x0020 */ FName Name;
    /* 0x0030 */ FText text;
    /* 0x0048 */ TArray<FString> StringArray;
    /* 0x0058 */ TSet<FString> StringSet;
    /* 0x00a8 */ TMap<FString, int32_t> StringIntMap;
    /* 0x00f8 */ int32_t LegacyInt;
    /* 0x00fc */ bool BoolInstanceOnly;
    /* 0x00fd */ bool BoolDefaultsOnly;
};

// Size: 0x30
class UPyTestStructLibrary : public UBlueprintFunctionLibrary {

    static FPyTestStruct AddFloat(const FPyTestStruct& InStruct, const float InValue);
    static FPyTestStruct AddInt(const FPyTestStruct& InStruct, const int32_t InValue);
    static FPyTestStruct AddStr(const FPyTestStruct& InStruct, FString InValue);
    static int32_t GetConstantValue();
    static bool IsBoolSet(const FPyTestStruct& InStruct);
    static bool LegacyIsBoolSet(const FPyTestStruct& InStruct);
};

// Size: 0x40
class UPythonCallableForDelegate : public UObject {
};

// Size: 0x418
class UPythonGeneratedClass : public UClass {
};

// Size: 0xc8
class UPythonGeneratedEnum : public UEnum {
};

// Size: 0x410
class UPythonGeneratedStruct : public UScriptStruct {
};

// Size: 0x18
struct FPythonLogOutputEntry {
    /* 0x0000 */ EPythonLogOutputType Type;
    /* 0x0008 */ FString Output;
};

// Size: 0x88
class UPythonOnlineDocsCommandlet : public UCommandlet {
};

// Size: 0x30
class IPythonResourceOwner : public UInterface {
};

// Size: 0x88
class UPythonScriptCommandlet : public UCommandlet {
};

// Size: 0x30
class UPythonScriptLibrary : public UBlueprintFunctionLibrary {

    static bool ExecutePythonCommand(FString PythonCommand);
    static bool ExecutePythonCommandEx(FString PythonCommand, FString& CommandResult, TArray<FPythonLogOutputEntry>& LogOutput, const EPythonCommandExecutionMode ExecutionMode, const EPythonFileExecutionScope FileExecutionScope);
    static bool ExecutePythonScript(FString PythonScript, const TArray<FString>& PythonInputs, const TArray<FString>& PythonOutputs);
    static bool IsPythonAvailable();
};

// Size: 0xb8
class UPythonScriptPluginSettings : public UDeveloperSettings {
    /* 0x0060 */ TArray<FString> StartupScripts;
    /* 0x0070 */ TArray<FDirectoryPath> AdditionalPaths;
    /* 0x0080 */ bool bDeveloperMode;
    /* 0x0081 */ bool bRemoteExecution;
    /* 0x0088 */ FString RemoteExecutionMulticastGroupEndpoint;
    /* 0x0098 */ FString RemoteExecutionMulticastBindAddress;
    /* 0x00a8 */ int32_t RemoteExecutionSendBufferSizeBytes;
    /* 0x00ac */ int32_t RemoteExecutionReceiveBufferSizeBytes;
    /* 0x00b0 */ uint8_t RemoteExecutionMulticastTtl;
};

// Size: 0x68
class UPythonScriptPluginUserSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bDeveloperMode;
    /* 0x0061 */ bool bEnableContentBrowserIntegration;
};

// Size: 0x40
struct FLightPropagationVolumeSettings {
    /* 0x0000 */ bool bOverride_LPVIntensity;
    /* 0x0000 */ bool bOverride_LPVDirectionalOcclusionIntensity;
    /* 0x0000 */ bool bOverride_LPVDirectionalOcclusionRadius;
    /* 0x0000 */ bool bOverride_LPVDiffuseOcclusionExponent;
    /* 0x0000 */ bool bOverride_LPVSpecularOcclusionExponent;
    /* 0x0000 */ bool bOverride_LPVDiffuseOcclusionIntensity;
    /* 0x0000 */ bool bOverride_LPVSpecularOcclusionIntensity;
    /* 0x0000 */ bool bOverride_LPVSize;
    /* 0x0001 */ bool bOverride_LPVSecondaryOcclusionIntensity;
    /* 0x0001 */ bool bOverride_LPVSecondaryBounceIntensity;
    /* 0x0001 */ bool bOverride_LPVGeometryVolumeBias;
    /* 0x0001 */ bool bOverride_LPVVplInjectionBias;
    /* 0x0001 */ bool bOverride_LPVEmissiveInjectionIntensity;
    /* 0x0004 */ float LPVIntensity;
    /* 0x0008 */ float LPVVplInjectionBias;
    /* 0x000c */ float LPVSize;
    /* 0x0010 */ float LPVSecondaryOcclusionIntensity;
    /* 0x0014 */ float LPVSecondaryBounceIntensity;
    /* 0x0018 */ float LPVGeometryVolumeBias;
    /* 0x001c */ float LPVEmissiveInjectionIntensity;
    /* 0x0020 */ float LPVDirectionalOcclusionIntensity;
    /* 0x0024 */ float LPVDirectionalOcclusionRadius;
    /* 0x0028 */ float LPVDiffuseOcclusionExponent;
    /* 0x002c */ float LPVSpecularOcclusionExponent;
    /* 0x0030 */ float LPVDiffuseOcclusionIntensity;
    /* 0x0034 */ float LPVSpecularOcclusionIntensity;
    /* 0x0038 */ float LPVFadeRange;
    /* 0x003c */ float LPVDirectionalOcclusionFadeRange;
};

// Size: 0x50
class USceneOutlinerMenuContext : public UObject {
};

// Size: 0x38
class USceneOutlinerSettings : public UObject {
    /* 0x0030 */ bool bHideTemporaryActors;
    /* 0x0030 */ bool bShowOnlyActorsInCurrentLevel;
    /* 0x0030 */ bool bHideFoldersContainingHiddenActors;
    /* 0x0030 */ bool bShowOnlySelectedActors;
    /* 0x0030 */ bool bShowActorComponents;
};

// Size: 0x150
class UActorRecording : public USequenceRecordingBase {
    /* 0x0030 */ FActorRecordingSettings ActorSettings;
    /* 0x0048 */ bool bActive;
    /* 0x0049 */ bool bCreateLevelSequence;
    /* 0x0050 */ ULevelSequence* TargetLevelSequence;
    /* 0x0058 */ FText TargetName;
    /* 0x0070 */ uint32_t TakeNumber;
    /* 0x0074 */ bool bSpecifyTargetAnimation;
    /* 0x0078 */ UAnimSequence* TargetAnimation;
    /* 0x0080 */ FAnimationRecordingSettings AnimationSettings;
    /* 0x0094 */ bool bRecordToPossessable;
    /* 0x0098 */ TSoftObjectPtr<AActor> ActorToRecord;
};

// Size: 0x18
struct FActorRecordingSettings {
    /* 0x0000 */ TArray<UObject*> Settings;
};

enum class EAudioRecordingMode {
    None = 0,
    AudioTrack = 1,
    EAudioRecordingMode_MAX = 2,
};

// Size: 0x38
class UMovieScene3DTransformSectionRecorderSettings : public UObject {
    /* 0x0030 */ bool bRecordTransforms;
};

// Size: 0x18
struct FPropertiesToRecordForActorClass {
    /* 0x0000 */ UClass* Class;
    /* 0x0008 */ TArray<FName> Properties;
};

// Size: 0x18
struct FPropertiesToRecordForClass {
    /* 0x0000 */ UClass* Class;
    /* 0x0008 */ TArray<FName> Properties;
};

// Size: 0x10
struct FSequenceRecorderActorFilter {
    /* 0x0000 */ TArray<UClass*> ActorClassesToRecord;
};

// Size: 0x88
class USequenceRecorderActorGroup : public UObject {
    /* 0x0030 */ FName GroupName;
    /* 0x0040 */ FString SequenceName;
    /* 0x0050 */ FDirectoryPath SequenceRecordingBasePath;
    /* 0x0060 */ bool bSpecifyTargetLevelSequence;
    /* 0x0068 */ ULevelSequence* TargetLevelSequence;
    /* 0x0070 */ bool bDuplicateTargetLevelSequence;
    /* 0x0071 */ bool bRecordTargetLevelSequenceLength;
    /* 0x0078 */ TArray<UActorRecording*> RecordedActors;
};

// Size: 0x30
class USequenceRecorderBlueprintLibrary : public UBlueprintFunctionLibrary {

    static bool IsRecordingSequence();
    static void StartRecordingSequence(const TArray<AActor*>& ActorsToRecord);
    static void StopRecordingSequence();
};

// Size: 0x308
class ASequenceRecorderGroup : public AActor {
    /* 0x02f8 */ TArray<USequenceRecorderActorGroup*> ActorGroups;
};

// Size: 0x108
class USequenceRecorderSettings : public UObject {
    /* 0x0030 */ bool bCreateLevelSequence;
    /* 0x0031 */ bool bImmersiveMode;
    /* 0x0034 */ float SequenceLength;
    /* 0x0038 */ float RecordingDelay;
    /* 0x003c */ bool bAllowLooping;
    /* 0x0040 */ float GlobalTimeDilation;
    /* 0x0044 */ bool bIgnoreTimeDilation;
    /* 0x0048 */ FString AnimationSubDirectory;
    /* 0x0058 */ EAudioRecordingMode RecordAudio;
    /* 0x005c */ float AudioGain;
    /* 0x0060 */ bool bSplitAudioChannelsIntoSeparateTracks;
    /* 0x0061 */ bool bReplaceRecordedAudio;
    /* 0x0068 */ FText AudioTrackName;
    /* 0x0080 */ FString AudioSubDirectory;
    /* 0x0090 */ bool bRecordNearbySpawnedActors;
    /* 0x0094 */ float NearbyActorRecordingProximity;
    /* 0x0098 */ bool bRecordWorldSettingsActor;
    /* 0x0099 */ bool bReduceKeys;
    /* 0x009a */ bool bAutoSaveAsset;
    /* 0x00a0 */ FSequenceRecorderActorFilter ActorFilter;
    /* 0x00b0 */ TArray<TLazyObjectPtr<ALevelSequenceActor>> LevelSequenceActorsToTrigger;
    /* 0x00c0 */ FAnimationRecordingSettings DefaultAnimationSettings;
    /* 0x00d4 */ bool bRecordSequencerSpawnedActors;
    /* 0x00d8 */ TArray<FPropertiesToRecordForClass> ClassesAndPropertiesToRecord;
    /* 0x00e8 */ TArray<FPropertiesToRecordForActorClass> ActorsAndPropertiesToRecord;
    /* 0x00f8 */ TArray<FSettingsForActorClass> PerActorSettings;
};

// Size: 0x30
class USequenceRecordingBase : public UObject {
};

// Size: 0x10
struct FSettingsForActorClass {
    /* 0x0000 */ UClass* Class;
    /* 0x0008 */ bool bRecordToPossessable;
};

// Size: 0x38
class UMovieSceneParticleTrackSectionRecorder : public UObject {

    void OnTriggered(UParticleSystemComponent* Component, bool bActivating);
};

// Size: 0x38
class UMovieSceneVisibilitySectionRecorderSettings : public UObject {
    /* 0x0030 */ bool bRecordVisibility;
};

enum class EAllowEditsMode {
    AllEdits = 0,
    AllowSequencerEditsOnly = 1,
    AllowLevelEditsOnly = 2,
    EAllowEditsMode_MAX = 3,
};

enum class EAutoChangeMode {
    AutoKey = 0,
    AutoTrack = 1,
    All = 2,
    None = 3,
    EAutoChangeMode_MAX = 4,
};

enum class EKeyGroupMode {
    KeyChanged = 0,
    KeyGroup = 1,
    KeyAll = 2,
    EKeyGroupMode_MAX = 3,
};

enum class ESequencerLoopMode {
    SLM_NoLoop = 0,
    SLM_Loop = 1,
    SLM_LoopSelectionRange = 2,
    SLM_MAX = 3,
};

enum class ESequencerSectionResizeMode {
    SSRM_LeadingEdge = 0,
    SSRM_TrailingEdge = 1,
    SSRM_MAX = 2,
};

enum class ESequencerSpawnPosition {
    SSP_Origin = 0,
    SSP_PlaceInFrontOfCamera = 1,
    SSP_MAX = 2,
};

enum class ESequencerZoomPosition {
    SZP_CurrentTime = 0,
    SZP_MousePosition = 1,
    SZP_MAX = 2,
};

// Size: 0x180
class UMovieSceneCopyableBinding : public UObject {
    /* 0x0030 */ UObject* SpawnableObjectTemplate;
    /* 0x0038 */ TArray<UMovieSceneTrack*> Tracks;
    /* 0x0048 */ FMovieSceneBinding Binding;
    /* 0x0080 */ FMovieSceneSpawnable Spawnable;
    /* 0x0120 */ FMovieScenePossessable Possessable;
    /* 0x0168 */ TArray<FName> FolderPath;
};

// Size: 0x50
class UMovieSceneCopyableTrack : public UObject {
    /* 0x0030 */ UMovieSceneTrack* Track;
    /* 0x0038 */ bool bIsAMasterTrack;
    /* 0x0040 */ TArray<FName> FolderPath;
};

// Size: 0x190
class UMovieSceneKeyStructType : public UScriptStruct {
    /* 0x00d0 */ FFieldPath SourceTimesProperty;
    /* 0x0100 */ FFieldPath SourceValuesProperty;
    /* 0x0130 */ FFieldPath DestTimeProperty;
    /* 0x0160 */ FFieldPath DestValueProperty;
};

// Size: 0x88
class USequencerExportTask : public UAssetExportTask {
    /* 0x0080 */ UObject* SequencerContext;
};

// Size: 0x318
class ASequencerKeyActor : public AActor {
    /* 0x02f8 */ UStaticMeshComponent* KeyMeshComponent;
    /* 0x0300 */ AActor* AssociatedActor;
    /* 0x0308 */ UMovieScene3DTransformSection* TrackSection;
    /* 0x0310 */ float KeyTime;
};

// Size: 0x338
class ASequencerMeshTrail : public AActor {
};

// Size: 0xf0
class USequencerSettings : public UObject {
    /* 0x0030 */ EAutoChangeMode AutoChangeMode;
    /* 0x0031 */ EAllowEditsMode AllowEditsMode;
    /* 0x0032 */ EKeyGroupMode KeyGroupMode;
    /* 0x0033 */ EMovieSceneKeyInterpolation KeyInterpolation;
    /* 0x0034 */ bool bAutoSetTrackDefaults;
    /* 0x0035 */ uint8_t SpawnPosition;
    /* 0x0036 */ bool bCreateSpawnableCameras;
    /* 0x0037 */ bool bShowRangeSlider;
    /* 0x0038 */ bool bIsSnapEnabled;
    /* 0x0039 */ bool bSnapKeyTimesToInterval;
    /* 0x003a */ bool bSnapKeyTimesToKeys;
    /* 0x003b */ bool bSnapSectionTimesToInterval;
    /* 0x003c */ bool bSnapSectionTimesToSections;
    /* 0x003d */ bool bSnapKeysAndSectionsToPlayRange;
    /* 0x003e */ bool bSnapPlayTimeToKeys;
    /* 0x003f */ bool bSnapPlayTimeToInterval;
    /* 0x0040 */ bool bSnapPlayTimeToPressedKey;
    /* 0x0041 */ bool bSnapPlayTimeToDraggedKey;
    /* 0x0050 */ bool bSnapCurveValueToInterval;
    /* 0x0051 */ bool bShowSelectedNodesOnly;
    /* 0x0052 */ bool bRewindOnRecord;
    /* 0x0053 */ uint8_t ZoomPosition;
    /* 0x0054 */ bool bAutoScrollEnabled;
    /* 0x0055 */ bool bLinkCurveEditorTimeRange;
    /* 0x0056 */ bool bSynchronizeCurveEditorSelection;
    /* 0x0057 */ bool bIsolateCurveEditorToSelection;
    /* 0x0058 */ uint8_t LoopMode;
    /* 0x0059 */ bool bKeepCursorInPlayRangeWhileScrubbing;
    /* 0x005a */ bool bKeepPlayRangeInSectionBounds;
    /* 0x005b */ uint8_t ZeroPadFrames;
    /* 0x005c */ FFrameNumber JumpFrameIncrement;
    /* 0x0060 */ bool bShowCombinedKeyframes;
    /* 0x0061 */ bool bInfiniteKeyAreas;
    /* 0x0062 */ bool bShowChannelColors;
    /* 0x0064 */ float ReduceKeysTolerance;
    /* 0x0068 */ bool bDeleteKeysWhenTrimming;
    /* 0x0069 */ bool bDisableSectionsAfterBaking;
    /* 0x006a */ bool bCleanPlaybackMode;
    /* 0x006b */ bool bActivateRealtimeViewports;
    /* 0x006c */ bool bEvaluateSubSequencesInIsolation;
    /* 0x006d */ bool bRerunConstructionScripts;
    /* 0x006e */ bool bShowDebugVisualization;
    /* 0x006f */ bool bVisualizePreAndPostRoll;
    /* 0x0070 */ bool bCompileDirectorOnEvaluate;
    /* 0x0074 */ uint32_t TrajectoryPathCap;
    /* 0x0078 */ bool bShowOutlinerInfoColumn;
    /* 0x0079 */ EFrameNumberDisplayFormats FrameNumberDisplayFormat;
    /* 0x0080 */ FString MovieRendererName;
};

// Size: 0x30
class USequencerSettingsContainer : public UObject {
};

// Size: 0x30
class USequencerTrackFilterExtension : public UObject {
};

// Size: 0x60
struct FStructSerializerArrayTestStruct {
    /* 0x0000 */ TArray<int32_t> Int32Array;
    /* 0x0010 */ TArray<uint8_t> ByteArray;
    /* 0x0020 */ int32_t StaticSingleElement;
    /* 0x0024 */ int32_t StaticInt32Array[3];
    /* 0x0030 */ float StaticFloatArray[3];
    /* 0x0040 */ TArray<FVector> VectorArray;
    /* 0x0050 */ TArray<FStructSerializerBuiltinTestStruct> StructArray;
};

// Size: 0x3
struct FStructSerializerBooleanTestStruct {
    /* 0x0000 */ bool BoolFalse;
    /* 0x0001 */ bool BoolTrue;
    /* 0x0002 */ bool Bitfield0;
    /* 0x0002 */ bool Bitfield1;
    /* 0x0002 */ bool Bitfield2Set;
    /* 0x0002 */ bool Bitfield3;
    /* 0x0002 */ bool Bitfield4Set;
    /* 0x0002 */ bool Bitfield5Set;
    /* 0x0002 */ bool Bitfield6;
    /* 0x0002 */ bool Bitfield7Set;
};

// Size: 0xa0
struct FStructSerializerBuiltinTestStruct {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ FName Name;
    /* 0x0020 */ FString string;
    /* 0x0030 */ FText text;
    /* 0x0048 */ FVector Vector;
    /* 0x0060 */ FVector4 Vector4;
    /* 0x0070 */ FRotator Rotator;
    /* 0x0080 */ FQuat Quat;
    /* 0x0090 */ FColor Color;
};

// Size: 0x38
struct FStructSerializerByteArray {
    /* 0x0000 */ int32_t Dummy1;
    /* 0x0008 */ TArray<uint8_t> ByteArray;
    /* 0x0018 */ int32_t Dummy2;
    /* 0x0020 */ TArray<int8_t> Int8Array;
    /* 0x0030 */ int32_t Dummy3;
};

// Size: 0x140
struct FStructSerializerMapTestStruct {
    /* 0x0000 */ TMap<int32_t, FString> IntToStr;
    /* 0x0050 */ TMap<FString, FString> StrToStr;
    /* 0x00a0 */ TMap<FString, FVector> StrToVec;
    /* 0x00f0 */ TMap<FString, FStructSerializerBuiltinTestStruct> StrToStruct;
};

// Size: 0x30
struct FStructSerializerNumericTestStruct {
    /* 0x0000 */ int8_t Int8;
    /* 0x0002 */ int16_t Int16;
    /* 0x0004 */ int32_t Int32;
    /* 0x0008 */ int64_t int64;
    /* 0x0010 */ uint8_t UInt8;
    /* 0x0012 */ uint16_t UInt16;
    /* 0x0014 */ uint32_t UInt32;
    /* 0x0018 */ uint64_t UInt64;
    /* 0x0020 */ float float;
    /* 0x0028 */ double Double;
};

// Size: 0xc0
struct FStructSerializerObjectTestStruct {
    /* 0x0000 */ UClass* Class;
    /* 0x0008 */ UClass* SubClass;
    /* 0x0010 */ TSoftClassPtr<UMetaData> softclass;
    /* 0x0040 */ UObject* Object;
    /* 0x0048 */ TWeakObjectPtr<UMetaData> WeakObject;
    /* 0x0050 */ TSoftObjectPtr<UMetaData> softobject;
    /* 0x0080 */ FSoftClassPath ClassPath;
    /* 0x00a0 */ FSoftObjectPath ObjectPath;
};

// Size: 0x140
struct FStructSerializerSetTestStruct {
    /* 0x0000 */ TSet<FString> StrSet;
    /* 0x0050 */ TSet<int32_t> IntSet;
    /* 0x00a0 */ TSet<FName> NameSet;
    /* 0x00f0 */ TSet<FStructSerializerBuiltinTestStruct> StructSet;
};

// Size: 0x480
struct FStructSerializerTestStruct {
    /* 0x0000 */ FStructSerializerNumericTestStruct Numerics;
    /* 0x0030 */ FStructSerializerBooleanTestStruct Booleans;
    /* 0x0038 */ FStructSerializerObjectTestStruct Objects;
    /* 0x0100 */ FStructSerializerBuiltinTestStruct Builtins;
    /* 0x01a0 */ FStructSerializerArrayTestStruct Arrays;
    /* 0x0200 */ FStructSerializerMapTestStruct Maps;
    /* 0x0340 */ FStructSerializerSetTestStruct Sets;
};

// Size: 0x40
struct FSessionServiceLog {
    /* 0x0000 */ FName Category;
    /* 0x0010 */ FString Data;
    /* 0x0020 */ FGuid InstanceId;
    /* 0x0030 */ double TimeSeconds;
    /* 0x0038 */ uint8_t Verbosity;
};

// Size: 0x1
struct FSessionServiceLogSubscribe {
};

// Size: 0x1
struct FSessionServiceLogUnsubscribe {
};

// Size: 0x10
struct FSessionServicePing {
    /* 0x0000 */ FString UserName;
};

// Size: 0x90
struct FSessionServicePong {
    /* 0x0000 */ bool Authorized;
    /* 0x0008 */ FString BuildDate;
    /* 0x0018 */ FString DeviceName;
    /* 0x0028 */ FGuid InstanceId;
    /* 0x0038 */ FString InstanceName;
    /* 0x0048 */ FString PlatformName;
    /* 0x0058 */ FGuid SessionId;
    /* 0x0068 */ FString SessionName;
    /* 0x0078 */ FString SessionOwner;
    /* 0x0088 */ bool Standalone;
};

// Size: 0x130
class USignificanceManager : public UObject {
    /* 0x0110 */ FSoftClassPath SignificanceManagerClassName;
};

// Size: 0x10
struct FAnchors {
    /* 0x0000 */ FVector2D Minimum;
    /* 0x0008 */ FVector2D Maximum;
};

// Size: 0x338
class UButtonWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FButtonStyle ButtonStyle;
};

// Size: 0x6d0
class UCheckBoxWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FCheckBoxStyle CheckBoxStyle;
};

// Size: 0x508
class UComboBoxWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FComboBoxStyle ComboBoxStyle;
};

// Size: 0x4a8
class UComboButtonWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FComboButtonStyle ComboButtonStyle;
};

// Size: 0x1f0
struct FCustomizedToolMenu {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ TMap<FName, FCustomizedToolMenuEntry> Entries;
    /* 0x0060 */ TMap<FName, FCustomizedToolMenuSection> Sections;
    /* 0x00b0 */ TMap<FName, FCustomizedToolMenuNameArray> EntryOrder;
    /* 0x0100 */ TArray<FName> SectionOrder;
};

// Size: 0x4
struct FCustomizedToolMenuEntry {
    /* 0x0000 */ ECustomizedToolMenuVisibility Visibility;
};

// Size: 0x10
struct FCustomizedToolMenuNameArray {
    /* 0x0000 */ TArray<FName> Names;
};

// Size: 0x4
struct FCustomizedToolMenuSection {
    /* 0x0000 */ ECustomizedToolMenuVisibility Visibility;
};

enum class ECustomizedToolMenuVisibility {
    None = 0,
    Visible = 1,
    Hidden = 2,
    ECustomizedToolMenuVisibility_MAX = 3,
};

enum class EDescendantScrollDestination {
    IntoView = 0,
    TopOrLeft = 1,
    Center = 2,
    BottomOrRight = 3,
    EDescendantScrollDestination_MAX = 4,
};

enum class EListItemAlignment {
    EvenlyDistributed = 0,
    EvenlySize = 1,
    EvenlyWide = 2,
    LeftAligned = 3,
    RightAligned = 4,
    CenterAligned = 5,
    Fill = 6,
    EListItemAlignment_MAX = 7,
};

enum class EMultiBlockType {
    None = 0,
    ButtonRow = 1,
    EditableText = 2,
    Heading = 3,
    MenuEntry = 4,
    Separator = 5,
    ToolBarButton = 6,
    ToolBarComboButton = 7,
    Widget = 8,
    EMultiBlockType_MAX = 9,
};

enum class EMultiBoxType {
    MenuBar = 0,
    ToolBar = 1,
    VerticalToolBar = 2,
    UniformToolBar = 3,
    Menu = 4,
    ButtonRow = 5,
    EMultiBoxType_MAX = 6,
};

enum class EMultipleKeyBindingIndex {
    Primary = 0,
    Secondary = 1,
    NumChords = 2,
    EMultipleKeyBindingIndex_MAX = 3,
};

enum class EProgressBarFillType {
    LeftToRight = 0,
    RightToLeft = 1,
    FillFromCenter = 2,
    TopToBottom = 3,
    BottomToTop = 4,
    EProgressBarFillType_MAX = 5,
};

enum class EScrollWhenFocusChanges {
    NoScroll = 0,
    InstantScroll = 1,
    AnimatedScroll = 2,
    EScrollWhenFocusChanges_MAX = 3,
};

enum class ESelectionMode {
    None = 0,
    Single = 1,
    SingleToggle = 2,
    Multi = 3,
    ESelectionMode_MAX = 4,
};

enum class EStretch {
    None = 0,
    Fill = 1,
    ScaleToFit = 2,
    ScaleToFitX = 3,
    ScaleToFitY = 4,
    ScaleToFill = 5,
    ScaleBySafeZone = 6,
    UserSpecified = 7,
    EStretch_MAX = 8,
};

enum class EStretchDirection {
    Both = 0,
    DownOnly = 1,
    UpOnly = 2,
    EStretchDirection_MAX = 3,
};

enum class ETableViewMode {
    List = 0,
    Tile = 1,
    Tree = 2,
    ETableViewMode_MAX = 3,
};

enum class ETextFlowDirection {
    Auto = 0,
    LeftToRight = 1,
    RightToLeft = 2,
    ETextFlowDirection_MAX = 3,
};

enum class ETextJustify {
    Left = 0,
    Center = 1,
    Right = 2,
    ETextJustify_MAX = 3,
};

enum class ETextTransformPolicy {
    None = 0,
    ToLower = 1,
    ToUpper = 2,
    ETextTransformPolicy_MAX = 3,
};

enum class ETextWrappingPolicy {
    DefaultWrapping = 0,
    AllowPerCharacterWrapping = 1,
    ETextWrappingPolicy_MAX = 2,
};

enum class EUserInterfaceActionType {
    None = 0,
    Button = 1,
    ToggleButton = 2,
    RadioButton = 3,
    Check = 4,
    CollapsedButton = 5,
    EUserInterfaceActionType_MAX = 6,
};

enum class EVirtualKeyboardDismissAction {
    TextChangeOnDismiss = 0,
    TextCommitOnAccept = 1,
    TextCommitOnDismiss = 2,
    EVirtualKeyboardDismissAction_MAX = 3,
};

enum class EVirtualKeyboardTrigger {
    OnFocusByPointer = 0,
    OnAllFocusEvents = 1,
    EVirtualKeyboardTrigger_MAX = 2,
};

// Size: 0x978
class UEditableTextBoxWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FEditableTextBoxStyle EditableTextBoxStyle;
};

// Size: 0x2b0
class UEditableTextWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FEditableTextStyle EditableTextStyle;
};

// Size: 0x28
struct FInputChord {
    /* 0x0000 */ FKey Key;
    /* 0x0020 */ bool bShift;
    /* 0x0020 */ bool bCtrl;
    /* 0x0020 */ bool bAlt;
    /* 0x0020 */ bool bCmd;
};

// Size: 0x220
class UProgressWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FProgressBarStyle ProgressBarStyle;
};

// Size: 0x5e0
class UScrollBarWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FScrollBarStyle ScrollBarStyle;
};

// Size: 0x2c0
class UScrollBoxWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FScrollBoxStyle ScrollBoxStyle;
};

// Size: 0x38
class USlateSettings : public UObject {
    /* 0x0030 */ bool bExplicitCanvasChildZOrder;
};

// Size: 0x398
class USpinBoxWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FSpinBoxStyle SpinBoxStyle;
};

// Size: 0x300
class UTextBlockWidgetStyle : public USlateWidgetStyleContainerBase {
    /* 0x0038 */ FTextBlockStyle TextBlockStyle;
};

// Size: 0x30
class UToolMenuBase : public UObject {
};

// Size: 0x1
struct FVirtualKeyboardOptions {
    /* 0x0000 */ bool bEnableAutocorrect;
};

// Size: 0x48
struct FAnalogInputEvent : public FKeyEvent {
};

// Size: 0x300
struct FButtonStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush Normal;
    /* 0x00a8 */ FSlateBrush Hovered;
    /* 0x0148 */ FSlateBrush Pressed;
    /* 0x01e8 */ FSlateBrush Disabled;
    /* 0x0288 */ FMargin NormalPadding;
    /* 0x0298 */ FMargin PressedPadding;
    /* 0x02a8 */ FSlateSound PressedSlateSound;
    /* 0x02c8 */ FSlateSound HoveredSlateSound;
    /* 0x02e8 */ FName PressedSound;
    /* 0x02f4 */ FName HoveredSound;
};

// Size: 0x8
struct FCaptureLostEvent {
};

// Size: 0x20
struct FCharacterEvent : public FInputEvent {
};

// Size: 0x698
struct FCheckBoxStyle : public FSlateWidgetStyle {
    /* 0x0008 */ uint8_t CheckBoxType;
    /* 0x0010 */ FSlateBrush UncheckedImage;
    /* 0x00b0 */ FSlateBrush UncheckedHoveredImage;
    /* 0x0150 */ FSlateBrush UncheckedPressedImage;
    /* 0x01f0 */ FSlateBrush CheckedImage;
    /* 0x0290 */ FSlateBrush CheckedHoveredImage;
    /* 0x0330 */ FSlateBrush CheckedPressedImage;
    /* 0x03d0 */ FSlateBrush UndeterminedImage;
    /* 0x0470 */ FSlateBrush UndeterminedHoveredImage;
    /* 0x0510 */ FSlateBrush UndeterminedPressedImage;
    /* 0x05b0 */ FMargin Padding;
    /* 0x05c0 */ FSlateColor ForegroundColor;
    /* 0x05e8 */ FSlateColor BorderBackgroundColor;
    /* 0x0610 */ FSlateSound CheckedSlateSound;
    /* 0x0630 */ FSlateSound UncheckedSlateSound;
    /* 0x0650 */ FSlateSound HoveredSlateSound;
    /* 0x0670 */ FName CheckedSound;
    /* 0x067c */ FName UncheckedSound;
    /* 0x0688 */ FName HoveredSound;
};

// Size: 0x4d0
struct FComboBoxStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FComboButtonStyle ComboButtonStyle;
    /* 0x0478 */ FSlateSound PressedSlateSound;
    /* 0x0498 */ FSlateSound SelectionChangeSlateSound;
    /* 0x04b8 */ FName PressedSound;
    /* 0x04c4 */ FName SelectionChangeSound;
};

// Size: 0x470
struct FComboButtonStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FButtonStyle ButtonStyle;
    /* 0x0308 */ FSlateBrush DownArrowImage;
    /* 0x03a8 */ FVector2D ShadowOffset;
    /* 0x03b0 */ FLinearColor ShadowColorAndOpacity;
    /* 0x03c0 */ FSlateBrush MenuBorderBrush;
    /* 0x0460 */ FMargin MenuBorderPadding;
};

// Size: 0x18
struct FCompositeFallbackFont {
    /* 0x0000 */ FTypeface Typeface;
    /* 0x0010 */ float ScalingFactor;
};

// Size: 0x40
struct FCompositeFont {
    /* 0x0000 */ FTypeface DefaultTypeface;
    /* 0x0010 */ FCompositeFallbackFont FallbackTypeface;
    /* 0x0028 */ TArray<FCompositeSubFont> SubTypefaces;
};

// Size: 0x48
struct FCompositeSubFont : public FCompositeFallbackFont {
    /* 0x0018 */ TArray<FInt32Range> CharacterRanges;
    /* 0x0028 */ FString Cultures;
    /* 0x0038 */ FName EditorName;
};

// Size: 0x848
struct FDockTabStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FButtonStyle CloseButtonStyle;
    /* 0x0308 */ FSlateBrush NormalBrush;
    /* 0x03a8 */ FSlateBrush ActiveBrush;
    /* 0x0448 */ FSlateBrush ColorOverlayTabBrush;
    /* 0x04e8 */ FSlateBrush ColorOverlayIconBrush;
    /* 0x0588 */ FSlateBrush ForegroundBrush;
    /* 0x0628 */ FSlateBrush HoveredBrush;
    /* 0x06c8 */ FSlateBrush ContentAreaBrush;
    /* 0x0768 */ FSlateBrush TabWellBrush;
    /* 0x0808 */ FMargin TabPadding;
    /* 0x0818 */ float OverlapWidth;
    /* 0x0820 */ FSlateColor FlashColor;
};

enum class EButtonClickMethod {
    DownAndUp = 0,
    MouseDown = 1,
    MouseUp = 2,
    PreciseClick = 3,
    EButtonClickMethod_MAX = 4,
};

enum class EButtonPressMethod {
    DownAndUp = 0,
    ButtonPress = 1,
    ButtonRelease = 2,
    EButtonPressMethod_MAX = 3,
};

enum class EButtonTouchMethod {
    DownAndUp = 0,
    Down = 1,
    PreciseTap = 2,
    EButtonTouchMethod_MAX = 3,
};

enum class ECheckBoxState {
    Unchecked = 0,
    Checked = 1,
    Undetermined = 2,
    ECheckBoxState_MAX = 3,
};

enum class EColorVisionDeficiency {
    NormalVision = 0,
    Deuteranope = 1,
    Protanope = 2,
    Tritanope = 3,
    EColorVisionDeficiency_MAX = 4,
};

enum class EConsumeMouseWheel {
    WhenScrollingPossible = 0,
    Always = 1,
    Never = 2,
    EConsumeMouseWheel_MAX = 3,
};

enum class EFlowDirectionPreference {
    Inherit = 0,
    Culture = 1,
    LeftToRight = 2,
    RightToLeft = 3,
    EFlowDirectionPreference_MAX = 4,
};

enum class EFocusCause {
    Mouse = 0,
    Navigation = 1,
    SetDirectly = 2,
    Cleared = 3,
    OtherWidgetLostFocus = 4,
    WindowActivate = 5,
    EFocusCause_MAX = 6,
};

enum class EFontHinting {
    Default = 0,
    Auto = 1,
    AutoLight = 2,
    Monochrome = 3,
    None = 4,
    EFontHinting_MAX = 5,
};

enum class EFontLayoutMethod {
    Metrics = 0,
    BoundingBox = 1,
    EFontLayoutMethod_MAX = 2,
};

enum class EFontLoadingPolicy {
    LazyLoad = 0,
    Stream = 1,
    Inline = 2,
    EFontLoadingPolicy_MAX = 3,
};

enum class EHorizontalAlignment {
    HAlign_Fill = 0,
    HAlign_Left = 1,
    HAlign_Center = 2,
    HAlign_Right = 3,
    HAlign_MAX = 4,
};

enum class EMenuPlacement {
    MenuPlacement_BelowAnchor = 0,
    MenuPlacement_CenteredBelowAnchor = 1,
    MenuPlacement_BelowRightAnchor = 2,
    MenuPlacement_ComboBox = 3,
    MenuPlacement_ComboBoxRight = 4,
    MenuPlacement_MenuRight = 5,
    MenuPlacement_AboveAnchor = 6,
    MenuPlacement_CenteredAboveAnchor = 7,
    MenuPlacement_AboveRightAnchor = 8,
    MenuPlacement_MenuLeft = 9,
    MenuPlacement_Center = 10,
    MenuPlacement_RightLeftCenter = 11,
    MenuPlacement_MatchBottomLeft = 12,
    MenuPlacement_MAX = 13,
};

enum class ENavigationGenesis {
    Keyboard = 0,
    Controller = 1,
    User = 2,
    ENavigationGenesis_MAX = 3,
};

enum class ENavigationSource {
    FocusedWidget = 0,
    WidgetUnderCursor = 1,
    ENavigationSource_MAX = 2,
};

enum class EOrientation {
    Orient_Horizontal = 0,
    Orient_Vertical = 1,
    Orient_MAX = 2,
};

enum class EScrollDirection {
    Scroll_Down = 0,
    Scroll_Up = 1,
    Scroll_MAX = 2,
};

enum class ESelectInfo {
    OnKeyPress = 0,
    OnNavigation = 1,
    OnMouseClick = 2,
    Direct = 3,
    ESelectInfo_MAX = 4,
};

enum class ESlateBrushDrawType {
    NoDrawType = 0,
    Box = 1,
    Border = 2,
    Image = 3,
    ESlateBrushDrawType_MAX = 4,
};

enum class ESlateBrushImageType {
    NoImage = 0,
    FullColor = 1,
    Linear = 2,
    ESlateBrushImageType_MAX = 3,
};

enum class ESlateBrushMirrorType {
    NoMirror = 0,
    Horizontal = 1,
    Vertical = 2,
    Both = 3,
    ESlateBrushMirrorType_MAX = 4,
};

enum class ESlateBrushTileType {
    NoTile = 0,
    Horizontal = 1,
    Vertical = 2,
    Both = 3,
    ESlateBrushTileType_MAX = 4,
};

enum class ESlateCheckBoxType {
    CheckBox = 0,
    ToggleButton = 1,
    ESlateCheckBoxType_MAX = 2,
};

enum class ESlateColorStylingMode {
    UseColor_Specified = 0,
    UseColor_Specified_Link = 1,
    UseColor_Foreground = 2,
    UseColor_Foreground_Subdued = 3,
    UseColor_MAX = 4,
};

enum class ESlateDebuggingFocusEvent {
    FocusChanging = 0,
    FocusLost = 1,
    FocusReceived = 2,
    MAX = 3,
};

enum class ESlateDebuggingInputEvent {
    MouseMove = 0,
    MouseEnter = 1,
    MouseLeave = 2,
    PreviewMouseButtonDown = 3,
    MouseButtonDown = 4,
    MouseButtonUp = 5,
    MouseButtonDoubleClick = 6,
    MouseWheel = 7,
    TouchStart = 8,
    TouchEnd = 9,
    TouchForceChanged = 10,
    TouchFirstMove = 11,
    TouchMoved = 12,
    DragDetected = 13,
    DragEnter = 14,
    DragLeave = 15,
    DragOver = 16,
    DragDrop = 17,
    DropMessage = 18,
    PreviewKeyDown = 19,
    KeyDown = 20,
    KeyUp = 21,
    KeyChar = 22,
    AnalogInput = 23,
    TouchGesture = 24,
    MotionDetected = 25,
    MAX = 26,
};

enum class ESlateDebuggingNavigationMethod {
    Unknown = 0,
    Explicit = 1,
    CustomDelegateBound = 2,
    CustomDelegateUnbound = 3,
    NextOrPrevious = 4,
    HitTestGrid = 5,
    ESlateDebuggingNavigationMethod_MAX = 6,
};

enum class ESlateDebuggingStateChangeEvent {
    MouseCaptureGained = 0,
    MouseCaptureLost = 1,
    ESlateDebuggingStateChangeEvent_MAX = 2,
};

enum class ESlateParentWindowSearchMethod {
    ActiveWindow = 0,
    MainWindow = 1,
    ESlateParentWindowSearchMethod_MAX = 2,
};

enum class ETextCommit {
    Default = 0,
    OnEnter = 1,
    OnUserMovedFocus = 2,
    OnCleared = 3,
    ETextCommit_MAX = 4,
};

enum class ETextShapingMethod {
    Auto = 0,
    KerningOnly = 1,
    FullShaping = 2,
    ETextShapingMethod_MAX = 3,
};

enum class EUINavigation {
    Left = 0,
    Right = 1,
    Up = 2,
    Down = 3,
    Next = 4,
    Previous = 5,
    Num = 6,
    Invalid = 7,
    EUINavigation_MAX = 8,
};

enum class EUINavigationAction {
    Accept = 0,
    Back = 1,
    Num = 2,
    Invalid = 3,
    EUINavigationAction_MAX = 4,
};

enum class EUINavigationRule {
    Escape = 0,
    Explicit = 1,
    Wrap = 2,
    Stop = 3,
    Custom = 4,
    CustomBoundary = 5,
    Invalid = 6,
    EUINavigationRule_MAX = 7,
};

enum class EVerticalAlignment {
    VAlign_Fill = 0,
    VAlign_Top = 1,
    VAlign_Center = 2,
    VAlign_Bottom = 3,
    VAlign_MAX = 4,
};

enum class EWidgetClipping {
    Inherit = 0,
    ClipToBounds = 1,
    ClipToBoundsWithoutIntersecting = 2,
    ClipToBoundsAlways = 3,
    OnDemand = 4,
    EWidgetClipping_MAX = 5,
};

// Size: 0x940
struct FEditableTextBoxStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush BackgroundImageNormal;
    /* 0x00a8 */ FSlateBrush BackgroundImageHovered;
    /* 0x0148 */ FSlateBrush BackgroundImageFocused;
    /* 0x01e8 */ FSlateBrush BackgroundImageReadOnly;
    /* 0x0288 */ FMargin Padding;
    /* 0x0298 */ FSlateFontInfo Font;
    /* 0x0300 */ FSlateColor ForegroundColor;
    /* 0x0328 */ FSlateColor BackgroundColor;
    /* 0x0350 */ FSlateColor ReadOnlyForegroundColor;
    /* 0x0378 */ FMargin HScrollBarPadding;
    /* 0x0388 */ FMargin VScrollBarPadding;
    /* 0x0398 */ FScrollBarStyle ScrollBarStyle;
};

// Size: 0x278
struct FEditableTextStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateFontInfo Font;
    /* 0x0070 */ FSlateColor ColorAndOpacity;
    /* 0x0098 */ FSlateBrush BackgroundImageSelected;
    /* 0x0138 */ FSlateBrush BackgroundImageComposing;
    /* 0x01d8 */ FSlateBrush CaretImage;
};

// Size: 0x150
struct FExpandableAreaStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush CollapsedImage;
    /* 0x00a8 */ FSlateBrush ExpandedImage;
    /* 0x0148 */ float RolloutAnimationSeconds;
};

// Size: 0x8
struct FFocusEvent {
};

// Size: 0xf0
class UFontBulkData : public UObject {
};

// Size: 0x38
struct FFontData {
    /* 0x0000 */ FString FontFilename;
    /* 0x0010 */ EFontHinting Hinting;
    /* 0x0011 */ EFontLoadingPolicy LoadingPolicy;
    /* 0x0014 */ int32_t SubFaceIndex;
    /* 0x0018 */ UObject* FontFaceAsset;
    /* 0x0020 */ UFontBulkData* BulkDataPtr;
    /* 0x0028 */ TArray<uint8_t> FontData;
};

// Size: 0x30
class IFontFaceInterface : public UInterface {
};

// Size: 0x20
struct FFontOutlineSettings {
    /* 0x0000 */ int32_t OutlineSize;
    /* 0x0004 */ bool bSeparateFillAlpha;
    /* 0x0005 */ bool bApplyOutlineToDropShadows;
    /* 0x0008 */ UObject* OutlineMaterial;
    /* 0x0010 */ FLinearColor OutlineColor;
};

// Size: 0x30
class IFontProviderInterface : public UInterface {
};

// Size: 0x38
struct FGeometry {
};

// Size: 0xd68
struct FHeaderRowStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FTableColumnHeaderStyle ColumnStyle;
    /* 0x05b0 */ FTableColumnHeaderStyle LastColumnStyle;
    /* 0x0b58 */ FSplitterStyle ColumnSplitterStyle;
    /* 0x0ca0 */ FSlateBrush BackgroundBrush;
    /* 0x0d40 */ FSlateColor ForegroundColor;
};

// Size: 0x5e0
struct FHyperlinkStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FButtonStyle UnderlineStyle;
    /* 0x0308 */ FTextBlockStyle TextStyle;
    /* 0x05d0 */ FMargin Padding;
};

// Size: 0xc10
struct FInlineEditableTextBlockStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FEditableTextBoxStyle EditableTextBoxStyle;
    /* 0x0948 */ FTextBlockStyle TextStyle;
};

// Size: 0xb0
struct FInlineTextImageStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush Image;
    /* 0x00a8 */ int16_t Baseline;
};

// Size: 0x18
struct FInputEvent {
};

// Size: 0x40
struct FKeyEvent : public FInputEvent {
};

// Size: 0x10
struct FMargin {
    /* 0x0000 */ float Left;
    /* 0x0004 */ float Top;
    /* 0x0008 */ float Right;
    /* 0x000c */ float Bottom;
};

// Size: 0x48
struct FMotionEvent : public FInputEvent {
};

// Size: 0x20
struct FNavigationEvent : public FInputEvent {
};

// Size: 0x78
struct FPointerEvent : public FInputEvent {
};

// Size: 0x1e8
struct FProgressBarStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush BackgroundImage;
    /* 0x00a8 */ FSlateBrush FillImage;
    /* 0x0148 */ FSlateBrush MarqueeImage;
};

// Size: 0x5a8
struct FScrollBarStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush HorizontalBackgroundImage;
    /* 0x00a8 */ FSlateBrush VerticalBackgroundImage;
    /* 0x0148 */ FSlateBrush VerticalTopSlotImage;
    /* 0x01e8 */ FSlateBrush HorizontalTopSlotImage;
    /* 0x0288 */ FSlateBrush VerticalBottomSlotImage;
    /* 0x0328 */ FSlateBrush HorizontalBottomSlotImage;
    /* 0x03c8 */ FSlateBrush NormalThumbImage;
    /* 0x0468 */ FSlateBrush HoveredThumbImage;
    /* 0x0508 */ FSlateBrush DraggedThumbImage;
};

// Size: 0x148
struct FScrollBorderStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush TopShadowBrush;
    /* 0x00a8 */ FSlateBrush BottomShadowBrush;
};

// Size: 0x288
struct FScrollBoxStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush TopShadowBrush;
    /* 0x00a8 */ FSlateBrush BottomShadowBrush;
    /* 0x0148 */ FSlateBrush LeftShadowBrush;
    /* 0x01e8 */ FSlateBrush RightShadowBrush;
};

// Size: 0xc48
struct FSearchBoxStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FEditableTextBoxStyle TextBoxStyle;
    /* 0x0948 */ FSlateFontInfo ActiveFontInfo;
    /* 0x09b0 */ FSlateBrush UpArrowImage;
    /* 0x0a50 */ FSlateBrush DownArrowImage;
    /* 0x0af0 */ FSlateBrush GlassImage;
    /* 0x0b90 */ FSlateBrush ClearImage;
    /* 0x0c30 */ FMargin ImagePadding;
    /* 0x0c40 */ bool bLeftAlignButtons;
};

// Size: 0xa0
struct FSlateBrush {
    /* 0x0008 */ FVector2D ImageSize;
    /* 0x0010 */ FMargin Margin;
    /* 0x0020 */ FLinearColor Tint;
    /* 0x0030 */ FSlateColor TintColor;
    /* 0x0058 */ UObject* ResourceObject;
    /* 0x0060 */ FName ResourceName;
    /* 0x006c */ FBox2D UVRegion;
    /* 0x0080 */ uint8_t DrawAs;
    /* 0x0081 */ uint8_t Tiling;
    /* 0x0082 */ uint8_t Mirroring;
    /* 0x0083 */ uint8_t ImageType;
    /* 0x0098 */ bool bIsDynamicallyLoaded;
    /* 0x0098 */ bool bHasUObject;
};

// Size: 0x28
struct FSlateColor {
    /* 0x0000 */ FLinearColor SpecifiedColor;
    /* 0x0010 */ uint8_t ColorUseRule;
};

// Size: 0x68
struct FSlateFontInfo {
    /* 0x0000 */ UObject* FontObject;
    /* 0x0008 */ UObject* FontMaterial;
    /* 0x0010 */ FFontOutlineSettings OutlineSettings;
    /* 0x0040 */ FName TypefaceFontName;
    /* 0x004c */ int32_t Size;
    /* 0x0050 */ int32_t LetterSpacing;
    /* 0x0058 */ FName FontName;
    /* 0x0064 */ EFontHinting Hinting;
};

// Size: 0x20
struct FSlateSound {
    /* 0x0000 */ UObject* ResourceObject;
};

// Size: 0x30
class USlateTypes : public UObject {
};

// Size: 0x8
struct FSlateWidgetStyle {
};

// Size: 0x38
class USlateWidgetStyleAsset : public UObject {
    /* 0x0030 */ USlateWidgetStyleContainerBase* CustomStyle;
};

// Size: 0x38
class USlateWidgetStyleContainerBase : public UObject {
};

// Size: 0x30
class ISlateWidgetStyleContainerInterface : public UInterface {
};

// Size: 0x3d0
struct FSliderStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush NormalBarImage;
    /* 0x00a8 */ FSlateBrush HoveredBarImage;
    /* 0x0148 */ FSlateBrush DisabledBarImage;
    /* 0x01e8 */ FSlateBrush NormalThumbImage;
    /* 0x0288 */ FSlateBrush HoveredThumbImage;
    /* 0x0328 */ FSlateBrush DisabledThumbImage;
    /* 0x03c8 */ float BarThickness;
};

// Size: 0x360
struct FSpinBoxStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush BackgroundBrush;
    /* 0x00a8 */ FSlateBrush HoveredBackgroundBrush;
    /* 0x0148 */ FSlateBrush ActiveFillBrush;
    /* 0x01e8 */ FSlateBrush InactiveFillBrush;
    /* 0x0288 */ FSlateBrush ArrowsImage;
    /* 0x0328 */ FSlateColor ForegroundColor;
    /* 0x0350 */ FMargin TextPadding;
};

// Size: 0x148
struct FSplitterStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush HandleNormalBrush;
    /* 0x00a8 */ FSlateBrush HandleHighlightBrush;
};

// Size: 0x5a8
struct FTableColumnHeaderStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush SortPrimaryAscendingImage;
    /* 0x00a8 */ FSlateBrush SortPrimaryDescendingImage;
    /* 0x0148 */ FSlateBrush SortSecondaryAscendingImage;
    /* 0x01e8 */ FSlateBrush SortSecondaryDescendingImage;
    /* 0x0288 */ FSlateBrush NormalBrush;
    /* 0x0328 */ FSlateBrush HoveredBrush;
    /* 0x03c8 */ FSlateBrush MenuDropdownImage;
    /* 0x0468 */ FSlateBrush MenuDropdownNormalBorderBrush;
    /* 0x0508 */ FSlateBrush MenuDropdownHoveredBorderBrush;
};

// Size: 0x918
struct FTableRowStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush SelectorFocusedBrush;
    /* 0x00a8 */ FSlateBrush ActiveHoveredBrush;
    /* 0x0148 */ FSlateBrush ActiveBrush;
    /* 0x01e8 */ FSlateBrush InactiveHoveredBrush;
    /* 0x0288 */ FSlateBrush InactiveBrush;
    /* 0x0328 */ FSlateBrush EvenRowBackgroundHoveredBrush;
    /* 0x03c8 */ FSlateBrush EvenRowBackgroundBrush;
    /* 0x0468 */ FSlateBrush OddRowBackgroundHoveredBrush;
    /* 0x0508 */ FSlateBrush OddRowBackgroundBrush;
    /* 0x05a8 */ FSlateColor TextColor;
    /* 0x05d0 */ FSlateColor SelectedTextColor;
    /* 0x05f8 */ FSlateBrush DropIndicator_Above;
    /* 0x0698 */ FSlateBrush DropIndicator_Onto;
    /* 0x0738 */ FSlateBrush DropIndicator_Below;
    /* 0x07d8 */ FSlateBrush ActiveHighlightedBrush;
    /* 0x0878 */ FSlateBrush InactiveHighlightedBrush;
};

// Size: 0x2c8
struct FTextBlockStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateFontInfo Font;
    /* 0x0070 */ FSlateColor ColorAndOpacity;
    /* 0x0098 */ FVector2D ShadowOffset;
    /* 0x00a0 */ FLinearColor ShadowColorAndOpacity;
    /* 0x00b0 */ FSlateColor SelectedBackgroundColor;
    /* 0x00d8 */ FLinearColor HighlightColor;
    /* 0x00e8 */ FSlateBrush HighlightShape;
    /* 0x0188 */ FSlateBrush StrikeBrush;
    /* 0x0228 */ FSlateBrush UnderlineBrush;
};

// Size: 0x10
struct FTypeface {
    /* 0x0000 */ TArray<FTypefaceEntry> Fonts;
};

// Size: 0x48
struct FTypefaceEntry {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ FFontData Font;
};

// Size: 0x6f8
struct FVolumeControlStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSliderStyle SliderStyle;
    /* 0x03d8 */ FSlateBrush HighVolumeImage;
    /* 0x0478 */ FSlateBrush MidVolumeImage;
    /* 0x0518 */ FSlateBrush LowVolumeImage;
    /* 0x05b8 */ FSlateBrush NoVolumeImage;
    /* 0x0658 */ FSlateBrush MutedImage;
};

// Size: 0x1380
struct FWindowStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FButtonStyle MinimizeButtonStyle;
    /* 0x0308 */ FButtonStyle MaximizeButtonStyle;
    /* 0x0608 */ FButtonStyle RestoreButtonStyle;
    /* 0x0908 */ FButtonStyle CloseButtonStyle;
    /* 0x0c08 */ FTextBlockStyle TitleTextStyle;
    /* 0x0ed0 */ FSlateBrush ActiveTitleBrush;
    /* 0x0f70 */ FSlateBrush InactiveTitleBrush;
    /* 0x1010 */ FSlateBrush FlashTitleBrush;
    /* 0x10b0 */ FSlateColor BackgroundColor;
    /* 0x10d8 */ FSlateBrush OutlineBrush;
    /* 0x1178 */ FSlateColor OutlineColor;
    /* 0x11a0 */ FSlateBrush BorderBrush;
    /* 0x1240 */ FSlateBrush BackgroundBrush;
    /* 0x12e0 */ FSlateBrush ChildBackgroundBrush;
};

// Size: 0x20
struct FWidgetSnapshotRequest {
    /* 0x0000 */ FGuid TargetInstanceId;
    /* 0x0010 */ FGuid SnapshotRequestId;
};

// Size: 0x20
struct FWidgetSnapshotResponse {
    /* 0x0000 */ FGuid SnapshotRequestId;
    /* 0x0010 */ TArray<uint8_t> SnapshotData;
};

// Size: 0x38
class UAmbisonicsEncodingSettings : public USoundfieldEncodingSettingsBase {
    /* 0x0030 */ int32_t AmbisonicsOrder;
};

// Size: 0x40
class USourceCodeAccessSettings : public UObject {
    /* 0x0030 */ FString PreferredAccessor;
};

// Size: 0x30
class USourceControlHelpers : public UObject {

    static bool CheckInFile(FString InFile, FString InDescription, bool bSilent);
    static bool CheckInFiles(const TArray<FString>& InFiles, FString InDescription, bool bSilent);
    static bool CheckOutFile(FString InFile, bool bSilent);
    static bool CheckOutFiles(const TArray<FString>& InFiles, bool bSilent);
    static bool CheckOutOrAddFile(FString InFile, bool bSilent);
    static bool CheckOutOrAddFiles(const TArray<FString>& InFiles, bool bSilent);
    static bool CopyFile(FString InSourceFile, FString InDestFile, bool bSilent);
    static FString CurrentProvider();
    static bool IsAvailable();
    static bool IsEnabled();
    static FText LastErrorMsg();
    static bool MarkFileForAdd(FString InFile, bool bSilent);
    static bool MarkFileForDelete(FString InFile, bool bSilent);
    static bool MarkFilesForAdd(const TArray<FString>& InFiles, bool bSilent);
    static bool MarkFilesForDelete(const TArray<FString>& InFiles, bool bSilent);
    static FSourceControlState QueryFileState(FString InFile, bool bSilent);
    static bool RevertFile(FString InFile, bool bSilent);
    static bool RevertFiles(const TArray<FString>& InFiles, bool bSilent);
    static bool RevertUnchangedFile(FString InFile, bool bSilent);
    static bool RevertUnchangedFiles(const TArray<FString>& InFiles, bool bSilent);
    static bool SyncFile(FString InFile, bool bSilent);
    static bool SyncFiles(const TArray<FString>& InFiles, bool bSilent);
};

// Size: 0x38
struct FSourceControlState {
    /* 0x0000 */ FString Filename;
    /* 0x0010 */ bool bIsValid;
    /* 0x0011 */ bool bIsUnknown;
    /* 0x0012 */ bool bCanCheckIn;
    /* 0x0013 */ bool bCanCheckOut;
    /* 0x0014 */ bool bIsCheckedOut;
    /* 0x0015 */ bool bIsCurrent;
    /* 0x0016 */ bool bIsSourceControlled;
    /* 0x0017 */ bool bIsAdded;
    /* 0x0018 */ bool bIsDeleted;
    /* 0x0019 */ bool bIsIgnored;
    /* 0x001a */ bool bCanEdit;
    /* 0x001b */ bool bCanDelete;
    /* 0x001c */ bool bIsModified;
    /* 0x001d */ bool bCanAdd;
    /* 0x001e */ bool bIsConflicted;
    /* 0x001f */ bool bCanRevert;
    /* 0x0020 */ bool bIsCheckedOutOther;
    /* 0x0028 */ FString CheckedOutOther;
};

enum class EImportGeometryType {
    IGT_3D = 0,
    IGT_Billboards = 1,
    IGT_Both = 2,
    IGT_MAX = 3,
};

enum class EImportLODType {
    ILT_PaintedFoliage = 0,
    ILT_IndividualActors = 1,
    ILT_MAX = 2,
};

// Size: 0x108
class UReimportSpeedTreeFactory : public USpeedTreeImportFactory {
};

// Size: 0x70
class USpeedTreeImportData : public UAssetImportData {
    /* 0x0060 */ float TreeScale;
    /* 0x0064 */ uint8_t ImportGeometryType;
    /* 0x0065 */ uint8_t LODType;
    /* 0x0068 */ bool IncludeCollision;
    /* 0x0068 */ bool MakeMaterialsCheck;
    /* 0x0068 */ bool IncludeNormalMapCheck;
    /* 0x0068 */ bool IncludeDetailMapCheck;
    /* 0x0068 */ bool IncludeSpecularMapCheck;
    /* 0x0068 */ bool IncludeBranchSeamSmoothing;
    /* 0x0068 */ bool IncludeSpeedTreeAO;
    /* 0x0068 */ bool IncludeColorAdjustment;
    /* 0x0069 */ bool IncludeSubsurface;
    /* 0x0069 */ bool IncludeVertexProcessingCheck;
    /* 0x0069 */ bool IncludeWindCheck;
    /* 0x0069 */ bool IncludeSmoothLODCheck;
};

// Size: 0xe8
class USpeedTreeImportFactory : public UFactory {
};

// Size: 0x398
class UStaticMeshDescription : public UMeshDescriptionBase {

    void CreateCube(FVector Center, FVector HalfExtents, FPolygonGroupID PolygonGroup, FPolygonID& PolygonID_PlusX, FPolygonID& PolygonID_MinusX, FPolygonID& PolygonID_PlusY, FPolygonID& PolygonID_MinusY, FPolygonID& PolygonID_PlusZ, FPolygonID& PolygonID_MinusZ);
    FVector2D GetVertexInstanceUV(FVertexInstanceID VertexInstanceID, int32_t UVIndex) const;
    void SetPolygonGroupMaterialSlotName(FPolygonGroupID PolygonGroupID, const FName& SlotName);
    void SetVertexInstanceUV(FVertexInstanceID VertexInstanceID, FVector2D UV, int32_t UVIndex);
};

// Size: 0x38
struct FUVMapSettings {
    /* 0x0000 */ FVector Size;
    /* 0x000c */ FVector2D UVTile;
    /* 0x0014 */ FVector Position;
    /* 0x0020 */ FRotator Rotation;
    /* 0x002c */ FVector Scale;
};

// Size: 0x58
class UCookerStats : public UObject {
    /* 0x0030 */ TArray<TWeakObjectPtr<UObject>> Assets;
    /* 0x0040 */ float SizeBefore;
    /* 0x0044 */ float SizeAfter;
    /* 0x0048 */ FString Path;
};

enum class ECookerStatsObjectSets {
    CookerStatsObjectSets_Default = 0,
    CookerStatsObjectSets_MAX = 1,
};

enum class ELightingBuildInfoObjectSets {
    LightingBuildInfoObjectSets_Default = 0,
    LightingBuildInfoObjectSets_MAX = 1,
};

enum class EPrimitiveObjectSets {
    PrimitiveObjectSets_AllObjects = 0,
    PrimitiveObjectSets_CurrentLevel = 1,
    PrimitiveObjectSets_SelectedObjects = 2,
    PrimitiveObjectSets_MAX = 3,
};

enum class EShaderCookerStatsSets {
    EShaderCookerStatsSets_Default = 0,
    EShaderCookerStatsSets_MAX = 1,
};

enum class EStaticMeshLightingInfoObjectSets {
    StaticMeshLightingInfoObjectSets_CurrentLevel = 0,
    StaticMeshLightingInfoObjectSets_SelectedLevels = 1,
    StaticMeshLightingInfoObjectSets_AllLevels = 2,
    StaticMeshLightingInfoObjectSets_MAX = 3,
};

enum class ETextureObjectSets {
    TextureObjectSet_CurrentStreamingLevel = 0,
    TextureObjectSet_AllStreamingLevels = 1,
    TextureObjectSet_SelectedActors = 2,
    TextureObjectSet_SelectedMaterials = 3,
    TextureObjectSet_MAX = 4,
};

// Size: 0x58
class ULightingBuildInfo : public UObject {
    /* 0x0030 */ TWeakObjectPtr<UObject> Object;
    /* 0x0038 */ float LightingTime;
    /* 0x003c */ float UnmappedTexelsPercentage;
    /* 0x0040 */ float UnmappedTexelsMemory;
    /* 0x0044 */ float TotalTexelMemory;
    /* 0x0048 */ FString LevelName;
};

// Size: 0xa0
class UPrimitiveStats : public UObject {
    /* 0x0030 */ TWeakObjectPtr<UObject> Object;
    /* 0x0038 */ TArray<TWeakObjectPtr<AActor>> Actors;
    /* 0x0048 */ FString Type;
    /* 0x0058 */ int32_t Count;
    /* 0x005c */ int32_t Sections;
    /* 0x0060 */ int32_t HWInstances;
    /* 0x0064 */ int32_t InstSections;
    /* 0x0068 */ int32_t Triangles;
    /* 0x006c */ int32_t InstTriangles;
    /* 0x0070 */ float ResourceSize;
    /* 0x0074 */ float VertexColorMem;
    /* 0x0078 */ float InstVertexColorMem;
    /* 0x007c */ int32_t LightsLM;
    /* 0x0080 */ float LightsOther;
    /* 0x0084 */ float LightsTotal;
    /* 0x0088 */ float ObjLightCost;
    /* 0x008c */ float LightMapData;
    /* 0x0090 */ float LMSMResolution;
    /* 0x0094 */ float RadiusMin;
    /* 0x0098 */ float RadiusMax;
    /* 0x009c */ float RadiusAvg;
};

// Size: 0x88
class UShaderCookerStats : public UObject {
    /* 0x0030 */ FString Name;
    /* 0x0040 */ FString Platform;
    /* 0x0050 */ FString Category;
    /* 0x0060 */ int32_t Compiled;
    /* 0x0064 */ int32_t Cooked;
    /* 0x0068 */ int32_t Permutations;
    /* 0x006c */ float CompileTime;
    /* 0x0070 */ FString Path;
};

// Size: 0x88
class UStaticMeshLightingInfo : public UObject {
    /* 0x0030 */ TWeakObjectPtr<AActor> StaticMeshActor;
    /* 0x0038 */ TWeakObjectPtr<UStaticMesh> StaticMesh;
    /* 0x0040 */ FString LevelName;
    /* 0x0058 */ FString TextureMapping;
    /* 0x0068 */ bool bTextureMapping;
    /* 0x0069 */ bool bHasLightmapTexCoords;
    /* 0x006c */ int32_t StaticLightingResolution;
    /* 0x0070 */ float TextureLightMapMemoryUsage;
    /* 0x0074 */ float VertexLightMapMemoryUsage;
    /* 0x0078 */ int32_t LightMapLightCount;
    /* 0x007c */ float TextureShadowMapMemoryUsage;
    /* 0x0080 */ float VertexShadowMapMemoryUsage;
    /* 0x0084 */ int32_t ShadowMapLightCount;
};

// Size: 0x90
class UTextureStats : public UObject {
    /* 0x0030 */ TWeakObjectPtr<UTexture> Texture;
    /* 0x0038 */ TArray<TWeakObjectPtr<AActor>> Actors;
    /* 0x0048 */ FString Type;
    /* 0x0058 */ FVector2D MaxDim;
    /* 0x0060 */ FVector2D CurrentDim;
    /* 0x0068 */ uint8_t Format;
    /* 0x0069 */ uint8_t Group;
    /* 0x006c */ int32_t LODBias;
    /* 0x0070 */ float CurrentKB;
    /* 0x0074 */ float FullyLoadedKB;
    /* 0x0078 */ int32_t NumUses;
    /* 0x007c */ float LastTimeRendered;
    /* 0x0080 */ FString Path;
};

enum class ESteamVRTrackedDeviceType {
    Controller = 0,
    TrackingReference = 1,
    Other = 2,
    Invalid = 3,
    ESteamVRTrackedDeviceType_MAX = 4,
};

// Size: 0xe8
class USteamVRChaperoneComponent : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate OnLeaveBounds;
    /* 0x00d0 */ FMulticastInlineDelegate OnReturnToBounds;

    TArray<FVector> GetBounds() const;
    void SteamVRChaperoneEvent__DelegateSignature();
};

// Size: 0x30
class USteamVRFunctionLibrary : public UBlueprintFunctionLibrary {

    static bool GetHandPositionAndOrientation(int32_t ControllerIndex, EControllerHand hand, FVector& OutPosition, FRotator& OutOrientation);
    static bool GetTrackedDevicePositionAndOrientation(int32_t DeviceID, FVector& OutPosition, FRotator& OutOrientation);
    static void GetValidTrackedDeviceIds(ESteamVRTrackedDeviceType DeviceType, TArray<int32_t>& OutTrackedDeviceIds);
};

// Size: 0x40
class USteamVRHQStereoLayerShape : public UStereoLayerShapeQuad {
    /* 0x0030 */ bool bCurved;
    /* 0x0031 */ bool bAntiAlias;
    /* 0x0034 */ float AutoCurveMinDistance;
    /* 0x0038 */ float AutoCurveMaxDistance;

    void SetAntiAlias(bool InAntiAlias);
    void SetAutoCurveMaxDistance(float InDistance);
    void SetAutoCurveMinDistance(float InDistance);
    void SetCurved(bool InCurved);
};

// Size: 0x790
class UAnimGraphNode_SteamVRInputAnimPose : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_SteamVRInputAnimPose Node;
};

// Size: 0x1c0
class UAnimGraphNode_SteamVRSetWristTransform : public UAnimGraphNode_Base {
    /* 0x0170 */ FAnimNode_SteamVRSetWristTransform Node;
};

// Size: 0x38
class USteamVREditorSettings : public UObject {
    /* 0x0030 */ bool bShowSteamVrInputToolbarButton;
};

// Size: 0x620
struct FAnimNode_SteamVRInputAnimPose : public FAnimNode_Base {
    /* 0x0010 */ EMotionRange MotionRange;
    /* 0x0011 */ EHand hand;
    /* 0x0012 */ EHandSkeleton HandSkeleton;
    /* 0x0013 */ bool Mirror;
    /* 0x0020 */ FSteamVRSkeletonTransform SteamVRSkeletalTransform;
    /* 0x05f0 */ FUE4RetargettingRefs UE4RetargettingRefs;
};

// Size: 0x50
struct FAnimNode_SteamVRSetWristTransform : public FAnimNode_Base {
    /* 0x0010 */ FPoseLink ReferencePose;
    /* 0x0028 */ EHandSkeleton HandSkeleton;
    /* 0x0030 */ FPoseLink TargetPose;
};

enum class EControllerFidelity {
    VR_ControllerFidelity_Estimated = 0,
    VR_ControllerFidelity_Full = 1,
    VR_ControllerFidelity_Partial = 2,
    VR_ControllerFidelity_MAX = 3,
};

enum class EHand {
    VR_LeftHand = 0,
    VR_RightHand = 1,
    VR_MAX = 2,
};

enum class EHandSkeleton {
    VR_SteamVRHandSkeleton = 0,
    VR_UE4HandSkeleton = 1,
    VR_MAX = 2,
};

enum class EMotionRange {
    VR_WithoutController = 0,
    VR_WithController = 1,
    VR_MAX = 2,
};

enum class ESkeletalSummaryDataType {
    VR_SummaryType_FromAnimation = 0,
    VR_SummaryType_FromDevice = 1,
    VR_SummaryType_MAX = 2,
};

enum class ESteamVRHand {
    VR_Left = 0,
    VR_Right = 1,
    VR_MAX = 2,
};

enum class ESteamVRInputStringBits {
    VR_InputString_Hand = 0,
    VR_InputString_ControllerType = 1,
    VR_InputString_InputSource = 2,
    VR_InputString_All = 3,
    VR_InputString_MAX = 4,
};

// Size: 0x30
struct FSteamVRAction {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ FString Path;
};

// Size: 0x18
struct FSteamVRActionSet {
    /* 0x0000 */ FString Path;
};

// Size: 0x14
struct FSteamVRFingerCurls {
    /* 0x0000 */ float Thumb;
    /* 0x0004 */ float index;
    /* 0x0008 */ float Middle;
    /* 0x000c */ float Ring;
    /* 0x0010 */ float Pinky;
};

// Size: 0x10
struct FSteamVRFingerSplays {
    /* 0x0000 */ float Thumb_Index;
    /* 0x0004 */ float Index_Middle;
    /* 0x0008 */ float Middle_Ring;
    /* 0x000c */ float Ring_Pinky;
};

// Size: 0x30
struct FSteamVRInputBindingInfo {
    /* 0x0000 */ FName DevicePathName;
    /* 0x000c */ FName InputPathName;
    /* 0x0018 */ FName ModeName;
    /* 0x0024 */ FName SlotName;
};

// Size: 0x30
class USteamVRInputDeviceFunctionLibrary : public UBlueprintFunctionLibrary {

    static void FindSteamVR_Action(FName ActionName, bool& bResult, FSteamVRAction& FoundAction, FSteamVRActionSet& FoundActionSet, FName ActionSet);
    static bool FindSteamVR_ActionOrigin(FName ActionName, FName ActionSet);
    static TArray<FSteamVRInputBindingInfo> FindSteamVR_InputBindingInfo(FName ActionName, FName ActionSet);
    static void FindSteamVR_OriginTrackedDeviceInfo(FName ActionName, bool& bResult, FSteamVRInputOriginInfo& InputOriginInfo, FName ActionSet);
    static void GetControllerFidelity(EControllerFidelity& LeftControllerFidelity, EControllerFidelity& RightControllerFidelity);
    static void GetCurlsAndSplaysState(bool& LeftHandState, bool& RightHandState);
    static void GetFingerCurlsAndSplays(EHand hand, FSteamVRFingerCurls& FingerCurls, FSteamVRFingerSplays& FingerSplays, ESkeletalSummaryDataType SummaryDataType);
    static void GetLeftHandPoseData(FVector& Position, FRotator& Orientation, FVector& AngularVelocity, FVector& Velocity);
    static void GetPoseSource(bool& bUsingSkeletonPose);
    static void GetRightHandPoseData(FVector& Position, FRotator& Orientation, FVector& AngularVelocity, FVector& Velocity);
    static void GetSkeletalState(bool& LeftHandState, bool& RightHandState);
    static void GetSkeletalTransform(FSteamVRSkeletonTransform& LeftHand, FSteamVRSkeletonTransform& RightHand, bool bWithController);
    static void GetSteamVR_ActionArray(TArray<FSteamVRAction>& SteamVRActions);
    static void GetSteamVR_ActionSetArray(TArray<FSteamVRActionSet>& SteamVRActionSets);
    static float GetSteamVR_GlobalPredictedSecondsFromNow();
    static bool GetSteamVR_HandPoseRelativeToNow(FVector& Position, FRotator& Orientation, ESteamVRHand hand, float PredictedSecondsFromNow);
    static TArray<FSteamVRInputBindingInfo> GetSteamVR_InputBindingInfo(FSteamVRAction SteamVRActionHandle);
    static void GetSteamVR_OriginLocalizedName(FSteamVRAction SteamVRAction, TArray<ESteamVRInputStringBits> LocalizedParts, FString& OriginLocalizedName);
    static bool GetSteamVR_OriginTrackedDeviceInfo(FSteamVRAction SteamVRAction, FSteamVRInputOriginInfo& InputOriginInfo);
    static float GetUserIPD();
    static void PlaySteamVR_HapticFeedback(ESteamVRHand hand, float StartSecondsFromNow, float DurationSeconds, float Frequency, float Amplitude);
    static bool ResetSeatedPosition();
    static void SetCurlsAndSplaysState(bool NewLeftHandState, bool NewRightHandState);
    static void SetPoseSource(bool bUseSkeletonPose);
    static float SetSteamVR_GlobalPredictedSecondsFromNow(float NewValue);
    static void ShowAllSteamVR_ActionOrigins();
    static void ShowSteamVR_ActionOrigin(FSteamVRAction SteamVRAction, FSteamVRActionSet SteamVRActionSet);
};

// Size: 0x28
struct FSteamVRInputOriginInfo {
    /* 0x0000 */ int32_t TrackedDeviceIndex;
    /* 0x0008 */ FString RenderModelComponentName;
    /* 0x0018 */ FString TrackedDeviceModel;
};

// Size: 0x5d0
struct FSteamVRSkeletonTransform {
    /* 0x0000 */ FTransform Root;
    /* 0x0030 */ FTransform wrist;
    /* 0x0060 */ FTransform Thumb_0;
    /* 0x0090 */ FTransform Thumb_1;
    /* 0x00c0 */ FTransform Thumb_2;
    /* 0x00f0 */ FTransform Thumb_3;
    /* 0x0120 */ FTransform index_0;
    /* 0x0150 */ FTransform index_1;
    /* 0x0180 */ FTransform index_2;
    /* 0x01b0 */ FTransform index_3;
    /* 0x01e0 */ FTransform index_4;
    /* 0x0210 */ FTransform Middle_0;
    /* 0x0240 */ FTransform Middle_1;
    /* 0x0270 */ FTransform Middle_2;
    /* 0x02a0 */ FTransform Middle_3;
    /* 0x02d0 */ FTransform Middle_4;
    /* 0x0300 */ FTransform Ring_0;
    /* 0x0330 */ FTransform Ring_1;
    /* 0x0360 */ FTransform Ring_2;
    /* 0x0390 */ FTransform Ring_3;
    /* 0x03c0 */ FTransform Ring_4;
    /* 0x03f0 */ FTransform Pinky_0;
    /* 0x0420 */ FTransform Pinky_1;
    /* 0x0450 */ FTransform Pinky_2;
    /* 0x0480 */ FTransform Pinky_3;
    /* 0x04b0 */ FTransform Pinky_4;
    /* 0x04e0 */ FTransform Aux_Thumb;
    /* 0x0510 */ FTransform Aux_Index;
    /* 0x0540 */ FTransform Aux_Middle;
    /* 0x0570 */ FTransform Aux_Ring;
    /* 0x05a0 */ FTransform Aux_Pinky;
};

// Size: 0x118
class USteamVRTrackingReferences : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate OnTrackedDeviceActivated;
    /* 0x00d0 */ FMulticastInlineDelegate OnTrackedDeviceDeactivated;
    /* 0x00e0 */ float ActiveDevicePollFrequency;
    /* 0x00e4 */ FVector TrackingReferenceScale;
    /* 0x00f0 */ TArray<UStaticMeshComponent*> TrackingReferences;

    void HideTrackingReferences();
    bool ShowTrackingReferences(UStaticMesh* TrackingReferenceMesh);
};

// Size: 0x28
struct FUE4RetargettingRefs {
    /* 0x0000 */ bool bIsInitialized;
    /* 0x0001 */ bool bIsRightHanded;
    /* 0x0004 */ FVector KnuckleAverageMS_UE4;
    /* 0x0010 */ FVector WristSideDirectionLS_UE4;
    /* 0x001c */ FVector WristForwardLS_UE4;
};

// Size: 0x50
class UStructViewerProjectSettings : public UObject {
    /* 0x0030 */ TArray<FDirectoryPath> InternalOnlyPaths;
    /* 0x0040 */ TArray<TSoftObjectPtr<UScriptStruct>> InternalOnlyStructs;
};

// Size: 0x38
struct FSwarmAlertMessage {
    /* 0x0000 */ FGuid JobGuid;
    /* 0x0010 */ uint8_t AlertLevel;
    /* 0x0014 */ FGuid ObjectGuid;
    /* 0x0024 */ int32_t TypeId;
    /* 0x0028 */ FString TextMessage;
};

// Size: 0x10
struct FSwarmInfoMessage {
    /* 0x0000 */ FString TextMessage;
};

// Size: 0x38
struct FSwarmJobStateMessage {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ uint8_t State;
    /* 0x0018 */ FString Message;
    /* 0x0028 */ int32_t ExitCode;
    /* 0x0030 */ double RunningTime;
};

// Size: 0x1
struct FSwarmPingMessage {
};

// Size: 0x18
struct FSwarmPongMessage {
    /* 0x0000 */ bool bIsEditor;
    /* 0x0008 */ FString ComputerName;
};

// Size: 0x1
struct FSwarmQuitMessage {
};

// Size: 0x1
struct FSwarmTaskRequestMessage {
};

// Size: 0x1
struct FSwarmTaskRequestReleaseMessage {
};

// Size: 0x1
struct FSwarmTaskRequestReservationMessage {
};

// Size: 0x38
struct FSwarmTaskRequestSpecificationMessage {
    /* 0x0000 */ FGuid TaskGuid;
    /* 0x0010 */ FString Parameters;
    /* 0x0020 */ uint8_t Flags;
    /* 0x0024 */ uint32_t Cost;
    /* 0x0028 */ TArray<FString> Dependencies;
};

// Size: 0x38
struct FSwarmTaskStateMessage {
    /* 0x0000 */ FGuid Guid;
    /* 0x0010 */ uint8_t State;
    /* 0x0018 */ FString Message;
    /* 0x0028 */ int32_t ExitCode;
    /* 0x0030 */ double RunningTime;
};

// Size: 0x8
struct FSwarmTimingMessage {
    /* 0x0000 */ uint8_t State;
    /* 0x0004 */ int32_t ThreadNum;
};

// Size: 0x78
class UAudioImpulseResponse : public UObject {
    /* 0x0030 */ TArray<float> ImpulseResponse;
    /* 0x0040 */ int32_t NumChannels;
    /* 0x0044 */ int32_t SampleRate;
    /* 0x0048 */ float NormalizationVolumeDb;
    /* 0x004c */ bool bTrueStereo;
    /* 0x0050 */ TArray<float> IRData;
};

enum class CurveInterpolationType {
    AUTOINTERP = 0,
    LINEAR = 1,
    CONSTANT = 2,
    CurveInterpolationType_MAX = 3,
};

// Size: 0x20
struct FDynamicsBandSettings {
    /* 0x0000 */ float CrossoverTopFrequency;
    /* 0x0004 */ float AttackTimeMsec;
    /* 0x0008 */ float ReleaseTimeMsec;
    /* 0x000c */ float ThresholdDb;
    /* 0x0010 */ float Ratio;
    /* 0x0014 */ float KneeBandwidthDb;
    /* 0x0018 */ float InputGainDb;
    /* 0x001c */ float OutputGainDb;
};

enum class EEnvelopeFollowerPeakMode {
    MeanSquared = 0,
    RootMeanSquared = 1,
    Peak = 2,
    Count = 3,
    EEnvelopeFollowerPeakMode_MAX = 4,
};

enum class EGranularSynthEnvelopeType {
    Rectangular = 0,
    Triangle = 1,
    DownwardTriangle = 2,
    UpwardTriangle = 3,
    ExponentialDecay = 4,
    ExponentialIncrease = 5,
    Gaussian = 6,
    Hanning = 7,
    Lanczos = 8,
    Cosine = 9,
    CosineSquared = 10,
    Welch = 11,
    Blackman = 12,
    BlackmanHarris = 13,
    Count = 14,
    EGranularSynthEnvelopeType_MAX = 15,
};

enum class EGranularSynthSeekType {
    FromBeginning = 0,
    FromCurrentPosition = 1,
    Count = 2,
    EGranularSynthSeekType_MAX = 3,
};

enum class EPhaserLFOType {
    Sine = 0,
    UpSaw = 1,
    DownSaw = 2,
    Square = 3,
    Triangle = 4,
    Exponential = 5,
    RandomSampleHold = 6,
    Count = 7,
    EPhaserLFOType_MAX = 8,
};

enum class ERingModulatorTypeSourceEffect {
    Sine = 0,
    Saw = 1,
    Triangle = 2,
    Square = 3,
    Count = 4,
    ERingModulatorTypeSourceEffect_MAX = 5,
};

enum class ESamplePlayerSeekType {
    FromBeginning = 0,
    FromCurrentPosition = 1,
    FromEnd = 2,
    Count = 3,
    ESamplePlayerSeekType_MAX = 4,
};

enum class ESourceEffectDynamicsPeakMode {
    MeanSquared = 0,
    RootMeanSquared = 1,
    Peak = 2,
    Count = 3,
    ESourceEffectDynamicsPeakMode_MAX = 4,
};

enum class ESourceEffectDynamicsProcessorType {
    Compressor = 0,
    Limiter = 1,
    Expander = 2,
    Gate = 3,
    Count = 4,
    ESourceEffectDynamicsProcessorType_MAX = 5,
};

enum class ESourceEffectFilterCircuit {
    OnePole = 0,
    StateVariable = 1,
    Ladder = 2,
    Count = 3,
    ESourceEffectFilterCircuit_MAX = 4,
};

enum class ESourceEffectFilterParam {
    FilterFrequency = 0,
    FilterResonance = 1,
    Count = 2,
    ESourceEffectFilterParam_MAX = 3,
};

enum class ESourceEffectFilterType {
    LowPass = 0,
    HighPass = 1,
    BandPass = 2,
    BandStop = 3,
    Count = 4,
    ESourceEffectFilterType_MAX = 5,
};

enum class EStereoChannelMode {
    MidSide = 0,
    LeftRight = 1,
    count = 2,
    EStereoChannelMode_MAX = 3,
};

enum class EStereoDelayFiltertype {
    Lowpass = 0,
    Highpass = 1,
    Bandpass = 2,
    Notch = 3,
    Count = 4,
    EStereoDelayFiltertype_MAX = 5,
};

enum class EStereoDelaySourceEffect {
    Normal = 0,
    Cross = 1,
    PingPong = 2,
    Count = 3,
    EStereoDelaySourceEffect_MAX = 4,
};

enum class ESubmixEffectConvolutionReverbBlockSize {
    BlockSize256 = 0,
    BlockSize512 = 1,
    BlockSize1024 = 2,
    ESubmixEffectConvolutionReverbBlockSize_MAX = 3,
};

enum class ESubmixFilterAlgorithm {
    OnePole = 0,
    StateVariable = 1,
    Ladder = 2,
    Count = 3,
    ESubmixFilterAlgorithm_MAX = 4,
};

enum class ESubmixFilterType {
    LowPass = 0,
    HighPass = 1,
    BandPass = 2,
    BandStop = 3,
    Count = 4,
    ESubmixFilterType_MAX = 5,
};

enum class ESynth1OscType {
    Sine = 0,
    Saw = 1,
    Triangle = 2,
    Square = 3,
    Noise = 4,
    Count = 5,
    ESynth1OscType_MAX = 6,
};

enum class ESynth1PatchDestination {
    Osc1Gain = 0,
    Osc1Frequency = 1,
    Osc1Pulsewidth = 2,
    Osc2Gain = 3,
    Osc2Frequency = 4,
    Osc2Pulsewidth = 5,
    FilterFrequency = 6,
    FilterQ = 7,
    Gain = 8,
    Pan = 9,
    LFO1Frequency = 10,
    LFO1Gain = 11,
    LFO2Frequency = 12,
    LFO2Gain = 13,
    Count = 14,
    ESynth1PatchDestination_MAX = 15,
};

enum class ESynth1PatchSource {
    LFO1 = 0,
    LFO2 = 1,
    Envelope = 2,
    BiasEnvelope = 3,
    Count = 4,
    ESynth1PatchSource_MAX = 5,
};

enum class ESynthFilterAlgorithm {
    OnePole = 0,
    StateVariable = 1,
    Ladder = 2,
    Count = 3,
    ESynthFilterAlgorithm_MAX = 4,
};

enum class ESynthFilterType {
    LowPass = 0,
    HighPass = 1,
    BandPass = 2,
    BandStop = 3,
    Count = 4,
    ESynthFilterType_MAX = 5,
};

enum class ESynthKnobSize {
    Medium = 0,
    Large = 1,
    Count = 2,
    ESynthKnobSize_MAX = 3,
};

enum class ESynthLFOMode {
    Sync = 0,
    OneShot = 1,
    Free = 2,
    Count = 3,
    ESynthLFOMode_MAX = 4,
};

enum class ESynthLFOPatchType {
    PatchToNone = 0,
    PatchToGain = 1,
    PatchToOscFreq = 2,
    PatchToFilterFreq = 3,
    PatchToFilterQ = 4,
    PatchToOscPulseWidth = 5,
    PatchToOscPan = 6,
    PatchLFO1ToLFO2Frequency = 7,
    PatchLFO1ToLFO2Gain = 8,
    Count = 9,
    ESynthLFOPatchType_MAX = 10,
};

enum class ESynthLFOType {
    Sine = 0,
    UpSaw = 1,
    DownSaw = 2,
    Square = 3,
    Triangle = 4,
    Exponential = 5,
    RandomSampleHold = 6,
    Count = 7,
    ESynthLFOType_MAX = 8,
};

enum class ESynthModEnvBiasPatch {
    PatchToNone = 0,
    PatchToOscFreq = 1,
    PatchToFilterFreq = 2,
    PatchToFilterQ = 3,
    PatchToLFO1Gain = 4,
    PatchToLFO2Gain = 5,
    PatchToLFO1Freq = 6,
    PatchToLFO2Freq = 7,
    Count = 8,
    ESynthModEnvBiasPatch_MAX = 9,
};

enum class ESynthModEnvPatch {
    PatchToNone = 0,
    PatchToOscFreq = 1,
    PatchToFilterFreq = 2,
    PatchToFilterQ = 3,
    PatchToLFO1Gain = 4,
    PatchToLFO2Gain = 5,
    PatchToLFO1Freq = 6,
    PatchToLFO2Freq = 7,
    Count = 8,
    ESynthModEnvPatch_MAX = 9,
};

enum class ESynthSlateColorStyle {
    Light = 0,
    Dark = 1,
    Count = 2,
    ESynthSlateColorStyle_MAX = 3,
};

enum class ESynthSlateSizeType {
    Small = 0,
    Medium = 1,
    Large = 2,
    Count = 3,
    ESynthSlateSizeType_MAX = 4,
};

enum class ESynthStereoDelayMode {
    Normal = 0,
    Cross = 1,
    PingPong = 2,
    Count = 3,
    ESynthStereoDelayMode_MAX = 4,
};

enum class ETapLineMode {
    SendToChannel = 0,
    Panning = 1,
    Disabled = 2,
    ETapLineMode_MAX = 3,
};

// Size: 0xe0
class UEnvelopeFollowerListener : public UActorComponent {
    /* 0x00c0 */ FMulticastInlineDelegate OnEnvelopeFollowerUpdate;
};

// Size: 0x18
struct FEpicSynth1Patch {
    /* 0x0000 */ ESynth1PatchSource PatchSource;
    /* 0x0008 */ TArray<FSynth1PatchCable> PatchCables;
};

// Size: 0xae0
class UGranularSynth : public USynthComponent {
    /* 0x0720 */ USoundWave* GranulatedSoundWave;

    float GetCurrentPlayheadTime() const;
    float GetSampleDuration() const;
    bool IsLoaded() const;
    void NoteOff(const float Note, const bool bKill);
    void NoteOn(const float Note, const int32_t Velocity, const float Duration);
    void SetAttackTime(const float AttackTimeMsec);
    void SetDecayTime(const float DecayTimeMsec);
    void SetGrainDuration(const float BaseDurationMsec, const FVector2D DurationRange);
    void SetGrainEnvelopeType(const EGranularSynthEnvelopeType EnvelopeType);
    void SetGrainPan(const float BasePan, const FVector2D PanRange);
    void SetGrainPitch(const float BasePitch, const FVector2D PitchRange);
    void SetGrainProbability(const float InGrainProbability);
    void SetGrainVolume(const float BaseVolume, const FVector2D VolumeRange);
    void SetGrainsPerSecond(const float InGrainsPerSecond);
    void SetPlaybackSpeed(const float InPlayheadRate);
    void SetPlayheadTime(const float InPositionSec, const float LerpTimeSec, EGranularSynthSeekType SeekType);
    void SetReleaseTimeMsec(const float ReleaseTimeMsec);
    void SetScrubMode(const bool bScrubMode);
    void SetSoundWave(USoundWave* InSoundWave);
    void SetSustainGain(const float SustainGain);
};

// Size: 0xde0
class UModularSynthComponent : public USynthComponent {
    /* 0x0720 */ int32_t VoiceCount;

    FPatchId CreatePatch(const ESynth1PatchSource PatchSource, const TArray<FSynth1PatchCable>& PatchCables, const bool bEnableByDefault);
    void NoteOff(const float Note, const bool bAllNotesOff, const bool bKillAllNotes);
    void NoteOn(const float Note, const int32_t Velocity, const float Duration);
    void SetAttackTime(float AttackTimeMsec);
    void SetChorusDepth(float Depth);
    void SetChorusEnabled(bool EnableChorus);
    void SetChorusFeedback(float Feedback);
    void SetChorusFrequency(float Frequency);
    void SetDecayTime(float DecayTimeMsec);
    void SetEnableLegato(bool LegatoEnabled);
    bool SetEnablePatch(const FPatchId PatchId, const bool bIsEnabled);
    void SetEnablePolyphony(bool bEnablePolyphony);
    void SetEnableRetrigger(bool RetriggerEnabled);
    void SetEnableUnison(bool EnableUnison);
    void SetFilterAlgorithm(ESynthFilterAlgorithm FilterAlgorithm);
    void SetFilterFrequency(float FilterFrequencyHz);
    void SetFilterFrequencyMod(float FilterFrequencyHz);
    void SetFilterQ(float FilterQ);
    void SetFilterQMod(float FilterQ);
    void SetFilterType(ESynthFilterType FilterType);
    void SetGainDb(float GainDb);
    void SetLFOFrequency(int32_t LFOIndex, float FrequencyHz);
    void SetLFOFrequencyMod(int32_t LFOIndex, float FrequencyModHz);
    void SetLFOGain(int32_t LFOIndex, float Gain);
    void SetLFOGainMod(int32_t LFOIndex, float GainMod);
    void SetLFOMode(int32_t LFOIndex, ESynthLFOMode LFOMode);
    void SetLFOPatch(int32_t LFOIndex, ESynthLFOPatchType LFOPatchType);
    void SetLFOType(int32_t LFOIndex, ESynthLFOType LFOType);
    void SetModEnvAttackTime(const float AttackTimeMsec);
    void SetModEnvBiasInvert(const bool bInvert);
    void SetModEnvBiasPatch(const ESynthModEnvBiasPatch InPatchType);
    void SetModEnvDecayTime(const float DecayTimeMsec);
    void SetModEnvDepth(const float Depth);
    void SetModEnvInvert(const bool bInvert);
    void SetModEnvPatch(const ESynthModEnvPatch InPatchType);
    void SetModEnvReleaseTime(const float Release);
    void SetModEnvSustainGain(const float SustainGain);
    void SetOscCents(int32_t OscIndex, float Cents);
    void SetOscFrequencyMod(int32_t OscIndex, float OscFreqMod);
    void SetOscGain(int32_t OscIndex, float OscGain);
    void SetOscGainMod(int32_t OscIndex, float OscGainMod);
    void SetOscOctave(int32_t OscIndex, float Octave);
    void SetOscPulsewidth(int32_t OscIndex, float Pulsewidth);
    void SetOscSemitones(int32_t OscIndex, float Semitones);
    void SetOscSync(const bool bIsSynced);
    void SetOscType(int32_t OscIndex, ESynth1OscType OscType);
    void SetPan(float Pan);
    void SetPitchBend(float PitchBend);
    void SetPortamento(float Portamento);
    void SetReleaseTime(float ReleaseTimeMsec);
    void SetSpread(float Spread);
    void SetStereoDelayFeedback(float DelayFeedback);
    void SetStereoDelayIsEnabled(bool StereoDelayEnabled);
    void SetStereoDelayMode(ESynthStereoDelayMode StereoDelayMode);
    void SetStereoDelayRatio(float DelayRatio);
    void SetStereoDelayTime(float DelayTimeMsec);
    void SetStereoDelayWetlevel(float DelayWetlevel);
    void SetSustainGain(float SustainGain);
    void SetSynthPreset(const FModularSynthPreset& SynthPreset);
};

// Size: 0x30
class UModularSynthLibrary : public UBlueprintFunctionLibrary {

    static void AddModularSynthPresetToBankAsset(UModularSynthPresetBank* InBank, const FModularSynthPreset& Preset, FString PresetName);
};

// Size: 0xe0
struct FModularSynthPreset : public FTableRowBase {
    /* 0x0008 */ bool bEnablePolyphony;
    /* 0x000c */ ESynth1OscType Osc1Type;
    /* 0x0010 */ float Osc1Gain;
    /* 0x0014 */ float Osc1Octave;
    /* 0x0018 */ float Osc1Semitones;
    /* 0x001c */ float Osc1Cents;
    /* 0x0020 */ float Osc1PulseWidth;
    /* 0x0024 */ ESynth1OscType Osc2Type;
    /* 0x0028 */ float Osc2Gain;
    /* 0x002c */ float Osc2Octave;
    /* 0x0030 */ float Osc2Semitones;
    /* 0x0034 */ float Osc2Cents;
    /* 0x0038 */ float Osc2PulseWidth;
    /* 0x003c */ float Portamento;
    /* 0x0040 */ bool bEnableUnison;
    /* 0x0040 */ bool bEnableOscillatorSync;
    /* 0x0044 */ float Spread;
    /* 0x0048 */ float Pan;
    /* 0x004c */ float LFO1Frequency;
    /* 0x0050 */ float LFO1Gain;
    /* 0x0054 */ ESynthLFOType LFO1Type;
    /* 0x0055 */ ESynthLFOMode LFO1Mode;
    /* 0x0056 */ ESynthLFOPatchType LFO1PatchType;
    /* 0x0058 */ float LFO2Frequency;
    /* 0x005c */ float LFO2Gain;
    /* 0x0060 */ ESynthLFOType LFO2Type;
    /* 0x0061 */ ESynthLFOMode LFO2Mode;
    /* 0x0062 */ ESynthLFOPatchType LFO2PatchType;
    /* 0x0064 */ float GainDb;
    /* 0x0068 */ float AttackTime;
    /* 0x006c */ float DecayTime;
    /* 0x0070 */ float SustainGain;
    /* 0x0074 */ float ReleaseTime;
    /* 0x0078 */ ESynthModEnvPatch ModEnvPatchType;
    /* 0x0079 */ ESynthModEnvBiasPatch ModEnvBiasPatchType;
    /* 0x007c */ bool bInvertModulationEnvelope;
    /* 0x007c */ bool bInvertModulationEnvelopeBias;
    /* 0x0080 */ float ModulationEnvelopeDepth;
    /* 0x0084 */ float ModulationEnvelopeAttackTime;
    /* 0x0088 */ float ModulationEnvelopeDecayTime;
    /* 0x008c */ float ModulationEnvelopeSustainGain;
    /* 0x0090 */ float ModulationEnvelopeReleaseTime;
    /* 0x0094 */ bool bLegato;
    /* 0x0094 */ bool bRetrigger;
    /* 0x0098 */ float FilterFrequency;
    /* 0x009c */ float FilterQ;
    /* 0x00a0 */ ESynthFilterType FilterType;
    /* 0x00a1 */ ESynthFilterAlgorithm FilterAlgorithm;
    /* 0x00a4 */ bool bStereoDelayEnabled;
    /* 0x00a8 */ ESynthStereoDelayMode StereoDelayMode;
    /* 0x00ac */ float StereoDelayTime;
    /* 0x00b0 */ float StereoDelayFeedback;
    /* 0x00b4 */ float StereoDelayWetlevel;
    /* 0x00b8 */ float StereoDelayRatio;
    /* 0x00bc */ bool bChorusEnabled;
    /* 0x00c0 */ float ChorusDepth;
    /* 0x00c4 */ float ChorusFeedback;
    /* 0x00c8 */ float ChorusFrequency;
    /* 0x00d0 */ TArray<FEpicSynth1Patch> Patches;
};

// Size: 0x40
class UModularSynthPresetBank : public UObject {
    /* 0x0030 */ TArray<FModularSynthPresetBankEntry> Presets;
};

// Size: 0xf0
struct FModularSynthPresetBankEntry {
    /* 0x0000 */ FString PresetName;
    /* 0x0010 */ FModularSynthPreset Preset;
};

// Size: 0x178
class UMonoWaveTableSynthPreset : public UObject {
    /* 0x0030 */ FString PresetName;
    /* 0x0040 */ bool bLockKeyframesToGridBool;
    /* 0x0044 */ int32_t LockKeyframesToGrid;
    /* 0x0048 */ int32_t WaveTableResolution;
    /* 0x0050 */ TArray<FRuntimeFloatCurve> WaveTable;
    /* 0x0060 */ bool bNormalizeWaveTables;
};

// Size: 0x4
struct FPatchId {
    /* 0x0000 */ int32_t ID;
};

// Size: 0x8
struct FSourceEffectBitCrusherBaseSettings {
    /* 0x0000 */ float SampleRate;
    /* 0x0004 */ float BitDepth;
};

// Size: 0xf8
class USourceEffectBitCrusherPreset : public USoundEffectSourcePreset {
    /* 0x00c8 */ FSourceEffectBitCrusherSettings Settings;

    void SetBitModulator(const USoundModulatorBase* Modulator);
    void SetBits(float Bits);
    void SetModulationSettings(const FSourceEffectBitCrusherSettings& ModulationSettings);
    void SetSampleRate(float SampleRate);
    void SetSampleRateModulator(const USoundModulatorBase* Modulator);
    void SetSettings(const FSourceEffectBitCrusherBaseSettings& Settings);
};

// Size: 0x30
struct FSourceEffectBitCrusherSettings {
    /* 0x0000 */ float CrushedSampleRate;
    /* 0x0008 */ FSoundModulationDestinationSettings SampleRateModulation;
    /* 0x0018 */ float CrushedBits;
    /* 0x0020 */ FSoundModulationDestinationSettings BitModulation;
};

// Size: 0x18
struct FSourceEffectChorusBaseSettings {
    /* 0x0000 */ float Depth;
    /* 0x0004 */ float Frequency;
    /* 0x0008 */ float Feedback;
    /* 0x000c */ float WetLevel;
    /* 0x0010 */ float DryLevel;
    /* 0x0014 */ float Spread;
};

// Size: 0x188
class USourceEffectChorusPreset : public USoundEffectSourcePreset {
    /* 0x0110 */ FSourceEffectChorusSettings Settings;

    void SetDepth(float Depth);
    void SetDepthModulator(const USoundModulatorBase* Modulator);
    void SetDry(float DryAmount);
    void SetDryModulator(const USoundModulatorBase* Modulator);
    void SetFeedback(float Feedback);
    void SetFeedbackModulator(const USoundModulatorBase* Modulator);
    void SetFrequency(float Frequency);
    void SetFrequencyModulator(const USoundModulatorBase* Modulator);
    void SetModulationSettings(const FSourceEffectChorusSettings& ModulationSettings);
    void SetSettings(const FSourceEffectChorusBaseSettings& Settings);
    void SetSpread(float Spread);
    void SetSpreadModulator(const USoundModulatorBase* Modulator);
    void SetWet(float WetAmount);
    void SetWetModulator(const USoundModulatorBase* Modulator);
};

// Size: 0x78
struct FSourceEffectChorusSettings {
    /* 0x0000 */ float Depth;
    /* 0x0004 */ float Frequency;
    /* 0x0008 */ float Feedback;
    /* 0x000c */ float WetLevel;
    /* 0x0010 */ float DryLevel;
    /* 0x0014 */ float Spread;
    /* 0x0018 */ FSoundModulationDestinationSettings DepthModulation;
    /* 0x0028 */ FSoundModulationDestinationSettings FrequencyModulation;
    /* 0x0038 */ FSoundModulationDestinationSettings FeedbackModulation;
    /* 0x0048 */ FSoundModulationDestinationSettings WetModulation;
    /* 0x0058 */ FSoundModulationDestinationSettings DryModulation;
    /* 0x0068 */ FSoundModulationDestinationSettings SpreadModulation;
};

// Size: 0xe8
class USourceEffectDynamicsProcessorPreset : public USoundEffectSourcePreset {
    /* 0x00c0 */ FSourceEffectDynamicsProcessorSettings Settings;

    void SetSettings(const FSourceEffectDynamicsProcessorSettings& InSettings);
};

// Size: 0x28
struct FSourceEffectDynamicsProcessorSettings {
    /* 0x0000 */ ESourceEffectDynamicsProcessorType DynamicsProcessorType;
    /* 0x0001 */ ESourceEffectDynamicsPeakMode PeakMode;
    /* 0x0004 */ float LookAheadMsec;
    /* 0x0008 */ float AttackTimeMsec;
    /* 0x000c */ float ReleaseTimeMsec;
    /* 0x0010 */ float ThresholdDb;
    /* 0x0014 */ float Ratio;
    /* 0x0018 */ float KneeBandwidthDb;
    /* 0x001c */ float InputGainDb;
    /* 0x0020 */ float OutputGainDb;
    /* 0x0024 */ bool bStereoLinked;
    /* 0x0024 */ bool bAnalogMode;
};

// Size: 0x10
struct FSourceEffectEQBand {
    /* 0x0000 */ float Frequency;
    /* 0x0004 */ float Bandwidth;
    /* 0x0008 */ float GainDb;
    /* 0x000c */ bool bEnabled;
};

// Size: 0xb8
class USourceEffectEQPreset : public USoundEffectSourcePreset {
    /* 0x00a8 */ FSourceEffectEQSettings Settings;

    void SetSettings(const FSourceEffectEQSettings& InSettings);
};

// Size: 0x10
struct FSourceEffectEQSettings {
    /* 0x0000 */ TArray<FSourceEffectEQBand> EQBands;
};

// Size: 0xb0
class USourceEffectEnvelopeFollowerPreset : public USoundEffectSourcePreset {
    /* 0x00a4 */ FSourceEffectEnvelopeFollowerSettings Settings;

    void RegisterEnvelopeFollowerListener(UEnvelopeFollowerListener* EnvelopeFollowerListener);
    void SetSettings(const FSourceEffectEnvelopeFollowerSettings& InSettings);
    void UnregisterEnvelopeFollowerListener(UEnvelopeFollowerListener* EnvelopeFollowerListener);
};

// Size: 0xc
struct FSourceEffectEnvelopeFollowerSettings {
    /* 0x0000 */ float AttackTime;
    /* 0x0004 */ float ReleaseTime;
    /* 0x0008 */ EEnvelopeFollowerPeakMode PeakMode;
    /* 0x0009 */ bool bIsAnalogMode;
};

// Size: 0x28
struct FSourceEffectFilterAudioBusModulationSettings {
    /* 0x0000 */ UAudioBus* AudioBus;
    /* 0x0008 */ int32_t EnvelopeFollowerAttackTimeMsec;
    /* 0x000c */ int32_t EnvelopeFollowerReleaseTimeMsec;
    /* 0x0010 */ float EnvelopeGainMultiplier;
    /* 0x0014 */ ESourceEffectFilterParam FilterParam;
    /* 0x0018 */ float MinFrequencyModulation;
    /* 0x001c */ float MaxFrequencyModulation;
    /* 0x0020 */ float MinResonanceModulation;
    /* 0x0024 */ float MaxResonanceModulation;
};

// Size: 0xd8
class USourceEffectFilterPreset : public USoundEffectSourcePreset {
    /* 0x00b8 */ FSourceEffectFilterSettings Settings;

    void SetSettings(const FSourceEffectFilterSettings& InSettings);
};

// Size: 0x20
struct FSourceEffectFilterSettings {
    /* 0x0000 */ ESourceEffectFilterCircuit FilterCircuit;
    /* 0x0001 */ ESourceEffectFilterType FilterType;
    /* 0x0004 */ float CutoffFrequency;
    /* 0x0008 */ float FilterQ;
    /* 0x0010 */ TArray<FSourceEffectFilterAudioBusModulationSettings> AudioBusModulation;
};

// Size: 0xb0
class USourceEffectFoldbackDistortionPreset : public USoundEffectSourcePreset {
    /* 0x00a4 */ FSourceEffectFoldbackDistortionSettings Settings;

    void SetSettings(const FSourceEffectFoldbackDistortionSettings& InSettings);
};

// Size: 0xc
struct FSourceEffectFoldbackDistortionSettings {
    /* 0x0000 */ float InputGainDb;
    /* 0x0004 */ float ThresholdDb;
    /* 0x0008 */ float OutputGainDb;
};

// Size: 0xa8
class USourceEffectMidSideSpreaderPreset : public USoundEffectSourcePreset {
    /* 0x00a0 */ FSourceEffectMidSideSpreaderSettings Settings;

    void SetSettings(const FSourceEffectMidSideSpreaderSettings& InSettings);
};

// Size: 0x8
struct FSourceEffectMidSideSpreaderSettings {
    /* 0x0000 */ float SpreadAmount;
    /* 0x0004 */ EStereoChannelMode InputMode;
    /* 0x0005 */ EStereoChannelMode OutputMode;
    /* 0x0006 */ bool bEqualPower;
};

// Size: 0xa8
class USourceEffectPannerPreset : public USoundEffectSourcePreset {
    /* 0x00a0 */ FSourceEffectPannerSettings Settings;

    void SetSettings(const FSourceEffectPannerSettings& InSettings);
};

// Size: 0x8
struct FSourceEffectPannerSettings {
    /* 0x0000 */ float Spread;
    /* 0x0004 */ float Pan;
};

// Size: 0xb8
class USourceEffectPhaserPreset : public USoundEffectSourcePreset {
    /* 0x00a8 */ FSourceEffectPhaserSettings Settings;

    void SetSettings(const FSourceEffectPhaserSettings& InSettings);
};

// Size: 0x10
struct FSourceEffectPhaserSettings {
    /* 0x0000 */ float WetLevel;
    /* 0x0004 */ float Frequency;
    /* 0x0008 */ float Feedback;
    /* 0x000c */ EPhaserLFOType LFOType;
    /* 0x000d */ bool UseQuadraturePhase;
};

// Size: 0xd8
class USourceEffectRingModulationPreset : public USoundEffectSourcePreset {
    /* 0x00b8 */ FSourceEffectRingModulationSettings Settings;

    void SetSettings(const FSourceEffectRingModulationSettings& InSettings);
};

// Size: 0x20
struct FSourceEffectRingModulationSettings {
    /* 0x0000 */ ERingModulatorTypeSourceEffect ModulatorType;
    /* 0x0004 */ float Frequency;
    /* 0x0008 */ float Depth;
    /* 0x000c */ float DryLevel;
    /* 0x0010 */ float WetLevel;
    /* 0x0018 */ UAudioBus* AudioBusModulator;
};

// Size: 0xc8
class USourceEffectSimpleDelayPreset : public USoundEffectSourcePreset {
    /* 0x00b0 */ FSourceEffectSimpleDelaySettings Settings;

    void SetSettings(const FSourceEffectSimpleDelaySettings& InSettings);
};

// Size: 0x18
struct FSourceEffectSimpleDelaySettings {
    /* 0x0000 */ float SpeedOfSound;
    /* 0x0004 */ float DelayAmount;
    /* 0x0008 */ float DryAmount;
    /* 0x000c */ float WetAmount;
    /* 0x0010 */ float Feedback;
    /* 0x0014 */ bool bDelayBasedOnDistance;
};

// Size: 0xe0
class USourceEffectStereoDelayPreset : public USoundEffectSourcePreset {
    /* 0x00bc */ FSourceEffectStereoDelaySettings Settings;

    void SetSettings(const FSourceEffectStereoDelaySettings& InSettings);
};

// Size: 0x24
struct FSourceEffectStereoDelaySettings {
    /* 0x0000 */ EStereoDelaySourceEffect DelayMode;
    /* 0x0004 */ float DelayTimeMsec;
    /* 0x0008 */ float Feedback;
    /* 0x000c */ float DelayRatio;
    /* 0x0010 */ float WetLevel;
    /* 0x0014 */ float DryLevel;
    /* 0x0018 */ bool bFilterEnabled;
    /* 0x0019 */ EStereoDelayFiltertype FilterType;
    /* 0x001c */ float FilterFrequency;
    /* 0x0020 */ float FilterQ;
};

// Size: 0xa8
class USourceEffectWaveShaperPreset : public USoundEffectSourcePreset {
    /* 0x00a0 */ FSourceEffectWaveShaperSettings Settings;

    void SetSettings(const FSourceEffectWaveShaperSettings& InSettings);
};

// Size: 0x8
struct FSourceEffectWaveShaperSettings {
    /* 0x0000 */ float Amount;
    /* 0x0004 */ float OutputGainDb;
};

// Size: 0x148
class USubmixEffectConvolutionReverbPreset : public USoundEffectSubmixPreset {
    /* 0x0070 */ UAudioImpulseResponse* ImpulseResponse;
    /* 0x0078 */ FSubmixEffectConvolutionReverbSettings Settings;
    /* 0x00a0 */ ESubmixEffectConvolutionReverbBlockSize BlockSize;
    /* 0x00a1 */ bool bEnableHardwareAcceleration;

    void SetImpulseResponse(UAudioImpulseResponse* InImpulseResponse);
    void SetSettings(const FSubmixEffectConvolutionReverbSettings& InSettings);
};

// Size: 0x28
struct FSubmixEffectConvolutionReverbSettings {
    /* 0x0000 */ float NormalizationVolumeDb;
    /* 0x0004 */ bool bBypass;
    /* 0x0005 */ bool bMixInputChannelFormatToImpulseResponseFormat;
    /* 0x0006 */ bool bMixReverbOutputToOutputChannelFormat;
    /* 0x0008 */ float SurroundRearChannelBleedDb;
    /* 0x000c */ bool bInvertRearChannelBleedPhase;
    /* 0x000d */ bool bSurroundRearChannelFlip;
    /* 0x0010 */ float SurroundRearChannelBleedAmount;
    /* 0x0018 */ UAudioImpulseResponse* ImpulseResponse;
    /* 0x0020 */ bool AllowHArdwareAcceleration;
};

// Size: 0xc0
class USubmixEffectDelayPreset : public USoundEffectSubmixPreset {
    /* 0x00a4 */ FSubmixEffectDelaySettings Settings;
    /* 0x00b0 */ FSubmixEffectDelaySettings DynamicSettings;

    float GetMaxDelayInMilliseconds();
    void SetDelay(float Length);
    void SetInterpolationTime(float Time);
    void SetSettings(const FSubmixEffectDelaySettings& InSettings);
};

// Size: 0xc
struct FSubmixEffectDelaySettings {
    /* 0x0000 */ float MaximumDelayLength;
    /* 0x0004 */ float InterpolationTime;
    /* 0x0008 */ float DelayLength;
};

// Size: 0xb0
class USubmixEffectFilterPreset : public USoundEffectSubmixPreset {
    /* 0x00a4 */ FSubmixEffectFilterSettings Settings;

    void SetFilterAlgorithm(ESubmixFilterAlgorithm InAlgorithm);
    void SetFilterCutoffFrequency(float InFrequency);
    void SetFilterCutoffFrequencyMod(float InFrequency);
    void SetFilterQ(float InQ);
    void SetFilterQMod(float InQ);
    void SetFilterType(ESubmixFilterType InType);
    void SetSettings(const FSubmixEffectFilterSettings& InSettings);
};

// Size: 0xc
struct FSubmixEffectFilterSettings {
    /* 0x0000 */ ESubmixFilterType FilterType;
    /* 0x0001 */ ESubmixFilterAlgorithm FilterAlgorithm;
    /* 0x0004 */ float FilterFrequency;
    /* 0x0008 */ float FilterQ;
};

// Size: 0xb8
class USubmixEffectFlexiverbPreset : public USoundEffectSubmixPreset {
    /* 0x00a8 */ FSubmixEffectFlexiverbSettings Settings;

    void SetSettings(const FSubmixEffectFlexiverbSettings& InSettings);
};

// Size: 0x10
struct FSubmixEffectFlexiverbSettings {
    /* 0x0000 */ float PreDelay;
    /* 0x0004 */ float DecayTime;
    /* 0x0008 */ float RoomDampening;
    /* 0x000c */ int32_t Complexity;
};

// Size: 0xd8
class USubmixEffectMultibandCompressorPreset : public USoundEffectSubmixPreset {
    /* 0x00b8 */ FSubmixEffectMultibandCompressorSettings Settings;

    void SetSettings(const FSubmixEffectMultibandCompressorSettings& InSettings);
};

// Size: 0x20
struct FSubmixEffectMultibandCompressorSettings {
    /* 0x0000 */ ESubmixEffectDynamicsProcessorType DynamicsProcessorType;
    /* 0x0001 */ ESubmixEffectDynamicsPeakMode PeakMode;
    /* 0x0004 */ float LookAheadMsec;
    /* 0x0008 */ bool bLinkChannels;
    /* 0x0009 */ bool bAnalogMode;
    /* 0x000a */ bool bFourPole;
    /* 0x0010 */ TArray<FDynamicsBandSettings> Bands;
};

// Size: 0xe0
class USubmixEffectStereoDelayPreset : public USoundEffectSubmixPreset {
    /* 0x00bc */ FSubmixEffectStereoDelaySettings Settings;

    void SetSettings(const FSubmixEffectStereoDelaySettings& InSettings);
};

// Size: 0x24
struct FSubmixEffectStereoDelaySettings {
    /* 0x0000 */ EStereoDelaySourceEffect DelayMode;
    /* 0x0004 */ float DelayTimeMsec;
    /* 0x0008 */ float Feedback;
    /* 0x000c */ float DelayRatio;
    /* 0x0010 */ float WetLevel;
    /* 0x0014 */ float DryLevel;
    /* 0x0018 */ bool bFilterEnabled;
    /* 0x0019 */ EStereoDelayFiltertype FilterType;
    /* 0x001c */ float FilterFrequency;
    /* 0x0020 */ float FilterQ;
};

// Size: 0xe0
class USubmixEffectTapDelayPreset : public USoundEffectSubmixPreset {
    /* 0x00b0 */ FSubmixEffectTapDelaySettings Settings;

    void AddTap(int32_t& TapId);
    float GetMaxDelayInMilliseconds();
    void GetTap(int32_t TapId, FTapDelayInfo& TapInfo);
    void GetTapIds(TArray<int32_t>& TapIds);
    void RemoveTap(int32_t TapId);
    void SetInterpolationTime(float Time);
    void SetSettings(const FSubmixEffectTapDelaySettings& InSettings);
    void SetTap(int32_t TapId, const FTapDelayInfo& TapInfo);
};

// Size: 0x18
struct FSubmixEffectTapDelaySettings {
    /* 0x0000 */ float MaximumDelayLength;
    /* 0x0004 */ float InterpolationTime;
    /* 0x0008 */ TArray<FTapDelayInfo> Taps;
};

// Size: 0x8
struct FSynth1PatchCable {
    /* 0x0000 */ float Depth;
    /* 0x0004 */ ESynth1PatchDestination Destination;
};

// Size: 0x620
class USynth2DSlider : public UWidget {
    /* 0x0228 */ float ValueX;
    /* 0x022c */ float ValueY;
    /* 0x0230 */ FDelegate ValueXDelegate;
    /* 0x0244 */ FDelegate ValueYDelegate;
    /* 0x0258 */ FSynth2DSliderStyle WidgetStyle;
    /* 0x0588 */ FLinearColor SliderHandleColor;
    /* 0x0598 */ bool IndentHandle;
    /* 0x0599 */ bool Locked;
    /* 0x059c */ float StepSize;
    /* 0x05a0 */ bool IsFocusable;
    /* 0x05a8 */ FMulticastInlineDelegate OnMouseCaptureBegin;
    /* 0x05b8 */ FMulticastInlineDelegate OnMouseCaptureEnd;
    /* 0x05c8 */ FMulticastInlineDelegate OnControllerCaptureBegin;
    /* 0x05d8 */ FMulticastInlineDelegate OnControllerCaptureEnd;
    /* 0x05e8 */ FMulticastInlineDelegate OnValueChangedX;
    /* 0x05f8 */ FMulticastInlineDelegate OnValueChangedY;

    FVector2D GetValue() const;
    void SetIndentHandle(bool InValue);
    void SetLocked(bool InValue);
    void SetSliderHandleColor(FLinearColor InValue);
    void SetStepSize(float InValue);
    void SetValue(FVector2D InValue);
};

// Size: 0x330
struct FSynth2DSliderStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush NormalThumbImage;
    /* 0x00a8 */ FSlateBrush DisabledThumbImage;
    /* 0x0148 */ FSlateBrush NormalBarImage;
    /* 0x01e8 */ FSlateBrush DisabledBarImage;
    /* 0x0288 */ FSlateBrush BackgroundImage;
    /* 0x0328 */ float BarThickness;
};

// Size: 0xe60
class USynthComponentMonoWaveTable : public USynthComponent {
    /* 0x0720 */ FMulticastInlineDelegate OnTableAltered;
    /* 0x0730 */ FMulticastInlineDelegate OnNumTablesChanged;
    /* 0x0740 */ UMonoWaveTableSynthPreset* CurrentPreset;

    float GetCurveTangent(int32_t TableIndex);
    TArray<float> GetKeyFrameValuesForTable(float TableIndex) const;
    int32_t GetMaxTableIndex() const;
    int32_t GetNumTableEntries();
    void NoteOff(const float InMidiNote);
    void NoteOn(const float InMidiNote, const float InVelocity);
    void RefreshAllWaveTables();
    void RefreshWaveTable(int32_t index);
    void SetAmpEnvelopeAttackTime(const float InAttackTimeMsec);
    void SetAmpEnvelopeBiasDepth(const float InDepth);
    void SetAmpEnvelopeBiasInvert(const bool bInBiasInvert);
    void SetAmpEnvelopeDecayTime(const float InDecayTimeMsec);
    void SetAmpEnvelopeDepth(const float InDepth);
    void SetAmpEnvelopeInvert(const bool bInInvert);
    void SetAmpEnvelopeReleaseTime(const float InReleaseTimeMsec);
    void SetAmpEnvelopeSustainGain(const float InSustainGain);
    bool SetCurveInterpolationType(CurveInterpolationType InterpolationType, int32_t TableIndex);
    bool SetCurveTangent(int32_t TableIndex, float InNewTangent);
    bool SetCurveValue(int32_t TableIndex, int32_t KeyframeIndex, const float NewValue);
    void SetFilterEnvelopeAttackTime(const float InAttackTimeMsec);
    void SetFilterEnvelopeBiasDepth(const float InDepth);
    void SetFilterEnvelopeBiasInvert(const bool bInBiasInvert);
    void SetFilterEnvelopeDepth(const float InDepth);
    void SetFilterEnvelopeInvert(const bool bInInvert);
    void SetFilterEnvelopeReleaseTime(const float InReleaseTimeMsec);
    void SetFilterEnvelopeSustainGain(const float InSustainGain);
    void SetFilterEnvelopenDecayTime(const float InDecayTimeMsec);
    void SetFrequency(const float FrequencyHz);
    void SetFrequencyPitchBend(const float FrequencyOffsetCents);
    void SetFrequencyWithMidiNote(const float InMidiNote);
    void SetLowPassFilterResonance(float InNewQ);
    void SetPosLfoDepth(const float InLfoDepth);
    void SetPosLfoFrequency(const float InLfoFrequency);
    void SetPosLfoType(const ESynthLFOType InLfoType);
    void SetPositionEnvelopeAttackTime(const float InAttackTimeMsec);
    void SetPositionEnvelopeBiasDepth(const float InDepth);
    void SetPositionEnvelopeBiasInvert(const bool bInBiasInvert);
    void SetPositionEnvelopeDecayTime(const float InDecayTimeMsec);
    void SetPositionEnvelopeDepth(const float InDepth);
    void SetPositionEnvelopeInvert(const bool bInInvert);
    void SetPositionEnvelopeReleaseTime(const float InReleaseTimeMsec);
    void SetPositionEnvelopeSustainGain(const float InSustainGain);
    void SetSustainPedalState(bool InSustainPedalState);
    void SetWaveTablePosition(float InPosition);
};

// Size: 0x740
class USynthComponentToneGenerator : public USynthComponent {
    /* 0x0720 */ float Frequency;
    /* 0x0724 */ float Volume;

    void SetFrequency(float InFrequency);
    void SetVolume(float InVolume);
};

// Size: 0x590
class USynthKnob : public UWidget {
    /* 0x0228 */ float Value;
    /* 0x022c */ float StepSize;
    /* 0x0230 */ float MouseSpeed;
    /* 0x0234 */ float MouseFineTuneSpeed;
    /* 0x0238 */ bool ShowTooltipInfo;
    /* 0x0240 */ FText ParameterName;
    /* 0x0258 */ FText ParameterUnits;
    /* 0x0270 */ FDelegate ValueDelegate;
    /* 0x0288 */ FSynthKnobStyle WidgetStyle;
    /* 0x0520 */ bool Locked;
    /* 0x0521 */ bool IsFocusable;
    /* 0x0528 */ FMulticastInlineDelegate OnMouseCaptureBegin;
    /* 0x0538 */ FMulticastInlineDelegate OnMouseCaptureEnd;
    /* 0x0548 */ FMulticastInlineDelegate OnControllerCaptureBegin;
    /* 0x0558 */ FMulticastInlineDelegate OnControllerCaptureEnd;
    /* 0x0568 */ FMulticastInlineDelegate OnValueChanged;

    float GetValue() const;
    void SetLocked(bool InValue);
    void SetStepSize(float InValue);
    void SetValue(float InValue);
};

// Size: 0x298
struct FSynthKnobStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush LargeKnob;
    /* 0x00a8 */ FSlateBrush LargeKnobOverlay;
    /* 0x0148 */ FSlateBrush MediumKnob;
    /* 0x01e8 */ FSlateBrush MediumKnobOverlay;
    /* 0x0288 */ float MinValueAngle;
    /* 0x028c */ float MaxValueAngle;
    /* 0x0290 */ ESynthKnobSize KnobSize;
};

// Size: 0x850
class USynthSamplePlayer : public USynthComponent {
    /* 0x0720 */ USoundWave* SoundWave;
    /* 0x0728 */ FMulticastInlineDelegate OnSampleLoaded;
    /* 0x0738 */ FMulticastInlineDelegate OnSamplePlaybackProgress;

    float GetCurrentPlaybackProgressPercent() const;
    float GetCurrentPlaybackProgressTime() const;
    float GetSampleDuration() const;
    bool IsLoaded() const;
    void SeekToTime(float TimeSec, ESamplePlayerSeekType SeekType, bool bWrap);
    void SetPitch(float InPitch, float TimeSec);
    void SetScrubMode(bool bScrubMode);
    void SetScrubTimeWidth(float InScrubTimeWidthSec);
    void SetSoundWave(USoundWave* InSoundWave);
};

// Size: 0x10
struct FSynthSlateStyle : public FSlateWidgetStyle {
    /* 0x0008 */ ESynthSlateSizeType SizeType;
    /* 0x0009 */ ESynthSlateColorStyle ColorStyle;
};

// Size: 0x30
class USynthesisUtilitiesBlueprintFunctionLibrary : public UBlueprintFunctionLibrary {

    static float GetLinearFrequency(float InLogFrequencyValue, float InDomainMin, float InDomainMax, float InRangeMin, float InRangeMax);
    static float GetLogFrequency(float InLinearValue, float InDomainMin, float InDomainMax, float InRangeMin, float InRangeMax);
};

// Size: 0x18
struct FTapDelayInfo {
    /* 0x0000 */ ETapLineMode TapLineMode;
    /* 0x0004 */ float DelayLength;
    /* 0x0008 */ float Gain;
    /* 0x000c */ int32_t OutputChannel;
    /* 0x0010 */ float PanInDegrees;
    /* 0x0014 */ int32_t TapId;
};

// Size: 0xb8
class UAudioImpulseResponseFactory : public UFactory {
};

// Size: 0x88
class UModularSynthPresetBankFactory : public UFactory {
};

// Size: 0x88
class UMonoWaveTableSynthPresetFactory : public UFactory {
};

// Size: 0x2e0
class USynthesisEditorSettings : public UDeveloperSettings {
    /* 0x0060 */ FSoftObjectPath BitCrusherWidget;
    /* 0x0080 */ FSoftObjectPath ChorusWidget;
    /* 0x00a0 */ FSoftObjectPath DynamicsProcessorWidget;
    /* 0x00c0 */ FSoftObjectPath EnvelopeFollowerWidget;
    /* 0x00e0 */ FSoftObjectPath EQWidget;
    /* 0x0100 */ FSoftObjectPath FilterWidget;
    /* 0x0120 */ FSoftObjectPath FoldbackDistortionWidget;
    /* 0x0140 */ FSoftObjectPath MidSideSpreaderWidget;
    /* 0x0160 */ FSoftObjectPath PannerWidget;
    /* 0x0180 */ FSoftObjectPath PhaserWidget;
    /* 0x01a0 */ FSoftObjectPath RingModulationWidget;
    /* 0x01c0 */ FSoftObjectPath SimpleDelayWidget;
    /* 0x01e0 */ FSoftObjectPath StereoDelayWidget;
    /* 0x0200 */ FSoftObjectPath WaveShaperWidget;
    /* 0x0220 */ FSoftObjectPath SubmixConvolutionReverbWidget;
    /* 0x0240 */ FSoftObjectPath SubmixDelayWidget;
    /* 0x0260 */ FSoftObjectPath SubmixFilterWidget;
    /* 0x0280 */ FSoftObjectPath SubmixFlexiverbWidget;
    /* 0x02a0 */ FSoftObjectPath SubmixStereoDelayWidget;
    /* 0x02c0 */ FSoftObjectPath SubmixTapDelayWidget;
};

// Size: 0x4a8
class UMovieSceneTakeSection : public UMovieSceneSection {
    /* 0x0128 */ FMovieSceneIntegerChannel HoursCurve;
    /* 0x01b8 */ FMovieSceneIntegerChannel MinutesCurve;
    /* 0x0248 */ FMovieSceneIntegerChannel SecondsCurve;
    /* 0x02d8 */ FMovieSceneIntegerChannel FramesCurve;
    /* 0x0368 */ FMovieSceneFloatChannel SubFramesCurve;
    /* 0x0408 */ FMovieSceneStringChannel Slate;
};

// Size: 0x90
class UMovieSceneTakeSettings : public UObject {
    /* 0x0030 */ FString HoursName;
    /* 0x0040 */ FString MinutesName;
    /* 0x0050 */ FString SecondsName;
    /* 0x0060 */ FString FramesName;
    /* 0x0070 */ FString SubFramesName;
    /* 0x0080 */ FString SlateName;
};

// Size: 0xe8
class UMovieSceneTakeTrack : public UMovieSceneNameableTrack {
    /* 0x00d8 */ TArray<UMovieSceneSection*> Sections;
};

enum class ETakeRecorderMode {
    RecordNewSequence = 0,
    RecordIntoSequence = 1,
    ETakeRecorderMode_MAX = 2,
};

enum class ETakeRecorderPanelMode {
    NewRecording = 0,
    RecordingInto = 1,
    EditingPreset = 2,
    ReviewingRecording = 3,
    ETakeRecorderPanelMode_MAX = 4,
};

enum class ETakeRecorderState {
    CountingDown = 0,
    PreRecord = 1,
    TickingAfterPre = 2,
    Started = 3,
    Stopped = 4,
    Cancelled = 5,
    ETakeRecorderState_MAX = 6,
};

// Size: 0x1d0
class UTakeRecorder : public UObject {
    /* 0x0060 */ ULevelSequence* SequenceAsset;
    /* 0x0068 */ UTakeRecorderOverlayWidget* OverlayWidget;
    /* 0x0070 */ TWeakObjectPtr<UWorld> WeakWorld;
    /* 0x0078 */ FTakeRecorderParameters Parameters;

    float GetCountdownSeconds() const;
    ULevelSequence* GetSequence() const;
    ETakeRecorderState GetState() const;
};

// Size: 0x30
class UTakeRecorderBlueprintLibrary : public UBlueprintFunctionLibrary {

    static UTakeRecorder* GetActiveRecorder();
    static FTakeRecorderParameters GetDefaultParameters();
    static UTakeRecorderPanel* GetTakeRecorderPanel();
    static bool IsRecording();
    static bool IsTakeRecorderEnabled();
    void OnTakeRecorderCancelled__DelegateSignature();
    void OnTakeRecorderFinished__DelegateSignature(ULevelSequence* SequenceAsset);
    void OnTakeRecorderMarkedFrameAdded__DelegateSignature(const FMovieSceneMarkedFrame& MarkedFrame);
    void OnTakeRecorderPanelChanged__DelegateSignature();
    void OnTakeRecorderPreInitialize__DelegateSignature();
    void OnTakeRecorderStarted__DelegateSignature();
    void OnTakeRecorderStopped__DelegateSignature();
    static UTakeRecorderPanel* OpenTakeRecorderPanel();
    static void SetOnTakeRecorderCancelled(FDelegate OnTakeRecorderCancelled);
    static void SetOnTakeRecorderFinished(FDelegate OnTakeRecorderFinished);
    static void SetOnTakeRecorderMarkedFrameAdded(FDelegate OnTakeRecorderMarkedFrameAdded);
    static void SetOnTakeRecorderPanelChanged(FDelegate OnTakeRecorderPanelChanged);
    static void SetOnTakeRecorderPreInitialize(FDelegate OnTakeRecorderPreInitialize);
    static void SetOnTakeRecorderStarted(FDelegate OnTakeRecorderStarted);
    static void SetOnTakeRecorderStopped(FDelegate OnTakeRecorderStopped);
    static UTakeRecorder* StartRecording(ULevelSequence* LevelSequence, UTakeRecorderSources* Sources, UTakeMetaData* MetaData, const FTakeRecorderParameters& Parameters);
    static void StopRecording();
};

// Size: 0x400
class UTakeRecorderOverlayWidget : public UUserWidget {
    /* 0x03f8 */ UTakeRecorder* Recorder;
};

// Size: 0x40
class UTakeRecorderPanel : public UObject {

    bool CanStartRecording(FText& OutErrorText) const;
    void ClearPendingTake();
    FFrameRate GetFrameRate() const;
    ULevelSequence* GetLastRecordedLevelSequence() const;
    ULevelSequence* GetLevelSequence() const;
    ETakeRecorderPanelMode GetMode() const;
    UTakeRecorderSources* GetSources() const;
    UTakeMetaData* GetTakeMetaData() const;
    void NewTake();
    void SetFrameRate(FFrameRate InFrameRate);
    void SetFrameRateFromTimecode(bool bInFromTimecode);
    void SetupForEditing(UTakePreset* TakePreset);
    void SetupForRecordingInto_LevelSequence(ULevelSequence* LevelSequenceAsset);
    void SetupForRecording_LevelSequence(ULevelSequence* LevelSequenceAsset);
    void SetupForRecording_TakePreset(UTakePreset* TakePresetAsset);
    void SetupForViewing(ULevelSequence* LevelSequenceAsset);
    void StartRecording() const;
    void StopRecording() const;
};

// Size: 0x70
struct FTakeRecorderParameters {
    /* 0x0000 */ FTakeRecorderUserParameters User;
    /* 0x0018 */ FTakeRecorderProjectParameters Project;
    /* 0x0068 */ ETakeRecorderMode TakeRecorderMode;
    /* 0x0069 */ bool bDisableRecordingAndSave;
};

// Size: 0x50
struct FTakeRecorderProjectParameters {
    /* 0x0000 */ FDirectoryPath RootTakeSaveDir;
    /* 0x0010 */ FString TakeSaveDir;
    /* 0x0020 */ FString DefaultSlate;
    /* 0x0030 */ bool bStartAtCurrentTimecode;
    /* 0x0031 */ bool bRecordTimecode;
    /* 0x0032 */ bool bRecordSourcesIntoSubSequences;
    /* 0x0033 */ bool bRecordToPossessable;
    /* 0x0038 */ TArray<FTakeRecorderTrackSettings> DefaultTracks;
    /* 0x0048 */ bool bShowNotifications;
};

// Size: 0x90
class UTakeRecorderProjectSettings : public UObject {
    /* 0x0030 */ FTakeRecorderProjectParameters Settings;
};

// Size: 0x18
struct FTakeRecorderUserParameters {
    /* 0x0000 */ bool bMaximizeViewport;
    /* 0x0004 */ float CountdownSeconds;
    /* 0x0008 */ float EngineTimeDilation;
    /* 0x000c */ bool bStopAtPlaybackEnd;
    /* 0x000d */ bool bRemoveRedundantTracks;
    /* 0x0010 */ float ReduceKeysTolerance;
    /* 0x0014 */ bool bSaveRecordedAssets;
    /* 0x0015 */ bool bAutoLock;
    /* 0x0016 */ bool bAutoSerialize;
};

// Size: 0x90
class UTakeRecorderUserSettings : public UObject {
    /* 0x0030 */ FTakeRecorderUserParameters Settings;
    /* 0x0048 */ FDirectoryPath PresetSaveDir;
    /* 0x0058 */ TSoftObjectPtr<UTakePreset> LastOpenedPreset;
    /* 0x0088 */ bool bIsSequenceOpen;
    /* 0x0089 */ bool bShowUserSettingsOnUI;
};

enum class ETakeRecorderActorRecordType {
    Possessable = 0,
    Spawnable = 1,
    ProjectDefault = 2,
    ETakeRecorderActorRecordType_MAX = 3,
};

// Size: 0x1d0
class UTakeRecorderActorSource : public UTakeRecorderSource {
    /* 0x0048 */ TSoftObjectPtr<AActor> Target;
    /* 0x0078 */ ETakeRecorderActorRecordType RecordType;
    /* 0x0079 */ bool bRecordParentHierarchy;
    /* 0x007a */ bool bReduceKeys;
    /* 0x0080 */ UActorRecorderPropertyMap* RecordedProperties;
    /* 0x0088 */ ULevelSequence* TargetLevelSequence;
    /* 0x0090 */ ULevelSequence* MasterLevelSequence;
    /* 0x0098 */ TArray<UObject*> FactorySettings;
    /* 0x00a8 */ TArray<UMovieSceneTrackRecorder*> TrackRecorders;

    static UTakeRecorderSource* AddSourceForActor(AActor* InActor, UTakeRecorderSources* InSources);
    TSoftObjectPtr<AActor> GetSourceActor() const;
    static void RemoveActorFromSources(AActor* InActor, UTakeRecorderSources* InSources);
    void SetSourceActor(TSoftObjectPtr<AActor> InTarget);
};

// Size: 0x70
class UTakeRecorderCameraCutSource : public UTakeRecorderSource {
    /* 0x0040 */ UWorld* World;
    /* 0x0048 */ ULevelSequence* MasterLevelSequence;
};

// Size: 0x60
class UTakeRecorderLevelSequenceSource : public UTakeRecorderSource {
    /* 0x0040 */ TArray<ULevelSequence*> LevelSequencesToTrigger;
};

// Size: 0x60
class UTakeRecorderLevelVisibilitySource : public UTakeRecorderLevelVisibilitySourceSettings {
};

// Size: 0x58
class UTakeRecorderLevelVisibilitySourceSettings : public UTakeRecorderSource {
    /* 0x0040 */ FText LevelVisibilityTrackName;
};

// Size: 0xa0
class UTakeRecorderMicrophoneAudioSource : public UTakeRecorderMicrophoneAudioSourceSettings {
    /* 0x0068 */ float AudioGain;
    /* 0x006c */ bool bSplitAudioChannelsIntoSeparateTracks;
    /* 0x006d */ bool bReplaceRecordedAudio;
};

// Size: 0x68
class UTakeRecorderMicrophoneAudioSourceSettings : public UTakeRecorderSource {
    /* 0x0040 */ FText AudioTrackName;
    /* 0x0058 */ FString AudioSubDirectory;
};

// Size: 0xb8
class UTakeRecorderNearbySpawnedActorSource : public UTakeRecorderSource {
    /* 0x0040 */ float Proximity;
    /* 0x0044 */ bool bFilterSpawnedActors;
    /* 0x0048 */ TArray<UClass*> FilterTypes;
};

// Size: 0x48
class UTakeRecorderPlayerSource : public UTakeRecorderSource {
};

// Size: 0x50
class UTakeRecorderWorldSource : public UTakeRecorderWorldSourceSettings {
};

// Size: 0x48
class UTakeRecorderWorldSourceSettings : public UTakeRecorderSource {
    /* 0x0040 */ bool bRecordWorldSettings;
    /* 0x0041 */ bool bAutotrackActors;
};

// Size: 0xd0
class UMovieScene3DAttachTrackRecorder : public UMovieSceneTrackRecorder {
};

// Size: 0x230
class UMovieScene3DTransformTrackRecorder : public UMovieSceneTrackRecorder {
};

// Size: 0x1c0
class UMovieSceneAnimationTrackRecorder : public UMovieSceneTrackRecorder {
};

// Size: 0x70
class UMovieSceneAnimationTrackRecorderEditorSettings : public UMovieSceneTrackRecorderSettings {
    /* 0x0030 */ FText AnimationTrackName;
    /* 0x0048 */ FString AnimationAssetName;
    /* 0x0058 */ FString AnimationSubDirectory;
    /* 0x0068 */ uint8_t InterpMode;
    /* 0x0069 */ uint8_t TangentMode;
    /* 0x006a */ bool bRemoveRootAnimation;
};

// Size: 0x70
class UMovieSceneAnimationTrackRecorderSettings : public UMovieSceneAnimationTrackRecorderEditorSettings {
};

// Size: 0xb8
class UMovieSceneParticleTrackRecorder : public UMovieSceneTrackRecorder {

    void OnTriggered(UParticleSystemComponent* Component, bool bActivating);
};

// Size: 0xc0
class UMovieScenePropertyTrackRecorder : public UMovieSceneTrackRecorder {
};

// Size: 0xf0
class UMovieSceneSpawnTrackRecorder : public UMovieSceneTrackRecorder {
};

// Size: 0x90
class UMovieSceneTrackRecorder : public UObject {
};

// Size: 0x30
class UMovieSceneTrackRecorderSettings : public UObject {
};

// Size: 0xa0
class UMovieSceneVisibilityTrackRecorder : public UMovieSceneTrackRecorder {
};

// Size: 0x20
struct FTakeRecorderPropertyTrackSettings {
    /* 0x0000 */ FString ComponentPath;
    /* 0x0010 */ FString PropertyPath;
};

// Size: 0x40
struct FTakeRecorderTrackSettings {
    /* 0x0000 */ FSoftClassPath MatchingActorClass;
    /* 0x0020 */ TArray<FTakeRecorderPropertyTrackSettings> DefaultPropertyTracks;
    /* 0x0030 */ TArray<FTakeRecorderPropertyTrackSettings> ExcludePropertyTracks;
};

// Size: 0x28
struct FActorRecordedProperty {
    /* 0x0000 */ FName PropertyName;
    /* 0x000c */ bool bEnabled;
    /* 0x0010 */ FText RecorderName;
};

// Size: 0x90
class UActorRecorderPropertyMap : public UObject {
    /* 0x0030 */ TSoftObjectPtr<UObject> RecordedObject;
    /* 0x0060 */ TArray<FActorRecordedProperty> Properties;
    /* 0x0070 */ TArray<UActorRecorderPropertyMap*> Children;
};

// Size: 0x110
class UTakeMetaData : public UObject {
    /* 0x0038 */ bool bIsLocked;
    /* 0x0040 */ FString Slate;
    /* 0x0050 */ int32_t TakeNumber;
    /* 0x0058 */ FDateTime Timestamp;
    /* 0x0060 */ FTimecode TimecodeIn;
    /* 0x0074 */ FTimecode TimecodeOut;
    /* 0x0088 */ FFrameTime Duration;
    /* 0x0090 */ FFrameRate FrameRate;
    /* 0x0098 */ FString Description;
    /* 0x00a8 */ TSoftObjectPtr<UTakePreset> PresetOrigin;
    /* 0x00d8 */ TSoftObjectPtr<ULevel> LevelOrigin;
    /* 0x0108 */ bool bFrameRateFromTimecode;

    FString GenerateAssetPath(FString PathFormatString) const;
    FString GetDescription() const;
    FFrameTime GetDuration() const;
    FFrameRate GetFrameRate();
    bool GetFrameRateFromTimecode() const;
    ULevel* GetLevelOrigin() const;
    FString GetLevelPath() const;
    UTakePreset* GetPresetOrigin() const;
    FString GetSlate() const;
    int32_t GetTakeNumber() const;
    FDateTime GetTimeStamp() const;
    FTimecode GetTimecodeIn() const;
    FTimecode GetTimecodeOut() const;
    bool IsLocked() const;
    void Lock();
    bool Recorded() const;
    void SetDescription(FString InDescription);
    void SetDuration(FFrameTime InDuration);
    void SetFrameRate(FFrameRate InFrameRate);
    void SetFrameRateFromTimecode(bool InFromTimecode);
    void SetLevelOrigin(ULevel* InLevelOrigin);
    void SetPresetOrigin(UTakePreset* InPresetOrigin);
    void SetSlate(FString InSlate, bool bEmitChanged);
    void SetTakeNumber(int32_t InTakeNumber, bool bEmitChanged);
    void SetTimecodeIn(FTimecode InTimecodeIn);
    void SetTimecodeOut(FTimecode InTimecodeOut);
    void SetTimestamp(FDateTime InTimestamp);
    void Unlock();
};

// Size: 0x50
class UTakePreset : public UObject {
    /* 0x0030 */ ULevelSequence* LevelSequence;
};

// Size: 0x40
class UTakeRecorderSource : public UObject {
    /* 0x0030 */ bool bEnabled;
    /* 0x0034 */ int32_t TakeNumber;
    /* 0x0038 */ FColor TrackTint;
};

// Size: 0x118
class UTakeRecorderSources : public UObject {
    /* 0x0048 */ TArray<UTakeRecorderSource*> Sources;
    /* 0x0058 */ TMap<UTakeRecorderSource*, ULevelSequence*> SourceSubSequenceMap;
    /* 0x00a8 */ TArray<UMovieSceneSubSection*> ActiveSubSections;

    UTakeRecorderSource* AddSource(UClass* InSourceType);
    TArray<UTakeRecorderSource*> GetSourcesCopy() const;
    void RemoveSource(UTakeRecorderSource* InSource);
    void StartRecordingSource(TArray<UTakeRecorderSource*> InSources, const FQualifiedFrameTime& CurrentFrameTime);
};

// Size: 0x30
class UTakesCoreBlueprintLibrary : public UBlueprintFunctionLibrary {

    static int32_t ComputeNextTakeNumber(FString Slate);
    static TArray<FAssetData> FindTakes(FString Slate, int32_t TakeNumber);
    void OnTakeRecorderSlateChanged__DelegateSignature(FString Slate);
    void OnTakeRecorderTakeNumberChanged__DelegateSignature(int32_t TakeNumber);
    static void SetOnTakeRecorderSlateChanged(FDelegate OnTakeRecorderSlateChanged);
    static void SetOnTakeRecorderTakeNumberChanged(FDelegate OnTakeRecorderTakeNumberChanged);
};

// Size: 0x30
struct FTargetDeviceClaimDenied {
    /* 0x0000 */ FString DeviceName;
    /* 0x0010 */ FString HostName;
    /* 0x0020 */ FString HostUser;
};

// Size: 0x30
struct FTargetDeviceClaimed {
    /* 0x0000 */ FString DeviceName;
    /* 0x0010 */ FString HostName;
    /* 0x0020 */ FString HostUser;
};

// Size: 0x1c
struct FTargetDeviceServiceDeployCommit {
    /* 0x0000 */ FName Variant;
    /* 0x000c */ FGuid TransactionId;
};

// Size: 0x20
struct FTargetDeviceServiceDeployFile {
    /* 0x0000 */ FString TargetFileName;
    /* 0x0010 */ FGuid TransactionId;
};

// Size: 0x38
struct FTargetDeviceServiceDeployFinished {
    /* 0x0000 */ FName Variant;
    /* 0x0010 */ FString AppID;
    /* 0x0020 */ bool Succeeded;
    /* 0x0024 */ FGuid TransactionId;
};

// Size: 0x38
struct FTargetDeviceServiceLaunchApp {
    /* 0x0000 */ FName Variant;
    /* 0x0010 */ FString AppID;
    /* 0x0020 */ uint8_t BuildConfiguration;
    /* 0x0028 */ FString Params;
};

// Size: 0x18
struct FTargetDeviceServiceLaunchFinished {
    /* 0x0000 */ FString AppID;
    /* 0x0010 */ int32_t ProcessId;
    /* 0x0014 */ bool Succeeded;
};

// Size: 0x10
struct FTargetDeviceServicePing {
    /* 0x0000 */ FString HostUser;
};

// Size: 0xd8
struct FTargetDeviceServicePong {
    /* 0x0000 */ bool Connected;
    /* 0x0001 */ bool Authorized;
    /* 0x0008 */ FString HostName;
    /* 0x0018 */ FString HostUser;
    /* 0x0028 */ FString Make;
    /* 0x0038 */ FString Model;
    /* 0x0048 */ FString Name;
    /* 0x0058 */ FString DeviceUser;
    /* 0x0068 */ FString DeviceUserPassword;
    /* 0x0078 */ bool Shared;
    /* 0x0079 */ bool SupportsMultiLaunch;
    /* 0x007a */ bool SupportsPowerOff;
    /* 0x007b */ bool SupportsPowerOn;
    /* 0x007c */ bool SupportsReboot;
    /* 0x007d */ bool SupportsVariants;
    /* 0x0080 */ FString Type;
    /* 0x0090 */ FName DefaultVariant;
    /* 0x00a0 */ TArray<FTargetDeviceVariant> Variants;
    /* 0x00b0 */ bool Aggregated;
    /* 0x00b8 */ FString AllDevicesName;
    /* 0x00c8 */ FName AllDevicesDefaultVariant;
};

// Size: 0x18
struct FTargetDeviceServicePowerOff {
    /* 0x0000 */ bool Force;
    /* 0x0008 */ FString Operator;
};

// Size: 0x10
struct FTargetDeviceServicePowerOn {
    /* 0x0000 */ FString Operator;
};

// Size: 0x10
struct FTargetDeviceServiceReboot {
    /* 0x0000 */ FString Operator;
};

// Size: 0x30
struct FTargetDeviceServiceRunExecutable {
    /* 0x0000 */ FName Variant;
    /* 0x0010 */ FString ExecutablePath;
    /* 0x0020 */ FString Params;
};

// Size: 0x28
struct FTargetDeviceServiceRunFinished {
    /* 0x0000 */ FName Variant;
    /* 0x0010 */ FString ExecutablePath;
    /* 0x0020 */ int32_t ProcessId;
    /* 0x0024 */ bool Succeeded;
};

// Size: 0x20
struct FTargetDeviceServiceTerminateLaunchedProcess {
    /* 0x0000 */ FName Variant;
    /* 0x0010 */ FString AppID;
};

// Size: 0x30
struct FTargetDeviceUnclaimed {
    /* 0x0000 */ FString DeviceName;
    /* 0x0010 */ FString HostName;
    /* 0x0020 */ FString HostUser;
};

// Size: 0x58
struct FTargetDeviceVariant {
    /* 0x0000 */ FString DeviceID;
    /* 0x0010 */ FName VariantName;
    /* 0x0020 */ FString TargetPlatformName;
    /* 0x0030 */ FName TargetPlatformId;
    /* 0x003c */ FName VanillaPlatformId;
    /* 0x0048 */ FString PlatformDisplayName;
};

// Size: 0x60
class UTcpMessagingSettings : public UObject {
    /* 0x0030 */ bool EnableTransport;
    /* 0x0038 */ FString ListenEndpoint;
    /* 0x0048 */ TArray<FString> ConnectToEndpoints;
    /* 0x0058 */ int32_t ConnectionRetryDelay;
    /* 0x005c */ bool bStopServiceWhenAppDeactivates;
};

// Size: 0x120
class UCameraAnimationSequence : public UTemplateSequence {
};

enum class ETemplateSectionPropertyScaleType {
    FloatProperty = 0,
    TransformPropertyLocationOnly = 1,
    TransformPropertyRotationOnly = 2,
    ETemplateSectionPropertyScaleType_MAX = 3,
};

// Size: 0x6c0
class USequenceCameraShakeCameraStandIn : public UObject {
    /* 0x0038 */ float FieldOfView;
    /* 0x003c */ bool bConstrainAspectRatio;
    /* 0x0040 */ float AspectRatio;
    /* 0x0050 */ FPostProcessSettings PostProcessSettings;
    /* 0x05e0 */ float PostProcessBlendWeight;
    /* 0x05e4 */ FCameraFilmbackSettings Filmback;
    /* 0x05f0 */ FCameraLensSettings LensSettings;
    /* 0x0608 */ FCameraFocusSettings FocusSettings;
    /* 0x0668 */ float CurrentFocalLength;
    /* 0x066c */ float CurrentAperture;
    /* 0x0670 */ float CurrentFocusDistance;
};

// Size: 0x60
class USequenceCameraShakePattern : public UCameraShakePattern {
    /* 0x0030 */ UCameraAnimationSequence* Sequence;
    /* 0x0038 */ float PlayRate;
    /* 0x003c */ float Scale;
    /* 0x0040 */ float BlendInTime;
    /* 0x0044 */ float BlendOutTime;
    /* 0x0048 */ float RandomSegmentDuration;
    /* 0x004c */ bool bRandomSegment;
    /* 0x0050 */ USequenceCameraShakeSequencePlayer* Player;
    /* 0x0058 */ USequenceCameraShakeCameraStandIn* CameraStandIn;
};

// Size: 0x438
class USequenceCameraShakeSequencePlayer : public UObject {
    /* 0x02d8 */ UObject* BoundObjectOverride;
    /* 0x02e0 */ UMovieSceneSequence* Sequence;
    /* 0x02e8 */ FMovieSceneRootEvaluationTemplateInstance RootTemplateInstance;
};

// Size: 0xd0
struct FTemplateSectionPropertyScale {
    /* 0x0000 */ FGuid ObjectBinding;
    /* 0x0010 */ FMovieScenePropertyBinding PropertyBinding;
    /* 0x002c */ ETemplateSectionPropertyScaleType PropertyScaleType;
    /* 0x0030 */ FMovieSceneFloatChannel FloatChannel;
};

// Size: 0x120
class UTemplateSequence : public UMovieSceneSequence {
    /* 0x0068 */ UMovieScene* MovieScene;
    /* 0x0070 */ TSoftClassPtr<AActor> BoundActorClass;
    /* 0x00a0 */ TSoftObjectPtr<AActor> BoundPreviewActor;
    /* 0x00d0 */ TMap<FGuid, FName> BoundActorComponents;
};

// Size: 0x358
class ATemplateSequenceActor : public AActor {
    /* 0x0308 */ FMovieSceneSequencePlaybackSettings PlaybackSettings;
    /* 0x0320 */ UTemplateSequencePlayer* SequencePlayer;
    /* 0x0328 */ FSoftObjectPath TemplateSequence;
    /* 0x0348 */ FTemplateSequenceBindingOverrideData BindingOverride;

    UTemplateSequence* GetSequence() const;
    UTemplateSequencePlayer* GetSequencePlayer() const;
    UTemplateSequence* LoadSequence() const;
    void SetBinding(AActor* Actor, bool bOverridesDefault);
    void SetSequence(UTemplateSequence* InSequence);
};

// Size: 0xc
struct FTemplateSequenceBindingOverrideData {
    /* 0x0000 */ TWeakObjectPtr<UObject> Object;
    /* 0x0008 */ bool bOverridesDefault;
};

// Size: 0x508
class UTemplateSequencePlayer : public UMovieSceneSequencePlayer {

    static UTemplateSequencePlayer* CreateTemplateSequencePlayer(UObject* WorldContextObject, UTemplateSequence* TemplateSequence, FMovieSceneSequencePlaybackSettings Settings, ATemplateSequenceActor*& OutActor);
};

// Size: 0xa0
class UTemplateSequencePropertyScalingEvaluatorSystem : public UMovieSceneEntitySystem {
};

// Size: 0xa8
class UTemplateSequencePropertyScalingInstantiatorSystem : public UMovieSceneEntitySystem {
};

// Size: 0x1d8
class UTemplateSequenceSection : public UMovieSceneSubSection {
    /* 0x01c8 */ TArray<FTemplateSectionPropertyScale> PropertyScales;
};

// Size: 0xc0
class UTemplateSequenceSystem : public UMovieSceneEntitySystem {
};

// Size: 0xe8
class UTemplateSequenceTrack : public UMovieSceneSubTrack {
};

// Size: 0x88
class UCameraAnimationSequenceFactoryNew : public UFactory {
};

// Size: 0x38
class UTemplateSequenceEditorSettings : public UObject {
    /* 0x0030 */ bool bShowOutdatedAssetsInCameraAnimationTrackEditor;
};

// Size: 0x90
class UTemplateSequenceFactoryNew : public UFactory {
    /* 0x0088 */ UClass* BoundActorClass;
};

enum class EFrameNumberDisplayFormats {
    NonDropFrameTimecode = 0,
    DropFrameTimecode = 1,
    Seconds = 2,
    Frames = 3,
    MAX_Count = 4,
    EFrameNumberDisplayFormats_MAX = 5,
};

enum class ETimedDataInputEvaluationType {
    None = 0,
    Timecode = 1,
    PlatformTime = 2,
    ETimedDataInputEvaluationType_MAX = 3,
};

enum class ETimedDataInputState {
    Connected = 0,
    Unresponsive = 1,
    Disconnected = 2,
    ETimedDataInputState_MAX = 3,
};

// Size: 0x30
class UFixedFrameRateCustomTimeStep : public UEngineCustomTimeStep {
};

// Size: 0x30
class UGenlockedCustomTimeStep : public UFixedFrameRateCustomTimeStep {
};

// Size: 0x50
class UGenlockedFixedRateCustomTimeStep : public UGenlockedCustomTimeStep {
    /* 0x0030 */ FFrameRate FrameRate;
};

// Size: 0x60
class UGenlockedTimecodeProvider : public UTimecodeProvider {
    /* 0x0038 */ bool bUseGenlockToCount;
};

// Size: 0x30
class UTimeManagementBlueprintLibrary : public UBlueprintFunctionLibrary {

    static FFrameNumber Add_FrameNumberFrameNumber(FFrameNumber A, FFrameNumber B);
    static FFrameNumber Add_FrameNumberInteger(FFrameNumber A, int32_t B);
    static int32_t Conv_FrameNumberToInteger(const FFrameNumber& InFrameNumber);
    static float Conv_FrameRateToSeconds(const FFrameRate& InFrameRate);
    static float Conv_QualifiedFrameTimeToSeconds(const FQualifiedFrameTime& InFrameTime);
    static FString Conv_TimecodeToString(const FTimecode& InTimecode, bool bForceSignDisplay);
    static FFrameNumber Divide_FrameNumberInteger(FFrameNumber A, int32_t B);
    static FTimecode GetTimecode();
    static FFrameRate GetTimecodeFrameRate();
    static bool IsValid_Framerate(const FFrameRate& InFrameRate);
    static bool IsValid_MultipleOf(const FFrameRate& InFrameRate, const FFrameRate& OtherFramerate);
    static FFrameNumber Multiply_FrameNumberInteger(FFrameNumber A, int32_t B);
    static FFrameTime Multiply_SecondsFrameRate(float TimeInSeconds, const FFrameRate& FrameRate);
    static FFrameTime SnapFrameTimeToRate(const FFrameTime& SourceTime, const FFrameRate& SourceRate, const FFrameRate& SnapToRate);
    static FFrameNumber Subtract_FrameNumberFrameNumber(FFrameNumber A, FFrameNumber B);
    static FFrameNumber Subtract_FrameNumberInteger(FFrameNumber A, int32_t B);
    static FFrameTime TransformTime(const FFrameTime& SourceTime, const FFrameRate& SourceRate, const FFrameRate& DestinationRate);
};

// Size: 0x38
class UTimeSynchronizationSource : public UObject {
    /* 0x0030 */ bool bUseForSynchronization;
    /* 0x0034 */ int32_t FrameOffset;
};

// Size: 0x18
struct FTimedDataChannelSampleTime {
};

// Size: 0x8
struct FTimedDataInputEvaluationData {
    /* 0x0000 */ float DistanceToNewestSampleSeconds;
    /* 0x0004 */ float DistanceToOldestSampleSeconds;
};

enum class EToolMenuInsertType {
    Default = 0,
    Before = 1,
    After = 2,
    First = 3,
    EToolMenuInsertType_MAX = 4,
};

enum class EToolMenuStringCommandType {
    Command = 0,
    Python = 1,
    Custom = 2,
    EToolMenuStringCommandType_MAX = 3,
};

// Size: 0x24
struct FScriptSlateIcon {
    /* 0x0000 */ FName StyleSetName;
    /* 0x000c */ FName StyleName;
    /* 0x0018 */ FName SmallStyleName;
};

// Size: 0x40
class USlateTabManagerContext : public UToolMenuContextBase {
};

// Size: 0x50
struct FToolDynamicUIAction {
    /* 0x0000 */ FDelegate ExecuteAction;
    /* 0x0014 */ FDelegate CanExecuteAction;
    /* 0x0028 */ FDelegate GetActionCheckState;
    /* 0x003c */ FDelegate IsActionVisibleDelegate;
};

// Size: 0x110
class UToolMenu : public UToolMenuBase {
    /* 0x0030 */ FName MenuName;
    /* 0x003c */ FName MenuParent;
    /* 0x0048 */ FName StyleName;
    /* 0x0054 */ FName TutorialHighlightName;
    /* 0x0060 */ EMultiBoxType MenuType;
    /* 0x0061 */ bool bShouldCloseWindowAfterMenuSelection;
    /* 0x0062 */ bool bCloseSelfOnly;
    /* 0x0063 */ bool bSearchable;
    /* 0x0064 */ bool bToolBarIsFocusable;
    /* 0x0065 */ bool bToolBarForceSmallIcons;
    /* 0x0066 */ bool bPreventCustomization;
    /* 0x0068 */ FToolMenuOwner MenuOwner;
    /* 0x0078 */ FToolMenuContext Context;
    /* 0x00c0 */ TArray<FToolMenuSection> Sections;
    /* 0x00d0 */ UToolMenu* SubMenuParent;
    /* 0x00d8 */ FName SubMenuSourceEntryName;

    void AddDynamicSectionScript(const FName SectionName, UToolMenuSectionDynamic* Object);
    void AddMenuEntry(const FName SectionName, const FToolMenuEntry& Args);
    void AddMenuEntryObject(UToolMenuEntryScript* InObject);
    void AddSectionScript(const FName SectionName, const FText& Label, const FName InsertName, const EToolMenuInsertType InsertType);
    UToolMenu* AddSubMenuScript(const FName Owner, const FName SectionName, const FName Name, const FText& Label, const FText& Tooltip);
    void InitMenu(const FToolMenuOwner Owner, FName Name, FName Parent, EMultiBoxType Type);
};

// Size: 0x48
struct FToolMenuContext {
    /* 0x0008 */ TArray<UObject*> ContextObjects;
};

// Size: 0x30
class UToolMenuContextBase : public UObject {
};

// Size: 0x30
class UToolMenuContextExtensions : public UObject {

    static UObject* FindByClass(const FToolMenuContext& Context, UClass* InClass);
};

// Size: 0x300
struct FToolMenuEntry {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ FToolMenuOwner Owner;
    /* 0x0020 */ EMultiBlockType Type;
    /* 0x0021 */ EUserInterfaceActionType UserInterfaceActionType;
    /* 0x0024 */ FName TutorialHighlightName;
    /* 0x0030 */ FToolMenuInsert InsertPosition;
    /* 0x0040 */ bool bShouldCloseWindowAfterMenuSelection;
    /* 0x0048 */ UToolMenuEntryScript* ScriptObject;
};

// Size: 0x30
class UToolMenuEntryExtensions : public UObject {

    static void BreakScriptSlateIcon(const FScriptSlateIcon& InValue, FName& StyleSetName, FName& StyleName, FName& SmallStyleName);
    static void BreakStringCommand(const FToolMenuStringCommand& InValue, EToolMenuStringCommandType& Type, FName& CustomType, FString& string);
    static void BreakToolMenuOwner(const FToolMenuOwner& InValue, FName& Name);
    static FText GetLabel(const FToolMenuEntry& Target);
    static FText GetToolTip(const FToolMenuEntry& Target);
    static FToolMenuEntry InitMenuEntry(const FName InOwner, const FName InName, const FText& InLabel, const FText& InToolTip, const EToolMenuStringCommandType CommandType, const FName CustomCommandType, FString CommandString);
    static FScriptSlateIcon MakeScriptSlateIcon(const FName StyleSetName, const FName StyleName, const FName SmallStyleName);
    static FToolMenuStringCommand MakeStringCommand(EToolMenuStringCommandType Type, FName CustomType, FString string);
    static FToolMenuOwner MakeToolMenuOwner(FName Name);
    static void SetIcon(FToolMenuEntry& Target, const FName StyleSetName, const FName StyleName, const FName SmallStyleName);
    static void SetLabel(FToolMenuEntry& Target, const FText& Label);
    static void SetStringCommand(FToolMenuEntry& Target, const EToolMenuStringCommandType Type, const FName CustomType, FString string);
    static void SetToolTip(FToolMenuEntry& Target, const FText& Tooltip);
};

// Size: 0xe0
class UToolMenuEntryScript : public UObject {
    /* 0x0030 */ FToolMenuEntryScriptData Data;

    bool CanExecute(const FToolMenuContext& Context) const;
    void ConstructMenuEntry(UToolMenu* Menu, const FName SectionName, const FToolMenuContext& Context);
    void Execute(const FToolMenuContext& Context);
    ECheckBoxState GetCheckState(const FToolMenuContext& Context) const;
    FScriptSlateIcon GetIcon(const FToolMenuContext& Context) const;
    FText GetLabel(const FToolMenuContext& Context) const;
    FText GetToolTip(const FToolMenuContext& Context) const;
    void InitEntry(const FName OwnerName, const FName Menu, const FName Section, const FName Name, const FText& Label, const FText& Tooltip);
    bool IsVisible(const FToolMenuContext& Context) const;
    void RegisterMenuEntry();
};

// Size: 0xb0
struct FToolMenuEntryScriptData {
    /* 0x0000 */ FName Menu;
    /* 0x000c */ FName Section;
    /* 0x0018 */ FName Name;
    /* 0x0028 */ FText Label;
    /* 0x0040 */ FText Tooltip;
    /* 0x0058 */ FScriptSlateIcon Icon;
    /* 0x007c */ FName OwnerName;
    /* 0x0088 */ FToolMenuInsert InsertPosition;
    /* 0x0098 */ FToolMenuEntryScriptDataAdvanced Advanced;
};

// Size: 0x14
struct FToolMenuEntryScriptDataAdvanced {
    /* 0x0000 */ FName TutorialHighlight;
    /* 0x000c */ EMultiBlockType EntryType;
    /* 0x000d */ EUserInterfaceActionType UserInterfaceActionType;
    /* 0x000e */ bool bIsSubMenu;
    /* 0x000f */ bool bOpenSubMenuOnClick;
    /* 0x0010 */ bool bShouldCloseWindowAfterMenuSelection;
    /* 0x0011 */ bool bSimpleComboBox;
};

// Size: 0x10
struct FToolMenuInsert {
    /* 0x0000 */ FName Name;
    /* 0x000c */ EToolMenuInsertType Position;
};

// Size: 0x10
struct FToolMenuOwner {
};

// Size: 0xf8
struct FToolMenuSection {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ FToolMenuOwner Owner;
    /* 0x0020 */ TArray<FToolMenuEntry> Blocks;
    /* 0x0030 */ FToolMenuInsert InsertPosition;
    /* 0x0040 */ FToolMenuContext Context;
    /* 0x0088 */ UToolMenuSectionDynamic* ToolMenuSectionDynamic;
};

// Size: 0x30
class UToolMenuSectionDynamic : public UObject {

    void ConstructSections(UToolMenu* Menu, const FToolMenuContext& Context);
};

// Size: 0x30
class UToolMenuSectionExtensions : public UObject {

    static void AddEntry(FToolMenuSection& Section, const FToolMenuEntry& Args);
    static void AddEntryObject(FToolMenuSection& Section, UToolMenuEntryScript* InObject);
    static FText GetLabel(const FToolMenuSection& Section);
    static void SetLabel(FToolMenuSection& Section, const FText& Label);
};

// Size: 0x20
struct FToolMenuStringCommand {
    /* 0x0000 */ EToolMenuStringCommandType Type;
    /* 0x0004 */ FName CustomType;
    /* 0x0010 */ FString string;
};

// Size: 0x278
class UToolMenus : public UObject {
    /* 0x00a0 */ TArray<FCustomizedToolMenu> CustomizedMenus;
    /* 0x00b0 */ TMap<FName, FName> MenuSubstitutionsDuringGenerate;
    /* 0x0100 */ TMap<FName, UToolMenu*> Menus;

    static bool AddMenuEntryObject(UToolMenuEntryScript* MenuEntryObject);
    UToolMenu* ExtendMenu(const FName Name);
    static UObject* FindContext(const FToolMenuContext& InContext, UClass* InClass);
    UToolMenu* FindMenu(const FName Name);
    static UToolMenus* Get();
    bool IsMenuRegistered(const FName Name) const;
    void RefreshAllWidgets();
    bool RefreshMenuWidget(const FName Name);
    UToolMenu* RegisterMenu(FName Name, const FName Parent, EMultiBoxType Type, bool bWarnIfAlreadyRegistered);
    void RemoveEntry(const FName MenuName, const FName Section, const FName Name);
    void RemoveMenu(const FName MenuName);
    void RemoveSection(const FName MenuName, const FName Section);
    void SetSectionLabel(const FName MenuName, const FName SectionName, const FText Label);
    void SetSectionPosition(const FName MenuName, const FName SectionName, const FName OtherSectionName, const EToolMenuInsertType PositionType);
    void UnregisterOwnerByName(FName InOwnerName);
};

// Size: 0xa8
class UInternationalizationExportSettings : public UObject {
    /* 0x0030 */ TArray<FString> CulturesToGenerate;
    /* 0x0040 */ FString CommandletClass;
    /* 0x0050 */ FString SourcePath;
    /* 0x0060 */ FString DestinationPath;
    /* 0x0070 */ FString PortableObjectName;
    /* 0x0080 */ FString ManifestName;
    /* 0x0090 */ FString ArchiveName;
    /* 0x00a0 */ bool bExportLoc;
    /* 0x00a1 */ bool bImportLoc;
    /* 0x00a2 */ bool bUseCultureDirectory;
};

// Size: 0x38
struct FTranslationChange {
    /* 0x0000 */ FString Version;
    /* 0x0010 */ FDateTime DateAndTime;
    /* 0x0018 */ FString Source;
    /* 0x0028 */ FString Translation;
};

// Size: 0x30
struct FTranslationContextInfo {
    /* 0x0000 */ FString Key;
    /* 0x0010 */ FString Context;
    /* 0x0020 */ TArray<FTranslationChange> Changes;
};

// Size: 0x38
class UTranslationPickerSettings : public UObject {
    /* 0x0030 */ bool bSubmitTranslationPickerChangesToLocalizationService;
};

// Size: 0xd0
class UTranslationUnit : public UObject {
    /* 0x0030 */ FString Namespace;
    /* 0x0040 */ FString Key;
    /* 0x0050 */ FString Source;
    /* 0x0060 */ FString Translation;
    /* 0x0070 */ TArray<FTranslationContextInfo> Contexts;
    /* 0x0080 */ bool HasBeenReviewed;
    /* 0x0088 */ FString TranslationBeforeImport;
    /* 0x0098 */ FString LocresPath;
};

// Size: 0x28
struct FAnchorData {
    /* 0x0000 */ FMargin Offsets;
    /* 0x0010 */ FAnchors Anchors;
    /* 0x0020 */ FVector2D Alignment;
};

// Size: 0x30
struct FAnimationEventBinding {
    /* 0x0000 */ UWidgetAnimation* Animation;
    /* 0x0008 */ FDelegate delegate;
    /* 0x001c */ EWidgetAnimationEvent AnimationEvent;
    /* 0x0020 */ FName UserTag;
};

// Size: 0x58
class UAsyncTaskDownloadImage : public UBlueprintAsyncActionBase {
    /* 0x0038 */ FMulticastInlineDelegate OnSuccess;
    /* 0x0048 */ FMulticastInlineDelegate OnFail;

    static UAsyncTaskDownloadImage* DownloadImage(FString URL);
};

// Size: 0x310
class UBackgroundBlur : public UContentWidget {
    /* 0x0240 */ FMargin Padding;
    /* 0x0250 */ uint8_t HorizontalAlignment;
    /* 0x0251 */ uint8_t VerticalAlignment;
    /* 0x0252 */ bool bApplyAlphaToBlur;
    /* 0x0254 */ float BlurStrength;
    /* 0x0258 */ bool bOverrideAutoRadiusCalculation;
    /* 0x025c */ int32_t BlurRadius;
    /* 0x0260 */ FSlateBrush LowQualityFallbackBrush;

    void SetApplyAlphaToBlur(bool bInApplyAlphaToBlur);
    void SetBlurRadius(int32_t InBlurRadius);
    void SetBlurStrength(float InStrength);
    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetLowQualityFallbackBrush(const FSlateBrush& InBrush);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x68
class UBackgroundBlurSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0050 */ uint8_t HorizontalAlignment;
    /* 0x0051 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x28
struct FBlueprintWidgetAnimationDelegateBinding {
    /* 0x0000 */ EWidgetAnimationEvent Action;
    /* 0x0004 */ FName AnimationToBind;
    /* 0x0010 */ FName FunctionNameToBind;
    /* 0x001c */ FName UserTag;
};

// Size: 0x78
class UBoolBinding : public UPropertyBinding {

    bool GetValue() const;
};

// Size: 0x3d8
class UBorder : public UContentWidget {
    /* 0x0240 */ uint8_t HorizontalAlignment;
    /* 0x0241 */ uint8_t VerticalAlignment;
    /* 0x0242 */ bool bShowEffectWhenDisabled;
    /* 0x0244 */ FLinearColor ContentColorAndOpacity;
    /* 0x0254 */ FDelegate ContentColorAndOpacityDelegate;
    /* 0x0268 */ FMargin Padding;
    /* 0x0278 */ FSlateBrush Background;
    /* 0x0318 */ FDelegate BackgroundDelegate;
    /* 0x032c */ FLinearColor BrushColor;
    /* 0x033c */ FDelegate BrushColorDelegate;
    /* 0x0350 */ FVector2D DesiredSizeScale;
    /* 0x0358 */ bool bFlipForRightToLeftFlowDirection;
    /* 0x035c */ FDelegate OnMouseButtonDownEvent;
    /* 0x0370 */ FDelegate OnMouseButtonUpEvent;
    /* 0x0384 */ FDelegate OnMouseMoveEvent;
    /* 0x0398 */ FDelegate OnMouseDoubleClickEvent;
    /* 0x03c0 */ USlateBrushAsset* Brush;

    UMaterialInstanceDynamic* GetDynamicMaterial();
    void SetBrush(const FSlateBrush& InBrush);
    void SetBrushColor(FLinearColor InBrushColor);
    void SetBrushFromAsset(USlateBrushAsset* Asset);
    void SetBrushFromMaterial(UMaterialInterface* Material);
    void SetBrushFromTexture(UTexture2D* Texture);
    void SetContentColorAndOpacity(FLinearColor InContentColorAndOpacity);
    void SetDesiredSizeScale(FVector2D InScale);
    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x68
class UBorderSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0050 */ uint8_t HorizontalAlignment;
    /* 0x0051 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x80
class UBrushBinding : public UPropertyBinding {

    FSlateBrush GetValue() const;
};

// Size: 0x5d0
class UButton : public UContentWidget {
    /* 0x0240 */ USlateWidgetStyleAsset* Style;
    /* 0x0248 */ FButtonStyle WidgetStyle;
    /* 0x0548 */ FLinearColor ColorAndOpacity;
    /* 0x0558 */ FLinearColor BackgroundColor;
    /* 0x0568 */ uint8_t ClickMethod;
    /* 0x0569 */ uint8_t TouchMethod;
    /* 0x056a */ uint8_t PressMethod;
    /* 0x056b */ bool IsFocusable;
    /* 0x0570 */ FMulticastInlineDelegate OnClicked;
    /* 0x0580 */ FMulticastInlineDelegate OnPressed;
    /* 0x0590 */ FMulticastInlineDelegate OnReleased;
    /* 0x05a0 */ FMulticastInlineDelegate OnHovered;
    /* 0x05b0 */ FMulticastInlineDelegate OnUnhovered;

    bool IsPressed() const;
    void SetBackgroundColor(FLinearColor InBackgroundColor);
    void SetClickMethod(uint8_t InClickMethod);
    void SetColorAndOpacity(FLinearColor InColorAndOpacity);
    void SetPressMethod(uint8_t InPressMethod);
    void SetStyle(const FButtonStyle& InStyle);
    void SetTouchMethod(uint8_t InTouchMethod);
};

// Size: 0x68
class UButtonSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0050 */ uint8_t HorizontalAlignment;
    /* 0x0051 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x250
class UCanvasPanel : public UPanelWidget {

    UCanvasPanelSlot* AddChildToCanvas(UWidget* Content);
};

// Size: 0xe8
class UCanvasPanelSlot : public UPanelSlot {
    /* 0x0040 */ FAnchorData LayoutData;
    /* 0x0068 */ bool bAutoSize;
    /* 0x006c */ int32_t ZOrder;

    FVector2D GetAlignment() const;
    FAnchors GetAnchors() const;
    bool GetAutoSize() const;
    FAnchorData GetLayout() const;
    FMargin GetOffsets() const;
    FVector2D GetPosition() const;
    FVector2D GetSize() const;
    int32_t GetZOrder() const;
    void SetAlignment(FVector2D InAlignment);
    void SetAnchors(FAnchors InAnchors);
    void SetAutoSize(bool InbAutoSize);
    void SetLayout(const FAnchorData& InLayoutData);
    void SetMaximum(FVector2D InMaximumAnchors);
    void SetMinimum(FVector2D InMinimumAnchors);
    void SetOffsets(FMargin InOffset);
    void SetPosition(FVector2D InPosition);
    void SetSize(FVector2D InSize);
    void SetZOrder(int32_t InZOrder);
};

// Size: 0x9b0
class UCheckBox : public UContentWidget {
    /* 0x0240 */ ECheckBoxState CheckedState;
    /* 0x0244 */ FDelegate CheckedStateDelegate;
    /* 0x0258 */ FCheckBoxStyle WidgetStyle;
    /* 0x08f0 */ USlateWidgetStyleAsset* Style;
    /* 0x08f8 */ USlateBrushAsset* UncheckedImage;
    /* 0x0900 */ USlateBrushAsset* UncheckedHoveredImage;
    /* 0x0908 */ USlateBrushAsset* UncheckedPressedImage;
    /* 0x0910 */ USlateBrushAsset* CheckedImage;
    /* 0x0918 */ USlateBrushAsset* CheckedHoveredImage;
    /* 0x0920 */ USlateBrushAsset* CheckedPressedImage;
    /* 0x0928 */ USlateBrushAsset* UndeterminedImage;
    /* 0x0930 */ USlateBrushAsset* UndeterminedHoveredImage;
    /* 0x0938 */ USlateBrushAsset* UndeterminedPressedImage;
    /* 0x0940 */ uint8_t HorizontalAlignment;
    /* 0x0944 */ FMargin Padding;
    /* 0x0958 */ FSlateColor BorderBackgroundColor;
    /* 0x0980 */ uint8_t ClickMethod;
    /* 0x0981 */ uint8_t TouchMethod;
    /* 0x0982 */ uint8_t PressMethod;
    /* 0x0983 */ bool IsFocusable;
    /* 0x0988 */ FMulticastInlineDelegate OnCheckStateChanged;

    ECheckBoxState GetCheckedState() const;
    bool IsChecked() const;
    bool IsPressed() const;
    void SetCheckedState(ECheckBoxState InCheckedState);
    void SetClickMethod(uint8_t InClickMethod);
    void SetIsChecked(bool InIsChecked);
    void SetPressMethod(uint8_t InPressMethod);
    void SetTouchMethod(uint8_t InTouchMethod);
};

// Size: 0x80
class UCheckedStateBinding : public UPropertyBinding {

    ECheckBoxState GetValue() const;
};

// Size: 0x2f8
class UCircularThrobber : public UWidget {
    /* 0x0228 */ int32_t NumberOfPieces;
    /* 0x022c */ float Period;
    /* 0x0230 */ float Radius;
    /* 0x0238 */ USlateBrushAsset* PieceImage;
    /* 0x0240 */ FSlateBrush Image;
    /* 0x02e0 */ bool bEnableRadius;

    void SetNumberOfPieces(int32_t InNumberOfPieces);
    void SetPeriod(float InPeriod);
    void SetRadius(float InRadius);
};

// Size: 0x80
class UColorBinding : public UPropertyBinding {

    FLinearColor GetLinearValue() const;
    FSlateColor GetSlateValue() const;
};

// Size: 0x260
class UComboBox : public UWidget {
    /* 0x0228 */ TArray<UObject*> Items;
    /* 0x0238 */ FDelegate OnGenerateWidgetEvent;
    /* 0x024c */ bool bIsFocusable;
};

// Size: 0x1160
class UComboBoxString : public UWidget {
    /* 0x0228 */ TArray<FString> DefaultOptions;
    /* 0x0238 */ FString SelectedOption;
    /* 0x0248 */ FComboBoxStyle WidgetStyle;
    /* 0x0718 */ FTableRowStyle ItemStyle;
    /* 0x1030 */ FMargin ContentPadding;
    /* 0x1040 */ float MaxListHeight;
    /* 0x1044 */ bool HasDownArrow;
    /* 0x1045 */ bool EnableGamepadNavigationMode;
    /* 0x1048 */ FSlateFontInfo Font;
    /* 0x10b0 */ FSlateColor ForegroundColor;
    /* 0x10d8 */ bool bIsFocusable;
    /* 0x10dc */ FDelegate OnGenerateWidgetEvent;
    /* 0x10f0 */ FMulticastInlineDelegate OnSelectionChanged;
    /* 0x1100 */ FMulticastInlineDelegate OnOpening;

    void AddOption(FString Option);
    void ClearOptions();
    void ClearSelection();
    int32_t FindOptionIndex(FString Option) const;
    FString GetOptionAtIndex(int32_t index) const;
    int32_t GetOptionCount() const;
    int32_t GetSelectedIndex() const;
    FString GetSelectedOption() const;
    bool IsOpen() const;
    void OnOpeningEvent__DelegateSignature();
    void OnSelectionChangedEvent__DelegateSignature(FString SelectedItem, uint8_t SelectionType);
    void RefreshOptions();
    bool RemoveOption(FString Option);
    void SetSelectedIndex(const int32_t index);
    void SetSelectedOption(FString Option);
};

// Size: 0x240
class UContentWidget : public UPanelWidget {

    UWidget* GetContent() const;
    UPanelSlot* GetContentSlot() const;
    UPanelSlot* SetContent(UWidget* Content);
};

// Size: 0x60
struct FDelegateRuntimeBinding {
    /* 0x0000 */ FString ObjectName;
    /* 0x0010 */ FName PropertyName;
    /* 0x001c */ FName FunctionName;
    /* 0x0028 */ FDynamicPropertyPath SourcePath;
    /* 0x0058 */ EBindingKind Kind;
};

// Size: 0x90
class UDragDropOperation : public UObject {
    /* 0x0030 */ FString Tag;
    /* 0x0040 */ UObject* Payload;
    /* 0x0048 */ UWidget* DefaultDragVisual;
    /* 0x0050 */ EDragPivot Pivot;
    /* 0x0054 */ FVector2D Offset;
    /* 0x0060 */ FMulticastInlineDelegate OnDrop;
    /* 0x0070 */ FMulticastInlineDelegate OnDragCancelled;
    /* 0x0080 */ FMulticastInlineDelegate OnDragged;

    void DragCancelled(const FPointerEvent& PointerEvent);
    void Dragged(const FPointerEvent& PointerEvent);
    void Drop(const FPointerEvent& PointerEvent);
};

// Size: 0x360
class UDynamicEntryBox : public UDynamicEntryBoxBase {
    /* 0x02f8 */ int32_t NumDesignerPreviewEntries;
    /* 0x0350 */ UClass* EntryWidgetClass;

    UUserWidget* BP_CreateEntry();
    UUserWidget* BP_CreateEntryOfClass(UClass* EntryClass);
    void RemoveEntry(UUserWidget* EntryWidget);
    void Reset(bool bDeleteWidgets);
};

// Size: 0x2f8
class UDynamicEntryBoxBase : public UWidget {
    /* 0x0228 */ EDynamicBoxType EntryBoxType;
    /* 0x022c */ FVector2D EntrySpacing;
    /* 0x0238 */ TArray<FVector2D> SpacingPattern;
    /* 0x0248 */ FSlateChildSize EntrySizeRule;
    /* 0x0250 */ uint8_t EntryHorizontalAlignment;
    /* 0x0251 */ uint8_t EntryVerticalAlignment;
    /* 0x0254 */ int32_t MaxElementSize;
    /* 0x0258 */ FRadialBoxSettings RadialBoxSettings;
    /* 0x0278 */ FUserWidgetPool EntryWidgetPool;

    TArray<UUserWidget*> GetAllEntries() const;
    int32_t GetNumEntries() const;
    void SetEntrySpacing(const FVector2D& InEntrySpacing);
    void SetRadialSettings(const FRadialBoxSettings& InSettings);
};

// Size: 0x30
struct FDynamicPropertyPath : public FCachedPropertyPath {
};

enum class EBindingKind {
    Function = 0,
    Property = 1,
    EBindingKind_MAX = 2,
};

enum class EDesignPreviewSizeMode {
    FillScreen = 0,
    Custom = 1,
    CustomOnScreen = 2,
    Desired = 3,
    DesiredOnScreen = 4,
    EDesignPreviewSizeMode_MAX = 5,
};

enum class EDragPivot {
    MouseDown = 0,
    TopLeft = 1,
    TopCenter = 2,
    TopRight = 3,
    CenterLeft = 4,
    CenterCenter = 5,
    CenterRight = 6,
    BottomLeft = 7,
    BottomCenter = 8,
    BottomRight = 9,
    EDragPivot_MAX = 10,
};

enum class EDynamicBoxType {
    Horizontal = 0,
    Vertical = 1,
    Wrap = 2,
    VerticalWrap = 3,
    Radial = 4,
    Overlay = 5,
    EDynamicBoxType_MAX = 6,
};

enum class ESlateAccessibleBehavior {
    NotAccessible = 0,
    Auto = 1,
    Summary = 2,
    Custom = 3,
    ToolTip = 4,
    ESlateAccessibleBehavior_MAX = 5,
};

enum class ESlateSizeRule {
    Automatic = 0,
    Fill = 1,
    ESlateSizeRule_MAX = 2,
};

enum class ESlateVisibility {
    Visible = 0,
    Collapsed = 1,
    Hidden = 2,
    HitTestInvisible = 3,
    SelfHitTestInvisible = 4,
    ESlateVisibility_MAX = 5,
};

enum class ETickMode {
    Disabled = 0,
    Enabled = 1,
    Automatic = 2,
    ETickMode_MAX = 3,
};

enum class EUMGSequencePlayMode {
    Forward = 0,
    Reverse = 1,
    PingPong = 2,
    EUMGSequencePlayMode_MAX = 3,
};

enum class EVirtualKeyboardType {
    Default = 0,
    Number = 1,
    Web = 2,
    Email = 3,
    Password = 4,
    AlphaNumeric = 5,
    EVirtualKeyboardType_MAX = 6,
};

enum class EWidgetAnimationEvent {
    Started = 0,
    Finished = 1,
    EWidgetAnimationEvent_MAX = 2,
};

enum class EWidgetBlendMode {
    Opaque = 0,
    Masked = 1,
    Transparent = 2,
    EWidgetBlendMode_MAX = 3,
};

enum class EWidgetDesignFlags {
    None = 0,
    Designing = 1,
    ShowOutline = 2,
    ExecutePreConstruct = 4,
    EWidgetDesignFlags_MAX = 5,
};

enum class EWidgetGeometryMode {
    Plane = 0,
    Cylinder = 1,
    EWidgetGeometryMode_MAX = 2,
};

enum class EWidgetInteractionSource {
    World = 0,
    Mouse = 1,
    CenterScreen = 2,
    Custom = 3,
    EWidgetInteractionSource_MAX = 4,
};

enum class EWidgetSpace {
    World = 0,
    Screen = 1,
    EWidgetSpace_MAX = 2,
};

enum class EWidgetTickFrequency {
    Never = 0,
    Auto = 1,
    EWidgetTickFrequency_MAX = 2,
};

enum class EWidgetTimingPolicy {
    RealTime = 0,
    GameTime = 1,
    EWidgetTimingPolicy_MAX = 2,
};

enum class EWindowVisibility {
    Visible = 0,
    SelfHitTestInvisible = 1,
    EWindowVisibility_MAX = 2,
};

// Size: 0x628
class UEditableText : public UWidget {
    /* 0x0228 */ FText text;
    /* 0x0240 */ FDelegate TextDelegate;
    /* 0x0258 */ FText HintText;
    /* 0x0270 */ FDelegate HintTextDelegate;
    /* 0x0288 */ FEditableTextStyle WidgetStyle;
    /* 0x0500 */ USlateWidgetStyleAsset* Style;
    /* 0x0508 */ USlateBrushAsset* BackgroundImageSelected;
    /* 0x0510 */ USlateBrushAsset* BackgroundImageComposing;
    /* 0x0518 */ USlateBrushAsset* CaretImage;
    /* 0x0520 */ FSlateFontInfo Font;
    /* 0x0588 */ FSlateColor ColorAndOpacity;
    /* 0x05b0 */ bool IsReadOnly;
    /* 0x05b1 */ bool IsPassword;
    /* 0x05b4 */ float MinimumDesiredWidth;
    /* 0x05b8 */ bool IsCaretMovedWhenGainFocus;
    /* 0x05b9 */ bool SelectAllTextWhenFocused;
    /* 0x05ba */ bool RevertTextOnEscape;
    /* 0x05bb */ bool ClearKeyboardFocusOnCommit;
    /* 0x05bc */ bool SelectAllTextOnCommit;
    /* 0x05bd */ bool AllowContextMenu;
    /* 0x05be */ uint8_t KeyboardType;
    /* 0x05bf */ FVirtualKeyboardOptions VirtualKeyboardOptions;
    /* 0x05c0 */ EVirtualKeyboardTrigger VirtualKeyboardTrigger;
    /* 0x05c1 */ EVirtualKeyboardDismissAction VirtualKeyboardDismissAction;
    /* 0x05c2 */ uint8_t Justification;
    /* 0x05c3 */ FShapedTextOptions ShapedTextOptions;
    /* 0x05c8 */ FMulticastInlineDelegate OnTextChanged;
    /* 0x05d8 */ FMulticastInlineDelegate OnTextCommitted;

    FText GetText() const;
    void OnEditableTextChangedEvent__DelegateSignature(const FText& text);
    void OnEditableTextCommittedEvent__DelegateSignature(const FText& text, uint8_t CommitMethod);
    void SetHintText(FText InHintText);
    void SetIsPassword(bool InbIsPassword);
    void SetIsReadOnly(bool InbIsReadyOnly);
    void SetJustification(uint8_t InJustification);
    void SetText(FText InText);
};

// Size: 0xcf0
class UEditableTextBox : public UWidget {
    /* 0x0228 */ FText text;
    /* 0x0240 */ FDelegate TextDelegate;
    /* 0x0258 */ FEditableTextBoxStyle WidgetStyle;
    /* 0x0b98 */ USlateWidgetStyleAsset* Style;
    /* 0x0ba0 */ FText HintText;
    /* 0x0bb8 */ FDelegate HintTextDelegate;
    /* 0x0bd0 */ FSlateFontInfo Font;
    /* 0x0c38 */ FLinearColor ForegroundColor;
    /* 0x0c48 */ FLinearColor BackgroundColor;
    /* 0x0c58 */ FLinearColor ReadOnlyForegroundColor;
    /* 0x0c68 */ bool IsReadOnly;
    /* 0x0c69 */ bool IsPassword;
    /* 0x0c6c */ float MinimumDesiredWidth;
    /* 0x0c70 */ FMargin Padding;
    /* 0x0c80 */ bool IsCaretMovedWhenGainFocus;
    /* 0x0c81 */ bool SelectAllTextWhenFocused;
    /* 0x0c82 */ bool RevertTextOnEscape;
    /* 0x0c83 */ bool ClearKeyboardFocusOnCommit;
    /* 0x0c84 */ bool SelectAllTextOnCommit;
    /* 0x0c85 */ bool AllowContextMenu;
    /* 0x0c86 */ uint8_t KeyboardType;
    /* 0x0c87 */ FVirtualKeyboardOptions VirtualKeyboardOptions;
    /* 0x0c88 */ EVirtualKeyboardTrigger VirtualKeyboardTrigger;
    /* 0x0c89 */ EVirtualKeyboardDismissAction VirtualKeyboardDismissAction;
    /* 0x0c8a */ uint8_t Justification;
    /* 0x0c8b */ FShapedTextOptions ShapedTextOptions;
    /* 0x0c90 */ FMulticastInlineDelegate OnTextChanged;
    /* 0x0ca0 */ FMulticastInlineDelegate OnTextCommitted;

    void ClearError();
    FText GetText() const;
    bool HasError() const;
    void OnEditableTextBoxChangedEvent__DelegateSignature(const FText& text);
    void OnEditableTextBoxCommittedEvent__DelegateSignature(const FText& text, uint8_t CommitMethod);
    void SetError(FText InError);
    void SetHintText(FText InText);
    void SetIsPassword(bool bIsPassword);
    void SetIsReadOnly(bool bReadOnly);
    void SetJustification(uint8_t InJustification);
    void SetText(FText InText);
};

// Size: 0xc0
struct FEventReply {
};

// Size: 0x4a0
class UExpandableArea : public UWidget {
    /* 0x0230 */ FExpandableAreaStyle Style;
    /* 0x0380 */ FSlateBrush BorderBrush;
    /* 0x0420 */ FSlateColor BorderColor;
    /* 0x0448 */ bool bIsExpanded;
    /* 0x044c */ float MaxHeight;
    /* 0x0450 */ FMargin HeaderPadding;
    /* 0x0460 */ FMargin AreaPadding;
    /* 0x0470 */ FMulticastInlineDelegate OnExpansionChanged;
    /* 0x0480 */ UWidget* HeaderContent;
    /* 0x0488 */ UWidget* BodyContent;

    bool GetIsExpanded() const;
    void SetIsExpanded(bool IsExpanded);
    void SetIsExpanded_Animated(bool IsExpanded);
};

// Size: 0x78
class UFloatBinding : public UPropertyBinding {

    float GetValue() const;
};

// Size: 0x270
class UGridPanel : public UPanelWidget {
    /* 0x0240 */ TArray<float> ColumnFill;
    /* 0x0250 */ TArray<float> RowFill;

    UGridSlot* AddChildToGrid(UWidget* Content, int32_t InRow, int32_t InColumn);
    void SetColumnFill(int32_t ColumnIndex, float Coefficient);
    void SetRowFill(int32_t ColumnIndex, float Coefficient);
};

// Size: 0x78
class UGridSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0050 */ uint8_t HorizontalAlignment;
    /* 0x0051 */ uint8_t VerticalAlignment;
    /* 0x0054 */ int32_t Row;
    /* 0x0058 */ int32_t RowSpan;
    /* 0x005c */ int32_t Column;
    /* 0x0060 */ int32_t ColumnSpan;
    /* 0x0064 */ int32_t Layer;
    /* 0x0068 */ FVector2D Nudge;

    void SetColumn(int32_t InColumn);
    void SetColumnSpan(int32_t InColumnSpan);
    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetLayer(int32_t InLayer);
    void SetNudge(FVector2D InNudge);
    void SetPadding(FMargin InPadding);
    void SetRow(int32_t InRow);
    void SetRowSpan(int32_t InRowSpan);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x250
class UHorizontalBox : public UPanelWidget {

    UHorizontalBoxSlot* AddChildToHorizontalBox(UWidget* Content);
};

// Size: 0x68
class UHorizontalBoxSlot : public UPanelSlot {
    /* 0x0048 */ FMargin Padding;
    /* 0x0058 */ FSlateChildSize Size;
    /* 0x0060 */ uint8_t HorizontalAlignment;
    /* 0x0061 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetSize(FSlateChildSize InSize);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x388
class UImage : public UWidget {
    /* 0x0228 */ USlateBrushAsset* Image;
    /* 0x0230 */ FSlateBrush Brush;
    /* 0x02d0 */ FDelegate BrushDelegate;
    /* 0x02e4 */ FLinearColor ColorAndOpacity;
    /* 0x02f4 */ FDelegate ColorAndOpacityDelegate;
    /* 0x0308 */ bool bFlipForRightToLeftFlowDirection;
    /* 0x030c */ FDelegate OnMouseButtonDownEvent;

    UMaterialInstanceDynamic* GetDynamicMaterial();
    void SetBrush(const FSlateBrush& InBrush);
    void SetBrushFromAsset(USlateBrushAsset* Asset);
    void SetBrushFromAtlasInterface(TScriptInterface<ISlateTextureAtlasInterface> AtlasRegion, bool bMatchSize);
    void SetBrushFromMaterial(UMaterialInterface* Material);
    void SetBrushFromSoftMaterial(TSoftObjectPtr<UMaterialInterface> SoftMaterial);
    void SetBrushFromSoftTexture(TSoftObjectPtr<UTexture2D> SoftTexture, bool bMatchSize);
    void SetBrushFromTexture(UTexture2D* Texture, bool bMatchSize);
    void SetBrushFromTextureDynamic(UTexture2DDynamic* Texture, bool bMatchSize);
    void SetBrushResourceObject(UObject* ResourceObject);
    void SetBrushSize(FVector2D DesiredSize);
    void SetBrushTintColor(FSlateColor TintColor);
    void SetColorAndOpacity(FLinearColor InColorAndOpacity);
    void SetOpacity(float InOpacity);
};

// Size: 0x918
class UInputKeySelector : public UWidget {
    /* 0x0228 */ FButtonStyle WidgetStyle;
    /* 0x0528 */ FTextBlockStyle TextStyle;
    /* 0x07f0 */ FInputChord SelectedKey;
    /* 0x0818 */ FSlateFontInfo Font;
    /* 0x0880 */ FMargin Margin;
    /* 0x0890 */ FLinearColor ColorAndOpacity;
    /* 0x08a0 */ FText KeySelectionText;
    /* 0x08b8 */ FText NoKeySpecifiedText;
    /* 0x08d0 */ bool bAllowModifierKeys;
    /* 0x08d1 */ bool bAllowGamepadKeys;
    /* 0x08d8 */ TArray<FKey> EscapeKeys;
    /* 0x08e8 */ FMulticastInlineDelegate OnKeySelected;
    /* 0x08f8 */ FMulticastInlineDelegate OnIsSelectingKeyChanged;

    bool GetIsSelectingKey() const;
    void OnIsSelectingKeyChanged__DelegateSignature();
    void OnKeySelected__DelegateSignature(FInputChord SelectedKey);
    void SetAllowGamepadKeys(bool bInAllowGamepadKeys);
    void SetAllowModifierKeys(bool bInAllowModifierKeys);
    void SetEscapeKeys(const TArray<FKey>& InKeys);
    void SetKeySelectionText(FText InKeySelectionText);
    void SetNoKeySpecifiedText(FText InNoKeySpecifiedText);
    void SetSelectedKey(const FInputChord& InSelectedKey);
    void SetTextBlockVisibility(const ESlateVisibility InVisibility);
};

// Size: 0x78
class UInt32Binding : public UPropertyBinding {

    int32_t GetValue() const;
};

// Size: 0x258
class UInvalidationBox : public UContentWidget {
    /* 0x0240 */ bool bCanCache;
    /* 0x0241 */ bool CacheRelativeTransforms;

    bool GetCanCache() const;
    void InvalidateCache();
    void SetCanCache(bool CanCache);
};

// Size: 0x490
class UListView : public UListViewBase {
    /* 0x0400 */ uint8_t Orientation;
    /* 0x0401 */ uint8_t SelectionMode;
    /* 0x0402 */ EConsumeMouseWheel ConsumeMouseWheel;
    /* 0x0403 */ bool bClearSelectionOnClick;
    /* 0x0404 */ bool bIsFocusable;
    /* 0x0408 */ float EntrySpacing;
    /* 0x040c */ bool bReturnFocusToSelection;
    /* 0x0410 */ TArray<UObject*> ListItems;
    /* 0x0430 */ FMulticastInlineDelegate BP_OnEntryInitialized;
    /* 0x0440 */ FMulticastInlineDelegate BP_OnItemClicked;
    /* 0x0450 */ FMulticastInlineDelegate BP_OnItemDoubleClicked;
    /* 0x0460 */ FMulticastInlineDelegate BP_OnItemIsHoveredChanged;
    /* 0x0470 */ FMulticastInlineDelegate BP_OnItemSelectionChanged;
    /* 0x0480 */ FMulticastInlineDelegate BP_OnItemScrolledIntoView;

    void AddItem(UObject* Item);
    void BP_CancelScrollIntoView();
    void BP_ClearSelection();
    int32_t BP_GetNumItemsSelected() const;
    UObject* BP_GetSelectedItem() const;
    bool BP_GetSelectedItems(TArray<UObject*>& Items) const;
    bool BP_IsItemVisible(UObject* Item) const;
    void BP_NavigateToItem(UObject* Item);
    void BP_ScrollItemIntoView(UObject* Item);
    void BP_SetItemSelection(UObject* Item, bool bSelected);
    void BP_SetListItems(const TArray<UObject*>& InListItems);
    void BP_SetSelectedItem(UObject* Item);
    void ClearListItems();
    int32_t GetIndexForItem(UObject* Item) const;
    UObject* GetItemAt(int32_t index) const;
    TArray<UObject*> GetListItems() const;
    int32_t GetNumItems() const;
    bool IsRefreshPending() const;
    void NavigateToIndex(int32_t index);
    void RemoveItem(UObject* Item);
    void ScrollIndexIntoView(int32_t index);
    void SetSelectedIndex(int32_t index);
    void SetSelectionMode(uint8_t SelectionMode);
};

// Size: 0x340
class UListViewBase : public UWidget {
    /* 0x0228 */ UClass* EntryWidgetClass;
    /* 0x0230 */ float WheelScrollMultiplier;
    /* 0x0234 */ bool bEnableScrollAnimation;
    /* 0x0235 */ bool bEnableFixedLineOffset;
    /* 0x0238 */ float FixedLineScrollOffset;
    /* 0x0240 */ FMulticastInlineDelegate BP_OnEntryGenerated;
    /* 0x0250 */ FMulticastInlineDelegate BP_OnEntryReleased;
    /* 0x0264 */ int32_t NumDesignerPreviewEntries;
    /* 0x0268 */ FUserWidgetPool EntryWidgetPool;

    TArray<UUserWidget*> GetDisplayedEntryWidgets() const;
    void RegenerateAllEntries();
    void RequestRefresh();
    void ScrollToBottom();
    void ScrollToTop();
    void SetScrollOffset(const float InScrollOffset);
    void SetScrollbarVisibility(ESlateVisibility InVisibility);
    void SetWheelScrollMultiplier(float NewWheelScrollMultiplier);
};

// Size: 0x30
class UListViewDesignerPreviewItem : public UObject {
};

// Size: 0x298
class UMenuAnchor : public UContentWidget {
    /* 0x0240 */ UClass* MenuClass;
    /* 0x0248 */ FDelegate OnGetMenuContentEvent;
    /* 0x025c */ FDelegate OnGetUserMenuContentEvent;
    /* 0x0270 */ uint8_t PLACEMENT;
    /* 0x0271 */ bool bFitInWindow;
    /* 0x0272 */ bool ShouldDeferPaintingAfterWindowContent;
    /* 0x0273 */ bool UseApplicationMenuStack;
    /* 0x0278 */ FMulticastInlineDelegate OnMenuOpenChanged;

    void Close();
    void FitInWindow(bool bFit);
    FVector2D GetMenuPosition() const;
    UUserWidget* GetUserWidget__DelegateSignature();
    bool HasOpenSubMenus() const;
    bool IsOpen() const;
    void Open(bool bFocusMenu);
    void SetPlacement(uint8_t InPlacement);
    bool ShouldOpenDueToClick() const;
    void ToggleOpen(bool bFocusOnOpen);
};

// Size: 0x78
class UMouseCursorBinding : public UPropertyBinding {

    uint8_t GetValue() const;
};

// Size: 0x4
struct FMovieScene2DTransformMask {
    /* 0x0000 */ uint32_t mask;
};

// Size: 0x68
class UMovieScene2DTransformPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x598
class UMovieScene2DTransformSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieScene2DTransformMask TransformMask;
    /* 0x0138 */ FMovieSceneFloatChannel Translation[2];
    /* 0x0278 */ FMovieSceneFloatChannel Rotation;
    /* 0x0318 */ FMovieSceneFloatChannel Scale[2];
    /* 0x0458 */ FMovieSceneFloatChannel Shear[2];
};

// Size: 0x138
class UMovieScene2DTransformTrack : public UMovieScenePropertyTrack {
};

// Size: 0x68
class UMovieSceneMarginPropertySystem : public UMovieScenePropertySystem {
};

// Size: 0x3b0
class UMovieSceneMarginSection : public UMovieSceneSection {
    /* 0x0130 */ FMovieSceneFloatChannel TopCurve;
    /* 0x01d0 */ FMovieSceneFloatChannel LeftCurve;
    /* 0x0270 */ FMovieSceneFloatChannel RightCurve;
    /* 0x0310 */ FMovieSceneFloatChannel BottomCurve;
};

// Size: 0x138
class UMovieSceneMarginTrack : public UMovieScenePropertyTrack {
};

// Size: 0x90
struct FMovieSceneWidgetMaterialSectionTemplate : public FMovieSceneParameterSectionTemplate {
    /* 0x0080 */ TArray<FName> BrushPropertyNamePath;
};

// Size: 0x110
class UMovieSceneWidgetMaterialTrack : public UMovieSceneMaterialTrack {
    /* 0x00f0 */ TArray<FName> BrushPropertyNamePath;
    /* 0x0100 */ FName TrackName;
};

// Size: 0x618
class UMultiLineEditableText : public UTextLayoutWidget {
    /* 0x0248 */ FText text;
    /* 0x0260 */ FText HintText;
    /* 0x0278 */ FDelegate HintTextDelegate;
    /* 0x0290 */ FTextBlockStyle WidgetStyle;
    /* 0x0558 */ bool bIsReadOnly;
    /* 0x0560 */ FSlateFontInfo Font;
    /* 0x05c8 */ bool SelectAllTextWhenFocused;
    /* 0x05c9 */ bool ClearTextSelectionOnFocusLoss;
    /* 0x05ca */ bool RevertTextOnEscape;
    /* 0x05cb */ bool ClearKeyboardFocusOnCommit;
    /* 0x05cc */ bool AllowContextMenu;
    /* 0x05cd */ FVirtualKeyboardOptions VirtualKeyboardOptions;
    /* 0x05ce */ EVirtualKeyboardDismissAction VirtualKeyboardDismissAction;
    /* 0x05d0 */ FMulticastInlineDelegate OnTextChanged;
    /* 0x05e0 */ FMulticastInlineDelegate OnTextCommitted;

    FText GetHintText() const;
    FText GetText() const;
    void OnMultiLineEditableTextChangedEvent__DelegateSignature(const FText& text);
    void OnMultiLineEditableTextCommittedEvent__DelegateSignature(const FText& text, uint8_t CommitMethod);
    void SetHintText(FText InHintText);
    void SetIsReadOnly(bool bReadOnly);
    void SetText(FText InText);
    void SetWidgetStyle(const FTextBlockStyle& InWidgetStyle);
};

// Size: 0xf88
class UMultiLineEditableTextBox : public UTextLayoutWidget {
    /* 0x0248 */ FText text;
    /* 0x0260 */ FText HintText;
    /* 0x0278 */ FDelegate HintTextDelegate;
    /* 0x0290 */ FEditableTextBoxStyle WidgetStyle;
    /* 0x0bd0 */ FTextBlockStyle TextStyle;
    /* 0x0e98 */ bool bIsReadOnly;
    /* 0x0e99 */ bool AllowContextMenu;
    /* 0x0e9a */ FVirtualKeyboardOptions VirtualKeyboardOptions;
    /* 0x0e9b */ EVirtualKeyboardDismissAction VirtualKeyboardDismissAction;
    /* 0x0ea0 */ USlateWidgetStyleAsset* Style;
    /* 0x0ea8 */ FSlateFontInfo Font;
    /* 0x0f10 */ FLinearColor ForegroundColor;
    /* 0x0f20 */ FLinearColor BackgroundColor;
    /* 0x0f30 */ FLinearColor ReadOnlyForegroundColor;
    /* 0x0f40 */ FMulticastInlineDelegate OnTextChanged;
    /* 0x0f50 */ FMulticastInlineDelegate OnTextCommitted;

    FText GetHintText() const;
    FText GetText() const;
    void OnMultiLineEditableTextBoxChangedEvent__DelegateSignature(const FText& text);
    void OnMultiLineEditableTextBoxCommittedEvent__DelegateSignature(const FText& text, uint8_t CommitMethod);
    void SetError(FText InError);
    void SetHintText(FText InHintText);
    void SetIsReadOnly(bool bReadOnly);
    void SetText(FText InText);
    void SetTextStyle(const FTextBlockStyle& InTextStyle);
};

// Size: 0x250
class UNamedSlot : public UContentWidget {
};

// Size: 0x18
struct FNamedSlotBinding {
    /* 0x0000 */ FName Name;
    /* 0x0010 */ UWidget* Content;
};

// Size: 0x30
class INamedSlotInterface : public UInterface {
};

// Size: 0x238
class UNativeWidgetHost : public UWidget {
};

// Size: 0x250
class UOverlay : public UPanelWidget {

    UOverlaySlot* AddChildToOverlay(UWidget* Content);
};

// Size: 0x60
class UOverlaySlot : public UPanelSlot {
    /* 0x0048 */ FMargin Padding;
    /* 0x0058 */ uint8_t HorizontalAlignment;
    /* 0x0059 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x30
struct FPaintContext {
};

// Size: 0x40
class UPanelSlot : public UVisual {
    /* 0x0030 */ UPanelWidget* Parent;
    /* 0x0038 */ UWidget* Content;
};

// Size: 0x240
class UPanelWidget : public UWidget {
    /* 0x0228 */ TArray<UPanelSlot*> Slots;

    UPanelSlot* AddChild(UWidget* Content);
    void ClearChildren();
    TArray<UWidget*> GetAllChildren() const;
    UWidget* GetChildAt(int32_t index) const;
    int32_t GetChildIndex(const UWidget* Content) const;
    int32_t GetChildrenCount() const;
    bool HasAnyChildren() const;
    bool HasChild(UWidget* Content) const;
    bool RemoveChild(UWidget* Content);
    bool RemoveChildAt(int32_t index);
};

// Size: 0x4b0
class UProgressBar : public UWidget {
    /* 0x0228 */ FProgressBarStyle WidgetStyle;
    /* 0x0410 */ USlateWidgetStyleAsset* Style;
    /* 0x0418 */ USlateBrushAsset* BackgroundImage;
    /* 0x0420 */ USlateBrushAsset* FillImage;
    /* 0x0428 */ USlateBrushAsset* MarqueeImage;
    /* 0x0430 */ float Percent;
    /* 0x0434 */ uint8_t BarFillType;
    /* 0x0435 */ bool bIsMarquee;
    /* 0x0438 */ FVector2D BorderPadding;
    /* 0x0440 */ FDelegate PercentDelegate;
    /* 0x0454 */ FLinearColor FillColorAndOpacity;
    /* 0x0464 */ FDelegate FillColorAndOpacityDelegate;

    void SetFillColorAndOpacity(FLinearColor InColor);
    void SetIsMarquee(bool InbIsMarquee);
    void SetPercent(float InPercent);
};

// Size: 0x78
class UPropertyBinding : public UObject {
    /* 0x0030 */ TWeakObjectPtr<UObject> SourceObject;
    /* 0x0038 */ FDynamicPropertyPath SourcePath;
    /* 0x0068 */ FName DestinationProperty;
};

// Size: 0x10
struct FRadialBoxSettings {
    /* 0x0000 */ float StartingAngle;
    /* 0x0004 */ bool bDistributeItemsEvenly;
    /* 0x0008 */ float AngleBetweenItems;
    /* 0x000c */ float SectorCentralAngle;
};

// Size: 0x278
class URetainerBox : public UContentWidget {
    /* 0x0240 */ bool bRetainRender;
    /* 0x0241 */ bool RenderOnInvalidation;
    /* 0x0242 */ bool RenderOnPhase;
    /* 0x0244 */ int32_t Phase;
    /* 0x0248 */ int32_t PhaseCount;
    /* 0x0250 */ UMaterialInterface* EffectMaterial;
    /* 0x0258 */ FName TextureParameter;

    UMaterialInstanceDynamic* GetEffectMaterial() const;
    void RequestRender();
    void SetEffectMaterial(UMaterialInterface* EffectMaterial);
    void SetRenderingPhase(int32_t RenderPhase, int32_t TotalPhases);
    void SetRetainRendering(bool bInRetainRendering);
    void SetTextureParameter(FName TextureParameter);
};

// Size: 0xa8
struct FRichImageRow : public FTableRowBase {
    /* 0x0008 */ FSlateBrush Brush;
};

// Size: 0x848
class URichTextBlock : public UTextLayoutWidget {
    /* 0x0248 */ FText text;
    /* 0x0260 */ UDataTable* TextStyleSet;
    /* 0x0268 */ TArray<UClass*> DecoratorClasses;
    /* 0x0278 */ bool bOverrideDefaultStyle;
    /* 0x0280 */ FTextBlockStyle DefaultTextStyleOverride;
    /* 0x0548 */ float MinDesiredWidth;
    /* 0x054c */ ETextTransformPolicy TextTransformPolicy;
    /* 0x0550 */ FTextBlockStyle DefaultTextStyle;
    /* 0x0818 */ TArray<URichTextBlockDecorator*> InstanceDecorators;

    void ClearAllDefaultStyleOverrides();
    URichTextBlockDecorator* GetDecoratorByClass(UClass* DecoratorClass);
    FText GetText() const;
    void SetAutoWrapText(bool InAutoTextWrap);
    void SetDefaultColorAndOpacity(FSlateColor InColorAndOpacity);
    void SetDefaultFont(FSlateFontInfo InFontInfo);
    void SetDefaultShadowColorAndOpacity(FLinearColor InShadowColorAndOpacity);
    void SetDefaultShadowOffset(FVector2D InShadowOffset);
    void SetDefaultStrikeBrush(FSlateBrush& InStrikeBrush);
    void SetDefaultTextStyle(const FTextBlockStyle& InDefaultTextStyle);
    void SetMinDesiredWidth(float InMinDesiredWidth);
    void SetText(const FText& InText);
    void SetTextStyleSet(UDataTable* NewTextStyleSet);
    void SetTextTransformPolicy(ETextTransformPolicy InTransformPolicy);
};

// Size: 0x30
class URichTextBlockDecorator : public UObject {
};

// Size: 0x38
class URichTextBlockImageDecorator : public URichTextBlockDecorator {
    /* 0x0030 */ UDataTable* ImageSet;
};

// Size: 0x2d0
struct FRichTextStyleRow : public FTableRowBase {
    /* 0x0008 */ FTextBlockStyle TextStyle;
};

// Size: 0x270
class USafeZone : public UContentWidget {
    /* 0x0240 */ bool PadLeft;
    /* 0x0241 */ bool PadRight;
    /* 0x0242 */ bool PadTop;
    /* 0x0243 */ bool PadBottom;

    void SetSidesToPad(bool InPadLeft, bool InPadRight, bool InPadTop, bool InPadBottom);
};

// Size: 0x68
class USafeZoneSlot : public UPanelSlot {
    /* 0x0040 */ bool bIsTitleSafe;
    /* 0x0044 */ FMargin SafeAreaScale;
    /* 0x0054 */ uint8_t HAlign;
    /* 0x0055 */ uint8_t VAlign;
    /* 0x0058 */ FMargin Padding;
};

// Size: 0x270
class UScaleBox : public UContentWidget {
    /* 0x0240 */ uint8_t Stretch;
    /* 0x0241 */ uint8_t StretchDirection;
    /* 0x0244 */ float UserSpecifiedScale;
    /* 0x0248 */ bool IgnoreInheritedScale;

    void SetIgnoreInheritedScale(bool bInIgnoreInheritedScale);
    void SetStretch(uint8_t InStretch);
    void SetStretchDirection(uint8_t InStretchDirection);
    void SetUserSpecifiedScale(float InUserSpecifiedScale);
};

// Size: 0x68
class UScaleBoxSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0050 */ uint8_t HorizontalAlignment;
    /* 0x0051 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x808
class UScrollBar : public UWidget {
    /* 0x0228 */ FScrollBarStyle WidgetStyle;
    /* 0x07d0 */ USlateWidgetStyleAsset* Style;
    /* 0x07d8 */ bool bAlwaysShowScrollbar;
    /* 0x07d9 */ bool bAlwaysShowScrollbarTrack;
    /* 0x07da */ uint8_t Orientation;
    /* 0x07dc */ FVector2D Thickness;
    /* 0x07e4 */ FMargin Padding;

    void SetState(float InOffsetFraction, float InThumbSizeFraction);
};

// Size: 0xae0
class UScrollBox : public UPanelWidget {
    /* 0x0240 */ FScrollBoxStyle WidgetStyle;
    /* 0x04c8 */ FScrollBarStyle WidgetBarStyle;
    /* 0x0a70 */ USlateWidgetStyleAsset* Style;
    /* 0x0a78 */ USlateWidgetStyleAsset* BarStyle;
    /* 0x0a80 */ uint8_t Orientation;
    /* 0x0a81 */ ESlateVisibility ScrollBarVisibility;
    /* 0x0a82 */ EConsumeMouseWheel ConsumeMouseWheel;
    /* 0x0a84 */ FVector2D ScrollbarThickness;
    /* 0x0a8c */ FMargin ScrollbarPadding;
    /* 0x0a9c */ bool AlwaysShowScrollbar;
    /* 0x0a9d */ bool AlwaysShowScrollbarTrack;
    /* 0x0a9e */ bool AllowOverscroll;
    /* 0x0a9f */ bool bAnimateWheelScrolling;
    /* 0x0aa0 */ EDescendantScrollDestination NavigationDestination;
    /* 0x0aa4 */ float NavigationScrollPadding;
    /* 0x0aa8 */ EScrollWhenFocusChanges ScrollWhenFocusChanges;
    /* 0x0aa9 */ bool bAllowRightClickDragScrolling;
    /* 0x0aac */ float WheelScrollMultiplier;
    /* 0x0ab0 */ FMulticastInlineDelegate OnUserScrolled;

    void EndInertialScrolling();
    float GetScrollOffset() const;
    float GetScrollOffsetOfEnd() const;
    float GetViewOffsetFraction() const;
    void ScrollToEnd();
    void ScrollToStart();
    void ScrollWidgetIntoView(UWidget* WidgetToFind, bool AnimateScroll, EDescendantScrollDestination ScrollDestination, float Padding);
    void SetAllowOverscroll(bool NewAllowOverscroll);
    void SetAlwaysShowScrollbar(bool NewAlwaysShowScrollbar);
    void SetAnimateWheelScrolling(bool bShouldAnimateWheelScrolling);
    void SetConsumeMouseWheel(EConsumeMouseWheel NewConsumeMouseWheel);
    void SetOrientation(uint8_t NewOrientation);
    void SetScrollOffset(float NewScrollOffset);
    void SetScrollWhenFocusChanges(EScrollWhenFocusChanges NewScrollWhenFocusChanges);
    void SetScrollbarPadding(const FMargin& NewScrollbarPadding);
    void SetScrollbarThickness(const FVector2D& NewScrollbarThickness);
    void SetScrollbarVisibility(ESlateVisibility NewScrollBarVisibility);
    void SetWheelScrollMultiplier(float NewWheelScrollMultiplier);
};

// Size: 0x60
class UScrollBoxSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0050 */ uint8_t HorizontalAlignment;
    /* 0x0051 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x3
struct FShapedTextOptions {
    /* 0x0000 */ bool bOverride_TextShapingMethod;
    /* 0x0000 */ bool bOverride_TextFlowDirection;
    /* 0x0001 */ ETextShapingMethod TextShapingMethod;
    /* 0x0002 */ ETextFlowDirection TextFlowDirection;
};

// Size: 0x278
class USizeBox : public UContentWidget {
    /* 0x0250 */ float WidthOverride;
    /* 0x0254 */ float HeightOverride;
    /* 0x0258 */ float MinDesiredWidth;
    /* 0x025c */ float MinDesiredHeight;
    /* 0x0260 */ float MaxDesiredWidth;
    /* 0x0264 */ float MaxDesiredHeight;
    /* 0x0268 */ float MinAspectRatio;
    /* 0x026c */ float MaxAspectRatio;
    /* 0x0270 */ bool bOverride_WidthOverride;
    /* 0x0270 */ bool bOverride_HeightOverride;
    /* 0x0270 */ bool bOverride_MinDesiredWidth;
    /* 0x0270 */ bool bOverride_MinDesiredHeight;
    /* 0x0270 */ bool bOverride_MaxDesiredWidth;
    /* 0x0270 */ bool bOverride_MaxDesiredHeight;
    /* 0x0270 */ bool bOverride_MinAspectRatio;
    /* 0x0270 */ bool bOverride_MaxAspectRatio;

    void ClearHeightOverride();
    void ClearMaxAspectRatio();
    void ClearMaxDesiredHeight();
    void ClearMaxDesiredWidth();
    void ClearMinAspectRatio();
    void ClearMinDesiredHeight();
    void ClearMinDesiredWidth();
    void ClearWidthOverride();
    void SetHeightOverride(float InHeightOverride);
    void SetMaxAspectRatio(float InMaxAspectRatio);
    void SetMaxDesiredHeight(float InMaxDesiredHeight);
    void SetMaxDesiredWidth(float InMaxDesiredWidth);
    void SetMinAspectRatio(float InMinAspectRatio);
    void SetMinDesiredHeight(float InMinDesiredHeight);
    void SetMinDesiredWidth(float InMinDesiredWidth);
    void SetWidthOverride(float InWidthOverride);
};

// Size: 0x68
class USizeBoxSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0060 */ uint8_t HorizontalAlignment;
    /* 0x0061 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x98
class USlateAccessibleWidgetData : public UObject {
    /* 0x0030 */ bool bCanChildrenBeAccessible;
    /* 0x0031 */ ESlateAccessibleBehavior AccessibleBehavior;
    /* 0x0032 */ ESlateAccessibleBehavior AccessibleSummaryBehavior;
    /* 0x0038 */ FText AccessibleText;
    /* 0x0050 */ FDelegate AccessibleTextDelegate;
    /* 0x0068 */ FText AccessibleSummaryText;
    /* 0x0080 */ FDelegate AccessibleSummaryTextDelegate;

    FText GetText__DelegateSignature();
};

// Size: 0x30
class USlateBlueprintLibrary : public UBlueprintFunctionLibrary {

    static FVector2D AbsoluteToLocal(const FGeometry& Geometry, FVector2D AbsoluteCoordinate);
    static void AbsoluteToViewport(UObject* WorldContextObject, FVector2D AbsoluteDesktopCoordinate, FVector2D& PixelPosition, FVector2D& ViewportPosition);
    static bool EqualEqual_SlateBrush(const FSlateBrush& A, const FSlateBrush& B);
    static FVector2D GetAbsoluteSize(const FGeometry& Geometry);
    static FVector2D GetLocalSize(const FGeometry& Geometry);
    static FVector2D GetLocalTopLeft(const FGeometry& Geometry);
    static bool IsUnderLocation(const FGeometry& Geometry, const FVector2D& AbsoluteCoordinate);
    static FVector2D LocalToAbsolute(const FGeometry& Geometry, FVector2D LocalCoordinate);
    static void LocalToViewport(UObject* WorldContextObject, const FGeometry& Geometry, FVector2D LocalCoordinate, FVector2D& PixelPosition, FVector2D& ViewportPosition);
    static void ScreenToViewport(UObject* WorldContextObject, FVector2D ScreenPosition, FVector2D& ViewportPosition);
    static void ScreenToWidgetAbsolute(UObject* WorldContextObject, FVector2D ScreenPosition, FVector2D& AbsoluteCoordinate, bool bIncludeWindowPosition);
    static void ScreenToWidgetLocal(UObject* WorldContextObject, const FGeometry& Geometry, FVector2D ScreenPosition, FVector2D& LocalCoordinate, bool bIncludeWindowPosition);
    static float TransformScalarAbsoluteToLocal(const FGeometry& Geometry, float AbsoluteScalar);
    static float TransformScalarLocalToAbsolute(const FGeometry& Geometry, float LocalScalar);
    static FVector2D TransformVectorAbsoluteToLocal(const FGeometry& Geometry, FVector2D AbsoluteVector);
    static FVector2D TransformVectorLocalToAbsolute(const FGeometry& Geometry, FVector2D LocalVector);
};

// Size: 0x8
struct FSlateChildSize {
    /* 0x0000 */ float Value;
    /* 0x0004 */ uint8_t SizeRule;
};

// Size: 0x3c
struct FSlateMeshVertex {
    /* 0x0000 */ FVector2D Position;
    /* 0x0008 */ FColor Color;
    /* 0x000c */ FVector2D UV0;
    /* 0x0014 */ FVector2D UV1;
    /* 0x001c */ FVector2D UV2;
    /* 0x0024 */ FVector2D UV3;
    /* 0x002c */ FVector2D UV4;
    /* 0x0034 */ FVector2D UV5;
};

// Size: 0x78
class USlateVectorArtData : public UObject {
    /* 0x0030 */ UStaticMesh* MeshAsset;
    /* 0x0038 */ UMaterialInterface* SourceMaterial;
    /* 0x0040 */ TArray<FSlateMeshVertex> VertexData;
    /* 0x0050 */ TArray<uint32_t> IndexData;
    /* 0x0060 */ UMaterialInterface* Material;
    /* 0x0068 */ FVector2D ExtentMin;
    /* 0x0070 */ FVector2D ExtentMax;
};

// Size: 0x6b0
class USlider : public UWidget {
    /* 0x0228 */ float Value;
    /* 0x022c */ FDelegate ValueDelegate;
    /* 0x0240 */ float MinValue;
    /* 0x0244 */ float MaxValue;
    /* 0x0248 */ FSliderStyle WidgetStyle;
    /* 0x0618 */ uint8_t Orientation;
    /* 0x061c */ FLinearColor SliderBarColor;
    /* 0x062c */ FLinearColor SliderHandleColor;
    /* 0x063c */ bool IndentHandle;
    /* 0x063d */ bool Locked;
    /* 0x063e */ bool MouseUsesStep;
    /* 0x063f */ bool RequiresControllerLock;
    /* 0x0640 */ float StepSize;
    /* 0x0644 */ bool IsFocusable;
    /* 0x0648 */ FMulticastInlineDelegate OnMouseCaptureBegin;
    /* 0x0658 */ FMulticastInlineDelegate OnMouseCaptureEnd;
    /* 0x0668 */ FMulticastInlineDelegate OnControllerCaptureBegin;
    /* 0x0678 */ FMulticastInlineDelegate OnControllerCaptureEnd;
    /* 0x0688 */ FMulticastInlineDelegate OnValueChanged;

    float GetNormalizedValue() const;
    float GetValue() const;
    void SetIndentHandle(bool InValue);
    void SetLocked(bool InValue);
    void SetMaxValue(float InValue);
    void SetMinValue(float InValue);
    void SetSliderBarColor(FLinearColor InValue);
    void SetSliderHandleColor(FLinearColor InValue);
    void SetStepSize(float InValue);
    void SetValue(float InValue);
};

// Size: 0x240
class USpacer : public UWidget {
    /* 0x0228 */ FVector2D Size;

    void SetSize(FVector2D InSize);
};

// Size: 0x6d0
class USpinBox : public UWidget {
    /* 0x0228 */ float Value;
    /* 0x022c */ FDelegate ValueDelegate;
    /* 0x0240 */ FSpinBoxStyle WidgetStyle;
    /* 0x05a0 */ USlateWidgetStyleAsset* Style;
    /* 0x05a8 */ int32_t MinFractionalDigits;
    /* 0x05ac */ int32_t MaxFractionalDigits;
    /* 0x05b0 */ bool bAlwaysUsesDeltaSnap;
    /* 0x05b4 */ float Delta;
    /* 0x05b8 */ float SliderExponent;
    /* 0x05c0 */ FSlateFontInfo Font;
    /* 0x0628 */ uint8_t Justification;
    /* 0x062c */ float MinDesiredWidth;
    /* 0x0630 */ bool ClearKeyboardFocusOnCommit;
    /* 0x0631 */ bool SelectAllTextOnCommit;
    /* 0x0638 */ FSlateColor ForegroundColor;
    /* 0x0660 */ FMulticastInlineDelegate OnValueChanged;
    /* 0x0670 */ FMulticastInlineDelegate OnValueCommitted;
    /* 0x0680 */ FMulticastInlineDelegate OnBeginSliderMovement;
    /* 0x0690 */ FMulticastInlineDelegate OnEndSliderMovement;
    /* 0x06a0 */ bool bOverride_MinValue;
    /* 0x06a0 */ bool bOverride_MaxValue;
    /* 0x06a0 */ bool bOverride_MinSliderValue;
    /* 0x06a0 */ bool bOverride_MaxSliderValue;
    /* 0x06a4 */ float MinValue;
    /* 0x06a8 */ float MaxValue;
    /* 0x06ac */ float MinSliderValue;
    /* 0x06b0 */ float MaxSliderValue;

    void ClearMaxSliderValue();
    void ClearMaxValue();
    void ClearMinSliderValue();
    void ClearMinValue();
    bool GetAlwaysUsesDeltaSnap() const;
    float GetDelta() const;
    int32_t GetMaxFractionalDigits() const;
    float GetMaxSliderValue() const;
    float GetMaxValue() const;
    int32_t GetMinFractionalDigits() const;
    float GetMinSliderValue() const;
    float GetMinValue() const;
    float GetValue() const;
    void OnSpinBoxBeginSliderMovement__DelegateSignature();
    void OnSpinBoxValueChangedEvent__DelegateSignature(float InValue);
    void OnSpinBoxValueCommittedEvent__DelegateSignature(float InValue, uint8_t CommitMethod);
    void SetAlwaysUsesDeltaSnap(bool bNewValue);
    void SetDelta(float NewValue);
    void SetForegroundColor(FSlateColor InForegroundColor);
    void SetMaxFractionalDigits(int32_t NewValue);
    void SetMaxSliderValue(float NewValue);
    void SetMaxValue(float NewValue);
    void SetMinFractionalDigits(int32_t NewValue);
    void SetMinSliderValue(float NewValue);
    void SetMinValue(float NewValue);
    void SetValue(float NewValue);
};

// Size: 0x80
class UTextBinding : public UPropertyBinding {

    FString GetStringValue() const;
    FText GetTextValue() const;
};

// Size: 0x458
class UTextBlock : public UTextLayoutWidget {
    /* 0x0248 */ FText text;
    /* 0x0260 */ FDelegate TextDelegate;
    /* 0x0278 */ FSlateColor ColorAndOpacity;
    /* 0x02a0 */ FDelegate ColorAndOpacityDelegate;
    /* 0x02b8 */ FSlateFontInfo Font;
    /* 0x0320 */ FSlateBrush StrikeBrush;
    /* 0x03c0 */ FVector2D ShadowOffset;
    /* 0x03c8 */ FLinearColor ShadowColorAndOpacity;
    /* 0x03d8 */ FDelegate ShadowColorAndOpacityDelegate;
    /* 0x03ec */ float MinDesiredWidth;
    /* 0x03f0 */ bool bWrapWithInvalidationPanel;
    /* 0x03f1 */ bool bAutoWrapText;
    /* 0x03f2 */ ETextTransformPolicy TextTransformPolicy;
    /* 0x03f3 */ bool bSimpleTextMode;

    UMaterialInstanceDynamic* GetDynamicFontMaterial();
    UMaterialInstanceDynamic* GetDynamicOutlineMaterial();
    FText GetText() const;
    void SetAutoWrapText(bool InAutoTextWrap);
    void SetColorAndOpacity(FSlateColor InColorAndOpacity);
    void SetFont(FSlateFontInfo InFontInfo);
    void SetMinDesiredWidth(float InMinDesiredWidth);
    void SetOpacity(float InOpacity);
    void SetShadowColorAndOpacity(FLinearColor InShadowColorAndOpacity);
    void SetShadowOffset(FVector2D InShadowOffset);
    void SetStrikeBrush(FSlateBrush InStrikeBrush);
    void SetText(FText InText);
    void SetTextTransformPolicy(ETextTransformPolicy InTransformPolicy);
};

// Size: 0x248
class UTextLayoutWidget : public UWidget {
    /* 0x0228 */ FShapedTextOptions ShapedTextOptions;
    /* 0x022b */ uint8_t Justification;
    /* 0x022c */ ETextWrappingPolicy WrappingPolicy;
    /* 0x022d */ bool AutoWrapText;
    /* 0x0230 */ float WrapTextAt;
    /* 0x0234 */ FMargin Margin;
    /* 0x0244 */ float LineHeightPercentage;

    void SetJustification(uint8_t InJustification);
};

// Size: 0x2e8
class UThrobber : public UWidget {
    /* 0x0228 */ int32_t NumberOfPieces;
    /* 0x022c */ bool bAnimateHorizontally;
    /* 0x022d */ bool bAnimateVertically;
    /* 0x022e */ bool bAnimateOpacity;
    /* 0x0230 */ USlateBrushAsset* PieceImage;
    /* 0x0238 */ FSlateBrush Image;

    void SetAnimateHorizontally(bool bInAnimateHorizontally);
    void SetAnimateOpacity(bool bInAnimateOpacity);
    void SetAnimateVertically(bool bInAnimateVertically);
    void SetNumberOfPieces(int32_t InNumberOfPieces);
};

// Size: 0x4b0
class UTileView : public UListView {
    /* 0x0490 */ float EntryHeight;
    /* 0x0494 */ float EntryWidth;
    /* 0x0498 */ EListItemAlignment TileAlignment;
    /* 0x0499 */ bool bWrapHorizontalNavigation;

    float GetEntryHeight() const;
    float GetEntryWidth() const;
    void SetEntryHeight(float NewHeight);
    void SetEntryWidth(float NewWidth);
};

// Size: 0x4f0
class UTreeView : public UListView {
    /* 0x04a0 */ FDelegate BP_OnGetItemChildren;
    /* 0x04b8 */ FMulticastInlineDelegate BP_OnItemExpansionChanged;

    void CollapseAll();
    void ExpandAll();
    void SetItemExpansion(UObject* Item, bool bExpandItem);
};

// Size: 0x3e0
class UUMGSequencePlayer : public UObject {
    /* 0x0268 */ UWidgetAnimation* Animation;
    /* 0x0278 */ FMovieSceneRootEvaluationTemplateInstance RootTemplateInstance;

    FName GetUserTag() const;
    void SetUserTag(FName InUserTag);
};

// Size: 0x128
class UUMGSequenceTickManager : public UObject {
    /* 0x0030 */ TSet<TWeakObjectPtr<UUserWidget>> WeakUserWidgets;
    /* 0x0080 */ UMovieSceneEntitySystemLinker* Linker;
};

// Size: 0x268
class UUniformGridPanel : public UPanelWidget {
    /* 0x0240 */ FMargin SlotPadding;
    /* 0x0250 */ float MinDesiredSlotWidth;
    /* 0x0254 */ float MinDesiredSlotHeight;

    UUniformGridSlot* AddChildToUniformGrid(UWidget* Content, int32_t InRow, int32_t InColumn);
    void SetMinDesiredSlotHeight(float InMinDesiredSlotHeight);
    void SetMinDesiredSlotWidth(float InMinDesiredSlotWidth);
    void SetSlotPadding(FMargin InSlotPadding);
};

// Size: 0x58
class UUniformGridSlot : public UPanelSlot {
    /* 0x0040 */ uint8_t HorizontalAlignment;
    /* 0x0041 */ uint8_t VerticalAlignment;
    /* 0x0044 */ int32_t Row;
    /* 0x0048 */ int32_t Column;

    void SetColumn(int32_t InColumn);
    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetRow(int32_t InRow);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x30
class IUserListEntry : public UInterface {

    void BP_OnEntryReleased();
    void BP_OnItemExpansionChanged(bool bIsExpanded);
    void BP_OnItemSelectionChanged(bool bIsSelected);
};

// Size: 0x30
class UUserListEntryLibrary : public UBlueprintFunctionLibrary {

    static UListViewBase* GetOwningListView(TScriptInterface<IUserListEntry> UserListEntry);
    static bool IsListItemExpanded(TScriptInterface<IUserListEntry> UserListEntry);
    static bool IsListItemSelected(TScriptInterface<IUserListEntry> UserListEntry);
};

// Size: 0x30
class UUserObjectListEntry : public IUserListEntry {

    void OnListItemObjectSet(UObject* ListItemObject);
};

// Size: 0x30
class UUserObjectListEntryLibrary : public UBlueprintFunctionLibrary {

    static UObject* GetListItemObject(TScriptInterface<UUserObjectListEntry> UserObjectListEntry);
};

// Size: 0x3f8
class UUserWidget : public UWidget {
    /* 0x0230 */ FLinearColor ColorAndOpacity;
    /* 0x0240 */ FDelegate ColorAndOpacityDelegate;
    /* 0x0258 */ FSlateColor ForegroundColor;
    /* 0x0280 */ FDelegate ForegroundColorDelegate;
    /* 0x0298 */ FMulticastInlineDelegate OnVisibilityChanged;
    /* 0x02c0 */ FMargin Padding;
    /* 0x02d0 */ TArray<UUMGSequencePlayer*> ActiveSequencePlayers;
    /* 0x02e0 */ UUMGSequenceTickManager* AnimationTickManager;
    /* 0x02e8 */ TArray<UUMGSequencePlayer*> StoppedSequencePlayers;
    /* 0x02f8 */ TArray<FNamedSlotBinding> NamedSlotBindings;
    /* 0x0308 */ UWidgetTree* WidgetTree;
    /* 0x0310 */ FVector2D DesignTimeSize;
    /* 0x0318 */ EDesignPreviewSizeMode DesignSizeMode;
    /* 0x0320 */ FText PaletteCategory;
    /* 0x0338 */ UTexture2D* PreviewBackground;
    /* 0x0340 */ int32_t Priority;
    /* 0x0344 */ bool bSupportsKeyboardFocus;
    /* 0x0344 */ bool bIsFocusable;
    /* 0x0344 */ bool bStopAction;
    /* 0x0344 */ bool bHasScriptImplementedTick;
    /* 0x0344 */ bool bHasScriptImplementedPaint;
    /* 0x0350 */ EWidgetTickFrequency TickFrequency;
    /* 0x0358 */ UInputComponent* InputComponent;
    /* 0x0360 */ TArray<FAnimationEventBinding> AnimationCallbacks;

    bool AddToPlayerScreen(int32_t ZOrder);
    void AddToViewport(int32_t ZOrder);
    void BindToAnimationEvent(UWidgetAnimation* Animation, FDelegate delegate, EWidgetAnimationEvent AnimationEvent, FName UserTag);
    void BindToAnimationFinished(UWidgetAnimation* Animation, FDelegate delegate);
    void BindToAnimationStarted(UWidgetAnimation* Animation, FDelegate delegate);
    void CancelLatentActions();
    void Construct();
    void Destruct();
    void FlushAnimations();
    FVector2D GetAlignmentInViewport() const;
    FAnchors GetAnchorsInViewport() const;
    float GetAnimationCurrentTime(const UWidgetAnimation* InAnimation) const;
    bool GetIsVisible() const;
    APlayerCameraManager* GetOwningPlayerCameraManager() const;
    APawn* GetOwningPlayerPawn() const;
    bool IsAnimationPlaying(const UWidgetAnimation* InAnimation) const;
    bool IsAnimationPlayingForward(const UWidgetAnimation* InAnimation);
    bool IsAnyAnimationPlaying() const;
    bool IsInViewport() const;
    bool IsInteractable() const;
    bool IsListeningForInputAction(FName ActionName) const;
    bool IsPlayingAnimation() const;
    void ListenForInputAction(FName ActionName, uint8_t EventType, bool bConsume, FDelegate Callback);
    void OnAddedToFocusPath(FFocusEvent InFocusEvent);
    FEventReply OnAnalogValueChanged(FGeometry MyGeometry, FAnalogInputEvent InAnalogInputEvent);
    void OnAnimationFinished(const UWidgetAnimation* Animation);
    void OnAnimationStarted(const UWidgetAnimation* Animation);
    void OnDragCancelled(const FPointerEvent& PointerEvent, UDragDropOperation* Operation);
    void OnDragDetected(FGeometry MyGeometry, const FPointerEvent& PointerEvent, UDragDropOperation*& Operation);
    void OnDragEnter(FGeometry MyGeometry, FPointerEvent PointerEvent, UDragDropOperation* Operation);
    void OnDragLeave(FPointerEvent PointerEvent, UDragDropOperation* Operation);
    bool OnDragOver(FGeometry MyGeometry, FPointerEvent PointerEvent, UDragDropOperation* Operation);
    bool OnDrop(FGeometry MyGeometry, FPointerEvent PointerEvent, UDragDropOperation* Operation);
    void OnFocusLost(FFocusEvent InFocusEvent);
    FEventReply OnFocusReceived(FGeometry MyGeometry, FFocusEvent InFocusEvent);
    void OnInitialized();
    FEventReply OnKeyChar(FGeometry MyGeometry, FCharacterEvent InCharacterEvent);
    FEventReply OnKeyDown(FGeometry MyGeometry, FKeyEvent InKeyEvent);
    FEventReply OnKeyUp(FGeometry MyGeometry, FKeyEvent InKeyEvent);
    FEventReply OnMotionDetected(FGeometry MyGeometry, FMotionEvent InMotionEvent);
    FEventReply OnMouseButtonDoubleClick(FGeometry InMyGeometry, const FPointerEvent& InMouseEvent);
    FEventReply OnMouseButtonDown(FGeometry MyGeometry, const FPointerEvent& MouseEvent);
    FEventReply OnMouseButtonUp(FGeometry MyGeometry, const FPointerEvent& MouseEvent);
    void OnMouseCaptureLost();
    void OnMouseEnter(FGeometry MyGeometry, const FPointerEvent& MouseEvent);
    void OnMouseLeave(const FPointerEvent& MouseEvent);
    FEventReply OnMouseMove(FGeometry MyGeometry, const FPointerEvent& MouseEvent);
    FEventReply OnMouseWheel(FGeometry MyGeometry, const FPointerEvent& MouseEvent);
    void OnPaint(FPaintContext& Context) const;
    FEventReply OnPreviewKeyDown(FGeometry MyGeometry, FKeyEvent InKeyEvent);
    FEventReply OnPreviewMouseButtonDown(FGeometry MyGeometry, const FPointerEvent& MouseEvent);
    void OnRemovedFromFocusPath(FFocusEvent InFocusEvent);
    FEventReply OnTouchEnded(FGeometry MyGeometry, const FPointerEvent& InTouchEvent);
    FEventReply OnTouchForceChanged(FGeometry MyGeometry, const FPointerEvent& InTouchEvent);
    FEventReply OnTouchGesture(FGeometry MyGeometry, const FPointerEvent& GestureEvent);
    FEventReply OnTouchMoved(FGeometry MyGeometry, const FPointerEvent& InTouchEvent);
    FEventReply OnTouchStarted(FGeometry MyGeometry, const FPointerEvent& InTouchEvent);
    float PauseAnimation(const UWidgetAnimation* InAnimation);
    UUMGSequencePlayer* PlayAnimation(UWidgetAnimation* InAnimation, float StartAtTime, int32_t NumLoopsToPlay, uint8_t PlayMode, float PlaybackSpeed, bool bRestoreState);
    UUMGSequencePlayer* PlayAnimationForward(UWidgetAnimation* InAnimation, float PlaybackSpeed, bool bRestoreState);
    UUMGSequencePlayer* PlayAnimationReverse(UWidgetAnimation* InAnimation, float PlaybackSpeed, bool bRestoreState);
    UUMGSequencePlayer* PlayAnimationTimeRange(UWidgetAnimation* InAnimation, float StartAtTime, float EndAtTime, int32_t NumLoopsToPlay, uint8_t PlayMode, float PlaybackSpeed, bool bRestoreState);
    void PlaySound(USoundBase* SoundToPlay);
    void PreConstruct(bool IsDesignTime);
    void RegisterInputComponent();
    void RemoveFromViewport();
    void ReverseAnimation(const UWidgetAnimation* InAnimation);
    void SetAlignmentInViewport(FVector2D Alignment);
    void SetAnchorsInViewport(FAnchors Anchors);
    void SetAnimationCurrentTime(const UWidgetAnimation* InAnimation, float InTime);
    void SetColorAndOpacity(FLinearColor InColorAndOpacity);
    void SetDesiredSizeInViewport(FVector2D Size);
    void SetForegroundColor(FSlateColor InForegroundColor);
    void SetInputActionBlocking(bool bShouldBlock);
    void SetInputActionPriority(int32_t NewPriority);
    void SetNumLoopsToPlay(const UWidgetAnimation* InAnimation, int32_t NumLoopsToPlay);
    void SetOwningPlayer(APlayerController* LocalPlayerController);
    void SetPadding(FMargin InPadding);
    void SetPlaybackSpeed(const UWidgetAnimation* InAnimation, float PlaybackSpeed);
    void SetPositionInViewport(FVector2D Position, bool bRemoveDPIScale);
    void StopAllAnimations();
    void StopAnimation(const UWidgetAnimation* InAnimation);
    void StopAnimationsAndLatentActions();
    void StopListeningForAllInputActions();
    void StopListeningForInputAction(FName ActionName, uint8_t EventType);
    void Tick(FGeometry MyGeometry, float InDeltaTime);
    void UnbindAllFromAnimationFinished(UWidgetAnimation* Animation);
    void UnbindAllFromAnimationStarted(UWidgetAnimation* Animation);
    void UnbindFromAnimationFinished(UWidgetAnimation* Animation, FDelegate delegate);
    void UnbindFromAnimationStarted(UWidgetAnimation* Animation, FDelegate delegate);
    void UnregisterInputComponent();
};

// Size: 0x80
struct FUserWidgetPool {
    /* 0x0000 */ TArray<UUserWidget*> ActiveWidgets;
    /* 0x0010 */ TArray<UUserWidget*> InactiveWidgets;
};

// Size: 0x250
class UVerticalBox : public UPanelWidget {

    UVerticalBoxSlot* AddChildToVerticalBox(UWidget* Content);
};

// Size: 0x68
class UVerticalBoxSlot : public UPanelSlot {
    /* 0x0040 */ FSlateChildSize Size;
    /* 0x0048 */ FMargin Padding;
    /* 0x0060 */ uint8_t HorizontalAlignment;
    /* 0x0061 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetSize(FSlateChildSize InSize);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x298
class UViewport : public UContentWidget {
    /* 0x0240 */ FLinearColor BackgroundColor;

    FVector GetViewLocation() const;
    FRotator GetViewRotation() const;
    UWorld* GetViewportWorld() const;
    void SetViewLocation(FVector Location);
    void SetViewRotation(FRotator Rotation);
    AActor* Spawn(UClass* ActorClass);
};

// Size: 0x78
class UVisibilityBinding : public UPropertyBinding {

    ESlateVisibility GetValue() const;
};

// Size: 0x30
class UVisual : public UObject {
};

// Size: 0x228
class UWidget : public UVisual {
    /* 0x0030 */ UPanelSlot* Slot;
    /* 0x0038 */ FDelegate bIsEnabledDelegate;
    /* 0x0050 */ FText ToolTipText;
    /* 0x0068 */ FDelegate ToolTipTextDelegate;
    /* 0x0080 */ UWidget* ToolTipWidget;
    /* 0x0088 */ FDelegate ToolTipWidgetDelegate;
    /* 0x009c */ FDelegate VisibilityDelegate;
    /* 0x00b0 */ FWidgetTransform RenderTransform;
    /* 0x00cc */ FVector2D RenderTransformPivot;
    /* 0x00d4 */ bool bIsVariable;
    /* 0x00d4 */ bool bCreatedByConstructionScript;
    /* 0x00d4 */ bool bIsEnabled;
    /* 0x00d4 */ bool bOverride_Cursor;
    /* 0x00d4 */ bool bOverrideAccessibleDefaults;
    /* 0x00d4 */ bool bCanChildrenBeAccessible;
    /* 0x00d5 */ ESlateAccessibleBehavior AccessibleBehavior;
    /* 0x00d6 */ ESlateAccessibleBehavior AccessibleSummaryBehavior;
    /* 0x00d8 */ FText AccessibleText;
    /* 0x00f0 */ FDelegate AccessibleTextDelegate;
    /* 0x0108 */ FText AccessibleSummaryText;
    /* 0x0120 */ FDelegate AccessibleSummaryTextDelegate;
    /* 0x0138 */ USlateAccessibleWidgetData* AccessibleWidgetData;
    /* 0x0140 */ bool bIsVolatile;
    /* 0x0140 */ bool bHiddenInDesigner;
    /* 0x0140 */ bool bExpandedInDesigner;
    /* 0x0140 */ bool bLockedInDesigner;
    /* 0x0141 */ uint8_t Cursor;
    /* 0x0142 */ EWidgetClipping Clipping;
    /* 0x0143 */ ESlateVisibility Visibility;
    /* 0x0144 */ float RenderOpacity;
    /* 0x0148 */ UWidgetNavigation* Navigation;
    /* 0x0150 */ EFlowDirectionPreference FlowDirectionPreference;
    /* 0x0188 */ TArray<UPropertyBinding*> NativeBindings;
    /* 0x0198 */ uint8_t DesignerFlags;
    /* 0x01a0 */ FString DisplayLabel;
    /* 0x01c0 */ FString CategoryName;

    void ForceLayoutPrepass();
    void ForceVolatile(bool bForce);
    UWidget* GenerateWidgetForObject__DelegateSignature(UObject* Item);
    UWidget* GenerateWidgetForString__DelegateSignature(FString Item);
    FText GetAccessibleSummaryText() const;
    FText GetAccessibleText() const;
    bool GetBool__DelegateSignature();
    FGeometry GetCachedGeometry() const;
    ECheckBoxState GetCheckBoxState__DelegateSignature();
    EWidgetClipping GetClipping() const;
    FVector2D GetDesiredSize() const;
    float GetFloat__DelegateSignature();
    UGameInstance* GetGameInstance() const;
    int32_t GetInt32__DelegateSignature();
    bool GetIsEnabled() const;
    FLinearColor GetLinearColor__DelegateSignature();
    uint8_t GetMouseCursor__DelegateSignature();
    ULocalPlayer* GetOwningLocalPlayer() const;
    APlayerController* GetOwningPlayer() const;
    FGeometry GetPaintSpaceGeometry() const;
    UPanelWidget* GetParent() const;
    float GetRenderOpacity() const;
    float GetRenderTransformAngle() const;
    FSlateBrush GetSlateBrush__DelegateSignature();
    FSlateColor GetSlateColor__DelegateSignature();
    ESlateVisibility GetSlateVisibility__DelegateSignature();
    FText GetText__DelegateSignature();
    FGeometry GetTickSpaceGeometry() const;
    ESlateVisibility GetVisibility() const;
    UWidget* GetWidget__DelegateSignature();
    bool HasAnyUserFocus() const;
    bool HasFocusedDescendants() const;
    bool HasKeyboardFocus() const;
    bool HasMouseCapture() const;
    bool HasMouseCaptureByUser(int32_t UserIndex, int32_t PointerIndex) const;
    bool HasUserFocus(APlayerController* PlayerController) const;
    bool HasUserFocusedDescendants(APlayerController* PlayerController) const;
    void InvalidateLayoutAndVolatility();
    bool IsHovered() const;
    bool IsVisible() const;
    FEventReply OnPointerEvent__DelegateSignature(FGeometry MyGeometry, const FPointerEvent& MouseEvent);
    FEventReply OnReply__DelegateSignature();
    void RemoveFromParent();
    void ResetCursor();
    void SetAllNavigationRules(EUINavigationRule Rule, FName WidgetToFocus);
    void SetClipping(EWidgetClipping InClipping);
    void SetCursor(uint8_t InCursor);
    void SetFocus();
    void SetIsEnabled(bool bInIsEnabled);
    void SetKeyboardFocus();
    void SetNavigationRule(EUINavigation Direction, EUINavigationRule Rule, FName WidgetToFocus);
    void SetNavigationRuleBase(EUINavigation Direction, EUINavigationRule Rule);
    void SetNavigationRuleCustom(EUINavigation Direction, FDelegate InCustomDelegate);
    void SetNavigationRuleCustomBoundary(EUINavigation Direction, FDelegate InCustomDelegate);
    void SetNavigationRuleExplicit(EUINavigation Direction, UWidget* InWidget);
    void SetRenderOpacity(float InOpacity);
    void SetRenderScale(FVector2D Scale);
    void SetRenderShear(FVector2D Shear);
    void SetRenderTransform(FWidgetTransform InTransform);
    void SetRenderTransformAngle(float Angle);
    void SetRenderTransformPivot(FVector2D Pivot);
    void SetRenderTranslation(FVector2D Translation);
    void SetToolTip(UWidget* Widget);
    void SetToolTipText(const FText& InToolTipText);
    void SetUserFocus(APlayerController* PlayerController);
    void SetVisibility(ESlateVisibility InVisibility);
};

// Size: 0xb8
class UWidgetAnimation : public UMovieSceneSequence {
    /* 0x0068 */ FMulticastInlineDelegate OnAnimationStarted;
    /* 0x0078 */ FMulticastInlineDelegate OnAnimationFinished;
    /* 0x0088 */ UMovieScene* MovieScene;
    /* 0x0090 */ TArray<FWidgetAnimationBinding> AnimationBindings;
    /* 0x00a0 */ bool bLegacyFinishOnStop;
    /* 0x00a8 */ FString DisplayLabel;

    void BindToAnimationFinished(UUserWidget* Widget, FDelegate delegate);
    void BindToAnimationStarted(UUserWidget* Widget, FDelegate delegate);
    float GetEndTime() const;
    float GetStartTime() const;
    void UnbindAllFromAnimationFinished(UUserWidget* Widget);
    void UnbindAllFromAnimationStarted(UUserWidget* Widget);
    void UnbindFromAnimationFinished(UUserWidget* Widget, FDelegate delegate);
    void UnbindFromAnimationStarted(UUserWidget* Widget, FDelegate delegate);
};

// Size: 0x2c
struct FWidgetAnimationBinding {
    /* 0x0000 */ FName WidgetName;
    /* 0x000c */ FName SlotWidgetName;
    /* 0x0018 */ FGuid AnimationGuid;
    /* 0x0028 */ bool bIsRootWidget;
};

// Size: 0x40
class UWidgetAnimationDelegateBinding : public UDynamicBlueprintBinding {
    /* 0x0030 */ TArray<FBlueprintWidgetAnimationDelegateBinding> WidgetAnimationDelegateBindings;
};

// Size: 0x50
class UWidgetAnimationPlayCallbackProxy : public UObject {
    /* 0x0030 */ FMulticastInlineDelegate Finished;

    static UWidgetAnimationPlayCallbackProxy* CreatePlayAnimationProxyObject(UUMGSequencePlayer*& Result, UUserWidget* Widget, UWidgetAnimation* InAnimation, float StartAtTime, int32_t NumLoopsToPlay, uint8_t PlayMode, float PlaybackSpeed);
    static UWidgetAnimationPlayCallbackProxy* CreatePlayAnimationTimeRangeProxyObject(UUMGSequencePlayer*& Result, UUserWidget* Widget, UWidgetAnimation* InAnimation, float StartAtTime, float EndAtTime, int32_t NumLoopsToPlay, uint8_t PlayMode, float PlaybackSpeed);
};

// Size: 0x78
class UWidgetBinding : public UPropertyBinding {

    UWidget* GetValue() const;
};

// Size: 0x628
class UWidgetBlueprintGeneratedClass : public UBlueprintGeneratedClass {
    /* 0x05e8 */ UWidgetTree* WidgetTree;
    /* 0x05f0 */ bool bCanCallPreConstruct;
    /* 0x05f0 */ bool bClassRequiresNativeTick;
    /* 0x05f8 */ TArray<FDelegateRuntimeBinding> Bindings;
    /* 0x0608 */ TArray<UWidgetAnimation*> Animations;
    /* 0x0618 */ TArray<FName> NamedSlots;
};

// Size: 0x30
class UWidgetBlueprintLibrary : public UBlueprintFunctionLibrary {

    static void CancelDragDrop();
    static FEventReply CaptureJoystick(FEventReply& Reply, UWidget* CapturingWidget, bool bInAllJoysticks);
    static FEventReply CaptureMouse(FEventReply& Reply, UWidget* CapturingWidget);
    static FEventReply ClearUserFocus(FEventReply& Reply, bool bInAllUsers);
    static UUserWidget* Create(UObject* WorldContextObject, UClass* WidgetType, APlayerController* OwningPlayer);
    static UDragDropOperation* CreateDragDropOperation(UClass* OperationClass);
    static FEventReply DetectDrag(FEventReply& Reply, UWidget* WidgetDetectingDrag, FKey DragKey);
    static FEventReply DetectDragIfPressed(const FPointerEvent& PointerEvent, UWidget* WidgetDetectingDrag, FKey DragKey);
    static void DismissAllMenus();
    static void DrawBox(FPaintContext& Context, FVector2D Position, FVector2D Size, USlateBrushAsset* Brush, FLinearColor Tint);
    static void DrawLine(FPaintContext& Context, FVector2D PositionA, FVector2D PositionB, FLinearColor Tint, bool bAntiAlias, float Thickness);
    static void DrawLines(FPaintContext& Context, const TArray<FVector2D>& Points, FLinearColor Tint, bool bAntiAlias, float Thickness);
    static void DrawText(FPaintContext& Context, FString inString, FVector2D Position, FLinearColor Tint);
    static void DrawTextFormatted(FPaintContext& Context, const FText& text, FVector2D Position, UFont* Font, int32_t FontSize, FName FontTypeFace, FLinearColor Tint);
    static FEventReply EndDragDrop(FEventReply& Reply);
    static void GetAllWidgetsOfClass(UObject* WorldContextObject, TArray<UUserWidget*>& FoundWidgets, UClass* WidgetClass, bool TopLevelOnly);
    static void GetAllWidgetsWithInterface(UObject* WorldContextObject, TArray<UUserWidget*>& FoundWidgets, UClass* Interface, bool TopLevelOnly);
    static UObject* GetBrushResource(const FSlateBrush& Brush);
    static UMaterialInterface* GetBrushResourceAsMaterial(const FSlateBrush& Brush);
    static UTexture2D* GetBrushResourceAsTexture2D(const FSlateBrush& Brush);
    static UDragDropOperation* GetDragDroppingContent();
    static UMaterialInstanceDynamic* GetDynamicMaterial(FSlateBrush& Brush);
    static FInputEvent GetInputEventFromCharacterEvent(const FCharacterEvent& Event);
    static FInputEvent GetInputEventFromKeyEvent(const FKeyEvent& Event);
    static FInputEvent GetInputEventFromNavigationEvent(const FNavigationEvent& Event);
    static FInputEvent GetInputEventFromPointerEvent(const FPointerEvent& Event);
    static FKeyEvent GetKeyEventFromAnalogInputEvent(const FAnalogInputEvent& Event);
    static void GetSafeZonePadding(UObject* WorldContextObject, FVector4& SafePadding, FVector2D& SafePaddingScale, FVector4& SpillOverPadding);
    static FEventReply Handled();
    static bool IsDragDropping();
    static FEventReply LockMouse(FEventReply& Reply, UWidget* CapturingWidget);
    static FSlateBrush MakeBrushFromAsset(USlateBrushAsset* BrushAsset);
    static FSlateBrush MakeBrushFromMaterial(UMaterialInterface* Material, int32_t Width, int32_t Height);
    static FSlateBrush MakeBrushFromTexture(UTexture2D* Texture, int32_t Width, int32_t Height);
    static FSlateBrush NoResourceBrush();
    void OnGameWindowCloseButtonClickedDelegate__DelegateSignature();
    static FEventReply ReleaseJoystickCapture(FEventReply& Reply, bool bInAllJoysticks);
    static FEventReply ReleaseMouseCapture(FEventReply& Reply);
    static void RestorePreviousWindowTitleBarState();
    static void SetBrushResourceToMaterial(FSlateBrush& Brush, UMaterialInterface* Material);
    static void SetBrushResourceToTexture(FSlateBrush& Brush, UTexture2D* Texture);
    static void SetColorVisionDeficiencyType(EColorVisionDeficiency Type, float Severity, bool CorrectDeficiency, bool ShowCorrectionWithDeficiency);
    static void SetFocusToGameViewport();
    static bool SetHardwareCursor(UObject* WorldContextObject, uint8_t CursorShape, FName CursorName, FVector2D HotSpot);
    static void SetInputMode_GameAndUI(APlayerController* Target, UWidget* InWidgetToFocus, bool bLockMouseToViewport, bool bHideCursorDuringCapture);
    static void SetInputMode_GameAndUIEx(APlayerController* PlayerController, UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode, bool bHideCursorDuringCapture);
    static void SetInputMode_GameOnly(APlayerController* PlayerController);
    static void SetInputMode_UIOnly(APlayerController* Target, UWidget* InWidgetToFocus, bool bLockMouseToViewport);
    static void SetInputMode_UIOnlyEx(APlayerController* PlayerController, UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode);
    static FEventReply SetMousePosition(FEventReply& Reply, FVector2D NewMousePosition);
    static FEventReply SetUserFocus(FEventReply& Reply, UWidget* FocusWidget, bool bInAllUsers);
    static void SetWindowTitleBarCloseButtonActive(bool bActive);
    static void SetWindowTitleBarOnCloseClickedDelegate(FDelegate delegate);
    static void SetWindowTitleBarState(UWidget* TitleBarContent, EWindowTitleBarMode Mode, bool bTitleBarDragEnabled, bool bWindowButtonsVisible, bool bTitleBarVisible);
    static FEventReply Unhandled();
    static FEventReply UnlockMouse(FEventReply& Reply);
};

// Size: 0x630
class UWidgetComponent : public UMeshComponent {
    /* 0x0500 */ EWidgetSpace Space;
    /* 0x0501 */ EWidgetTimingPolicy TimingPolicy;
    /* 0x0508 */ UClass* WidgetClass;
    /* 0x0510 */ FIntPoint DrawSize;
    /* 0x0518 */ bool bManuallyRedraw;
    /* 0x0519 */ bool bRedrawRequested;
    /* 0x051c */ float RedrawTime;
    /* 0x0528 */ FIntPoint CurrentDrawSize;
    /* 0x0530 */ bool bDrawAtDesiredSize;
    /* 0x0534 */ FVector2D Pivot;
    /* 0x053c */ bool bReceiveHardwareInput;
    /* 0x053d */ bool bWindowFocusable;
    /* 0x053e */ EWindowVisibility WindowVisibility;
    /* 0x053f */ bool bApplyGammaCorrection;
    /* 0x0540 */ ULocalPlayer* OwnerPlayer;
    /* 0x0548 */ FLinearColor BackgroundColor;
    /* 0x0558 */ FLinearColor TintColorAndOpacity;
    /* 0x0568 */ float OpacityFromTexture;
    /* 0x056c */ EWidgetBlendMode BlendMode;
    /* 0x056d */ bool bIsTwoSided;
    /* 0x056e */ bool TickWhenOffscreen;
    /* 0x0570 */ UBodySetup* BodySetup;
    /* 0x0578 */ UMaterialInterface* TranslucentMaterial;
    /* 0x0580 */ UMaterialInterface* TranslucentMaterial_OneSided;
    /* 0x0588 */ UMaterialInterface* OpaqueMaterial;
    /* 0x0590 */ UMaterialInterface* OpaqueMaterial_OneSided;
    /* 0x0598 */ UMaterialInterface* MaskedMaterial;
    /* 0x05a0 */ UMaterialInterface* MaskedMaterial_OneSided;
    /* 0x05a8 */ UTextureRenderTarget2D* RenderTarget;
    /* 0x05b0 */ UMaterialInstanceDynamic* MaterialInstance;
    /* 0x05b8 */ bool bAddedToScreen;
    /* 0x05b9 */ bool bEditTimeUsable;
    /* 0x05bc */ FName SharedLayerName;
    /* 0x05c8 */ int32_t LayerZOrder;
    /* 0x05cc */ EWidgetGeometryMode GeometryMode;
    /* 0x05d0 */ float CylinderArcAngle;
    /* 0x05d4 */ ETickMode TickMode;
    /* 0x05f8 */ UUserWidget* Widget;

    FVector2D GetCurrentDrawSize() const;
    float GetCylinderArcAngle() const;
    bool GetDrawAtDesiredSize() const;
    FVector2D GetDrawSize() const;
    EWidgetGeometryMode GetGeometryMode() const;
    bool GetManuallyRedraw() const;
    UMaterialInstanceDynamic* GetMaterialInstance() const;
    ULocalPlayer* GetOwnerPlayer() const;
    FVector2D GetPivot() const;
    float GetRedrawTime() const;
    UTextureRenderTarget2D* GetRenderTarget() const;
    bool GetTickWhenOffscreen() const;
    bool GetTwoSided() const;
    UUserWidget* GetUserWidgetObject() const;
    UUserWidget* GetWidget() const;
    EWidgetSpace GetWidgetSpace() const;
    bool GetWindowFocusable() const;
    EWindowVisibility GetWindowVisiblility() const;
    bool IsWidgetVisible() const;
    void RequestRedraw();
    void RequestRenderUpdate();
    void SetBackgroundColor(const FLinearColor NewBackgroundColor);
    void SetCylinderArcAngle(const float InCylinderArcAngle);
    void SetDrawAtDesiredSize(bool bInDrawAtDesiredSize);
    void SetDrawSize(FVector2D Size);
    void SetGeometryMode(EWidgetGeometryMode InGeometryMode);
    void SetManuallyRedraw(bool bUseManualRedraw);
    void SetOwnerPlayer(ULocalPlayer* LocalPlayer);
    void SetPivot(const FVector2D& InPivot);
    void SetRedrawTime(float InRedrawTime);
    void SetTickMode(ETickMode InTickMode);
    void SetTickWhenOffscreen(const bool bWantTickWhenOffscreen);
    void SetTintColorAndOpacity(const FLinearColor NewTintColorAndOpacity);
    void SetTwoSided(const bool bWantTwoSided);
    void SetWidget(UUserWidget* Widget);
    void SetWidgetSpace(EWidgetSpace NewSpace);
    void SetWindowFocusable(bool bInWindowFocusable);
    void SetWindowVisibility(EWindowVisibility InVisibility);
};

// Size: 0xc8
struct FWidgetComponentInstanceData : public FSceneComponentInstanceData {
};

// Size: 0x440
class UWidgetInteractionComponent : public USceneComponent {
    /* 0x0228 */ FMulticastInlineDelegate OnHoveredWidgetChanged;
    /* 0x0248 */ int32_t VirtualUserIndex;
    /* 0x024c */ int32_t PointerIndex;
    /* 0x0250 */ uint8_t TraceChannel;
    /* 0x0254 */ float InteractionDistance;
    /* 0x0258 */ EWidgetInteractionSource InteractionSource;
    /* 0x0259 */ bool bEnableHitTesting;
    /* 0x025a */ bool bShowDebug;
    /* 0x025c */ float DebugSphereLineThickness;
    /* 0x0260 */ float DebugLineThickness;
    /* 0x0264 */ FLinearColor DebugColor;
    /* 0x02f0 */ FHitResult CustomHitResult;
    /* 0x0380 */ FVector2D LocalHitLocation;
    /* 0x0388 */ FVector2D LastLocalHitLocation;
    /* 0x0390 */ UWidgetComponent* HoveredWidgetComponent;
    /* 0x0398 */ FHitResult LastHitResult;
    /* 0x0428 */ bool bIsHoveredWidgetInteractable;
    /* 0x0429 */ bool bIsHoveredWidgetFocusable;
    /* 0x042a */ bool bIsHoveredWidgetHitTestVisible;
    /* 0x0430 */ UArrowComponent* ArrowComponent;

    FVector2D Get2DHitLocation() const;
    UWidgetComponent* GetHoveredWidgetComponent() const;
    FHitResult GetLastHitResult() const;
    bool IsOverFocusableWidget() const;
    bool IsOverHitTestVisibleWidget() const;
    bool IsOverInteractableWidget() const;
    bool PressAndReleaseKey(FKey Key);
    bool PressKey(FKey Key, bool bRepeat);
    void PressPointerKey(FKey Key);
    bool ReleaseKey(FKey Key);
    void ReleasePointerKey(FKey Key);
    void ScrollWheel(float ScrollDelta);
    bool SendKeyChar(FString Characters, bool bRepeat);
    void SetCustomHitResult(const FHitResult& HitResult);
    void SetFocus(UWidget* FocusWidget);
};

// Size: 0x30
class UWidgetLayoutLibrary : public UBlueprintFunctionLibrary {

    static FVector2D GetMousePositionOnPlatform();
    static FVector2D GetMousePositionOnViewport(UObject* WorldContextObject);
    static bool GetMousePositionScaledByDPI(APlayerController* Player, float& LocationX, float& LocationY);
    static FGeometry GetPlayerScreenWidgetGeometry(APlayerController* PlayerController);
    static float GetViewportScale(UObject* WorldContextObject);
    static FVector2D GetViewportSize(UObject* WorldContextObject);
    static FGeometry GetViewportWidgetGeometry(UObject* WorldContextObject);
    static bool ProjectWorldLocationToWidgetPosition(APlayerController* PlayerController, FVector WorldLocation, FVector2D& ScreenPosition, bool bPlayerViewportRelative);
    static void RemoveAllWidgets(UObject* WorldContextObject);
    static UBorderSlot* SlotAsBorderSlot(UWidget* Widget);
    static UCanvasPanelSlot* SlotAsCanvasSlot(UWidget* Widget);
    static UGridSlot* SlotAsGridSlot(UWidget* Widget);
    static UHorizontalBoxSlot* SlotAsHorizontalBoxSlot(UWidget* Widget);
    static UOverlaySlot* SlotAsOverlaySlot(UWidget* Widget);
    static USafeZoneSlot* SlotAsSafeBoxSlot(UWidget* Widget);
    static UScaleBoxSlot* SlotAsScaleBoxSlot(UWidget* Widget);
    static UScrollBoxSlot* SlotAsScrollBoxSlot(UWidget* Widget);
    static USizeBoxSlot* SlotAsSizeBoxSlot(UWidget* Widget);
    static UUniformGridSlot* SlotAsUniformGridSlot(UWidget* Widget);
    static UVerticalBoxSlot* SlotAsVerticalBoxSlot(UWidget* Widget);
    static UWidgetSwitcherSlot* SlotAsWidgetSwitcherSlot(UWidget* Widget);
    static UWrapBoxSlot* SlotAsWrapBoxSlot(UWidget* Widget);
};

// Size: 0x138
class UWidgetNavigation : public UObject {
    /* 0x0030 */ FWidgetNavigationData Up;
    /* 0x005c */ FWidgetNavigationData Down;
    /* 0x0088 */ FWidgetNavigationData Left;
    /* 0x00b4 */ FWidgetNavigationData Right;
    /* 0x00e0 */ FWidgetNavigationData Next;
    /* 0x010c */ FWidgetNavigationData Previous;
};

// Size: 0x2c
struct FWidgetNavigationData {
    /* 0x0000 */ EUINavigationRule Rule;
    /* 0x0004 */ FName WidgetToFocus;
    /* 0x0010 */ TWeakObjectPtr<UWidget> Widget;
    /* 0x0018 */ FDelegate CustomDelegate;
};

// Size: 0x258
class UWidgetSwitcher : public UPanelWidget {
    /* 0x0240 */ int32_t ActiveWidgetIndex;

    UWidget* GetActiveWidget() const;
    int32_t GetActiveWidgetIndex() const;
    int32_t GetNumWidgets() const;
    UWidget* GetWidgetAtIndex(int32_t index) const;
    void SetActiveWidget(UWidget* Widget);
    void SetActiveWidgetIndex(int32_t index);
};

// Size: 0x60
class UWidgetSwitcherSlot : public UPanelSlot {
    /* 0x0048 */ FMargin Padding;
    /* 0x0058 */ uint8_t HorizontalAlignment;
    /* 0x0059 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x1c
struct FWidgetTransform {
    /* 0x0000 */ FVector2D Translation;
    /* 0x0008 */ FVector2D Scale;
    /* 0x0010 */ FVector2D Shear;
    /* 0x0018 */ float Angle;
};

// Size: 0x48
class UWidgetTree : public UObject {
    /* 0x0030 */ UWidget* RootWidget;
    /* 0x0038 */ TArray<UWidget*> AllWidgets;
};

// Size: 0x260
class UWindowTitleBarArea : public UContentWidget {
    /* 0x0240 */ bool bWindowButtonsEnabled;
    /* 0x0241 */ bool bDoubleClickTogglesFullscreen;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x68
class UWindowTitleBarAreaSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0050 */ uint8_t HorizontalAlignment;
    /* 0x0051 */ uint8_t VerticalAlignment;

    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x268
class UWrapBox : public UPanelWidget {
    /* 0x0240 */ FVector2D InnerSlotPadding;
    /* 0x0248 */ float WrapWidth;
    /* 0x024c */ float WrapSize;
    /* 0x0250 */ bool bExplicitWrapWidth;
    /* 0x0251 */ bool bExplicitWrapSize;
    /* 0x0252 */ uint8_t Orientation;

    UWrapBoxSlot* AddChildToWrapBox(UWidget* Content);
    void SetInnerSlotPadding(FVector2D InPadding);
};

// Size: 0x68
class UWrapBoxSlot : public UPanelSlot {
    /* 0x0040 */ FMargin Padding;
    /* 0x0050 */ bool bFillEmptySpace;
    /* 0x0054 */ float FillSpanWhenLessThan;
    /* 0x0058 */ uint8_t HorizontalAlignment;
    /* 0x0059 */ uint8_t VerticalAlignment;

    void SetFillEmptySpace(bool InbFillEmptySpace);
    void SetFillSpanWhenLessThan(float InFillSpanWhenLessThan);
    void SetHorizontalAlignment(uint8_t InHorizontalAlignment);
    void SetPadding(FMargin InPadding);
    void SetVerticalAlignment(uint8_t InVerticalAlignment);
};

// Size: 0x28
struct FDebugResolution {
    /* 0x0000 */ int32_t Width;
    /* 0x0004 */ int32_t Height;
    /* 0x0008 */ FString Description;
    /* 0x0018 */ FLinearColor Color;
};

// Size: 0x60
struct FDelegateEditorBinding {
    /* 0x0000 */ FString ObjectName;
    /* 0x0010 */ FName PropertyName;
    /* 0x001c */ FName FunctionName;
    /* 0x0028 */ FName SourceProperty;
    /* 0x0038 */ FEditorPropertyPath SourcePath;
    /* 0x0048 */ FGuid MemberGuid;
    /* 0x0058 */ EBindingKind Kind;
};

// Size: 0x308
class UDetailsView : public UPropertyViewBase {
    /* 0x02b0 */ bool bAllowFiltering;
    /* 0x02b1 */ bool bAllowFavoriteSystem;
    /* 0x02b2 */ bool bShowModifiedPropertiesOption;
    /* 0x02b3 */ bool bShowKeyablePropertiesOption;
    /* 0x02b4 */ bool bShowAnimatedPropertiesOption;
    /* 0x02b8 */ float ColumnWidth;
    /* 0x02bc */ bool bShowScrollBar;
    /* 0x02bd */ bool bForceHiddenPropertyVisibility;
    /* 0x02c0 */ FName ViewIdentifier;
    /* 0x02d0 */ TArray<FName> CategoriesToShow;
    /* 0x02e0 */ TArray<FName> PropertiesToShow;
    /* 0x0300 */ bool bShowOnlyWhitelisted;
};

// Size: 0x38
struct FDirectoryWidgetCompilerOptions {
    /* 0x0000 */ FDirectoryPath Directory;
    /* 0x0010 */ TArray<TSoftObjectPtr<UWidgetBlueprint>> IgnoredWidgets;
    /* 0x0020 */ FWidgetCompilerOptions Options;
};

enum class EPropertyBindingPermissionLevel {
    Allow = 0,
    Prevent = 1,
    PreventAndWarn = 2,
    PreventAndError = 3,
    EPropertyBindingPermissionLevel_MAX = 4,
};

enum class EWidgetCompileTimeTickPrediction {
    WontTick = 0,
    OnDemand = 1,
    WillTick = 2,
    EWidgetCompileTimeTickPrediction_MAX = 3,
};

enum class EWidgetSupportsDynamicCreation {
    Default = 0,
    Yes = 1,
    No = 2,
    EWidgetSupportsDynamicCreation_MAX = 3,
};

// Size: 0x10
struct FEditorPropertyPath {
    /* 0x0000 */ TArray<FEditorPropertyPathSegment> Segments;
};

// Size: 0x28
struct FEditorPropertyPathSegment {
    /* 0x0000 */ Ustruct* struct;
    /* 0x0008 */ FName MemberName;
    /* 0x0014 */ FGuid MemberGuid;
    /* 0x0024 */ bool IsProperty;
};

// Size: 0x100
class UK2Node_CreateDragDropOperation : public UK2Node_ConstructObjectFromClass {
};

// Size: 0x100
class UK2Node_CreateWidget : public UK2Node_ConstructObjectFromClass {
};

// Size: 0xf8
class UK2Node_PlayAnimation : public UK2Node_BaseAsyncTask {
};

// Size: 0xf8
class UK2Node_PlayAnimationTimeRange : public UK2Node_BaseAsyncTask {
};

// Size: 0x1d8
class UK2Node_WidgetAnimationEvent : public UK2Node_Event {
    /* 0x0170 */ EWidgetAnimationEvent Action;
    /* 0x0174 */ FName AnimationPropertyName;
    /* 0x0180 */ FName UserTag;
    /* 0x0190 */ UWidgetBlueprint* SourceWidgetBlueprint;
};

// Size: 0x8
struct FNavigationSimulationArguments {
    /* 0x0000 */ int32_t UserIndex;
    /* 0x0004 */ ENavigationGenesis NavigationGenesis;
    /* 0x0005 */ EUINavigation UINavigation;
    /* 0x0006 */ bool bOverrideUINavigation;
    /* 0x0007 */ bool bShowPreview;
};

// Size: 0x2a8
class UPropertyViewBase : public UWidget {
    /* 0x0228 */ TLazyObjectPtr<UObject> LazyObject;
    /* 0x0248 */ FSoftObjectPath SoftObjectPath;
    /* 0x0268 */ bool bAutoLoadAsset;
    /* 0x0270 */ FMulticastInlineDelegate OnPropertyChanged;

    UObject* GetObject() const;
    void SetObject(UObject* NewObject);
};

// Size: 0x2e0
class USinglePropertyView : public UPropertyViewBase {
    /* 0x02a8 */ FName PropertyName;
    /* 0x02b8 */ FText NameOverride;

    FName GetPropertyName() const;
    void SetPropertyName(FName NewPropertyName);
};

// Size: 0x88
class USlateVectorArtDataFactory : public UFactory {
};

// Size: 0x108
class UUMGEditorProjectSettings : public UDeveloperSettings {
    /* 0x0060 */ FWidgetCompilerOptions DefaultCompilerOptions;
    /* 0x0078 */ TArray<FDirectoryWidgetCompilerOptions> DirectoryCompilerOptions;
    /* 0x0088 */ bool bShowWidgetsFromEngineContent;
    /* 0x0089 */ bool bShowWidgetsFromDeveloperContent;
    /* 0x0090 */ TArray<FString> CategoriesToHide;
    /* 0x00a0 */ TArray<FSoftClassPath> WidgetClassesToHide;
    /* 0x00b0 */ bool bUseWidgetTemplateSelector;
    /* 0x00b8 */ UClass* DefaultRootWidget;
    /* 0x00c0 */ TSoftClassPtr<UUserWidget> DefaultWidgetParentClass;
    /* 0x00f0 */ TArray<FDebugResolution> DebugResolutions;
    /* 0x0100 */ int32_t Version;
};

// Size: 0x18
struct FWidgetAnimation_DEPRECATED {
    /* 0x0000 */ UMovieScene* MovieScene;
    /* 0x0008 */ TArray<FWidgetAnimationBinding> AnimationBindings;
};

// Size: 0x540
class UWidgetBlueprint : public UBaseWidgetBlueprint {
    /* 0x04e0 */ TArray<FDelegateEditorBinding> Bindings;
    /* 0x04f0 */ TArray<FWidgetAnimation_DEPRECATED> AnimationData;
    /* 0x0500 */ TArray<UWidgetAnimation*> Animations;
    /* 0x0510 */ FString PaletteCategory;
    /* 0x0520 */ EWidgetTickFrequency TickFrequency;
    /* 0x0521 */ EWidgetCompileTimeTickPrediction TickPrediction;
    /* 0x0528 */ FString TickPredictionReason;
    /* 0x0538 */ int32_t PropertyBindings;
};

// Size: 0xa0
class UWidgetBlueprintFactory : public UFactory {
    /* 0x0088 */ uint8_t BlueprintType;
    /* 0x0090 */ UClass* ParentClass;
    /* 0x0098 */ UClass* RootWidgetClass;
};

// Size: 0x18
struct FWidgetCompilerOptions {
    /* 0x0000 */ bool bAllowBlueprintTick;
    /* 0x0001 */ bool bAllowBlueprintPaint;
    /* 0x0002 */ EPropertyBindingPermissionLevel PropertyBindingRule;
    /* 0x0008 */ TArray<TSoftClassPtr<UWidgetCompilerRule>> Rules;
};

// Size: 0x30
class UWidgetCompilerRule : public UObject {
};

// Size: 0x78
class UWidgetDesignerSettings : public UDeveloperSettings {
    /* 0x0060 */ bool GridSnapEnabled;
    /* 0x0064 */ int32_t GridSnapSize;
    /* 0x0068 */ bool bLockToPanelOnDragByDefault;
    /* 0x0069 */ bool bShowOutlines;
    /* 0x006a */ bool bExecutePreConstructEvent;
    /* 0x006b */ bool bRespectLocks;
    /* 0x0070 */ UWidgetPaletteFavorites* Favorites;
};

// Size: 0x40
class UWidgetGraphSchema : public UEdGraphSchema_K2 {
};

// Size: 0x58
class UWidgetPaletteFavorites : public UObject {
    /* 0x0048 */ TArray<FString> Favorites;
};

// Size: 0x60
class UWidgetSlotPair : public UObject {
    /* 0x0030 */ FName WidgetName;
    /* 0x0040 */ TArray<FName> SlotPropertyNames;
    /* 0x0050 */ TArray<FString> SlotPropertyValues;
};

// Size: 0x40
class UMyPluginObject : public UObject {
    /* 0x0030 */ FMyPluginStruct MyStruct;
};

// Size: 0x10
struct FMyPluginStruct {
    /* 0x0000 */ FString TestString;
};

enum class EUdpMessageFormat {
    None = 0,
    Json = 1,
    TaggedProperty = 2,
    CborPlatformEndianness = 3,
    CborStandardEndianness = 4,
    EUdpMessageFormat_MAX = 5,
};

// Size: 0xb0
class UUdpMessagingSettings : public UObject {
    /* 0x0030 */ bool EnabledByDefault;
    /* 0x0031 */ bool EnableTransport;
    /* 0x0032 */ bool bAutoRepair;
    /* 0x0034 */ float MaxSendRate;
    /* 0x0038 */ uint32_t AutoRepairAttemptLimit;
    /* 0x003c */ bool bStopServiceWhenAppDeactivates;
    /* 0x0040 */ FString UnicastEndpoint;
    /* 0x0050 */ FString MulticastEndpoint;
    /* 0x0060 */ EUdpMessageFormat MessageFormat;
    /* 0x0061 */ uint8_t MulticastTimeToLive;
    /* 0x0068 */ TArray<FString> StaticEndpoints;
    /* 0x0078 */ bool EnableTunnel;
    /* 0x0080 */ FString TunnelUnicastEndpoint;
    /* 0x0090 */ FString TunnelMulticastEndpoint;
    /* 0x00a0 */ TArray<FString> RemoteTunnelEndpoints;
};

// Size: 0x10
struct FUdpMockMessage {
    /* 0x0000 */ TArray<uint8_t> Data;
};

// Size: 0x38
class UUndoHistorySettings : public UObject {
    /* 0x0030 */ bool bShowTransactionDetails;
};

// Size: 0x78
class UActorFactory : public UObject {
    /* 0x0030 */ FText DisplayName;
    /* 0x0048 */ int32_t MenuPriority;
    /* 0x0050 */ FString NewActorClassName;
    /* 0x0060 */ UClass* NewActorClass;
    /* 0x0068 */ bool bShowInEditorQuickMenu;
    /* 0x0068 */ bool bUseSurfaceOrientation;
    /* 0x006c */ FVector SpawnPositionOffset;
};

// Size: 0x78
class UActorFactoryAmbientSound : public UActorFactory {
};

// Size: 0x80
class UActorFactoryAnimationAsset : public UActorFactorySkeletalMesh {
};

// Size: 0x78
class UActorFactoryAtmosphericFog : public UActorFactory {
};

// Size: 0x78
class UActorFactoryBasicShape : public UActorFactoryStaticMesh {
};

// Size: 0x78
class UActorFactoryBlueprint : public UActorFactory {
};

// Size: 0x78
class UActorFactoryBoxReflectionCapture : public UActorFactory {
};

// Size: 0x78
class UActorFactoryBoxVolume : public UActorFactoryVolume {
};

// Size: 0x78
class UActorFactoryCameraActor : public UActorFactory {
};

// Size: 0x78
class UActorFactoryCharacter : public UActorFactory {
};

// Size: 0x78
class UActorFactoryClass : public UActorFactory {
};

// Size: 0x78
class UActorFactoryCylinderVolume : public UActorFactoryVolume {
};

// Size: 0x78
class UActorFactoryDeferredDecal : public UActorFactory {
};

// Size: 0x78
class UActorFactoryDirectionalLight : public UActorFactory {
};

// Size: 0x78
class UActorFactoryEmitter : public UActorFactory {
};

// Size: 0x80
class UActorFactoryEmptyActor : public UActorFactory {
    /* 0x0078 */ bool bVisualizeActor;
};

// Size: 0x78
class UActorFactoryExponentialHeightFog : public UActorFactory {
};

// Size: 0x78
class UActorFactoryInteractiveFoliage : public UActorFactoryStaticMesh {
};

// Size: 0x78
class UActorFactoryLevelSequence : public UActorFactory {
};

// Size: 0x78
class UActorFactoryMatineeActor : public UActorFactory {
};

// Size: 0x78
class UActorFactoryNote : public UActorFactory {
};

// Size: 0x80
class UActorFactoryPawn : public UActorFactoryEmptyActor {
};

// Size: 0x78
class UActorFactoryPhysicsAsset : public UActorFactory {
};

// Size: 0x78
class UActorFactoryPlanarReflection : public UActorFactory {
};

// Size: 0x78
class UActorFactoryPlaneReflectionCapture : public UActorFactory {
};

// Size: 0x78
class UActorFactoryPlayerStart : public UActorFactory {
};

// Size: 0x78
class UActorFactoryPointLight : public UActorFactory {
};

// Size: 0x78
class UActorFactoryRectLight : public UActorFactory {
};

// Size: 0x78
class UActorFactoryRuntimeVirtualTextureVolume : public UActorFactory {
};

// Size: 0x80
class UActorFactorySkeletalMesh : public UActorFactory {
};

// Size: 0x78
class UActorFactorySkyAtmosphere : public UActorFactory {
};

// Size: 0x78
class UActorFactorySkyLight : public UActorFactory {
};

// Size: 0x78
class UActorFactorySphereReflectionCapture : public UActorFactory {
};

// Size: 0x78
class UActorFactorySphereVolume : public UActorFactoryVolume {
};

// Size: 0x78
class UActorFactorySpotLight : public UActorFactory {
};

// Size: 0x78
class UActorFactoryStaticMesh : public UActorFactory {
};

// Size: 0x78
class UActorFactoryTargetPoint : public UActorFactory {
};

// Size: 0x78
class UActorFactoryTextRender : public UActorFactory {
};

// Size: 0x78
class UActorFactoryTriggerBox : public UActorFactory {
};

// Size: 0x78
class UActorFactoryTriggerCapsule : public UActorFactory {
};

// Size: 0x78
class UActorFactoryTriggerSphere : public UActorFactory {
};

// Size: 0x78
class UActorFactoryVectorFieldVolume : public UActorFactory {
};

// Size: 0x78
class UActorFactoryVolume : public UActorFactory {
};

// Size: 0x78
class UActorFactoryVolumetricCloud : public UActorFactory {
};

// Size: 0x1
struct FActorFolderProps {
};

// Size: 0x30
class UActorGroupingUtils : public UObject {

    void AddSelectedToGroup();
    static UActorGroupingUtils* Get();
    void GroupActors(const TArray<AActor*>& ActorsToGroup);
    void GroupSelected();
    static bool IsGroupingActive();
    void LockSelectedGroups();
    void RemoveSelectedFromGroup();
    static void SetGroupingActive(bool bInGroupingActive);
    void UngroupActors(const TArray<AActor*>& ActorsToUngroup);
    void UngroupSelected();
    void UnlockSelectedGroups();
};

// Size: 0xa8
class UAimOffsetBlendSpaceFactory1D : public UBlendSpaceFactory1D {
};

// Size: 0xa8
class UAimOffsetBlendSpaceFactoryNew : public UBlendSpaceFactoryNew {
};

// Size: 0x40
class UAnalyticsPrivacySettings : public UObject {
    /* 0x0038 */ bool bSendUsageData;
};

// Size: 0xa8
class UAnimBlueprintFactory : public UFactory {
    /* 0x0088 */ uint8_t BlueprintType;
    /* 0x0090 */ UClass* ParentClass;
    /* 0x0098 */ USkeleton* TargetSkeleton;
    /* 0x00a0 */ USkeletalMesh* PreviewSkeletalMesh;
};

// Size: 0x88
class UAnimBlueprintThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x88
class UAnimBoneCompressionSettingsFactory : public UFactory {
};

// Size: 0xb0
class UAnimCompositeFactory : public UFactory {
    /* 0x0088 */ USkeleton* TargetSkeleton;
    /* 0x0090 */ UAnimSequence* SourceAnimation;
    /* 0x0098 */ USkeletalMesh* PreviewSkeletalMesh;
};

// Size: 0x88
class UAnimCurveCompressionSettingsFactory : public UFactory {
};

// Size: 0xa8
class UAnimLayerInterfaceFactory : public UAnimBlueprintFactory {
};

// Size: 0xb0
class UAnimMontageFactory : public UFactory {
    /* 0x0088 */ USkeleton* TargetSkeleton;
    /* 0x0090 */ UAnimSequence* SourceAnimation;
    /* 0x0098 */ USkeletalMesh* PreviewSkeletalMesh;
};

// Size: 0x38
class UAnimSeqExportOption : public UObject {
    /* 0x0030 */ bool bExportTransforms;
    /* 0x0031 */ bool bExportCurves;
    /* 0x0032 */ bool bRecordInWorldSpace;
    /* 0x0033 */ bool bEvaluateAllSkeletalMeshComponents;
    /* 0x0034 */ FFrameNumber WarmUpFrames;
};

// Size: 0x80
class UAnimSequenceExporterFBX : public UExporterFBX {
};

// Size: 0xa8
class UAnimSequenceFactory : public UFactory {
    /* 0x0088 */ USkeleton* TargetSkeleton;
    /* 0x0090 */ USkeletalMesh* PreviewSkeletalMesh;
};

// Size: 0x40
class UAnimSequenceThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x98
class UAnimStreamableFactory : public UFactory {
    /* 0x0088 */ USkeleton* TargetSkeleton;
    /* 0x0090 */ UAnimSequence* SourceAnimation;
};

// Size: 0x38
class UAnimationBlueprintEditorOptions : public UObject {
    /* 0x0030 */ bool bHideUnrelatedNodes;
};

// Size: 0x380
class AAnimationThumbnailSkeletalMeshActor : public ASkeletalMeshActor {
};

enum class ArrayLabelEnum {
    ArrayIndex0 = 0,
    ArrayIndex1 = 1,
    ArrayIndex2 = 2,
    ArrayIndex3 = 3,
    ArrayIndex4 = 4,
    ArrayIndex5 = 5,
    ArrayIndex_MAX = 6,
    ArrayLabelEnum_MAX = 7,
};

// Size: 0x40
class UAssetEditor : public UObject {
};

// Size: 0x8c
struct FAssetEditorOptions {
    /* 0x0000 */ FName Context;
    /* 0x000c */ FViewportConfigOptions ViewportConfigs[4];
};

// Size: 0x2a8
class UAssetEditorSubsystem : public UEditorSubsystem {
    /* 0x0200 */ TArray<UAssetEditor*> OwnedAssetEditors;

    int32_t CloseAllEditorsForAsset(UObject* Asset);
    bool OpenEditorForAssets(const TArray<UObject*>& Assets);
};

// Size: 0x40
class UAssetEditorToolkitMenuContext : public UObject {
};

// Size: 0x70
class UAssetGuideline : public UAssetUserData {
    /* 0x0030 */ TArray<FString> Plugins;
    /* 0x0040 */ TArray<FIniStringValue> ProjectSettings;
    /* 0x0050 */ FName GuidelineName;
};

// Size: 0x98
class UAssetImportTask : public UObject {
    /* 0x0030 */ FString Filename;
    /* 0x0040 */ FString DestinationPath;
    /* 0x0050 */ FString DestinationName;
    /* 0x0060 */ bool bReplaceExisting;
    /* 0x0061 */ bool bReplaceExistingSettings;
    /* 0x0062 */ bool bAutomated;
    /* 0x0063 */ bool bSave;
    /* 0x0068 */ UFactory* Factory;
    /* 0x0070 */ UObject* Options;
    /* 0x0078 */ TArray<FString> ImportedObjectPaths;
    /* 0x0088 */ TArray<UObject*> Result;
};

// Size: 0x90
class UAssetRegUtilCommandlet : public UCommandlet {
};

// Size: 0x88
class UAssetRegistryDumpCommandlet : public UCommandlet {
};

// Size: 0x88
class UAudioMixerCommandlet : public UCommandlet {
};

// Size: 0x88
class UAudioTestCommandlet : public UCommandlet {
};

// Size: 0x30
struct FAutoReimportDirectoryConfig {
    /* 0x0000 */ FString SourceDirectory;
    /* 0x0010 */ FString MountPoint;
    /* 0x0020 */ TArray<FAutoReimportWildcard> Wildcards;
};

// Size: 0x40
class UAutoReimportManager : public UObject {
};

// Size: 0x18
struct FAutoReimportWildcard {
    /* 0x0000 */ FString wildcard;
    /* 0x0010 */ bool bInclude;
};

// Size: 0xa0
class UAutomatedAssetImportData : public UObject {
    /* 0x0030 */ FString GroupName;
    /* 0x0040 */ TArray<FString> Filenames;
    /* 0x0050 */ FString DestinationPath;
    /* 0x0060 */ FString FactoryName;
    /* 0x0070 */ bool bReplaceExisting;
    /* 0x0071 */ bool bSkipReadOnly;
    /* 0x0078 */ UFactory* Factory;
    /* 0x0080 */ FString LevelToLoad;
};

// Size: 0x4e0
class UBaseWidgetBlueprint : public UBlueprint {
    /* 0x04d8 */ UWidgetTree* WidgetTree;
};

// Size: 0xa8
class UBlendSpaceFactory1D : public UFactory {
    /* 0x0088 */ USkeleton* TargetSkeleton;
    /* 0x0090 */ USkeletalMesh* PreviewSkeletalMesh;
};

// Size: 0xa8
class UBlendSpaceFactoryNew : public UFactory {
    /* 0x0088 */ USkeleton* TargetSkeleton;
    /* 0x0090 */ USkeletalMesh* PreviewSkeletalMesh;
};

// Size: 0x40
class UBlendSpaceThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0xa0
class UBlueprintEditorProjectSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bForceAllDependenciesToRecompile;
    /* 0x0060 */ bool bValidateUnloadedSoftActorReferences;
    /* 0x0060 */ bool bEnableChildActorExpansionInTreeView;
    /* 0x0068 */ TArray<FName> DisabledCompilerMessagesExceptEditor;
    /* 0x0078 */ TArray<FName> DisabledCompilerMessages;
    /* 0x0088 */ TArray<FString> NamespacesToAlwaysInclude;
    /* 0x0098 */ EChildActorComponentTreeViewVisualizationMode DefaultChildActorTreeViewMode;
};

// Size: 0x90
class UBlueprintFactory : public UFactory {
    /* 0x0088 */ UClass* ParentClass;
};

// Size: 0x90
class UBlueprintFunctionLibraryFactory : public UBlueprintFactory {
};

// Size: 0x88
class UBlueprintInterfaceFactory : public UFactory {
};

// Size: 0x90
class UBlueprintMacroFactory : public UBlueprintFactory {
};

// Size: 0x40
class UBlueprintPropertyContainerTestObject : public UObject {
    /* 0x0030 */ TArray<UBlueprintPropertyTestObject*> Array;
};

// Size: 0x38
class UBlueprintPropertyTestObject : public UObject {
    /* 0x0030 */ int32_t ShouldBeHidden;
    /* 0x0034 */ int32_t ShouldBeVisible;
};

// Size: 0x88
class UBlueprintThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x38
class UBrushEditingSubsystem : public UEditorSubsystem {
};

// Size: 0xc0
class UCSVImportFactory : public UFactory {
    /* 0x0098 */ FCSVImportSettings AutomatedImportSettings;
    /* 0x00b8 */ UDataTable* DataTableImportOptions;
};

// Size: 0x20
struct FCSVImportSettings {
    /* 0x0000 */ UScriptStruct* ImportRowStruct;
    /* 0x0008 */ ECSVImportType ImportType;
    /* 0x0009 */ uint8_t ImportCurveInterpMode;
};

// Size: 0x88
class UCameraAnimFactory : public UFactory {
};

// Size: 0x98
class UCanvasRenderTarget2DFactoryNew : public UFactory {
    /* 0x0088 */ int32_t Width;
    /* 0x008c */ int32_t Height;
    /* 0x0090 */ uint8_t Format;
};

// Size: 0x100
class UCascadeOptions : public UObject {
    /* 0x0030 */ bool bShowModuleDump;
    /* 0x0034 */ FColor BackgroundColor;
    /* 0x0038 */ bool bUseSubMenus;
    /* 0x0038 */ bool bUseSpaceBarReset;
    /* 0x0038 */ bool bUseSpaceBarResetInLevel;
    /* 0x003c */ FColor Empty_Background;
    /* 0x0040 */ FColor Emitter_Background;
    /* 0x0044 */ FColor Emitter_Unselected;
    /* 0x0048 */ FColor Emitter_Selected;
    /* 0x004c */ FColor ModuleColor_General_Unselected;
    /* 0x0050 */ FColor ModuleColor_General_Selected;
    /* 0x0054 */ FColor ModuleColor_TypeData_Unselected;
    /* 0x0058 */ FColor ModuleColor_TypeData_Selected;
    /* 0x005c */ FColor ModuleColor_Beam_Unselected;
    /* 0x0060 */ FColor ModuleColor_Beam_Selected;
    /* 0x0064 */ FColor ModuleColor_Trail_Unselected;
    /* 0x0068 */ FColor ModuleColor_Trail_Selected;
    /* 0x006c */ FColor ModuleColor_Spawn_Unselected;
    /* 0x0070 */ FColor ModuleColor_Spawn_Selected;
    /* 0x0074 */ FColor ModuleColor_Light_Unselected;
    /* 0x0078 */ FColor ModuleColor_Light_Selected;
    /* 0x007c */ FColor ModuleColor_SubUV_Unselected;
    /* 0x0080 */ FColor ModuleColor_SubUV_Selected;
    /* 0x0084 */ FColor ModuleColor_Required_Unselected;
    /* 0x0088 */ FColor ModuleColor_Required_Selected;
    /* 0x008c */ FColor ModuleColor_Event_Unselected;
    /* 0x0090 */ FColor ModuleColor_Event_Selected;
    /* 0x0094 */ bool bShowGrid;
    /* 0x0098 */ FColor GridColor_Hi;
    /* 0x009c */ FColor GridColor_Low;
    /* 0x00a0 */ float GridPerspectiveSize;
    /* 0x00a4 */ bool bShowParticleCounts;
    /* 0x00a4 */ bool bShowParticleEvents;
    /* 0x00a4 */ bool bShowParticleTimes;
    /* 0x00a4 */ bool bShowParticleDistance;
    /* 0x00a4 */ bool bShowParticleMemory;
    /* 0x00a8 */ float ParticleMemoryUpdateTime;
    /* 0x00ac */ bool bShowFloor;
    /* 0x00b0 */ FString FloorMesh;
    /* 0x00c0 */ FVector FloorPosition;
    /* 0x00cc */ FRotator FloorRotation;
    /* 0x00d8 */ float FloorScale;
    /* 0x00dc */ FVector FloorScale3D;
    /* 0x00e8 */ int32_t ShowPPFlags;
    /* 0x00ec */ bool bUseSlimCascadeDraw;
    /* 0x00f0 */ int32_t SlimCascadeDrawHeight;
    /* 0x00f4 */ bool bCenterCascadeModuleText;
    /* 0x00f8 */ int32_t Cascade_MouseMoveThreshold;
    /* 0x00fc */ float MotionModeRadius;
};

// Size: 0x88
class UChaosPhysicalMaterialFactory : public UFactory {
};

// Size: 0x8
struct FChunkDependency {
    /* 0x0000 */ int32_t ChunkID;
    /* 0x0004 */ int32_t ParentChunkID;
};

// Size: 0xb0
class UChunkDependencyInfo : public UObject {
    /* 0x0030 */ TArray<FChunkDependency> DependencyArray;
};

// Size: 0x38
struct FClassMoveInfo {
    /* 0x0000 */ FString ClassName;
    /* 0x0010 */ FString PackageName;
    /* 0x0020 */ FString GroupName;
    /* 0x0030 */ bool bActive;
};

// Size: 0x20
struct FClassPickerDefaults {
    /* 0x0000 */ FString ClassName;
    /* 0x0010 */ FString AssetClass;
};

// Size: 0x88
class UClassThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x48
class UClassViewerSettings : public UObject {
    /* 0x0030 */ TArray<FString> AllowedClasses;
    /* 0x0040 */ bool DisplayInternalClasses;
    /* 0x0041 */ EClassViewerDeveloperType DeveloperFolderType;
};

// Size: 0x40
class UCommonResolutionMenuContext : public UToolMenuContextBase {
};

// Size: 0x110
class UCompileAllBlueprintsCommandlet : public UCommandlet {
};

// Size: 0x4
struct FComponentMaskParameter {
    /* 0x0000 */ bool R;
    /* 0x0000 */ bool G;
    /* 0x0000 */ bool B;
    /* 0x0000 */ bool A;
};

// Size: 0x20
struct FComponentPropertyPath {
    /* 0x0000 */ TWeakObjectPtr<AActor> ParentOwningActor;
    /* 0x0008 */ TWeakObjectPtr<UActorComponent> LastResortComponentPtr;
    /* 0x0010 */ TArray<FPropertyNameAndIndex> PropertyChain;
};

// Size: 0x88
class UCompositeCurveTableFactory : public UFactory {
};

// Size: 0x90
class UCompositeDataTableFactory : public UDataTableFactory {
};

// Size: 0x88
class UCompressAnimationsCommandlet : public UCommandlet {
};

// Size: 0xb0
class UConeBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ float Z;
    /* 0x008c */ float CapZ;
    /* 0x0090 */ float OuterRadius;
    /* 0x0094 */ float InnerRadius;
    /* 0x0098 */ int32_t Sides;
    /* 0x009c */ FName GroupName;
    /* 0x00a8 */ bool AlignToSide;
    /* 0x00a8 */ bool Hollow;
};

// Size: 0x50
class UContentBrowserSettings : public UObject {
    /* 0x0030 */ int32_t NumObjectsToLoadBeforeWarning;
    /* 0x0034 */ bool bOpenSourcesPanelByDefault;
    /* 0x0035 */ bool RealTimeThumbnails;
    /* 0x0036 */ bool DisplayFolders;
    /* 0x0037 */ bool DisplayEmptyFolders;
    /* 0x0038 */ bool FilterRecursively;
    /* 0x0039 */ bool ShowAllFolder;
    /* 0x003a */ bool OrganizeFolders;
    /* 0x003c */ int32_t NumObjectsInRecentList;
    /* 0x0040 */ bool bShowFullCollectionNameInToolTip;
    /* 0x0041 */ bool bEnableRealtimeMaterialInstanceThumbnails;
    /* 0x0042 */ bool DisplayEngineFolder;
    /* 0x0044 */ bool DisplayDevelopersFolder;
    /* 0x0045 */ bool DisplayL10NFolder;
    /* 0x0047 */ bool DisplayPluginFolders;
    /* 0x0049 */ bool DisplayFavorites;
    /* 0x004a */ bool DockCollections;
    /* 0x004b */ bool DisplayCppFolders;
    /* 0x004c */ bool IncludeClassNames;
    /* 0x004d */ bool IncludeAssetPaths;
    /* 0x004e */ bool IncludeCollectionNames;
};

// Size: 0x90
class UConvertLevelsToExternalActorsCommandlet : public UCommandlet {
};

// Size: 0xd8
class UCookCommandlet : public UCommandlet {
    /* 0x0088 */ TArray<FString> FullGCAssetClassNames;
};

// Size: 0x88
class UCookGlobalShadersCommandlet : public UCommandlet {
};

// Size: 0x30
class UCookGlobalShadersDeviceHelperBase : public UObject {
};

// Size: 0x40
class UCookGlobalShadersDeviceHelperStaged : public UCookGlobalShadersDeviceHelperBase {
};

// Size: 0x3d0
class UCookOnTheFlyServer : public UObject {
};

// Size: 0xe0
class UCookerSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bEnableCookOnTheSide;
    /* 0x0061 */ bool bEnableBuildDDCInBackground;
    /* 0x0062 */ bool bIterativeCookingForLaunchOn;
    /* 0x0063 */ bool bIterativeCookingForFileCookContent;
    /* 0x0064 */ bool bCookOnTheFlyForLaunchOn;
    /* 0x0068 */ ECookProgressDisplayMode CookProgressDisplayMode;
    /* 0x006c */ bool bIgnoreIniSettingsOutOfDateForIteration;
    /* 0x006d */ bool bIgnoreScriptPackagesOutOfDateForIteration;
    /* 0x006e */ bool bCompileBlueprintsInDevelopmentMode;
    /* 0x0070 */ EBlueprintComponentDataCookingMethod BlueprintComponentDataCookingMethod;
    /* 0x0078 */ TArray<FString> ClassesExcludedOnDedicatedServer;
    /* 0x0088 */ TArray<FString> ModulesExcludedOnDedicatedServer;
    /* 0x0098 */ TArray<FString> ClassesExcludedOnDedicatedClient;
    /* 0x00a8 */ TArray<FString> ModulesExcludedOnDedicatedClient;
    /* 0x00b8 */ TArray<FString> VersionedIntRValues;
    /* 0x00c8 */ int32_t DefaultPVRTCQuality;
    /* 0x00cc */ int32_t DefaultASTCQualityBySpeed;
    /* 0x00d0 */ int32_t DefaultASTCQualityBySize;
    /* 0x00d4 */ bool bAllowCookedDataInEditorBuilds;
    /* 0x00d8 */ bool bCookBlueprintComponentTemplateData;
};

// Size: 0x20
struct FCopySelectedInfo {
};

// Size: 0x60
class UCrashReporterSettings : public UObject {
    /* 0x0030 */ FString UploadSymbolsPath;
    /* 0x0040 */ FString DownstreamStorage;
    /* 0x0050 */ TArray<FString> RemoteStorage;
};

// Size: 0x40
class UCrashReportsPrivacySettings : public UObject {
    /* 0x0038 */ bool bSendUnattendedBugReports;
};

// Size: 0xa8
class UCubeBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ float X;
    /* 0x008c */ float Y;
    /* 0x0090 */ float Z;
    /* 0x0094 */ float WallThickness;
    /* 0x0098 */ FName GroupName;
    /* 0x00a4 */ bool Hollow;
    /* 0x00a4 */ bool Tessellated;
};

// Size: 0xa8
class UCurveEdOptions : public UObject {
    /* 0x0030 */ float MinViewRange;
    /* 0x0034 */ float MaxViewRange;
    /* 0x0038 */ FLinearColor BackgroundColor;
    /* 0x0048 */ FLinearColor LabelColor;
    /* 0x0058 */ FLinearColor SelectedLabelColor;
    /* 0x0068 */ FLinearColor GridColor;
    /* 0x0078 */ FLinearColor GridTextColor;
    /* 0x0088 */ FLinearColor LabelBlockBkgColor;
    /* 0x0098 */ FLinearColor SelectedKeyColor;
};

// Size: 0x90
class UCurveFactory : public UFactory {
    /* 0x0088 */ UClass* CurveClass;
};

// Size: 0x90
class UCurveFloatFactory : public UCurveFactory {
};

// Size: 0x88
class UCurveImportFactory : public UFactory {
};

// Size: 0x98
class UCurveLinearColorAtlasFactory : public UFactory {
    /* 0x0088 */ int32_t Width;
    /* 0x008c */ int32_t Height;
    /* 0x0090 */ uint8_t Format;
};

// Size: 0x90
class UCurveLinearColorFactory : public UCurveFactory {
};

// Size: 0x30
class UCurveLinearColorThumbnailRenderer : public UThumbnailRenderer {
};

// Size: 0x90
class UCurveVectorFactory : public UCurveFactory {
};

// Size: 0xb0
class UCurvedStairBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ int32_t InnerRadius;
    /* 0x008c */ int32_t StepHeight;
    /* 0x0090 */ int32_t StepWidth;
    /* 0x0094 */ int32_t AngleOfCurve;
    /* 0x0098 */ int32_t NumSteps;
    /* 0x009c */ int32_t AddToFirstStep;
    /* 0x00a0 */ FName GroupName;
    /* 0x00ac */ bool CounterClockwise;
};

// Size: 0xa8
class UCylinderBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ float Z;
    /* 0x008c */ float OuterRadius;
    /* 0x0090 */ float InnerRadius;
    /* 0x0094 */ int32_t Sides;
    /* 0x0098 */ FName GroupName;
    /* 0x00a4 */ bool AlignToSide;
    /* 0x00a4 */ bool Hollow;
};

// Size: 0x4
struct FDComponentMaskParameter {
    /* 0x0000 */ bool R;
    /* 0x0000 */ bool G;
    /* 0x0000 */ bool B;
    /* 0x0000 */ bool A;
};

// Size: 0x88
class UDDCCleanupCommandlet : public UCommandlet {
};

// Size: 0x68
class UDDCProjectSettings : public UDeveloperSettings {
    /* 0x0060 */ bool RecommendEveryoneSetupAGlobalLocalDDCPath;
    /* 0x0061 */ bool RecommendEveryoneSetupAGlobalS3DDCPath;
};

// Size: 0x70
class UDEditorFontParameterValue : public UDEditorParameterValue {
    /* 0x0060 */ FDFontParameters ParameterValue;
};

// Size: 0x100
class UDEditorMaterialLayersParameterValue : public UDEditorParameterValue {
    /* 0x0060 */ FMaterialLayersFunctions ParameterValue;
};

// Size: 0x60
class UDEditorParameterValue : public UObject {
    /* 0x0030 */ bool bOverride;
    /* 0x0034 */ FMaterialParameterInfo ParameterInfo;
    /* 0x0048 */ FGuid ExpressionId;
    /* 0x0058 */ int32_t SortPriority;
};

// Size: 0x68
class UDEditorRuntimeVirtualTextureParameterValue : public UDEditorParameterValue {
    /* 0x0060 */ URuntimeVirtualTexture* ParameterValue;
};

// Size: 0xd8
class UDEditorScalarParameterValue : public UDEditorParameterValue {
    /* 0x0060 */ float ParameterValue;
    /* 0x0070 */ FScalarParameterAtlasData AtlasData;
};

// Size: 0x68
class UDEditorStaticComponentMaskParameterValue : public UDEditorParameterValue {
    /* 0x0060 */ FDComponentMaskParameter ParameterValue;
};

// Size: 0x68
class UDEditorStaticSwitchParameterValue : public UDEditorParameterValue {
    /* 0x0060 */ bool ParameterValue;
};

// Size: 0xc8
class UDEditorTextureParameterValue : public UDEditorParameterValue {
    /* 0x0060 */ UTexture* ParameterValue;
    /* 0x0068 */ FParameterChannelNames ChannelNames;
};

// Size: 0xd8
class UDEditorVectorParameterValue : public UDEditorParameterValue {
    /* 0x0060 */ FLinearColor ParameterValue;
    /* 0x0070 */ bool bIsUsedAsChannelMask;
    /* 0x0078 */ FParameterChannelNames ChannelNames;
};

// Size: 0x10
struct FDFontParameters {
    /* 0x0000 */ UFont* FontValue;
    /* 0x0008 */ int32_t FontPage;
};

// Size: 0x90
class UDataAssetFactory : public UFactory {
    /* 0x0088 */ UClass* DataAssetClass;
};

// Size: 0x90
class UDataTableFactory : public UFactory {
    /* 0x0088 */ UScriptStruct* struct;
};

// Size: 0x1170
class UDebugSkelMeshComponent : public USkeletalMeshComponent {
    /* 0x1030 */ bool bRenderRawSkeleton;
    /* 0x1030 */ bool bDrawMesh;
    /* 0x1030 */ bool bShowBoneNames;
    /* 0x1030 */ bool bDrawBoneInfluences;
    /* 0x1030 */ bool bDrawMorphTargetVerts;
    /* 0x1030 */ bool bDrawNormals;
    /* 0x1030 */ bool bDrawTangents;
    /* 0x1030 */ bool bDrawBinormals;
    /* 0x1031 */ bool bDrawSockets;
    /* 0x1031 */ bool bSkeletonSocketsVisible;
    /* 0x1031 */ bool bMeshSocketsVisible;
    /* 0x1031 */ bool bDisplayRawAnimation;
    /* 0x1031 */ bool bDisplayNonRetargetedPose;
    /* 0x1031 */ bool bDisplayAdditiveBasePose;
    /* 0x1031 */ bool bDisplayBakedAnimation;
    /* 0x1031 */ bool bDisplaySourceAnimation;
    /* 0x1034 */ bool bDisplayBound;
    /* 0x1035 */ bool bDisplayVertexColors;
    /* 0x1038 */ bool bPreviewRootMotion;
    /* 0x1038 */ bool bShowClothData;
    /* 0x103c */ float MinClothPropertyView;
    /* 0x1040 */ float MaxClothPropertyView;
    /* 0x1044 */ float ClothMeshOpacity;
    /* 0x1048 */ bool bClothFlipNormal;
    /* 0x1049 */ bool bClothCullBackface;
    /* 0x104c */ bool bRequiredBonesUpToDateDuringTick;
    /* 0x10c0 */ TArray<int32_t> BonesOfInterest;
    /* 0x10d0 */ TArray<UMorphTarget*> MorphTargetOfInterests;
    /* 0x10e0 */ TArray<UMaterialInterface*> SkelMaterials;
    /* 0x10f0 */ UAnimPreviewInstance* PreviewInstance;
    /* 0x10f8 */ UAnimInstance* SavedAnimScriptInstance;
    /* 0x1100 */ bool bIsUsingInGameBounds;
    /* 0x1101 */ bool bIsUsingPreSkinnedBounds;
    /* 0x1102 */ bool bPerformSingleClothingTick;
    /* 0x1103 */ bool bPauseClothingSimulationWithAnim;
};

// Size: 0x38
class UDefaultSizedThumbnailRenderer : public UThumbnailRenderer {
    /* 0x0030 */ int32_t DefaultSizeX;
    /* 0x0034 */ int32_t DefaultSizeY;
};

// Size: 0x198
class UDerivedDataCacheCommandlet : public UCommandlet {
};

// Size: 0xa8
struct FDialogueScriptEntry {
    /* 0x0000 */ FString SpeakingVoice;
    /* 0x0010 */ TArray<FString> TargetVoices;
    /* 0x0020 */ FString SpokenDialogue;
    /* 0x0030 */ FString VoiceActorDirection;
    /* 0x0040 */ FString AudioFileName;
    /* 0x0050 */ FString DialogueAsset;
    /* 0x0060 */ bool IsRecorded;
    /* 0x0068 */ TArray<FString> LocalizationKeys;
    /* 0x0078 */ FString SpeakingVoiceGUID;
    /* 0x0088 */ TArray<FString> TargetVoiceGUIDs;
    /* 0x0098 */ FString DialogueAssetGUID;
};

// Size: 0x9b8
class UDiffAssetRegistriesCommandlet : public UCommandlet {
    /* 0x0948 */ TArray<FString> AssetRegistrySearchPath;
    /* 0x0958 */ FString P4Repository;
    /* 0x0968 */ FString P4EngineBasePath;
    /* 0x0978 */ FString P4EngineAssetPath;
    /* 0x0988 */ FString P4GameBasePath;
    /* 0x0998 */ FString P4GameAssetPath;
    /* 0x09a8 */ FString RegexBranchCL;
};

// Size: 0x88
class UDiffAssetsCommandlet : public UCommandlet {
};

// Size: 0x128
class UDiffFilesCommandlet : public UCommandlet {
};

// Size: 0x170
class UDiffPackagesCommandlet : public UCommandlet {
    /* 0x0088 */ UPackage* Packages[3];
};

// Size: 0x88
class UDumpBlueprintsInfoCommandlet : public UCommandlet {
};

// Size: 0x88
class UDumpHiddenCategoriesCommandlet : public UCommandlet {
};

enum class EAnimationViewportCameraFollowMode {
    None = 0,
    Bounds = 1,
    Bone = 2,
    EAnimationViewportCameraFollowMode_MAX = 3,
};

enum class EBlueprintComponentDataCookingMethod {
    Disabled = 0,
    AllBlueprints = 1,
    EnabledBlueprintsOnly = 2,
    EBlueprintComponentDataCookingMethod_MAX = 3,
};

enum class ECSVImportType {
    ECSV_DataTable = 0,
    ECSV_CurveTable = 1,
    ECSV_CurveFloat = 2,
    ECSV_CurveVector = 3,
    ECSV_CurveLinearColor = 4,
    ECSV_MAX = 5,
};

enum class EClassViewerDeveloperType {
    CVDT_None = 0,
    CVDT_CurrentUser = 1,
    CVDT_All = 2,
    CVDT_Max = 3,
    CVDT_Max = 4,
};

enum class ECommentBoxMode {
    GroupMovement = 0,
    NoGroupMovement = 1,
    ECommentBoxMode_MAX = 2,
};

enum class ECookMode {
    CookOnTheFly = 0,
    CookOnTheFlyFromTheEditor = 1,
    CookByTheBookFromTheEditor = 2,
    CookByTheBook = 3,
    ECookMode_MAX = 4,
};

enum class ECookProgressDisplayMode {
    Nothing = 0,
    RemainingPackages = 1,
    PackageNames = 2,
    NamesAndRemainingPackages = 3,
    Max = 4,
    ECookProgressDisplayMode_MAX = 5,
};

enum class ECookTickFlags {
    None = 0,
    MarkupInUsePackages = 1,
    HideProgressDisplay = 2,
    ECookTickFlags_MAX = 3,
};

enum class EDefaultLocationUnit {
    Micrometers = 0,
    Millimeters = 1,
    Centimeters = 2,
    Meters = 3,
    Kilometers = 4,
    Inches = 5,
    Feet = 6,
    Yards = 7,
    Miles = 8,
    Invalid = 9,
    EDefaultLocationUnit_MAX = 10,
};

enum class EFBXAnimationLengthImportType {
    FBXALIT_ExportedTime = 0,
    FBXALIT_AnimatedKey = 1,
    FBXALIT_SetRange = 2,
    FBXALIT_MAX = 3,
};

enum class EFBXExpectedResultPreset {
    Error_Number = 0,
    Warning_Number = 1,
    Created_Staticmesh_Number = 2,
    Created_Skeletalmesh_Number = 3,
    Materials_Created_Number = 4,
    Material_Slot_Imported_Name = 5,
    Vertex_Number = 6,
    Lod_Number = 7,
    Vertex_Number_Lod = 8,
    Mesh_Materials_Number = 9,
    Mesh_LOD_Section_Number = 10,
    Mesh_LOD_Section_Vertex_Number = 11,
    Mesh_LOD_Section_Triangle_Number = 12,
    Mesh_LOD_Section_Material_Name = 13,
    Mesh_LOD_Section_Material_Index = 14,
    Mesh_LOD_Section_Material_Imported_Name = 15,
    Mesh_LOD_Vertex_Position = 16,
    Mesh_LOD_Vertex_Normal = 17,
    LOD_UV_Channel_Number = 18,
    Bone_Number = 19,
    Bone_Position = 20,
    Animation_Frame_Number = 21,
    Animation_Length = 22,
    Animation_CustomCurve_KeyValue = 23,
    Animation_CustomCurve_KeyArriveTangent = 24,
    Animation_CustomCurve_KeyLeaveTangent = 25,
    Skin_By_Bone_Vertex_Number = 26,
    EFBXExpectedResultPreset_MAX = 27,
};

enum class EFBXImportContentType {
    FBXICT_All = 0,
    FBXICT_Geometry = 1,
    FBXICT_SkinningWeights = 2,
    FBXICT_MAX = 3,
};

enum class EFBXImportType {
    FBXIT_StaticMesh = 0,
    FBXIT_SkeletalMesh = 1,
    FBXIT_Animation = 2,
    FBXIT_MAX = 3,
};

enum class EFBXNormalGenerationMethod {
    BuiltIn = 0,
    MikkTSpace = 1,
    EFBXNormalGenerationMethod_MAX = 2,
};

enum class EFBXNormalImportMethod {
    FBXNIM_ComputeNormals = 0,
    FBXNIM_ImportNormals = 1,
    FBXNIM_ImportNormalsAndTangents = 2,
    FBXNIM_MAX = 3,
};

enum class EFBXSceneNormalGenerationMethod {
    BuiltIn = 0,
    MikkTSpace = 1,
    EFBXSceneNormalGenerationMethod_MAX = 2,
};

enum class EFBXSceneNormalImportMethod {
    FBXSceneNIM_ComputeNormals = 0,
    FBXSceneNIM_ImportNormals = 1,
    FBXSceneNIM_ImportNormalsAndTangents = 2,
    FBXSceneNIM_MAX = 3,
};

enum class EFBXSceneOptionsCreateHierarchyType {
    FBXSOCHT_CreateLevelActors = 0,
    FBXSOCHT_CreateActorComponents = 1,
    FBXSOCHT_CreateBlueprint = 2,
    FBXSOCHT_MAX = 3,
};

enum class EFBXTestPlanActionType {
    Import = 0,
    Reimport = 1,
    AddLOD = 2,
    ReimportLOD = 3,
    ImportReload = 4,
    AddAlternateSkinnig = 5,
    EFBXTestPlanActionType_MAX = 6,
};

enum class EFbxExportCompatibility {
    FBX_2011 = 0,
    FBX_2012 = 1,
    FBX_2013 = 2,
    FBX_2014 = 3,
    FBX_2016 = 4,
    FBX_2018 = 5,
    FBX_2019 = 6,
    FBX_2020 = 7,
    FBX_MAX = 8,
};

enum class EFbxSceneReimportStatusFlags {
    None = 0,
    Added = 1,
    Removed = 2,
    Same = 4,
    FoundContentBrowserAsset = 8,
    ReimportAsset = 16,
    EFbxSceneReimportStatusFlags_MAX = 17,
};

enum class EFbxSceneVertexColorImportOption {
    Replace = 0,
    Ignore = 1,
    Override = 2,
    EFbxSceneVertexColorImportOption_MAX = 3,
};

enum class ELabelAnchorMode {
    LabelAnchorMode_TopLeft = 0,
    LabelAnchorMode_TopCenter = 1,
    LabelAnchorMode_TopRight = 2,
    LabelAnchorMode_CenterLeft = 3,
    LabelAnchorMode_Centered = 4,
    LabelAnchorMode_CenterRight = 5,
    LabelAnchorMode_BottomLeft = 6,
    LabelAnchorMode_BottomCenter = 7,
    LabelAnchorMode_BottomRight = 8,
    LabelAnchorMode_MAX = 9,
};

enum class ELandscapeFoliageEditorControlType {
    IgnoreCtrl = 0,
    RequireCtrl = 1,
    RequireNoCtrl = 2,
    ELandscapeFoliageEditorControlType_MAX = 3,
};

enum class ELaunchModeType {
    LaunchMode_OnDevice = 0,
    LaunchMode_MAX = 1,
};

enum class ELevelEditor2DAxis {
    X = 0,
    Y = 1,
    Z = 2,
    ELevelEditor2DAxis_MAX = 3,
};

enum class ELevelViewportType {
    LVT_OrthoXY = 0,
    LVT_OrthoXZ = 1,
    LVT_OrthoYZ = 2,
    LVT_Perspective = 3,
    LVT_OrthoFreelook = 4,
    LVT_OrthoNegativeXY = 5,
    LVT_OrthoNegativeXZ = 6,
    LVT_OrthoNegativeYZ = 7,
    LVT_MAX = 8,
    LVT_None = 255,
};

enum class ELevelVisibilityDirtyMode {
    ModifyOnChange = 0,
    DontModify = 1,
    ELevelVisibilityDirtyMode_MAX = 2,
};

enum class ELoadLevelAtStartup {
    None = 0,
    ProjectDefault = 1,
    LastOpened = 2,
    ELoadLevelAtStartup_MAX = 3,
};

enum class EMapSetBrushFlags {
    MSB_BrushColor = 1,
    MSB_Group = 2,
    MSB_PolyFlags = 4,
    MSB_BrushType = 8,
    MSB_MAX = 9,
};

enum class EMaterialSearchLocation {
    Local = 0,
    UnderParent = 1,
    UnderRoot = 2,
    AllAssets = 3,
    DoNotSearch = 4,
    EMaterialSearchLocation_MAX = 5,
};

enum class EMeasuringToolUnits {
    MeasureUnits_Centimeters = 0,
    MeasureUnits_Meters = 1,
    MeasureUnits_Kilometers = 2,
    MeasureUnits_MAX = 3,
};

enum class EOrthoThumbnailDirection {
    Top = 0,
    Bottom = 1,
    Left = 2,
    Right = 3,
    Front = 4,
    Back = 5,
    EOrthoThumbnailDirection_MAX = 6,
};

enum class EPackageNotifyState {
    NS_Updating = 0,
    NS_BalloonPrompted = 1,
    NS_DialogPrompted = 2,
    NS_PendingPrompt = 3,
    NS_PendingWarning = 4,
    NS_MAX = 5,
};

enum class EPasteTo {
    PT_OriginalLocation = 0,
    PT_Here = 1,
    PT_WorldOrigin = 2,
    PT_MAX = 3,
};

enum class EPhysAssetFitGeomType {
    EFG_Box = 0,
    EFG_Sphyl = 1,
    EFG_Sphere = 2,
    EFG_TaperedCapsule = 3,
    EFG_SingleConvexHull = 4,
    EFG_MultiConvexHull = 5,
    EFG_MAX = 6,
};

enum class EPhysAssetFitVertWeight {
    EVW_AnyWeight = 0,
    EVW_DominantWeight = 1,
    EVW_MAX = 2,
};

enum class EPhysicsAssetEditorConstraintViewMode {
    None = 0,
    AllPositions = 1,
    AllLimits = 2,
    EPhysicsAssetEditorConstraintViewMode_MAX = 3,
};

enum class EPhysicsAssetEditorRenderMode {
    Solid = 0,
    Wireframe = 1,
    None = 2,
    EPhysicsAssetEditorRenderMode_MAX = 3,
};

enum class EPlayModeLocations {
    PlayLocation_CurrentCameraLocation = 0,
    PlayLocation_DefaultPlayerStart = 1,
    PlayLocation_MAX = 2,
};

enum class EPlayModeType {
    PlayMode_InViewPort = 0,
    PlayMode_InEditorFloating = 1,
    PlayMode_InMobilePreview = 2,
    PlayMode_InTargetedMobilePreview = 3,
    PlayMode_InVulkanPreview = 4,
    PlayMode_InNewProcess = 5,
    PlayMode_InVR = 6,
    PlayMode_Simulate = 7,
    PlayMode_Count = 8,
    PlayMode_MAX = 9,
};

enum class EPlayNetMode {
    PIE_Standalone = 0,
    PIE_ListenServer = 1,
    PIE_Client = 2,
    PIE_MAX = 3,
};

enum class EPlayOnBuildMode {
    PlayOnBuild_Always = 0,
    PlayOnBuild_Never = 1,
    PlayOnBuild_Default = 2,
    PlayOnBuild_IfEditorBuiltLocally = 3,
    PlayOnBuild_MAX = 4,
};

enum class EPlayOnLaunchConfiguration {
    LaunchConfig_Default = 0,
    LaunchConfig_Debug = 1,
    LaunchConfig_Development = 2,
    LaunchConfig_Test = 3,
    LaunchConfig_Shipping = 4,
    LaunchConfig_MAX = 5,
};

enum class EPlayOnPakFileMode {
    NoPak = 0,
    PakNoCompress = 1,
    PakCompress = 2,
    EPlayOnPakFileMode_MAX = 3,
};

enum class EProjectPackagingBlueprintNativizationMethod {
    Disabled = 0,
    Inclusive = 1,
    Exclusive = 2,
    EProjectPackagingBlueprintNativizationMethod_MAX = 3,
};

enum class EProjectPackagingBuild {
    Always = 0,
    Never = 1,
    IfProjectHasCode = 2,
    IfEditorWasBuiltLocally = 3,
    EProjectPackagingBuild_MAX = 4,
};

enum class EProjectPackagingBuildConfigurations {
    PPBC_Debug = 0,
    PPBC_DebugGame = 1,
    PPBC_Development = 2,
    PPBC_Test = 3,
    PPBC_Shipping = 4,
    PPBC_MAX = 5,
};

enum class EProjectPackagingInternationalizationPresets {
    English = 0,
    EFIGS = 1,
    EFIGSCJK = 2,
    CJK = 3,
    All = 4,
    EProjectPackagingInternationalizationPresets_MAX = 5,
};

enum class EPropertyAccessBatchType {
    Unbatched = 0,
    Batched = 1,
    EPropertyAccessBatchType_MAX = 2,
};

enum class EReloadPackagesInteractionMode {
    Interactive = 0,
    AssumePositive = 1,
    AssumeNegative = 2,
    EReloadPackagesInteractionMode_MAX = 3,
};

enum class ERotationGridMode {
    GridMode_DivisionsOf360 = 0,
    GridMode_Common = 1,
    GridMode_MAX = 2,
};

enum class EScrollGestureDirection {
    UseSystemSetting = 0,
    Standard = 1,
    Natural = 2,
    EScrollGestureDirection_MAX = 3,
};

enum class ESheetAxis {
    AX_Horizontal = 0,
    AX_XAxis = 1,
    AX_YAxis = 2,
    AX_MAX = 3,
};

enum class EStructViewerDeveloperType {
    SVDT_None = 0,
    SVDT_CurrentUser = 1,
    SVDT_All = 2,
    SVDT_Max = 3,
    SVDT_Max = 4,
};

enum class ETestEnumFlags {
    None = 0,
    One = 1,
    Two = 2,
    Four = 4,
    ETestEnumFlags_MAX = 5,
};

enum class ETexAlign {
    TEXALIGN_None = 0,
    TEXALIGN_Default = 1,
    TEXALIGN_Box = 2,
    TEXALIGN_Planar = 3,
    TEXALIGN_Fit = 4,
    TEXALIGN_PlanarAuto = 5,
    TEXALIGN_PlanarWall = 6,
    TEXALIGN_PlanarFloor = 7,
    TEXALIGN_MAX = 8,
};

enum class ETextAssetCommandletMode {
    ResaveText = 0,
    ResaveBinary = 1,
    RoundTrip = 2,
    LoadBinary = 3,
    LoadText = 4,
    FindMismatchedSerializers = 5,
    GenerateSchema = 6,
    ETextAssetCommandletMode_MAX = 7,
};

enum class ETextureSourceColorSpace {
    Auto = 0,
    Linear = 1,
    SRGB = 2,
    ETextureSourceColorSpace_MAX = 3,
};

enum class EThumbnailPrimType {
    TPT_None = 0,
    TPT_Sphere = 1,
    TPT_Cube = 2,
    TPT_Plane = 3,
    TPT_Cylinder = 4,
    TPT_MAX = 5,
};

enum class EUnitDisplay {
    None = 0,
    Metric = 1,
    Imperial = 2,
    Invalid = 3,
    EUnitDisplay_MAX = 4,
};

enum class EVertexColorImportOption {
    Replace = 0,
    Ignore = 1,
    Override = 2,
    EVertexColorImportOption_MAX = 3,
};

enum class EWASDType {
    WASD_Always = 0,
    WASD_RMBOnly = 1,
    WASD_Never = 2,
    WASD_MAX = 3,
};

// Size: 0x118
class UEdGraphNode_Comment : public UEdGraphNode {
    /* 0x00c8 */ FLinearColor CommentColor;
    /* 0x00d8 */ int32_t FontSize;
    /* 0x00dc */ bool bCommentBubbleVisible_InDetailsPanel;
    /* 0x00dc */ bool bColorCommentBubble;
    /* 0x00e0 */ uint8_t MoveMode;
    /* 0x00e4 */ int32_t CommentDepth;
};

// Size: 0x188
class UEdMode : public UObject {
    /* 0x00f8 */ UEdModeInteractiveToolsContext* ToolsContext;
    /* 0x0140 */ TSoftClassPtr<UObject> SettingsClass;
    /* 0x0170 */ UObject* SettingsObject;
};

enum class EditColor {
    Red = 0,
    Orange = 1,
    Yellow = 2,
    Green = 3,
    Blue = 4,
    Indigo = 5,
    Violet = 6,
    Pink = 7,
    Magenta = 8,
    Cyan = 9,
    EditColor_MAX = 10,
};

// Size: 0x80
class UEditorActorFolders : public UObject {
};

// Size: 0x48
class UEditorAnimBaseObj : public UObject {
};

// Size: 0x70
class UEditorAnimCompositeSegment : public UEditorAnimBaseObj {
    /* 0x0048 */ FAnimSegment AnimSegment;
};

// Size: 0x78
class UEditorAnimCurveBoneLinks : public UObject {
    /* 0x0050 */ FSmartName CurveName;
    /* 0x0060 */ TArray<FBoneReference> ConnectedBones;
    /* 0x0070 */ uint8_t MaxLOD;
};

// Size: 0x70
class UEditorAnimSegment : public UEditorAnimBaseObj {
    /* 0x0048 */ FAnimSegment AnimSegment;
};

// Size: 0x88
class UEditorBrushBuilder : public UBrushBuilder {
};

// Size: 0x38
struct FEditorCommand {
    /* 0x0000 */ FName Parent;
    /* 0x000c */ FName CommandName;
    /* 0x0018 */ FString ExecCommand;
    /* 0x0028 */ FString Description;
};

// Size: 0x18
struct FEditorCommandCategory {
    /* 0x0000 */ FName Parent;
    /* 0x000c */ FName Name;
};

// Size: 0xb0
class UEditorCompositeSection : public UEditorAnimBaseObj {
    /* 0x0048 */ FCompositeSection CompositeSection;
};

// Size: 0x1a50
class UEditorEngine : public UEngine {
    /* 0x1100 */ UModel* TempModel;
    /* 0x1108 */ UModel* ConversionTempModel;
    /* 0x1110 */ UTransactor* Trans;
    /* 0x1118 */ UTexture2D* Bad;
    /* 0x1120 */ UFont* EditorFont;
    /* 0x1128 */ USoundCue* PreviewSoundCue;
    /* 0x1130 */ UAudioComponent* PreviewAudioComponent;
    /* 0x1138 */ UStaticMesh* EditorCube;
    /* 0x1140 */ UStaticMesh* EditorSphere;
    /* 0x1148 */ UStaticMesh* EditorPlane;
    /* 0x1150 */ UStaticMesh* EditorCylinder;
    /* 0x1158 */ bool bFastRebuild;
    /* 0x1158 */ bool IsImportingT3D;
    /* 0x115c */ uint32_t ClickFlags;
    /* 0x1160 */ UPackage* ParentContext;
    /* 0x1168 */ FVector UnsnappedClickLocation;
    /* 0x1174 */ FVector ClickLocation;
    /* 0x1180 */ FPlane ClickPlane;
    /* 0x1190 */ FVector MouseMovement;
    /* 0x119c */ uint8_t DetailMode;
    /* 0x11a0 */ bool UseSizingBox;
    /* 0x11a0 */ bool UseAxisIndicator;
    /* 0x11a0 */ bool GodMode;
    /* 0x11a8 */ FString GameCommandLine;
    /* 0x11b8 */ bool bShowBrushMarkerPolys;
    /* 0x11b8 */ bool bEnableSocketSnapping;
    /* 0x11b8 */ bool bEnableLODLocking;
    /* 0x11c0 */ FString HeightMapExportClassName;
    /* 0x11d0 */ TArray<UActorFactory*> ActorFactories;
    /* 0x11e0 */ FString UserOpenedFile;
    /* 0x11f0 */ FString InEditorGameURLOptions;
    /* 0x1200 */ UWorld* PlayWorld;
    /* 0x1208 */ bool bIsToggleBetweenPIEandSIEQueued;
    /* 0x1208 */ bool bAllowMultiplePIEWorlds;
    /* 0x1208 */ bool bRequestEndPlayMapQueued;
    /* 0x1208 */ bool bSquelchTransactionNotification;
    /* 0x1208 */ bool bNotifyUndoRedoSelectionChange;
    /* 0x1210 */ UClass* PlayFromHerePlayerStartClass;
    /* 0x1218 */ UWorld* EditorWorld;
    /* 0x1220 */ TArray<TWeakObjectPtr<AActor>> ActorsThatWereSelected;
    /* 0x1230 */ int32_t PlayWorldDestination;
    /* 0x1234 */ int32_t CurrentPlayWorldDestination;
    /* 0x1238 */ bool bMobilePreviewPortrait;
    /* 0x123c */ int32_t BuildPlayDevice;
    /* 0x1290 */ FString UserEditedPlayWorldURL;
    /* 0x12a0 */ UTextureRenderTarget2D* ScratchRenderTarget2048;
    /* 0x12a8 */ UTextureRenderTarget2D* ScratchRenderTarget1024;
    /* 0x12b0 */ UTextureRenderTarget2D* ScratchRenderTarget512;
    /* 0x12b8 */ UTextureRenderTarget2D* ScratchRenderTarget256;
    /* 0x12c0 */ UStaticMeshComponent* PreviewMeshComp;
    /* 0x12c8 */ int32_t PreviewMeshIndex;
    /* 0x12cc */ bool bShowPreviewMesh;
    /* 0x12cc */ bool bCustomCameraAlignEmitter;
    /* 0x12d0 */ float CustomCameraAlignEmitterDistance;
    /* 0x12d4 */ bool bDrawSocketsInGMode;
    /* 0x12d4 */ bool bDrawParticleHelpers;
    /* 0x12d8 */ TArray<UBrushBuilder*> BrushBuilders;
    /* 0x1358 */ UEditorWorldExtensionManager* EditorWorldExtensionsManager;
    /* 0x1990 */ FSoftClassPath ActorGroupingUtilsClassName;
    /* 0x19b0 */ UActorGroupingUtils* ActorGroupingUtils;
    /* 0x19d0 */ FVector PlayWorldLocation;
    /* 0x19dc */ FRotator PlayWorldRotation;
    /* 0x19e8 */ bool bIsPlayWorldQueued;
    /* 0x19e8 */ bool bIsSimulateInEditorQueued;
    /* 0x19e8 */ bool bHasPlayWorldPlacement;
    /* 0x19e8 */ bool bUseMobilePreviewForPlayWorld;
    /* 0x19e8 */ bool bUseVRPreviewForPlayWorld;
    /* 0x19e8 */ bool bIsSimulatingInEditor;
    /* 0x1a00 */ int32_t PlayInEditorViewportIndex;
};

// Size: 0x90
class UEditorExperimentalSettings : public UObject {
    /* 0x0030 */ bool bHDREditor;
    /* 0x0034 */ float HDREditorNITLevel;
    /* 0x0038 */ bool bProceduralFoliage;
    /* 0x0039 */ bool bEnableLocalizationDashboard;
    /* 0x003a */ bool bEnableTranslationPicker;
    /* 0x003b */ bool bEnableFavoriteSystem;
    /* 0x003c */ uint8_t ConsoleForGamepadLabels;
    /* 0x003d */ bool bToolbarCustomization;
    /* 0x003e */ bool bBreakOnExceptions;
    /* 0x003f */ bool bEnableOneFilePerActorSupport;
    /* 0x0040 */ TArray<TSoftClassPtr<UObject>> BaseClassesToAllowRecompilingDuringPlayInEditor;
    /* 0x0050 */ TArray<UClass*> ResolvedBaseClassesToAllowRecompilingDuringPlayInEditor;
    /* 0x0060 */ bool bDrawMidpointArrowsInBlueprints;
    /* 0x0061 */ bool bContextMenuChunkAssignments;
    /* 0x0062 */ bool bDisableCookInEditor;
    /* 0x0063 */ bool bSharedCookedBuilds;
    /* 0x0064 */ int32_t MultiProcessCooking;
    /* 0x0068 */ bool bAllowLateJoinInPIE;
    /* 0x0069 */ bool bAllowVulkanPreview;
    /* 0x006a */ bool bEnableMultithreadedLightmapEncoding;
    /* 0x006b */ bool bEnableMultithreadedShadowmapEncoding;
    /* 0x006c */ bool bUseOpenCLForConvexHullDecomp;
    /* 0x006d */ bool bAllowPotentiallyUnsafePropertyEditing;
    /* 0x006e */ bool bFacialAnimationImporter;
    /* 0x006f */ bool bMobilePIEPreviewDeviceLaunch;
    /* 0x0070 */ bool bTextAssetFormatSupport;
    /* 0x0071 */ bool bExampleLayersAndBlends;
    /* 0x0072 */ bool bEnableLongPathsSupport;
};

// Size: 0x38
struct FEditorFontParameterValue : public FEditorParameterValue {
    /* 0x0028 */ UFont* FontValue;
    /* 0x0030 */ int32_t FontPage;
};

// Size: 0x38
struct FEditorKeyBinding {
    /* 0x0000 */ bool bCtrlDown;
    /* 0x0000 */ bool bAltDown;
    /* 0x0000 */ bool bShiftDown;
    /* 0x0008 */ FKey Key;
    /* 0x0028 */ FName CommandName;
};

// Size: 0x30
class UEditorLevelUtils : public UObject {

    static ULevelStreaming* CreateNewStreamingLevel(UClass* LevelStreamingClass, FString NewLevelPath, bool bMoveSelectedActorsIntoNewLevel);
    static TArray<ULevel*> GetLevels(UWorld* World);
    static ULevelStreaming* K2_AddLevelToWorld(UWorld* World, FString LevelPackageName, UClass* LevelStreamingClass);
    static ULevelStreaming* K2_AddLevelToWorldWithTransform(UWorld* World, FString LevelPackageName, UClass* LevelStreamingClass, const FTransform& LevelTransform);
    static void MakeLevelCurrent(ULevelStreaming* InStreamingLevel);
    static int32_t MoveActorsToLevel(const TArray<AActor*>& ActorsToMove, ULevelStreaming* DestStreamingLevel, bool bWarnAboutReferences, bool bWarnAboutRenaming);
    static int32_t MoveSelectedActorsToLevel(ULevelStreaming* DestLevel, bool bWarnAboutReferences);
    static void SetLevelVisibility(ULevel* Level, const bool bShouldBeVisible, const bool bForceLayersVisible, const ELevelVisibilityDirtyMode ModifyMode);
    static void SetLevelsVisibility(const TArray<ULevel*>& Levels, const TArray<bool>& bShouldBeVisible, const bool bForceLayersVisible, const ELevelVisibilityDirtyMode ModifyMode);
};

// Size: 0x30
class UEditorLoadingAndSavingUtils : public UObject {

    static void ExportScene(bool bExportSelectedActorsOnly);
    static void GetDirtyContentPackages(TArray<UPackage*>& OutDirtyPackages);
    static void GetDirtyMapPackages(TArray<UPackage*>& OutDirtyPackages);
    static void ImportScene(FString Filename);
    static UWorld* LoadMap(FString Filename);
    static UWorld* LoadMapWithDialog();
    static UWorld* NewBlankMap(bool bSaveExistingMap);
    static UWorld* NewMapFromTemplate(FString PathToTemplateLevel, bool bSaveExistingMap);
    static void ReloadPackages(const TArray<UPackage*>& PackagesToReload, bool& bOutAnyPackagesReloaded, FText& OutErrorMessage, const EReloadPackagesInteractionMode InteractionMode);
    static bool SaveCurrentLevel();
    static bool SaveDirtyPackages(const bool bSaveMapPackages, const bool bSaveContentPackages);
    static bool SaveDirtyPackagesWithDialog(const bool bSaveMapPackages, const bool bSaveContentPackages);
    static bool SaveMap(UWorld* World, FString AssetPath);
    static bool SavePackages(const TArray<UPackage*>& PackagesToSave, bool bOnlyDirty);
    static bool SavePackagesWithDialog(const TArray<UPackage*>& PackagesToSave, bool bOnlyDirty);
    static void UnloadPackages(const TArray<UPackage*>& PackagesToUnload, bool& bOutAnyPackagesUnloaded, FText& OutErrorMessage);
};

// Size: 0xa8
class UEditorLoadingSavingSettings : public UObject {
    /* 0x0030 */ uint8_t LoadLevelAtStartup;
    /* 0x0034 */ bool bForceCompilationAtStartup;
    /* 0x0034 */ bool bRestoreOpenAssetTabsOnRestart;
    /* 0x0038 */ bool bEnableSourceControlCompatabilityCheck;
    /* 0x0039 */ bool bMonitorContentDirectories;
    /* 0x0040 */ TArray<FString> AutoReimportDirectories;
    /* 0x0050 */ TArray<FAutoReimportDirectoryConfig> AutoReimportDirectorySettings;
    /* 0x0060 */ float AutoReimportThreshold;
    /* 0x0064 */ bool bAutoCreateAssets;
    /* 0x0065 */ bool bAutoDeleteAssets;
    /* 0x0066 */ bool bDetectChangesOnStartup;
    /* 0x0067 */ bool bPromptBeforeAutoImporting;
    /* 0x0068 */ bool bDeleteSourceFilesWithAssets;
    /* 0x0069 */ bool bAutoReimportTextures;
    /* 0x006a */ bool bAutoReimportCSV;
    /* 0x006b */ bool bDirtyMigratedBlueprints;
    /* 0x006c */ bool bAutoSaveEnable;
    /* 0x006c */ bool bAutoSaveMaps;
    /* 0x006c */ bool bAutoSaveContent;
    /* 0x0070 */ int32_t AutoSaveTimeMinutes;
    /* 0x0074 */ int32_t AutoSaveInteractionDelayInSeconds;
    /* 0x0078 */ int32_t AutoSaveWarningInSeconds;
    /* 0x007c */ bool bAutomaticallyCheckoutOnAssetModification;
    /* 0x007c */ bool bPromptForCheckoutOnAssetModification;
    /* 0x007c */ bool bSCCAutoAddNewFiles;
    /* 0x007c */ bool bSCCUseGlobalSettings;
    /* 0x0080 */ FFilePath TextDiffToolPath;
};

// Size: 0x30
struct FEditorMaterialLayersParameterValue : public FEditorParameterValue {
    /* 0x0028 */ UMaterialFunctionInterface* FunctionValue;
};

// Size: 0x30
class UEditorMiscSettings : public UObject {
};

// Size: 0x128
class UEditorNotifyObject : public UEditorAnimBaseObj {
    /* 0x0048 */ FAnimNotifyEvent Event;
};

// Size: 0x28
struct FEditorParameterGroup {
    /* 0x0000 */ FName GroupName;
    /* 0x000c */ uint8_t GroupAssociation;
    /* 0x0010 */ TArray<UDEditorParameterValue*> Parameters;
    /* 0x0020 */ int32_t GroupSortPriority;
};

// Size: 0x28
struct FEditorParameterValue {
    /* 0x0000 */ bool bOverride;
    /* 0x0004 */ FMaterialParameterInfo ParameterInfo;
    /* 0x0018 */ FGuid ExpressionId;
};

// Size: 0x98
class UEditorParentPlayerListObj : public UObject {
    /* 0x0030 */ TArray<FAnimParentNodeAssetOverride> Overrides;
};

// Size: 0x100
class UEditorPerProjectUserSettings : public UObject {
    /* 0x0030 */ bool bDisplayUIExtensionPoints;
    /* 0x0030 */ bool bDisplayDocumentationLink;
    /* 0x0030 */ bool bDisplayActionListItemRefIds;
    /* 0x0030 */ bool bAlwaysGatherBehaviorTreeDebuggerData;
    /* 0x0030 */ bool bDisplayBlackboardKeysInAlphabeticalOrder;
    /* 0x0034 */ bool bDisplayEngineVersionInBadge;
    /* 0x0035 */ bool bUseSimplygonSwarm;
    /* 0x0038 */ FString SimplygonServerIP;
    /* 0x0048 */ bool bEnableSwarmDebugging;
    /* 0x004c */ uint32_t SimplygonSwarmDelay;
    /* 0x0050 */ uint32_t SwarmNumOfConcurrentJobs;
    /* 0x0054 */ uint32_t SwarmMaxUploadChunkSizeInMB;
    /* 0x0058 */ FString SwarmIntermediateFolder;
    /* 0x0068 */ bool bAutomaticallyHotReloadNewClasses;
    /* 0x0068 */ bool bShowCompilerLogOnCompileError;
    /* 0x0068 */ bool bKeepFbxNamespace;
    /* 0x0068 */ bool bShowImportDialogAtReimport;
    /* 0x0070 */ FDirectoryPath DataSourceFolder;
    /* 0x0080 */ bool bKeepAttachHierarchy;
    /* 0x0080 */ bool bAnimationReimportWarnings;
    /* 0x0080 */ bool bUseCurvesForDistributions;
    /* 0x0084 */ int32_t PropertyMatrix_NumberOfPasteOperationsBeforeWarning;
    /* 0x0088 */ bool bSCSEditorShowGrid;
    /* 0x0089 */ bool bSCSEditorShowFloor;
    /* 0x008a */ bool bGetAttentionOnUATCompletion;
    /* 0x008c */ int32_t SCSViewportCameraSpeed;
    /* 0x0090 */ bool bAutoloadCheckedOutPackages;
    /* 0x0090 */ bool bSuppressFullyLoadPrompt;
    /* 0x0090 */ bool bAllowSelectTranslucent;
    /* 0x0098 */ UBlueprintPaletteFavorites* BlueprintFavorites;
    /* 0x00a0 */ int32_t AssetViewerProfileIndex;
    /* 0x00a8 */ FString AssetViewerProfileName;
    /* 0x00b8 */ int32_t MaterialQualityLevel;
    /* 0x00bc */ int32_t PreviewFeatureLevel;
    /* 0x00c0 */ FName PreviewPlatformName;
    /* 0x00cc */ FName PreviewShaderFormatName;
    /* 0x00d8 */ bool bPreviewFeatureLevelActive;
    /* 0x00dc */ FName PreviewDeviceProfileName;
};

// Size: 0x70
class UEditorPerformanceSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bShowFrameRateAndMemory;
    /* 0x0060 */ bool bThrottleCPUWhenNotForeground;
    /* 0x0060 */ bool bDisableRealtimeViewportsInRemoteSessions;
    /* 0x0060 */ bool bMonitorEditorPerformance;
    /* 0x0064 */ bool bOverrideDPIBasedEditorViewportScaling;
    /* 0x0068 */ bool bEnableSharedDDCPerformanceNotifications;
    /* 0x0068 */ bool bEnableScalabilityWarningIndicator;
};

// Size: 0xa0
class UEditorProjectAppearanceSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bDisplayUnits;
    /* 0x0061 */ bool bDisplayUnitsOnComponentTransforms;
    /* 0x0068 */ TArray<EUnit> DistanceUnits;
    /* 0x0078 */ TArray<EUnit> MassUnits;
    /* 0x0088 */ TArray<EUnit> TimeUnits;
    /* 0x0098 */ EUnit AngleUnits;
    /* 0x0099 */ EUnit SpeedUnits;
    /* 0x009a */ EUnit TemperatureUnits;
    /* 0x009b */ EUnit ForceUnits;
    /* 0x009c */ EUnitDisplay UnitDisplay;
    /* 0x009d */ EDefaultLocationUnit DefaultInputUnits;
};

// Size: 0x2c
struct FEditorScalarParameterValue : public FEditorParameterValue {
    /* 0x0028 */ float ParameterValue;
};

// Size: 0x130
class UEditorSettings : public UObject {
    /* 0x0030 */ FDirectoryPath GlobalLocalDDCPath;
    /* 0x0040 */ FDirectoryPath GlobalSharedDDCPath;
    /* 0x0050 */ FDirectoryPath LocalDerivedDataCache;
    /* 0x0060 */ FDirectoryPath SharedDerivedDataCache;
    /* 0x0070 */ bool bEnableS3DDC;
    /* 0x0078 */ FDirectoryPath GlobalS3DDCPath;
    /* 0x0088 */ bool bLoadTheMostRecentlyLoadedProjectAtStartup;
    /* 0x0089 */ bool bEditorAnalyticsEnabled;
    /* 0x0090 */ TArray<FString> RecentlyOpenedProjectFiles;
    /* 0x00a0 */ TArray<FString> CreatedProjectPaths;
    /* 0x00b0 */ bool bCopyStarterContentPreference;
    /* 0x00b8 */ TArray<FGuid> CompletedSurveys;
    /* 0x00c8 */ TArray<FGuid> InProgressSurveys;
    /* 0x00d8 */ float AutoScalabilityWorkScaleAmount;
};

// Size: 0x50
class UEditorSkeletonNotifyObj : public UObject {
    /* 0x0040 */ FName Name;
};

// Size: 0x2c
struct FEditorStaticComponentMaskParameterValue : public FEditorParameterValue {
    /* 0x0028 */ FComponentMaskParameter ParameterValue;
};

// Size: 0x2c
struct FEditorStaticSwitchParameterValue : public FEditorParameterValue {
    /* 0x0028 */ bool ParameterValue;
};

// Size: 0x30
class UEditorSubsystemBlueprintLibrary : public UBlueprintFunctionLibrary {

    static UEditorSubsystem* GetEditorSubsystem(UClass* Class);
};

// Size: 0x30
struct FEditorTextureParameterValue : public FEditorParameterValue {
    /* 0x0028 */ UTexture* ParameterValue;
};

// Size: 0x38
struct FEditorVectorParameterValue : public FEditorParameterValue {
    /* 0x0028 */ FLinearColor ParameterValue;
};

// Size: 0x40
class UEditorViewportViewMenuContext : public UObject {
};

// Size: 0x50
class UEditorWorldExtension : public UObject {
    /* 0x0038 */ TArray<FEditorWorldExtensionActorData> ExtensionActors;
};

// Size: 0x10
struct FEditorWorldExtensionActorData {
    /* 0x0000 */ AActor* Actor;
    /* 0x0008 */ bool bValidForPIE;
};

// Size: 0x50
class UEditorWorldExtensionCollection : public UObject {
};

// Size: 0x40
class UEditorWorldExtensionManager : public UObject {
    /* 0x0030 */ TArray<UEditorWorldExtensionCollection*> EditorWorldExtensionCollection;
};

// Size: 0x88
class UEnumFactory : public UFactory {
};

// Size: 0xf8
class UExportDialogueScriptCommandlet : public UGatherTextCommandletBase {
};

// Size: 0x88
class UExportPakDependenciesCommandlet : public UCommandlet {
};

// Size: 0x40
class UExportTextContainer : public UObject {
    /* 0x0030 */ FString ExportText;
};

// Size: 0x80
class UExporterFBX : public UExporter {
};

// Size: 0x88
class UExtractLocResCommandlet : public UCommandlet {
};

// Size: 0x88
class UFactory : public UObject {
    /* 0x0030 */ bool bCreateNew;
    /* 0x0038 */ UClass* SupportedClass;
    /* 0x0040 */ UClass* ContextClass;
    /* 0x0048 */ TArray<FString> Formats;
    /* 0x0058 */ bool bEditAfterNew;
    /* 0x0058 */ bool bEditorImport;
    /* 0x0058 */ bool bText;
    /* 0x005c */ int32_t ImportPriority;
    /* 0x0060 */ UAutomatedAssetImportData* AutomatedImportData;
    /* 0x0068 */ UAssetImportTask* AssetImportTask;
    /* 0x0070 */ int32_t OverwriteYesOrNoToAllState;

    bool ScriptFactoryCanImport(FString Filename);
    bool ScriptFactoryCreateFile(UAssetImportTask* InTask);
};

// Size: 0xd8
class UFbxAnimSequenceImportData : public UFbxAssetImportData {
    /* 0x0088 */ bool bImportMeshesInBoneHierarchy;
    /* 0x0089 */ uint8_t AnimationLength;
    /* 0x008c */ int32_t StartFrame;
    /* 0x0090 */ int32_t EndFrame;
    /* 0x0094 */ FInt32Interval FrameImportRange;
    /* 0x009c */ bool bUseDefaultSampleRate;
    /* 0x00a0 */ int32_t CustomSampleRate;
    /* 0x00a8 */ FString SourceAnimationName;
    /* 0x00b8 */ bool bImportCustomAttribute;
    /* 0x00b9 */ bool bDeleteExistingCustomAttributeCurves;
    /* 0x00ba */ bool bDeleteExistingNonCurveCustomAttributes;
    /* 0x00bb */ bool bImportBoneTracks;
    /* 0x00bc */ bool bSetMaterialDriveParameterOnCustomAttribute;
    /* 0x00c0 */ TArray<FString> MaterialCurveSuffixes;
    /* 0x00d0 */ bool bRemoveRedundantKeys;
    /* 0x00d1 */ bool bDeleteExistingMorphTargetCurves;
    /* 0x00d2 */ bool bDoNotImportCurveWithZero;
    /* 0x00d3 */ bool bPreserveLocalTransform;
};

// Size: 0x88
class UFbxAssetImportData : public UAssetImportData {
    /* 0x0060 */ FVector ImportTranslation;
    /* 0x006c */ FRotator ImportRotation;
    /* 0x0078 */ float ImportUniformScale;
    /* 0x007c */ bool bConvertScene;
    /* 0x007d */ bool bForceFrontXAxis;
    /* 0x007e */ bool bConvertSceneUnit;
    /* 0x007f */ bool bImportAsScene;
    /* 0x0080 */ UFbxSceneImportData* FbxSceneImportDataReference;
};

// Size: 0x38
class UFbxExportOption : public UObject {
    /* 0x0030 */ EFbxExportCompatibility FbxExportCompatibility;
    /* 0x0034 */ bool bASCII;
    /* 0x0034 */ bool bForceFrontXAxis;
    /* 0x0034 */ bool VertexColor;
    /* 0x0034 */ bool LevelOfDetail;
    /* 0x0034 */ bool Collision;
    /* 0x0034 */ bool bExportMorphTargets;
    /* 0x0034 */ bool bExportPreviewMesh;
    /* 0x0034 */ bool MapSkeletalMotionToRoot;
    /* 0x0035 */ bool bExportLocalTime;
};

// Size: 0xa0
class UFbxFactory : public UFactory {
    /* 0x0088 */ UFbxImportUI* ImportUI;
    /* 0x0090 */ UFbxImportUI* OriginalImportUI;
};

// Size: 0x200
class UFbxImportUI : public UObject {
    /* 0x0038 */ bool bIsObjImport;
    /* 0x0039 */ uint8_t OriginalImportType;
    /* 0x003a */ uint8_t MeshTypeToImport;
    /* 0x003c */ bool bOverrideFullName;
    /* 0x0040 */ bool bImportAsSkeletal;
    /* 0x0041 */ bool bImportMesh;
    /* 0x0048 */ USkeleton* Skeleton;
    /* 0x0050 */ bool bCreatePhysicsAsset;
    /* 0x0058 */ UPhysicsAsset* PhysicsAsset;
    /* 0x0060 */ bool bAutoComputeLodDistances;
    /* 0x0064 */ float LodDistance0;
    /* 0x0068 */ float LodDistance1;
    /* 0x006c */ float LodDistance2;
    /* 0x0070 */ float LodDistance3;
    /* 0x0074 */ float LodDistance4;
    /* 0x0078 */ float LodDistance5;
    /* 0x007c */ float LodDistance6;
    /* 0x0080 */ float LodDistance7;
    /* 0x0084 */ int32_t MinimumLodNumber;
    /* 0x0088 */ int32_t LodNumber;
    /* 0x008c */ bool bImportAnimations;
    /* 0x0090 */ FString OverrideAnimationName;
    /* 0x00a0 */ bool bImportRigidMesh;
    /* 0x00a0 */ bool bImportMaterials;
    /* 0x00a0 */ bool bImportTextures;
    /* 0x00a0 */ bool bResetToFbxOnMaterialConflict;
    /* 0x00a8 */ UFbxStaticMeshImportData* StaticMeshImportData;
    /* 0x00b0 */ UFbxSkeletalMeshImportData* SkeletalMeshImportData;
    /* 0x00b8 */ UFbxAnimSequenceImportData* AnimSequenceImportData;
    /* 0x00c0 */ UFbxTextureImportData* TextureImportData;
    /* 0x00c8 */ bool bAutomatedImportShouldDetectType;
    /* 0x0180 */ FString FileVersion;
    /* 0x0190 */ FString FileCreator;
    /* 0x01a0 */ FString FileCreatorApplication;
    /* 0x01b0 */ FString FileUnits;
    /* 0x01c0 */ FString FileAxisDirection;
    /* 0x01d0 */ FString FileSampleRate;
    /* 0x01e0 */ FString AnimStartFrame;
    /* 0x01f0 */ FString AnimEndFrame;

    void ResetToDefault();
};

// Size: 0xc0
class UFbxMeshImportData : public UFbxAssetImportData {
    /* 0x0088 */ bool bTransformVertexToAbsolute;
    /* 0x0089 */ bool bBakePivotInVertex;
    /* 0x008c */ bool bImportMeshLODs;
    /* 0x0090 */ uint8_t NormalImportMethod;
    /* 0x0091 */ uint8_t NormalGenerationMethod;
    /* 0x0094 */ bool bComputeWeightedNormals;
    /* 0x0098 */ bool bReorderMaterialToFbxOrder;
    /* 0x00a0 */ TArray<FName> ImportMaterialOriginalNameData;
    /* 0x00b0 */ TArray<FImportMeshLodSectionsData> ImportMeshLodData;
};

// Size: 0xb8
class UFbxSceneImportData : public UObject {
    /* 0x0030 */ FString SourceFbxFile;
};

// Size: 0x190
class UFbxSceneImportFactory : public USceneImportFactory {
    /* 0x0088 */ UFbxSceneImportOptions* SceneImportOptions;
    /* 0x0090 */ UFbxSceneImportOptionsStaticMesh* SceneImportOptionsStaticMesh;
    /* 0x0098 */ UFbxSceneImportOptionsSkeletalMesh* SceneImportOptionsSkeletalMesh;
    /* 0x00a0 */ UFbxStaticMeshImportData* StaticMeshImportData;
    /* 0x00a8 */ UFbxSkeletalMeshImportData* SkeletalMeshImportData;
    /* 0x00b0 */ UFbxAnimSequenceImportData* AnimSequenceImportData;
    /* 0x00b8 */ UFbxTextureImportData* TextureImportData;
    /* 0x00d0 */ UFbxSceneImportData* ReimportData;
};

// Size: 0x60
class UFbxSceneImportOptions : public UObject {
    /* 0x0030 */ bool bCreateContentFolderHierarchy;
    /* 0x0030 */ bool bImportAsDynamic;
    /* 0x0034 */ EFBXSceneOptionsCreateHierarchyType HierarchyType;
    /* 0x0038 */ bool bForceFrontXAxis;
    /* 0x003c */ FVector ImportTranslation;
    /* 0x0048 */ FRotator ImportRotation;
    /* 0x0054 */ float ImportUniformScale;
    /* 0x0058 */ bool bTransformVertexToAbsolute;
    /* 0x0059 */ bool bBakePivotInVertex;
    /* 0x005c */ bool bImportStaticMeshLODs;
    /* 0x005c */ bool bImportSkeletalMeshLODs;
    /* 0x005c */ bool bInvertNormalMaps;
};

// Size: 0x68
class UFbxSceneImportOptionsSkeletalMesh : public UObject {
    /* 0x0030 */ bool bUpdateSkeletonReferencePose;
    /* 0x0030 */ bool bCreatePhysicsAsset;
    /* 0x0030 */ bool bUseT0AsRefPose;
    /* 0x0030 */ bool bPreserveSmoothingGroups;
    /* 0x0030 */ bool bImportMeshesInBoneHierarchy;
    /* 0x0030 */ bool bImportMorphTargets;
    /* 0x0034 */ float ThresholdPosition;
    /* 0x0038 */ float ThresholdTangentNormal;
    /* 0x003c */ float ThresholdUV;
    /* 0x0040 */ float MorphThresholdPosition;
    /* 0x0044 */ bool bImportAnimations;
    /* 0x0048 */ uint8_t AnimationLength;
    /* 0x004c */ FInt32Interval FrameImportRange;
    /* 0x0054 */ bool bUseDefaultSampleRate;
    /* 0x0058 */ int32_t CustomSampleRate;
    /* 0x005c */ bool bImportCustomAttribute;
    /* 0x005d */ bool bDeleteExistingCustomAttributeCurves;
    /* 0x005e */ bool bDeleteExistingNonCurveCustomAttributes;
    /* 0x005f */ bool bPreserveLocalTransform;
    /* 0x0060 */ bool bDeleteExistingMorphTargetCurves;
};

// Size: 0x50
class UFbxSceneImportOptionsStaticMesh : public UObject {
    /* 0x0030 */ FName StaticMeshLODGroup;
    /* 0x003c */ bool bAutoGenerateCollision;
    /* 0x0040 */ EFbxSceneVertexColorImportOption VertexColorImportOption;
    /* 0x0044 */ FColor VertexOverrideColor;
    /* 0x0048 */ bool bRemoveDegenerates;
    /* 0x0048 */ bool bBuildAdjacencyBuffer;
    /* 0x0048 */ bool bBuildReversedIndexBuffer;
    /* 0x0048 */ bool bGenerateLightmapUVs;
    /* 0x0048 */ bool bOneConvexHullPerUCX;
    /* 0x004c */ EFBXSceneNormalImportMethod NormalImportMethod;
    /* 0x004d */ EFBXSceneNormalGenerationMethod NormalGenerationMethod;
};

// Size: 0xe0
class UFbxSkeletalMeshImportData : public UFbxMeshImportData {
    /* 0x00c0 */ uint8_t ImportContentType;
    /* 0x00c1 */ uint8_t LastImportContentType;
    /* 0x00c2 */ uint8_t VertexColorImportOption;
    /* 0x00c4 */ FColor VertexOverrideColor;
    /* 0x00c8 */ bool bUpdateSkeletonReferencePose;
    /* 0x00c8 */ bool bUseT0AsRefPose;
    /* 0x00c8 */ bool bPreserveSmoothingGroups;
    /* 0x00c8 */ bool bImportMeshesInBoneHierarchy;
    /* 0x00c8 */ bool bImportMorphTargets;
    /* 0x00cc */ float ThresholdPosition;
    /* 0x00d0 */ float ThresholdTangentNormal;
    /* 0x00d4 */ float ThresholdUV;
    /* 0x00d8 */ float MorphThresholdPosition;
};

// Size: 0xd8
class UFbxStaticMeshImportData : public UFbxMeshImportData {
    /* 0x00c0 */ FName StaticMeshLODGroup;
    /* 0x00cc */ uint8_t VertexColorImportOption;
    /* 0x00d0 */ FColor VertexOverrideColor;
    /* 0x00d4 */ bool bRemoveDegenerates;
    /* 0x00d4 */ bool bBuildAdjacencyBuffer;
    /* 0x00d4 */ bool bBuildReversedIndexBuffer;
    /* 0x00d4 */ bool bGenerateLightmapUVs;
    /* 0x00d4 */ bool bOneConvexHullPerUCX;
    /* 0x00d4 */ bool bAutoGenerateCollision;
    /* 0x00d4 */ bool bCombineMeshes;
};

// Size: 0x68
class UFbxTestPlan : public UObject {
    /* 0x0030 */ FString TestPlanName;
    /* 0x0040 */ uint8_t Action;
    /* 0x0044 */ int32_t LODIndex;
    /* 0x0048 */ bool bDeleteFolderAssets;
    /* 0x0050 */ TArray<FFbxTestPlanExpectedResult> ExpectedResult;
    /* 0x0060 */ UFbxImportUI* ImportUI;
};

// Size: 0x48
struct FFbxTestPlanExpectedResult {
    /* 0x0000 */ uint8_t ExpectedPresetsType;
    /* 0x0008 */ TArray<int32_t> ExpectedPresetsDataInteger;
    /* 0x0018 */ TArray<float> ExpectedPresetsDataFloat;
    /* 0x0028 */ TArray<double> ExpectedPresetsDataDouble;
    /* 0x0038 */ TArray<FString> ExpectedPresetsDataString;
};

// Size: 0x128
class UFbxTextureImportData : public UFbxAssetImportData {
    /* 0x0088 */ bool bInvertNormalMaps;
    /* 0x008c */ EMaterialSearchLocation MaterialSearchLocation;
    /* 0x0090 */ FSoftObjectPath BaseMaterialName;
    /* 0x00b8 */ FString BaseColorName;
    /* 0x00c8 */ FString BaseDiffuseTextureName;
    /* 0x00d8 */ FString BaseNormalTextureName;
    /* 0x00e8 */ FString BaseEmissiveColorName;
    /* 0x00f8 */ FString BaseEmmisiveTextureName;
    /* 0x0108 */ FString BaseSpecularTextureName;
    /* 0x0118 */ FString BaseOpacityTextureName;
};

// Size: 0x98
class UFileServerCommandlet : public UCommandlet {
};

// Size: 0x88
class UFixConflictingLocalizationKeysCommandlet : public UCommandlet {
};

// Size: 0x1f0
class UFixupNeedsLoadForEditorGameCommandlet : public UResavePackagesCommandlet {
};

// Size: 0x88
class UFontFactory : public UFactory {
};

// Size: 0xb0
class UFontFileImportFactory : public UFactory {
};

// Size: 0x30
class UFontThumbnailRenderer : public UTextureThumbnailRenderer {
};

// Size: 0x88
class UForceFeedbackAttenuationFactory : public UFactory {
};

// Size: 0x88
class UForceFeedbackEffectFactory : public UFactory {
};

// Size: 0xf8
class UGatherTextCommandlet : public UGatherTextCommandletBase {
};

// Size: 0xf8
class UGatherTextCommandletBase : public UCommandlet {
};

// Size: 0x1e0
class UGatherTextFromAssetsCommandlet : public UGatherTextCommandletBase {
};

// Size: 0x140
class UGatherTextFromMetaDataCommandlet : public UGatherTextCommandletBase {
};

// Size: 0xf8
class UGatherTextFromSourceCommandlet : public UGatherTextCommandletBase {
};

// Size: 0x88
class UGenerateAssetManifestCommandlet : public UCommandlet {
};

// Size: 0x88
class UGenerateBlueprintAPICommandlet : public UCommandlet {
};

// Size: 0x88
class UGenerateDistillFileSetsCommandlet : public UCommandlet {
};

// Size: 0xf8
class UGenerateGatherArchiveCommandlet : public UGatherTextCommandletBase {
};

// Size: 0xf8
class UGenerateGatherManifestCommandlet : public UGatherTextCommandletBase {
};

// Size: 0x128
class UGenerateTextLocalizationReportCommandlet : public UGatherTextCommandletBase {
};

// Size: 0xf8
class UGenerateTextLocalizationResourceCommandlet : public UGatherTextCommandletBase {
};

// Size: 0x320
class AGroupActor : public AActor {
    /* 0x02f8 */ bool bLocked;
    /* 0x0300 */ TArray<AActor*> GroupActors;
    /* 0x0310 */ TArray<AGroupActor*> SubGroups;
};

// Size: 0x88
class UHapticFeedbackEffectBufferFactory : public UFactory {
};

// Size: 0x88
class UHapticFeedbackEffectCurveFactory : public UFactory {
};

// Size: 0x88
class UHapticFeedbackEffectSoundWaveFactory : public UFactory {
};

// Size: 0xf0
class UHierarchicalLODSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bForceSettingsInAllMaps;
    /* 0x0061 */ bool bSaveLODActorsToHLODPackages;
    /* 0x0068 */ TSoftClassPtr<UHierarchicalLODSetup> DefaultSetup;
    /* 0x0098 */ TArray<FDirectoryPath> DirectoriesForHLODCommandlet;
    /* 0x00a8 */ TArray<FFilePath> MapsToBuild;
    /* 0x00b8 */ bool bInvalidateHLODClusters;
    /* 0x00b9 */ bool bDeleteHLODAssets;
    /* 0x00c0 */ TSoftObjectPtr<UMaterialInterface> BaseMaterial;
};

// Size: 0x340
class AHierarchicalLODVolume : public AVolume {
    /* 0x0338 */ bool bIncludeOverlappingActors;
};

// Size: 0xc0
class UImportAssetsCommandlet : public UCommandlet {
    /* 0x00a0 */ UAutomatedAssetImportData* GlobalImportData;
    /* 0x00a8 */ TArray<UAutomatedAssetImportData*> ImportDataList;
};

// Size: 0xf8
class UImportDialogueScriptCommandlet : public UGatherTextCommandletBase {
};

// Size: 0x148
class UImportLocalizedDialogueCommandlet : public UGatherTextCommandletBase {
};

// Size: 0x10
struct FImportMeshLodSectionsData {
    /* 0x0000 */ TArray<FName> SectionOriginalMaterialName;
};

// Size: 0xf0
class UImportSubsystem : public UEditorSubsystem {
    /* 0x0098 */ FMulticastInlineDelegate OnAssetPreImport_BP;
    /* 0x00a8 */ FMulticastInlineDelegate OnAssetPostImport_BP;
    /* 0x00b8 */ FMulticastInlineDelegate OnAssetReimport_BP;
    /* 0x00c8 */ FMulticastInlineDelegate OnAssetPostLODImport_BP;

    void OnAssetPostImport_Dyn__DelegateSignature(UFactory* InFactory, UObject* InCreatedObject);
    void OnAssetPostLODImport_Dyn__DelegateSignature(UObject* InObject, int32_t InLODIndex);
    void OnAssetPreImport_Dyn__DelegateSignature(UFactory* InFactory, UClass* InClass, UObject* InParent, const FName& Name, const FString Type);
    void OnAssetReimport_Dyn__DelegateSignature(UObject* InCreatedObject);
};

// Size: 0x40
struct FIniStringValue {
    /* 0x0000 */ FString Section;
    /* 0x0010 */ FString Key;
    /* 0x0020 */ FString Value;
    /* 0x0030 */ FString Filename;
};

// Size: 0x188
class UInternationalizationConditioningCommandlet : public UGatherTextCommandletBase {
};

// Size: 0xf8
class UInternationalizationExportCommandlet : public UGatherTextCommandletBase {
};

// Size: 0x88
class UInterpDataFactoryNew : public UFactory {
};

// Size: 0x88
class UIoStoreCommandlet : public UCommandlet {
};

// Size: 0x60
class ULayersSubsystem : public UEditorSubsystem {

    bool AddActorToLayer(AActor* Actor, const FName& LayerName);
    bool AddActorToLayers(AActor* Actor, const TArray<FName>& LayerNames);
    bool AddActorsToLayer(const TArray<AActor*>& Actors, const FName& LayerName);
    bool AddActorsToLayers(const TArray<AActor*>& Actors, const TArray<FName>& LayerNames);
    void AddAllLayerNamesTo(TArray<FName>& OutLayerNames) const;
    void AddAllLayersTo(TArray<ULayer*>& OutLayers) const;
    void AddLevelLayerInformation(ULevel* Level);
    bool AddSelectedActorsToLayer(const FName& LayerName);
    bool AddSelectedActorsToLayers(const TArray<FName>& LayerNames);
    void AppendActorsFromLayer(const FName& LayerName, TArray<AActor*>& InOutActors) const;
    void AppendActorsFromLayers(const TArray<FName>& LayerNames, TArray<AActor*>& InOutActors) const;
    ULayer* CreateLayer(const FName& LayerName);
    void DeleteLayer(const FName& LayerToDelete);
    void DeleteLayers(const TArray<FName>& LayersToDelete);
    bool DisassociateActorFromLayers(AActor* Actor);
    void EditorMapChange();
    void EditorRefreshLayerBrowser();
    TArray<AActor*> GetActorsFromLayer(const FName& LayerName) const;
    TArray<AActor*> GetActorsFromLayers(const TArray<FName>& LayerNames) const;
    ULayer* GetLayer(const FName& LayerName) const;
    TArray<AActor*> GetSelectedActors() const;
    UWorld* GetWorld() const;
    bool InitializeNewActorLayers(AActor* Actor);
    bool IsActorValidForLayer(AActor* Actor);
    bool IsLayer(const FName& LayerName);
    void MakeAllLayersVisible();
    bool RemoveActorFromLayer(AActor* Actor, const FName& LayerToRemove, const bool bUpdateStats);
    bool RemoveActorFromLayers(AActor* Actor, const TArray<FName>& LayerNames, const bool bUpdateStats);
    bool RemoveActorsFromLayer(const TArray<AActor*>& Actors, const FName& LayerName, const bool bUpdateStats);
    bool RemoveActorsFromLayers(const TArray<AActor*>& Actors, const TArray<FName>& LayerNames, const bool bUpdateStats);
    void RemoveLevelLayerInformation(ULevel* Level);
    bool RemoveSelectedActorsFromLayer(const FName& LayerName);
    bool RemoveSelectedActorsFromLayers(const TArray<FName>& LayerNames);
    bool RenameLayer(const FName& OriginalLayerName, const FName& NewLayerName);
    bool SelectActorsInLayer(const FName& LayerName, const bool bSelect, const bool bNotify, const bool bSelectEvenIfHidden);
    bool SelectActorsInLayers(const TArray<FName>& LayerNames, const bool bSelect, const bool bNotify, const bool bSelectEvenIfHidden);
    void SetLayerVisibility(const FName& LayerName, const bool bIsVisible);
    void SetLayersVisibility(const TArray<FName>& LayerNames, const bool bIsVisible);
    void ToggleLayerVisibility(const FName& LayerName);
    void ToggleLayersVisibility(const TArray<FName>& LayerNames);
    bool TryGetLayer(const FName& LayerName, ULayer*& OutLayer);
    void UpdateActorAllViewsVisibility(AActor* Actor);
    bool UpdateActorVisibility(AActor* Actor, bool& bOutSelectionChanged, bool& bOutActorModified, const bool bNotifySelectionChange, const bool bRedrawViewports);
    bool UpdateAllActorsVisibility(const bool bNotifySelectionChange, const bool bRedrawViewports);
    void UpdateAllViewVisibility(const FName& LayerThatChanged);
};

// Size: 0x198
class ULegacyEdModeWrapper : public UEdMode {
};

// Size: 0x78
class ULevelEditor2DSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bEnable2DWidget;
    /* 0x0061 */ bool bEnableSnapLayers;
    /* 0x0062 */ ELevelEditor2DAxis SnapAxis;
    /* 0x0068 */ TArray<FMode2DLayer> SnapLayers;
};

// Size: 0xa0
class ULevelEditorMiscSettings : public UDeveloperSettings {
    /* 0x0060 */ bool bAutoApplyLightingEnable;
    /* 0x0060 */ bool bBSPAutoUpdate;
    /* 0x0060 */ bool bAutoMoveBSPPivotOffset;
    /* 0x0060 */ bool bNavigationAutoUpdate;
    /* 0x0060 */ bool bReplaceRespectsScale;
    /* 0x0060 */ bool bEnableLegacyMeshPaintMode;
    /* 0x0060 */ bool bAvoidRelabelOnPasteSelected;
    /* 0x0060 */ bool bCheckReferencesOnDelete;
    /* 0x0061 */ bool bAllowBackgroundAudio;
    /* 0x0061 */ bool bCreateNewAudioDeviceForPlayInEditor;
    /* 0x0061 */ bool bEnableRealTimeAudio;
    /* 0x0064 */ float EditorVolumeLevel;
    /* 0x0068 */ bool bEnableEditorSounds;
    /* 0x0070 */ UClass* DefaultLevelStreamingClass;
    /* 0x0078 */ bool bPromptWhenAddingToLevelBeforeCheckout;
    /* 0x0079 */ bool bPromptWhenAddingToLevelOutsideBounds;
    /* 0x007c */ float PercentageThresholdForPrompt;
    /* 0x0080 */ FVector MinimumBoundsForCheckingSize;
    /* 0x0090 */ FDirectoryPath EditorScreenshotSaveDirectory;
};

// Size: 0x30
struct FLevelEditorPlayNetworkEmulationSettings {
    /* 0x0000 */ bool bIsNetworkEmulationEnabled;
    /* 0x0004 */ NetworkEmulationTarget EmulationTarget;
    /* 0x0008 */ FString CurrentProfile;
    /* 0x0018 */ FNetworkEmulationPacketSettings OutPackets;
    /* 0x0024 */ FNetworkEmulationPacketSettings InPackets;
};

// Size: 0x240
class ULevelEditorPlaySettings : public UObject {
    /* 0x0030 */ FString PlayFromHerePlayerStartClassName;
    /* 0x0040 */ bool GameGetsMouseControl;
    /* 0x0041 */ bool UseMouseForTouch;
    /* 0x0042 */ bool ShowMouseControlLabel;
    /* 0x0043 */ uint8_t MouseControlLabelPosition;
    /* 0x0044 */ bool ViewportGetsHMDControl;
    /* 0x0045 */ bool ShouldMinimizeEditorOnVRPIE;
    /* 0x0046 */ bool AutoRecompileBlueprints;
    /* 0x0047 */ bool EnableGameSound;
    /* 0x0048 */ bool EnablePIEEnterAndExitSounds;
    /* 0x004c */ int32_t PlayInEditorSoundQualityLevel;
    /* 0x0050 */ bool bUseNonRealtimeAudioDevice;
    /* 0x0054 */ bool bOnlyLoadVisibleLevelsInPIE;
    /* 0x0054 */ bool bPreferToStreamLevelsInPIE;
    /* 0x0058 */ int32_t NewWindowWidth;
    /* 0x005c */ int32_t NewWindowHeight;
    /* 0x0060 */ FIntPoint NewWindowPosition;
    /* 0x0068 */ bool CenterNewWindow;
    /* 0x0068 */ bool PIEAlwaysOnTop;
    /* 0x0068 */ bool DisableStandaloneSound;
    /* 0x0070 */ FString AdditionalLaunchParameters;
    /* 0x0080 */ FString AdditionalLaunchParametersForMobile;
    /* 0x0090 */ uint8_t BuildGameBeforeLaunch;
    /* 0x0091 */ uint8_t LaunchConfiguration;
    /* 0x0092 */ EPlayOnPakFileMode PackFilesForLaunch;
    /* 0x0093 */ bool bAutoCompileBlueprintsOnLaunch;
    /* 0x00a8 */ bool bLaunchSeparateServer;
    /* 0x00a9 */ uint8_t PlayNetMode;
    /* 0x00aa */ bool RunUnderOneProcess;
    /* 0x00ab */ bool PlayNetDedicated;
    /* 0x00ac */ int32_t PlayNumberOfClients;
    /* 0x00b0 */ uint16_t ServerPort;
    /* 0x00b4 */ int32_t ClientWindowWidth;
    /* 0x00b8 */ bool AutoConnectToServer;
    /* 0x00b9 */ bool RouteGamepadToSecondWindow;
    /* 0x00ba */ bool CreateAudioDeviceForEveryPlayer;
    /* 0x00bc */ int32_t ClientWindowHeight;
    /* 0x00c0 */ FString ServerMapNameOverride;
    /* 0x00d0 */ FString AdditionalServerGameOptions;
    /* 0x00e0 */ FString AdditionalLaunchOptions;
    /* 0x00f0 */ bool bShowServerDebugDrawingByDefault;
    /* 0x00f4 */ float ServerDebugDrawingColorTintStrength;
    /* 0x00f8 */ FLinearColor ServerDebugDrawingColorTint;
    /* 0x0108 */ FString AdditionalServerLaunchParameters;
    /* 0x0118 */ int32_t ServerFixedFPS;
    /* 0x0120 */ TArray<int32_t> ClientFixedFPS;
    /* 0x0130 */ FLevelEditorPlayNetworkEmulationSettings NetworkEmulationSettings;
    /* 0x0160 */ FIntPoint LastSize;
    /* 0x0168 */ TArray<FIntPoint> MultipleInstancePositions;
    /* 0x0178 */ FString LastExecutedLaunchDevice;
    /* 0x0188 */ FString LastExecutedLaunchName;
    /* 0x0198 */ uint8_t LastExecutedLaunchModeType;
    /* 0x0199 */ uint8_t LastExecutedPlayModeLocation;
    /* 0x019a */ uint8_t LastExecutedPlayModeType;
    /* 0x01a0 */ FString LastExecutedPIEPreviewDevice;
    /* 0x01b0 */ TArray<FPlayScreenResolution> LaptopScreenResolutions;
    /* 0x01c0 */ TArray<FPlayScreenResolution> MonitorScreenResolutions;
    /* 0x01d0 */ TArray<FPlayScreenResolution> PhoneScreenResolutions;
    /* 0x01e0 */ TArray<FPlayScreenResolution> TabletScreenResolutions;
    /* 0x01f0 */ TArray<FPlayScreenResolution> TelevisionScreenResolutions;
    /* 0x0200 */ FString DeviceToEmulate;
    /* 0x0210 */ FMargin PIESafeZoneOverride;
    /* 0x0220 */ TArray<FVector2D> CustomUnsafeZoneStarts;
    /* 0x0230 */ TArray<FVector2D> CustomUnsafeZoneDimensions;
};

// Size: 0x70
struct FLevelEditorViewportInstanceSettings {
    /* 0x0000 */ uint8_t ViewportType;
    /* 0x0001 */ uint8_t PerspViewModeIndex;
    /* 0x0002 */ uint8_t OrthoViewModeIndex;
    /* 0x0008 */ FString EditorShowFlagsString;
    /* 0x0018 */ FString GameShowFlagsString;
    /* 0x0028 */ FName BufferVisualizationMode;
    /* 0x0034 */ FName RayTracingDebugVisualizationMode;
    /* 0x0040 */ FExposureSettings ExposureSettings;
    /* 0x0048 */ float FOVAngle;
    /* 0x004c */ float FarViewPlane;
    /* 0x0050 */ bool bIsRealtime;
    /* 0x0051 */ bool bShowFPS;
    /* 0x0052 */ bool bShowOnScreenStats;
    /* 0x0058 */ TArray<FString> EnabledStats;
    /* 0x0068 */ bool bShowFullToolbar;
};

// Size: 0x80
struct FLevelEditorViewportInstanceSettingsKeyValuePair {
    /* 0x0000 */ FString ConfigName;
    /* 0x0010 */ FLevelEditorViewportInstanceSettings ConfigSettings;
};

// Size: 0x180
class ULevelEditorViewportSettings : public UObject {
    /* 0x0030 */ uint8_t FlightCameraControlType;
    /* 0x0031 */ bool FlightCameraControlExperimentalNavigation;
    /* 0x0032 */ ELandscapeFoliageEditorControlType LandscapeEditorControlType;
    /* 0x0033 */ ELandscapeFoliageEditorControlType FoliageEditorControlType;
    /* 0x0034 */ bool bPanMovesCanvas;
    /* 0x0034 */ bool bCenterZoomAroundCursor;
    /* 0x0038 */ float MinimumOrthographicZoom;
    /* 0x003c */ bool bAllowTranslateRotateZWidget;
    /* 0x003c */ bool bAllowArcballRotate;
    /* 0x003c */ bool bAllowScreenRotate;
    /* 0x003c */ bool bClickBSPSelectsBrush;
    /* 0x0040 */ int32_t CameraSpeed;
    /* 0x0044 */ float CameraSpeedScalar;
    /* 0x0048 */ int32_t MouseScrollCameraSpeed;
    /* 0x004c */ float MouseSensitivty;
    /* 0x0050 */ bool bInvertMouseLookYAxis;
    /* 0x0051 */ bool bInvertOrbitYAxis;
    /* 0x0052 */ bool bInvertMiddleMousePan;
    /* 0x0053 */ bool bInvertRightMouseDollyYAxis;
    /* 0x0054 */ bool bUseAbsoluteTranslation;
    /* 0x0058 */ bool bLevelStreamingVolumePrevis;
    /* 0x0059 */ bool bUseUE3OrbitControls;
    /* 0x005a */ EScrollGestureDirection ScrollGestureDirectionFor3DViewports;
    /* 0x005b */ EScrollGestureDirection ScrollGestureDirectionForOrthoViewports;
    /* 0x005c */ bool bLevelEditorJoystickControls;
    /* 0x005d */ bool bUseDistanceScaledCameraSpeed;
    /* 0x005e */ bool bOrbitCameraAroundSelection;
    /* 0x005f */ bool bUsePowerOf2SnapSize;
    /* 0x0060 */ TArray<float> DecimalGridSizes;
    /* 0x0070 */ TArray<float> DecimalGridIntervals;
    /* 0x0080 */ TArray<float> Pow2GridSizes;
    /* 0x0090 */ TArray<float> Pow2GridIntervals;
    /* 0x00a0 */ TArray<float> CommonRotGridSizes;
    /* 0x00b0 */ TArray<float> DivisionsOf360RotGridSizes;
    /* 0x00c0 */ TArray<float> ScalingGridSizes;
    /* 0x00d0 */ bool GridEnabled;
    /* 0x00d0 */ bool RotGridEnabled;
    /* 0x00d0 */ bool SnapScaleEnabled;
    /* 0x00d4 */ FSnapToSurfaceSettings SnapToSurface;
    /* 0x00e0 */ bool bUsePercentageBasedScaling;
    /* 0x00e0 */ bool bEnableLayerSnap;
    /* 0x00e4 */ int32_t ActiveSnapLayerIndex;
    /* 0x00e8 */ bool bEnableActorSnap;
    /* 0x00ec */ float ActorSnapScale;
    /* 0x00f0 */ float ActorSnapDistance;
    /* 0x00f4 */ bool bSnapVertices;
    /* 0x00f8 */ float SnapDistance;
    /* 0x00fc */ int32_t CurrentPosGridSize;
    /* 0x0100 */ int32_t CurrentRotGridSize;
    /* 0x0104 */ int32_t CurrentScalingGridSize;
    /* 0x0108 */ bool PreserveNonUniformScale;
    /* 0x0109 */ uint8_t CurrentRotGridMode;
    /* 0x010a */ bool bUseLegacyPostEditBehavior;
    /* 0x010b */ uint8_t AspectRatioAxisConstraint;
    /* 0x010c */ bool bEnableViewportHoverFeedback;
    /* 0x010c */ bool bHighlightWithBrackets;
    /* 0x010c */ bool bUseLinkedOrthographicViewports;
    /* 0x010c */ bool bStrictBoxSelection;
    /* 0x010c */ bool bTransparentBoxSelection;
    /* 0x010c */ bool bUseSelectionOutline;
    /* 0x0110 */ float SelectionHighlightIntensity;
    /* 0x0114 */ float BSPSelectionHighlightIntensity;
    /* 0x0118 */ bool bEnableViewportCameraToUpdateFromPIV;
    /* 0x0118 */ bool bPreviewSelectedCameras;
    /* 0x011c */ float CameraPreviewSize;
    /* 0x0120 */ float BackgroundDropDistance;
    /* 0x0128 */ TArray<FSoftObjectPath> PreviewMeshes;
    /* 0x0138 */ float BillboardScale;
    /* 0x013c */ int32_t TransformWidgetSizeAdjustment;
    /* 0x0140 */ bool bSaveEngineStats;
    /* 0x0144 */ uint8_t MeasuringToolUnits;
    /* 0x0148 */ float SelectedSplinePointSizeAdjustment;
    /* 0x014c */ float SplineLineThicknessAdjustment;
    /* 0x0150 */ float SplineTangentHandleSizeAdjustment;
    /* 0x0154 */ float SplineTangentScale;
    /* 0x0158 */ TArray<FLevelEditorViewportInstanceSettingsKeyValuePair> PerInstanceSettings;
};

// Size: 0x80
class ULevelExporterFBX : public UExporterFBX {
};

// Size: 0x80
class ULevelExporterLOD : public UExporter {
};

// Size: 0x80
class ULevelExporterOBJ : public UExporter {
};

// Size: 0x80
class ULevelExporterSTL : public UExporter {
};

// Size: 0x80
class ULevelExporterT3D : public UExporter {
};

// Size: 0x88
class ULevelFactory : public UFactory {
};

// Size: 0x38
class ULevelThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x8
struct FLightmassBooleanParameterValue : public FLightmassParameterValue {
    /* 0x0004 */ bool ParameterValue;
};

// Size: 0x48
class ULightmassOptionsObject : public UObject {
    /* 0x0030 */ FLightmassDebugOptions DebugSettings;
    /* 0x0040 */ FSwarmDebugOptions SwarmSettings;
};

// Size: 0x4
struct FLightmassParameterValue {
    /* 0x0000 */ bool bOverride;
};

// Size: 0x20
struct FLightmassParameterizedMaterialSettings {
    /* 0x0000 */ FLightmassBooleanParameterValue CastShadowAsMasked;
    /* 0x0008 */ FLightmassScalarParameterValue EmissiveBoost;
    /* 0x0010 */ FLightmassScalarParameterValue DiffuseBoost;
    /* 0x0018 */ FLightmassScalarParameterValue ExportResolutionScale;
};

// Size: 0x8
struct FLightmassScalarParameterValue : public FLightmassParameterValue {
    /* 0x0004 */ float ParameterValue;
};

// Size: 0xa8
class ULinearStairBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ int32_t StepLength;
    /* 0x008c */ int32_t StepHeight;
    /* 0x0090 */ int32_t StepWidth;
    /* 0x0094 */ int32_t NumSteps;
    /* 0x0098 */ int32_t AddToFirstStep;
    /* 0x009c */ FName GroupName;
};

// Size: 0x88
class UListMaterialsUsedWithMeshEmittersCommandlet : public UCommandlet {
};

// Size: 0x88
class UListStaticMeshesImportedFromSpeedTreesCommandlet : public UCommandlet {
};

// Size: 0x88
class ULoadPackageCommandlet : public UCommandlet {
};

// Size: 0x88
class UMakeBinaryConfigCommandlet : public UCommandlet {
};

// Size: 0xf0
class UMaterialEditorInstanceConstant : public UObject {
    /* 0x0030 */ UPhysicalMaterial* PhysMaterial;
    /* 0x0038 */ UMaterialInterface* Parent;
    /* 0x0040 */ TArray<FEditorParameterGroup> ParameterGroups;
    /* 0x0050 */ float RefractionDepthBias;
    /* 0x0058 */ USubsurfaceProfile* SubsurfaceProfile;
    /* 0x0060 */ bool bOverrideSubsurfaceProfile;
    /* 0x0060 */ bool bOverrideBaseProperties;
    /* 0x0060 */ bool bIsFunctionPreviewMaterial;
    /* 0x0060 */ bool bIsFunctionInstanceDirty;
    /* 0x0064 */ FMaterialInstanceBasePropertyOverrides BasePropertyOverrides;
    /* 0x0070 */ UMaterialInstanceConstant* SourceInstance;
    /* 0x0078 */ UMaterialFunctionInstance* SourceFunction;
    /* 0x0080 */ TArray<FMaterialParameterInfo> VisibleExpressions;
    /* 0x0090 */ FLightmassParameterizedMaterialSettings LightmassSettings;
    /* 0x00b0 */ bool bUseOldStyleMICEditorGroups;
    /* 0x00c8 */ TArray<UMaterialInstanceConstant*> StoredLayerPreviews;
    /* 0x00d8 */ TArray<UMaterialInstanceConstant*> StoredBlendPreviews;
};

// Size: 0x5d0
class UMaterialEditorMeshComponent : public UStaticMeshComponent {
};

// Size: 0x48
class UMaterialEditorOptions : public UObject {
    /* 0x0030 */ bool bShowGrid;
    /* 0x0030 */ bool bHideUnusedConnectors;
    /* 0x0030 */ bool bRealtimeMaterialViewport;
    /* 0x0030 */ bool bRealtimeExpressionViewport;
    /* 0x0030 */ bool bLivePreviewUpdate;
    /* 0x0030 */ bool bHideUnrelatedNodes;
    /* 0x0030 */ bool bAlwaysRefreshAllPreviews;
    /* 0x0030 */ bool bUseUnsortedMenus;
    /* 0x0038 */ TArray<FString> FavoriteExpressions;
};

// Size: 0x78
class UMaterialEditorPreviewParameters : public UObject {
    /* 0x0030 */ TArray<FEditorParameterGroup> ParameterGroups;
    /* 0x0040 */ UMaterial* PreviewMaterial;
    /* 0x0048 */ UMaterialFunction* OriginalFunction;
    /* 0x0050 */ UMaterial* OriginalMaterial;
    /* 0x0058 */ TArray<UMaterialInstanceConstant*> StoredLayerPreviews;
    /* 0x0068 */ TArray<UMaterialInstanceConstant*> StoredBlendPreviews;
};

// Size: 0x90
class UMaterialFactoryNew : public UFactory {
    /* 0x0088 */ UTexture* InitialTexture;
};

// Size: 0x88
class UMaterialFunctionFactoryNew : public UFactory {
};

// Size: 0x90
class UMaterialFunctionInstanceFactory : public UFactory {
    /* 0x0088 */ UMaterialFunctionInterface* InitialParent;
};

// Size: 0x88
class UMaterialFunctionMaterialLayerBlendFactory : public UFactory {
};

// Size: 0x90
class UMaterialFunctionMaterialLayerBlendInstanceFactory : public UMaterialFunctionInstanceFactory {
};

// Size: 0x88
class UMaterialFunctionMaterialLayerFactory : public UFactory {
};

// Size: 0x90
class UMaterialFunctionMaterialLayerInstanceFactory : public UMaterialFunctionInstanceFactory {
};

// Size: 0x40
class UMaterialFunctionThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x118
class UMaterialGraph : public UEdGraph {
    /* 0x00b0 */ UMaterial* Material;
    /* 0x00b8 */ UMaterialFunction* MaterialFunction;
    /* 0x00c0 */ UMaterialGraphNode_Root* RootNode;
    /* 0x0108 */ FString OriginalMaterialFullName;
};

// Size: 0x108
class UMaterialGraphNode : public UMaterialGraphNode_Base {
    /* 0x00c8 */ UMaterialExpression* MaterialExpression;
};

// Size: 0xc8
class UMaterialGraphNode_Base : public UEdGraphNode {
};

// Size: 0x130
class UMaterialGraphNode_Comment : public UEdGraphNode_Comment {
    /* 0x0118 */ UMaterialExpressionComment* MaterialExpressionComment;
};

// Size: 0x108
class UMaterialGraphNode_Knot : public UMaterialGraphNode {
};

// Size: 0xd0
class UMaterialGraphNode_Root : public UMaterialGraphNode_Base {
    /* 0x00c8 */ UMaterial* Material;
};

// Size: 0x30
class UMaterialGraphSchema : public UEdGraphSchema {
};

// Size: 0x100
struct FMaterialGraphSchemaAction_NewComment : public FEdGraphSchemaAction {
};

// Size: 0x110
struct FMaterialGraphSchemaAction_NewFunctionCall : public FEdGraphSchemaAction {
    /* 0x0100 */ FString FunctionPath;
};

// Size: 0x108
struct FMaterialGraphSchemaAction_NewNamedRerouteUsage : public FEdGraphSchemaAction {
    /* 0x0100 */ UMaterialExpressionNamedRerouteDeclaration* Declaration;
};

// Size: 0x108
struct FMaterialGraphSchemaAction_NewNode : public FEdGraphSchemaAction {
    /* 0x0100 */ UClass* MaterialExpressionClass;
};

// Size: 0x100
struct FMaterialGraphSchemaAction_Paste : public FEdGraphSchemaAction {
};

// Size: 0x30
class UMaterialImportHelpers : public UObject {

    static UMaterialInterface* FindExistingMaterial(FString BasePath, FString MaterialFullName, const bool bRecursivePaths, FText& OutError);
    static UMaterialInterface* FindExistingMaterialFromSearchLocation(FString MaterialFullName, FString BasePackagePath, EMaterialSearchLocation SearchLocation, FText& OutError);
};

// Size: 0x90
class UMaterialInstanceConstantFactoryNew : public UFactory {
    /* 0x0088 */ UMaterialInterface* InitialParent;
};

// Size: 0x50
class UMaterialInstanceThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x88
class UMaterialParameterCollectionFactoryNew : public UFactory {
};

// Size: 0x108
class UMaterialStatsOptions : public UObject {
    /* 0x0030 */ int32_t bPlatformUsed[49];
    /* 0x00f4 */ int32_t bMaterialQualityUsed[4];
};

// Size: 0x88
class UMergeShaderPipelineCachesCommandlet : public UCommandlet {
};

// Size: 0x18
struct FMode2DLayer {
    /* 0x0000 */ FString Name;
    /* 0x0010 */ float Depth;
};

// Size: 0x80
class UModelExporterT3D : public UExporter {
};

// Size: 0x88
class UModelFactory : public UFactory {
};

// Size: 0x88
class UNativeCodeGenCommandlet : public UCommandlet {
};

// Size: 0xc
struct FNetworkEmulationPacketSettings {
    /* 0x0000 */ int32_t MinLatency;
    /* 0x0004 */ int32_t MaxLatency;
    /* 0x0008 */ int32_t PacketLossPercentage;
};

enum class NetworkEmulationTarget {
    Server = 0,
    Client = 1,
    Any = 2,
    NetworkEmulationTarget_MAX = 3,
};

// Size: 0x80
class UObjectExporterT3D : public UExporter {
};

// Size: 0x88
class UObjectLibraryFactory : public UFactory {
};

// Size: 0x30
struct FPIELoginInfo {
    /* 0x0000 */ FString Type;
    /* 0x0010 */ FString ID;
    /* 0x0020 */ FString Token;
};

// Size: 0x88
class UPackFactory : public UFactory {
};

// Size: 0x88
class UPackageFactory : public UFactory {
};

// Size: 0x30
class UPackageTools : public UObject {

    static FString SanitizePackageName(FString InPackageName);
};

// Size: 0xd8
class UPanelExtensionSubsystem : public UEditorSubsystem {
};

// Size: 0x480
class UParticleSystemAuditCommandlet : public UCommandlet {
    /* 0x0448 */ float HighSpawnRateOrBurstThreshold;
    /* 0x044c */ float FarLODDistanceTheshold;
};

// Size: 0x88
class UParticleSystemFactoryNew : public UFactory {
};

// Size: 0x48
class UParticleSystemThumbnailRenderer : public UTextureThumbnailRenderer {
    /* 0x0030 */ UTexture2D* NoImage;
    /* 0x0038 */ UTexture2D* OutOfDate;
};

// Size: 0xb0
class UPersonaOptions : public UObject {
    /* 0x0030 */ bool bAutoAlignFloorToMesh;
    /* 0x0030 */ bool bShowGrid;
    /* 0x0030 */ bool bHighlightOrigin;
    /* 0x0030 */ bool bMuteAudio;
    /* 0x0030 */ bool bUseAudioAttenuation;
    /* 0x0034 */ int32_t ShowMeshStats;
    /* 0x0038 */ uint32_t DefaultLocalAxesSelection;
    /* 0x003c */ uint32_t DefaultBoneDrawSelection;
    /* 0x0040 */ FLinearColor SectionTimingNodeColor;
    /* 0x0050 */ FLinearColor NotifyTimingNodeColor;
    /* 0x0060 */ FLinearColor BranchingPointTimingNodeColor;
    /* 0x0070 */ bool bUseInlineSocketEditor;
    /* 0x0071 */ bool bFlattenSkeletonHierarchyWhenFiltering;
    /* 0x0072 */ bool bHideParentsWhenFiltering;
    /* 0x0073 */ bool bAllowPreviewMeshCollectionsToSelectFromDifferentSkeletons;
    /* 0x0074 */ bool bAllowPreviewMeshCollectionsToUseCustomAnimBP;
    /* 0x0075 */ bool bAllowMeshSectionSelection;
    /* 0x0078 */ uint32_t NumFolderFiltersInAssetBrowser;
    /* 0x0080 */ TArray<FAssetEditorOptions> AssetEditorOptions;
    /* 0x0090 */ float CurveEditorSnapInterval;
    /* 0x0094 */ int32_t TimelineScrubSnapValue;
    /* 0x0098 */ EFrameNumberDisplayFormats TimelineDisplayFormat;
    /* 0x0099 */ bool bTimelineDisplayPercentage;
    /* 0x009a */ bool bTimelineDisplayFormatSecondary;
    /* 0x009b */ bool bTimelineDisplayCurveKeys;
    /* 0x00a0 */ TArray<FName> TimelineEnabledSnaps;
};

// Size: 0x18
struct FPhysAssetCreateParams {
    /* 0x0000 */ float MinBoneSize;
    /* 0x0004 */ float MinWeldSize;
    /* 0x0008 */ uint8_t GeomType;
    /* 0x0009 */ uint8_t VertWeight;
    /* 0x000a */ bool bAutoOrientToBone;
    /* 0x000b */ bool bCreateConstraints;
    /* 0x000c */ bool bWalkPastSmall;
    /* 0x000d */ bool bBodyForAll;
    /* 0x000e */ bool bDisableCollisionsByDefault;
    /* 0x000f */ uint8_t AngularConstraintMode;
    /* 0x0010 */ int32_t HullCount;
    /* 0x0014 */ int32_t MaxHullVerts;
};

// Size: 0x90
class UPhysicalMaterialFactoryNew : public UFactory {
    /* 0x0088 */ UClass* PhysicalMaterialClass;
};

// Size: 0xb0
class UPhysicalMaterialMaskFactory : public UFactory {
    /* 0x00a8 */ UClass* PhysicalMaterialMaskClass;
};

// Size: 0x30
class UPhysicalMaterialMaskThumbnailRenderer : public UTextureThumbnailRenderer {
};

// Size: 0x80
class UPhysicsAssetEditorOptions : public UObject {
    /* 0x0030 */ float PhysicsBlend;
    /* 0x0034 */ bool bUpdateJointsFromAnimation;
    /* 0x0035 */ uint8_t PhysicsUpdateMode;
    /* 0x0038 */ float PokePauseTime;
    /* 0x003c */ float PokeBlendTime;
    /* 0x0040 */ float GravScale;
    /* 0x0044 */ float GravityOverrideZ;
    /* 0x0048 */ bool bUseGravityOverride;
    /* 0x004c */ int32_t MaxFPS;
    /* 0x0050 */ float HandleLinearDamping;
    /* 0x0054 */ float HandleLinearStiffness;
    /* 0x0058 */ float HandleAngularDamping;
    /* 0x005c */ float HandleAngularStiffness;
    /* 0x0060 */ float InterpolationSpeed;
    /* 0x0064 */ float PokeStrength;
    /* 0x0068 */ bool bShowConstraintsAsPoints;
    /* 0x0068 */ bool bRenderOnlySelectedConstraints;
    /* 0x006c */ float ConstraintDrawSize;
    /* 0x0070 */ EPhysicsAssetEditorRenderMode MeshViewMode;
    /* 0x0071 */ EPhysicsAssetEditorRenderMode CollisionViewMode;
    /* 0x0072 */ EPhysicsAssetEditorConstraintViewMode ConstraintViewMode;
    /* 0x0073 */ EPhysicsAssetEditorRenderMode SimulationMeshViewMode;
    /* 0x0074 */ EPhysicsAssetEditorRenderMode SimulationCollisionViewMode;
    /* 0x0075 */ EPhysicsAssetEditorConstraintViewMode SimulationConstraintViewMode;
    /* 0x0078 */ float CollisionOpacity;
    /* 0x007c */ bool bSolidRenderingForSelectedOnly;
    /* 0x007d */ bool bHideSimulatedBodies;
    /* 0x007e */ bool bHideKinematicBodies;
    /* 0x007f */ bool bResetClothWhenSimulating;
};

// Size: 0xa0
class UPhysicsAssetFactory : public UFactory {
    /* 0x0088 */ USkeletalMesh* TargetSkeletalMesh;
};

// Size: 0x48
class UPhysicsAssetGenerationSettings : public UObject {
    /* 0x0030 */ FPhysAssetCreateParams CreateParams;
};

// Size: 0x40
class UPhysicsAssetThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x88
class UPkgInfoCommandlet : public UCommandlet {
};

// Size: 0x50
struct FPlayScreenResolution {
    /* 0x0000 */ FString Description;
    /* 0x0010 */ int32_t Width;
    /* 0x0014 */ int32_t Height;
    /* 0x0018 */ FString AspectRatio;
    /* 0x0028 */ bool bCanSwapAspectRatio;
    /* 0x0030 */ FString ProfileName;
    /* 0x0040 */ float ScaleFactor;
    /* 0x0044 */ int32_t LogicalHeight;
    /* 0x0048 */ int32_t LogicalWidth;
};

// Size: 0x80
class UPolysExporterOBJ : public UExporter {
};

// Size: 0x80
class UPolysExporterT3D : public UExporter {
};

// Size: 0x88
class UPolysFactory : public UFactory {
};

// Size: 0x88
class UPopulateDialogueWaveFromCharacterSheetCommandlet : public UCommandlet {
};

// Size: 0xb0
class UPoseAssetFactory : public UFactory {
    /* 0x0088 */ UAnimSequence* SourceAnimation;
    /* 0x0090 */ TArray<FString> PoseNames;
    /* 0x00a0 */ USkeleton* TargetSkeleton;
    /* 0x00a8 */ USkeletalMesh* PreviewSkeletalMesh;
};

// Size: 0xe78
class UPreviewMaterial : public UMaterial {
};

// Size: 0x90
class UPreviewMeshCollectionFactory : public UFactory {
    /* 0x0088 */ TWeakObjectPtr<USkeleton> CurrentSkeleton;
};

// Size: 0x240
class UProjectPackagingSettings : public UObject {
    /* 0x0030 */ EProjectPackagingBuild Build;
    /* 0x0034 */ uint8_t BuildConfiguration;
    /* 0x0038 */ FString BuildTarget;
    /* 0x0048 */ FDirectoryPath StagingDirectory;
    /* 0x0058 */ bool FullRebuild;
    /* 0x0059 */ bool ForDistribution;
    /* 0x005a */ bool IncludeDebugFiles;
    /* 0x005b */ EProjectPackagingBlueprintNativizationMethod BlueprintNativizationMethod;
    /* 0x0060 */ TArray<FFilePath> NativizeBlueprintAssets;
    /* 0x0070 */ bool bIncludeNativizedAssetsInProjectGeneration;
    /* 0x0071 */ bool bExcludeMonolithicEngineHeadersInNativizedCode;
    /* 0x0072 */ bool UsePakFile;
    /* 0x0073 */ bool bUseIoStore;
    /* 0x0074 */ bool bMakeBinaryConfig;
    /* 0x0075 */ bool bGenerateChunks;
    /* 0x0076 */ bool bGenerateNoChunks;
    /* 0x0077 */ bool bChunkHardReferencesOnly;
    /* 0x0078 */ bool bForceOneChunkPerFile;
    /* 0x0080 */ int64_t MaxChunkSize;
    /* 0x0088 */ bool bBuildHttpChunkInstallData;
    /* 0x0090 */ FDirectoryPath HttpChunkInstallDataDirectory;
    /* 0x00a0 */ bool bCompressed;
    /* 0x00a8 */ FString PakFileCompressionFormats;
    /* 0x00b8 */ bool bForceUseProjectCompressionFormatIgnoreHardwareOverride;
    /* 0x00c0 */ FString PakFileAdditionalCompressionOptions;
    /* 0x00d0 */ FString PakFileCompressionMethod;
    /* 0x00e0 */ int32_t PakFileCompressionLevel_DebugDevelopment;
    /* 0x00e4 */ int32_t PakFileCompressionLevel_TestShipping;
    /* 0x00e8 */ int32_t PakFileCompressionLevel_Distribution;
    /* 0x00f0 */ FString HttpChunkInstallDataVersion;
    /* 0x0100 */ bool IncludePrerequisites;
    /* 0x0101 */ bool IncludeAppLocalPrerequisites;
    /* 0x0102 */ bool bShareMaterialShaderCode;
    /* 0x0103 */ bool bDeterministicShaderCodeOrder;
    /* 0x0104 */ bool bSharedMaterialNativeLibraries;
    /* 0x0108 */ FDirectoryPath ApplocalPrerequisitesDirectory;
    /* 0x0118 */ bool IncludeCrashReporter;
    /* 0x0119 */ EProjectPackagingInternationalizationPresets InternationalizationPreset;
    /* 0x0120 */ TArray<FString> CulturesToStage;
    /* 0x0130 */ TArray<FString> LocalizationTargetsToChunk;
    /* 0x0140 */ int32_t LocalizationTargetCatchAllChunkId;
    /* 0x0144 */ bool bCookAll;
    /* 0x0145 */ bool bCookMapsOnly;
    /* 0x0146 */ bool bEncryptIniFiles;
    /* 0x0147 */ bool bEncryptPakIndex;
    /* 0x0148 */ bool GenerateEarlyDownloaderPakFile;
    /* 0x0149 */ bool bSkipEditorContent;
    /* 0x014a */ bool bSkipMovies;
    /* 0x0150 */ TArray<FString> UFSMovies;
    /* 0x0160 */ TArray<FString> NonUFSMovies;
    /* 0x0170 */ TArray<FString> CompressedChunkWildcard;
    /* 0x0180 */ TArray<FString> IniKeyBlacklist;
    /* 0x0190 */ TArray<FString> IniSectionBlacklist;
    /* 0x01a0 */ TArray<FString> EarlyDownloaderPakFileFiles;
    /* 0x01b0 */ TArray<FFilePath> MapsToCook;
    /* 0x01c0 */ TArray<FDirectoryPath> DirectoriesToAlwaysCook;
    /* 0x01d0 */ TArray<FDirectoryPath> DirectoriesToNeverCook;
    /* 0x01e0 */ TArray<FDirectoryPath> TestDirectoriesToNotSearch;
    /* 0x01f0 */ TArray<FDirectoryPath> DirectoriesToAlwaysStageAsUFS;
    /* 0x0200 */ TArray<FDirectoryPath> DirectoriesToAlwaysStageAsNonUFS;
    /* 0x0210 */ TArray<FDirectoryPath> DirectoriesToAlwaysStageAsUFSServer;
    /* 0x0220 */ TArray<FDirectoryPath> DirectoriesToAlwaysStageAsNonUFSServer;
};

// Size: 0x18
struct FPropertyEditTestTextStruct {
    /* 0x0000 */ FText NormalProperty;
};

// Size: 0x48
struct FPropertyEditorTestBasicStruct {
    /* 0x0000 */ int32_t IntPropertyInsideAStruct;
    /* 0x0004 */ float FloatPropertyInsideAStruct;
    /* 0x0008 */ UObject* ObjectPropertyInsideAStruct;
    /* 0x0010 */ FPropertyEditorTestSubStruct InnerStruct;
};

enum class PropertyEditorTestBitflags {
    First = 0,
    Second = 1,
    Third = 2,
    Hidden = 3,
    PropertyEditorTestBitflags_MAX = 4,
};

enum class PropertyEditorTestEnum {
    PropertyEditorTest_Enum1 = 0,
    PropertyEditorTest_Enum2 = 1,
    PropertyEditorTest_Enum3 = 2,
    PropertyEditorTest_Enum4 = 3,
    PropertyEditorTest_Enum5 = 4,
    PropertyEditorTest_Enum6 = 5,
    PropertyEditorTest_MAX = 6,
};

// Size: 0x8
struct FPropertyEditorTestInlineEditCondition {
    /* 0x0000 */ bool InlineEditCondition;
    /* 0x0004 */ int32_t HasInlineEditCondition;
};

// Size: 0x38
class UPropertyEditorTestInstancedObject : public UObject {
    /* 0x0030 */ int32_t Number;
};

// Size: 0x8
struct FPropertyEditorTestInstancedStruct {
    /* 0x0000 */ UPropertyEditorTestInstancedObject* Object;
};

// Size: 0x1070
class UPropertyEditorTestObject : public UObject {
    /* 0x0030 */ int8_t Int8Property;
    /* 0x0032 */ int16_t Int16Property;
    /* 0x0034 */ int32_t Int32Property;
    /* 0x0038 */ int64_t Int64Property;
    /* 0x0040 */ uint8_t ByteProperty;
    /* 0x0042 */ uint16_t UnsignedInt16Property;
    /* 0x0044 */ uint32_t UnsignedInt32Property;
    /* 0x0048 */ uint64_t UnsignedInt64Property;
    /* 0x0050 */ float FloatProperty;
    /* 0x0058 */ double DoubleProperty;
    /* 0x0060 */ FName NameProperty;
    /* 0x006c */ bool BoolProperty;
    /* 0x0070 */ FString StringProperty;
    /* 0x0080 */ FText TextProperty;
    /* 0x0098 */ FIntPoint IntPointProperty;
    /* 0x00a0 */ FVector Vector3Property;
    /* 0x00ac */ FVector2D Vector2Property;
    /* 0x00c0 */ FVector4 Vector4Property;
    /* 0x00d0 */ FRotator RotatorProperty;
    /* 0x00e0 */ UObject* ObjectProperty;
    /* 0x00e8 */ FLinearColor LinearColorProperty;
    /* 0x00f8 */ FColor ColorProperty;
    /* 0x00fc */ uint8_t EnumByteProperty;
    /* 0x00fd */ EditColor EnumProperty;
    /* 0x0100 */ FMatrix MatrixProperty;
    /* 0x0140 */ FTransform TransformProperty;
    /* 0x0170 */ UClass* ClassProperty;
    /* 0x0178 */ UClass* ClassPropertyWithAllowed;
    /* 0x0180 */ UClass* ClassPropertyWithDisallowed;
    /* 0x0188 */ UClass* SubclassOfTexture;
    /* 0x0190 */ UClass* SubclassOfWithAllowed;
    /* 0x0198 */ UClass* SubclassOfWithDisallowed;
    /* 0x01a0 */ TSoftObjectPtr<UObject> AssetPointerWithAllowedAndWhitespace;
    /* 0x01d0 */ TArray<int32_t> IntProperty32Array;
    /* 0x01e0 */ TArray<uint8_t> BytePropertyArray;
    /* 0x01f0 */ TArray<float> FloatPropertyArray;
    /* 0x0200 */ TArray<FName> NamePropertyArray;
    /* 0x0210 */ TArray<bool> BoolPropertyArray;
    /* 0x0220 */ TArray<FString> StringPropertyArray;
    /* 0x0230 */ TArray<FText> TextPropertyArray;
    /* 0x0240 */ TArray<FVector> Vector3PropertyArray;
    /* 0x0250 */ TArray<FVector2D> Vector2PropertyArray;
    /* 0x0260 */ TArray<FVector4> Vector4PropertyArray;
    /* 0x0270 */ TArray<FRotator> RotatorPropertyArray;
    /* 0x0280 */ TArray<UObject*> ObjectPropertyArray;
    /* 0x0290 */ TArray<AActor*> ActorPropertyArray;
    /* 0x02a0 */ TArray<FLinearColor> LinearColorPropertyArray;
    /* 0x02b0 */ TArray<FColor> ColorPropertyArray;
    /* 0x02c0 */ TArray<uint8_t> EnumPropertyArray;
    /* 0x02d0 */ TArray<FPropertyEditorTestBasicStruct> StructPropertyArray;
    /* 0x02e0 */ TArray<FPropertyEditorTestBasicStruct> StructPropertyArrayWithTitle;
    /* 0x02f0 */ TArray<FPropertyEditorTestInstancedStruct> InstancedStructArray;
    /* 0x0300 */ TArray<UPropertyEditorTestInstancedObject*> InstancedUObjectArray;
    /* 0x0310 */ TArray<int32_t> FixedArrayOfInts;
    /* 0x0320 */ int32_t StaticArrayOfInts[5];
    /* 0x0334 */ int32_t StaticArrayOfIntsWithEnumLabels[6];
    /* 0x034c */ float FloatPropertyWithClampedRange;
    /* 0x0350 */ int32_t IntPropertyWithClampedRange;
    /* 0x0354 */ int32_t IntThatCannotBeChanged;
    /* 0x0358 */ FString StringThatCannotBeChanged;
    /* 0x0368 */ UPrimitiveComponent* ObjectThatCannotBeChanged;
    /* 0x0370 */ int32_t EnumBitflags;
    /* 0x0378 */ FString StringPasswordProperty;
    /* 0x0388 */ FText TextPasswordProperty;
    /* 0x03a0 */ FPropertyEditorTestBasicStruct ThisIsBrokenIfItsVisibleInADetailsView;
    /* 0x03e8 */ FPropertyEditorTestBasicStruct StructWithMultipleInstances1;
    /* 0x0430 */ bool bEditConditionStructWithMultipleInstances2;
    /* 0x0438 */ FPropertyEditorTestBasicStruct StructWithMultipleInstances2;
    /* 0x0480 */ FRichCurve RichCurve;
    /* 0x0500 */ FSoftObjectPath AssetReferenceCustomStruct;
    /* 0x0520 */ FSoftObjectPath AssetReferenceCustomStructWithThumbnail;
    /* 0x0540 */ FSoftObjectPath ExactlyPointLightActorReference;
    /* 0x0560 */ FSoftObjectPath LightActorReference;
    /* 0x0580 */ FSoftObjectPath ExactPointOrSpotLightActorReference;
    /* 0x05a0 */ FSoftObjectPath LightOrStaticMeshActorReference;
    /* 0x05c0 */ FSoftObjectPath NotLightActorReference;
    /* 0x05e0 */ FSoftObjectPath MaterialOrTextureAssetReference;
    /* 0x0600 */ FSoftObjectPath ActorWithMetaClass;
    /* 0x0620 */ FSoftObjectPath DisabledByCanEditChange;
    /* 0x0640 */ bool bEditCondition;
    /* 0x0644 */ int32_t SimplePropertyWithEditCondition;
    /* 0x0648 */ bool bEditConditionAssetReferenceCustomStructWithEditCondition;
    /* 0x0650 */ FSoftObjectPath AssetReferenceCustomStructWithEditCondition;
    /* 0x0670 */ TArray<FPropertyEditorTestBasicStruct> ArrayOfStructs;
    /* 0x0680 */ FPropertyEditTestTextStruct struct;
    /* 0x0698 */ UStaticMeshComponent* EditInlineNewStaticMeshComponent;
    /* 0x06a0 */ TArray<UStaticMeshComponent*> ArrayOfEditInlineNewSMCs;
    /* 0x06b0 */ UTexture* TextureProp;
    /* 0x06b8 */ UStaticMesh* StaticMeshProp;
    /* 0x06c0 */ UMaterialInterface* AnyMaterialInterface;
    /* 0x06c8 */ AActor* OnlyActorsAllowed;
    /* 0x06d0 */ TSet<int32_t> Int32Set;
    /* 0x0720 */ TSet<float> FloatSet;
    /* 0x0770 */ TSet<FString> StringSet;
    /* 0x07c0 */ TSet<UObject*> ObjectSet;
    /* 0x0810 */ TSet<AActor*> ActorSet;
    /* 0x0860 */ TSet<EditColor> EditColorSet;
    /* 0x08b0 */ TSet<FName> NameSet;
    /* 0x0900 */ TMap<int32_t, FString> Int32ToStringMap;
    /* 0x0950 */ TMap<FString, FLinearColor> StringToColorMap;
    /* 0x09a0 */ TMap<int32_t, FPropertyEditorTestBasicStruct> Int32ToStructMap;
    /* 0x09f0 */ TMap<FString, float> StringToFloatMap;
    /* 0x0a40 */ TMap<FString, UObject*> StringToObjectMap;
    /* 0x0a90 */ TMap<FString, AActor*> StringToActorMap;
    /* 0x0ae0 */ TMap<UObject*, int32_t> ObjectToInt32Map;
    /* 0x0b30 */ TMap<UObject*, FLinearColor> ObjectToColorMap;
    /* 0x0b80 */ TMap<int32_t, uint8_t> IntToEnumMap;
    /* 0x0bd0 */ TMap<FName, FName> NameToNameMap;
    /* 0x0c20 */ TMap<FName, UObject*> NameToObjectMap;
    /* 0x0c70 */ TMap<FName, FPropertyEditorTestBasicStruct> NameToCustomMap;
    /* 0x0cc0 */ TMap<FName, FLinearColor> NameToColorMap;
    /* 0x0d10 */ TMap<int32_t, FPropertyEditorTestBasicStruct> IntToCustomMap;
    /* 0x0d60 */ TMap<int32_t, FPropertyEditorTestSubStruct> IntToSubStructMap;
    /* 0x0db0 */ TSet<FLinearColor> LinearColorSet;
    /* 0x0e00 */ TSet<FVector> VectorSet;
    /* 0x0e50 */ TMap<FLinearColor, FString> LinearColorToStringMap;
    /* 0x0ea0 */ TMap<FVector, float> VectorToFloatMap;
    /* 0x0ef0 */ TMap<FLinearColor, FVector> LinearColorToVectorMap;
    /* 0x0f40 */ TScriptInterface<IBlendableInterface> BlendableInterface;
    /* 0x0f50 */ TScriptInterface<IAnimClassInterface> AnimClassInterface;
    /* 0x0f60 */ TScriptInterface<IBlendableInterface> LightPropagationVolumeBlendable;
    /* 0x0f70 */ UObject* TextureOrBlendableInterface;
    /* 0x0f78 */ bool bSubcategory;
    /* 0x0f79 */ bool bSubcategoryAdvanced;
    /* 0x0f7a */ bool bSubcategoryFooSimple;
    /* 0x0f7b */ bool bSubcategoryFooAdvanced;
    /* 0x0f7c */ bool bSubcategoryBarSimple;
    /* 0x0f7d */ bool bSubcategoryBarAdvanced;
    /* 0x0f7e */ bool bSubcategoryLast;
    /* 0x0f7f */ bool bEnablesNext;
    /* 0x0f80 */ bool bEnabledByPrevious;
    /* 0x0f81 */ EditColor EnumEditCondition;
    /* 0x0f82 */ bool bEnabledWhenBlue;
    /* 0x0f83 */ bool bEnabledWhenPink;
    /* 0x0f84 */ uint8_t EnumAsByteEditCondition;
    /* 0x0f85 */ bool bEnabledWhenEnumIs2;
    /* 0x0f86 */ bool bEnabledWhenEnumIs4;
    /* 0x0f88 */ int32_t IntegerEditCondition;
    /* 0x0f8c */ bool bEnabledWhenIntGreaterOrEqual5;
    /* 0x0f8d */ bool bEnabledWhenIntLessOrEqual10;
    /* 0x0f90 */ float FloatEditCondition;
    /* 0x0f94 */ bool bEnabledWhenFloatGreaterThan5;
    /* 0x0f95 */ bool bEnabledWhenFloatLessThan10;
    /* 0x0f96 */ bool bEditConditionForArrays;
    /* 0x0f98 */ TArray<UTexture2D*> ArrayWithEditCondition;
    /* 0x0fa8 */ TArray<FPropertyEditorTestBasicStruct> ArrayOfStructsWithEditCondition;
    /* 0x0fb8 */ bool bEditConditionForFixedArray;
    /* 0x0fc0 */ FString FixedArrayWithEditCondition[5];
    /* 0x1010 */ int64_t EditConditionFlags;
    /* 0x1018 */ bool bEnabledWhenFlagsHasTwoOrFour;
    /* 0x1019 */ bool bDisabledWhenFlagsIsOdd;
    /* 0x101a */ uint8_t InlineProperty;
    /* 0x101b */ uint8_t PropertyThatHides;
    /* 0x101c */ bool bVisibleWhenStatic;
    /* 0x1020 */ int32_t VisibleWhenStationary;
    /* 0x1028 */ FDateTime DateTime;
    /* 0x1030 */ bool bInlineEditConditionWithoutMetaToggle;
    /* 0x1034 */ float InlineEditConditionWithoutMeta;
    /* 0x1038 */ bool bInlineEditConditionWithMetaToggle;
    /* 0x103c */ float InlineEditConditionWithMeta;
    /* 0x1040 */ bool bInlineEditConditionNotEditable;
    /* 0x1044 */ float HasNonEditableInlineCondition;
    /* 0x1048 */ bool bSharedEditCondition;
    /* 0x104c */ float UsesSharedEditCondition1;
    /* 0x1050 */ float UsesSharedEditCondition2;
    /* 0x1054 */ FPropertyEditorTestInlineEditCondition StructWithInlineCondition;
    /* 0x1060 */ TArray<FPropertyEditorTestInlineEditCondition> ArrayOfStructsWithInlineCondition;
};

// Size: 0x38
struct FPropertyEditorTestSubStruct {
    /* 0x0000 */ int32_t FirstProperty;
    /* 0x0004 */ int32_t SecondProperty;
    /* 0x0008 */ FLinearColor CustomizedStructInsideUncustomizedStruct;
    /* 0x0018 */ FSoftObjectPath CustomizedStructInsideUncustomizedStruct2;
};

// Size: 0x10
struct FPropertyNameAndIndex {
    /* 0x0000 */ FName Name;
    /* 0x000c */ int32_t index;
};

// Size: 0xe0
class UReimportCurveFactory : public UCSVImportFactory {
};

// Size: 0xe0
class UReimportCurveTableFactory : public UCSVImportFactory {
};

// Size: 0xe0
class UReimportDataTableFactory : public UCSVImportFactory {
};

// Size: 0xc0
class UReimportFbxAnimSequenceFactory : public UFbxFactory {
};

// Size: 0x1d0
class UReimportFbxSceneFactory : public UFbxSceneImportFactory {

    void ScriptReimportHelper(UObject* Obj);
};

// Size: 0xc0
class UReimportFbxSkeletalMeshFactory : public UFbxFactory {
};

// Size: 0xc0
class UReimportFbxStaticMeshFactory : public UFbxFactory {
};

// Size: 0x120
class UReimportTextureFactory : public UTextureFactory {
    /* 0x0110 */ UTexture* pOriginalTex;
};

// Size: 0xa8
class UReimportVectorFieldStaticFactory : public UVectorFieldStaticFactory {
};

// Size: 0x80
class URenderTargetExporterHDR : public UExporter {
};

// Size: 0x88
class UReplaceActorCommandlet : public UCommandlet {
};

// Size: 0x88
class UReplaceAssetsCommandlet : public UCommandlet {
};

// Size: 0x1a0
class UResavePackagesCommandlet : public UCommandlet {
};

// Size: 0xa0
class USavePackageUtilitiesCommandlet : public UCommandlet {
};

// Size: 0x68
struct FScalarParameterAtlasData {
    /* 0x0000 */ bool bIsUsedAsAtlasPosition;
    /* 0x0008 */ TSoftObjectPtr<UCurveLinearColor> Curve;
    /* 0x0038 */ TSoftObjectPtr<UCurveLinearColorAtlas> Atlas;
};

// Size: 0x88
class USceneImportFactory : public UFactory {
};

// Size: 0x40
class USceneThumbnailInfo : public UThumbnailInfo {
    /* 0x0030 */ float OrbitPitch;
    /* 0x0034 */ float OrbitYaw;
    /* 0x0038 */ float OrbitZoom;
};

// Size: 0x70
class USceneThumbnailInfoWithPrimitive : public USceneThumbnailInfo {
    /* 0x0040 */ uint8_t PrimitiveType;
    /* 0x0048 */ FSoftObjectPath PreviewMesh;
    /* 0x0068 */ bool bUserModifiedShape;
};

// Size: 0x10
struct FSelectedSocketInfo {
};

// Size: 0x20
struct FSelectionStateOfLevel {
    /* 0x0000 */ TArray<FString> SelectedActors;
    /* 0x0010 */ TArray<FString> SelectedComponents;
};

// Size: 0x80
class USequenceExporterT3D : public UExporter {
};

// Size: 0x88
class UShaderCodeLibraryToolsCommandlet : public UCommandlet {
};

// Size: 0x88
class UShaderPipelineCacheToolsCommandlet : public UCommandlet {
};

// Size: 0xa8
class USheetBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ int32_t X;
    /* 0x008c */ int32_t Y;
    /* 0x0090 */ int32_t XSegments;
    /* 0x0094 */ int32_t YSegments;
    /* 0x0098 */ uint8_t Axis;
    /* 0x009c */ FName GroupName;
};

// Size: 0x50
class USkeletalMeshEditorSettings : public UObject {
    /* 0x0030 */ FColor AnimPreviewFloorColor;
    /* 0x0034 */ FColor AnimPreviewSkyColor;
    /* 0x0038 */ float AnimPreviewSkyBrightness;
    /* 0x003c */ float AnimPreviewLightBrightness;
    /* 0x0040 */ FRotator AnimPreviewLightingDirection;
    /* 0x004c */ FColor AnimPreviewDirectionalColor;
};

// Size: 0x80
class USkeletalMeshExporterFBX : public UExporterFBX {
};

// Size: 0x40
class USkeletalMeshThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x40
class USkeletalMeshToolMenuContext : public UObject {
};

// Size: 0xa0
class USkeletonFactory : public UFactory {
    /* 0x0088 */ USkeletalMesh* TargetSkeletalMesh;
};

// Size: 0x90
class USlateBrushAssetFactory : public UFactory {
    /* 0x0088 */ UTexture2D* InitialTexture;
};

// Size: 0x38
class USlateBrushThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x38
struct FSlatePlayInEditorInfo {
};

// Size: 0x90
class USlateWidgetStyleAssetFactory : public UFactory {
    /* 0x0088 */ UClass* StyleType;
};

// Size: 0xc
struct FSnapToSurfaceSettings {
    /* 0x0000 */ bool bEnabled;
    /* 0x0004 */ float SnapOffsetExtent;
    /* 0x0008 */ bool bSnapRotation;
};

// Size: 0x80
class USoundExporterOGG : public UExporter {
};

// Size: 0x80
class USoundExporterWAV : public UExporter {
};

// Size: 0x80
class USoundSurroundExporterWAV : public UExporter {
};

// Size: 0x38
class USoundWaveThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0xb0
class USpiralStairBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ int32_t InnerRadius;
    /* 0x008c */ int32_t StepWidth;
    /* 0x0090 */ int32_t StepHeight;
    /* 0x0094 */ int32_t StepThickness;
    /* 0x0098 */ int32_t NumStepsPer360;
    /* 0x009c */ int32_t NumSteps;
    /* 0x00a0 */ FName GroupName;
    /* 0x00ac */ bool SlopedCeiling;
    /* 0x00ac */ bool SlopedFloor;
    /* 0x00ac */ bool CounterClockwise;
};

// Size: 0x88
class UStabilizeLocalizationKeysCommandlet : public UCommandlet {
};

// Size: 0x80
class UStaticMeshExporterFBX : public UExporterFBX {
};

// Size: 0x80
class UStaticMeshExporterOBJ : public UExporter {
};

// Size: 0x40
class UStaticMeshThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x88
class UStringTableFactory : public UFactory {
};

// Size: 0xd0
struct FStructVariableDescription {
    /* 0x0000 */ FName VarName;
    /* 0x000c */ FGuid VarGuid;
    /* 0x0020 */ FString FriendlyName;
    /* 0x0030 */ FString DefaultValue;
    /* 0x0040 */ FName Category;
    /* 0x004c */ FName SubCategory;
    /* 0x0058 */ TSoftObjectPtr<UObject> SubCategoryObject;
    /* 0x0088 */ FEdGraphTerminalType PinValueType;
    /* 0x00ac */ EPinContainerType ContainerType;
    /* 0x00ad */ bool bIsArray;
    /* 0x00ad */ bool bIsSet;
    /* 0x00ad */ bool bIsMap;
    /* 0x00ad */ bool bInvalidMember;
    /* 0x00ad */ bool bDontEditOnInstance;
    /* 0x00ad */ bool bEnableSaveGame;
    /* 0x00ad */ bool bEnableMultiLineText;
    /* 0x00ad */ bool bEnable3dWidget;
    /* 0x00b0 */ FString CurrentDefaultValue;
    /* 0x00c0 */ FString Tooltip;
};

// Size: 0x38
class UStructViewerSettings : public UObject {
    /* 0x0030 */ bool DisplayInternalStructs;
    /* 0x0031 */ EStructViewerDeveloperType DeveloperFolderType;
};

// Size: 0x88
class UStructureFactory : public UFactory {
};

// Size: 0x90
class USubUVAnimationFactory : public UFactory {
    /* 0x0088 */ UTexture2D* InitialTexture;
};

// Size: 0x88
class USubsurfaceProfileFactory : public UFactory {
};

// Size: 0x30
class USubsurfaceProfileRenderer : public UTextureThumbnailRenderer {
};

// Size: 0x88
class USwapSoundForDialogueInCuesCommandlet : public UCommandlet {
};

// Size: 0x18
struct FTemplateMapInfo {
    /* 0x0000 */ UTexture2D* ThumbnailTexture;
    /* 0x0008 */ FString Map;
};

// Size: 0x30
class UTemplateMapMetadata : public UObject {
};

// Size: 0x30
class UTestSparseClassData : public UTestSparseClassDataBase {
};

// Size: 0x30
class UTestSparseClassDataBase : public UObject {
};

// Size: 0x50
struct FTestSparseClassDataStorage {
    /* 0x0000 */ TMap<int32_t, int32_t> Map;
};

// Size: 0xa0
class UTetrahedronBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ float Radius;
    /* 0x008c */ int32_t SphereExtrapolation;
    /* 0x0090 */ FName GroupName;
};

// Size: 0x50
class UTexAligner : public UObject {
    /* 0x0030 */ uint8_t DefTexAlign;
    /* 0x0031 */ uint8_t TAxis;
    /* 0x0034 */ float UTile;
    /* 0x0038 */ float VTile;
    /* 0x0040 */ FString Desc;
};

// Size: 0x50
class UTexAlignerBox : public UTexAligner {
};

// Size: 0x50
class UTexAlignerDefault : public UTexAligner {
};

// Size: 0x50
class UTexAlignerFit : public UTexAligner {
};

// Size: 0x50
class UTexAlignerPlanar : public UTexAligner {
};

// Size: 0x88
class UTextAssetCommandlet : public UCommandlet {
};

// Size: 0x80
class UTextBufferExporterTXT : public UExporter {
};

// Size: 0x98
class UTexture2DArrayFactory : public UFactory {
    /* 0x0088 */ TArray<UTexture2D*> InitialTextures;
};

// Size: 0x30
class UTexture2DArrayThumbnailRenderer : public UTextureThumbnailRenderer {
};

// Size: 0x90
class UTexture2DFactoryNew : public UFactory {
    /* 0x0088 */ int32_t Width;
    /* 0x008c */ int32_t Height;
};

// Size: 0x80
class UTextureCubeExporterHDR : public UExporter {
};

// Size: 0x30
class UTextureCubeThumbnailRenderer : public UTextureThumbnailRenderer {
};

// Size: 0x80
class UTextureExporterBMP : public UExporter {
};

// Size: 0x80
class UTextureExporterHDR : public UExporter {
};

// Size: 0x80
class UTextureExporterPCX : public UExporter {
};

// Size: 0x80
class UTextureExporterTGA : public UExporter {
};

// Size: 0xf0
class UTextureFactory : public UFactory {
    /* 0x0090 */ bool NoCompression;
    /* 0x0090 */ bool NoAlpha;
    /* 0x0090 */ bool bDeferCompression;
    /* 0x0094 */ uint8_t CompressionSettings;
    /* 0x0098 */ bool bCreateMaterial;
    /* 0x0098 */ bool bRGBToBaseColor;
    /* 0x0098 */ bool bRGBToEmissive;
    /* 0x0098 */ bool bAlphaToRoughness;
    /* 0x0098 */ bool bAlphaToEmissive;
    /* 0x0098 */ bool bAlphaToOpacity;
    /* 0x0098 */ bool bAlphaToOpacityMask;
    /* 0x0098 */ bool bTwoSided;
    /* 0x009c */ uint8_t Blending;
    /* 0x009d */ uint8_t ShadingModel;
    /* 0x009e */ uint8_t MipGenSettings;
    /* 0x009f */ uint8_t LODGroup;
    /* 0x00a0 */ bool bDitherMipMapAlpha;
    /* 0x00b0 */ FVector4 AlphaCoverageThresholds;
    /* 0x00c0 */ bool bPreserveBorder;
    /* 0x00c0 */ bool bFlipNormalMapGreenChannel;
    /* 0x00c0 */ bool bUsingExistingSettings;
    /* 0x00c0 */ bool bUseHashAsGuid;
    /* 0x00c8 */ FString UdimRegexPattern;
    /* 0x00d8 */ ETextureSourceColorSpace ColorSpaceMode;
};

// Size: 0x68
class UTextureImportSettings : public UDeveloperSettings {
    /* 0x0060 */ int32_t AutoVTSize;
};

// Size: 0x98
class UTextureRenderTarget2DArrayFactoryNew : public UFactory {
    /* 0x0088 */ int32_t Width;
    /* 0x008c */ int32_t Height;
    /* 0x0090 */ int32_t Slices;
    /* 0x0094 */ uint8_t Format;
};

// Size: 0x90
class UTextureRenderTargetCubeFactoryNew : public UFactory {
    /* 0x0088 */ int32_t Width;
    /* 0x008c */ uint8_t Format;
};

// Size: 0x98
class UTextureRenderTargetFactoryNew : public UFactory {
    /* 0x0088 */ int32_t Width;
    /* 0x008c */ int32_t Height;
    /* 0x0090 */ uint8_t Format;
};

// Size: 0x98
class UTextureRenderTargetVolumeFactoryNew : public UFactory {
    /* 0x0088 */ int32_t Width;
    /* 0x008c */ int32_t Height;
    /* 0x0090 */ int32_t Depth;
    /* 0x0094 */ uint8_t Format;
};

// Size: 0x30
class UTextureThumbnailRenderer : public UThumbnailRenderer {
};

// Size: 0x118
class UThumbnailManager : public UObject {
    /* 0x0030 */ TArray<FThumbnailRenderingInfo> RenderableThumbnailTypes;
    /* 0x0098 */ FThumbnailRenderingInfo NotSupported;
    /* 0x00c8 */ UStaticMesh* EditorCube;
    /* 0x00d0 */ UStaticMesh* EditorSphere;
    /* 0x00d8 */ UStaticMesh* EditorCylinder;
    /* 0x00e0 */ UStaticMesh* EditorPlane;
    /* 0x00e8 */ UStaticMesh* EditorSkySphere;
    /* 0x00f0 */ UMaterial* FloorPlaneMaterial;
    /* 0x00f8 */ UTextureCube* AmbientCubemap;
    /* 0x0100 */ UTexture2D* CheckerboardTexture;
    /* 0x0108 */ FString ThumbnailManagerClassName;
};

// Size: 0x30
class UThumbnailRenderer : public UObject {
};

// Size: 0x30
struct FThumbnailRenderingInfo {
    /* 0x0000 */ FString ClassNeedingThumbnailName;
    /* 0x0010 */ UClass* ClassNeedingThumbnail;
    /* 0x0018 */ FString RendererClassName;
    /* 0x0028 */ UThumbnailRenderer* Renderer;
};

// Size: 0x88
class UTouchInterfaceFactory : public UFactory {
};

// Size: 0x130
class UTransBuffer : public UTransactor {
};

// Size: 0x30
class UTransactor : public UObject {
};

// Size: 0x120
class UTrueTypeFontFactory : public UTextureFactory {
    /* 0x0110 */ UFontImportOptions* ImportOptions;
    /* 0x0118 */ bool bPropertiesConfigured;
    /* 0x0119 */ bool bFontSelected;
};

// Size: 0x1cb0
class UUnrealEdEngine : public UEditorEngine {
    /* 0x1a50 */ UUnrealEdOptions* EditorOptionsInst;
    /* 0x1a58 */ UAutoReimportManager* AutoReimportManager;
    /* 0x1a60 */ UMaterial* MaterialCopyPasteBuffer;
    /* 0x1a68 */ TArray<UObject*> MatineeCopyPasteBuffer;
    /* 0x1a78 */ USoundCue* SoundCueCopyPasteBuffer;
    /* 0x1a80 */ TArray<UAnimCompress*> AnimationCompressionAlgorithms;
    /* 0x1a90 */ TArray<FString> PackagesToBeFullyLoadedAtStartup;
    /* 0x1aa0 */ AActor* CurrentLODParentActor;
    /* 0x1aa8 */ bool bNeedWarningForPkgEngineVer;
    /* 0x1ab0 */ TArray<FString> SortedSpriteCategories;
    /* 0x1ac0 */ TArray<FTemplateMapInfo> TemplateMapInfos;
    /* 0x1ad0 */ UCookOnTheFlyServer* CookServer;
};

// Size: 0x40
class UUnrealEdKeyBindings : public UObject {
    /* 0x0030 */ TArray<FEditorKeyBinding> KeyBindings;
};

// Size: 0xc0
class UUnrealEdOptions : public UObject {
    /* 0x0030 */ TArray<FEditorCommandCategory> EditorCategories;
    /* 0x0040 */ TArray<FEditorCommand> EditorCommands;
    /* 0x0050 */ UUnrealEdKeyBindings* EditorKeyBindings;
    /* 0x0058 */ bool bExpandClassPickerClassList;
    /* 0x0060 */ TArray<FClassPickerDefaults> NewAssetDefaultClasses;
};

// Size: 0x30
class UUnrealEdTypes : public UObject {
};

// Size: 0x88
class UUnrealPakCommandlet : public UCommandlet {
};

// Size: 0x88
class UUpdateGameProjectCommandlet : public UCommandlet {
};

// Size: 0x68
class UUserDefinedStructEditorData : public UObject {
    /* 0x0038 */ uint32_t UniqueNameId;
    /* 0x0040 */ TArray<FStructVariableDescription> VariablesDescriptions;
    /* 0x0050 */ FString Tooltip;
};

// Size: 0x80
class UVectorFieldExporter : public UExporter {
};

// Size: 0x88
class UVectorFieldStaticFactory : public UFactory {
};

// Size: 0x20
struct FViewportConfigOptions {
    /* 0x0000 */ uint8_t ViewModeIndex;
    /* 0x0004 */ float ViewFOV;
    /* 0x0008 */ int32_t CameraSpeedSetting;
    /* 0x000c */ float CameraSpeedScalar;
    /* 0x0010 */ EAnimationViewportCameraFollowMode CameraFollowMode;
    /* 0x0014 */ FName CameraFollowBoneName;
};

// Size: 0x80
class UVirtualTextureBuilderExporterBMP : public UTextureExporterBMP {
};

// Size: 0x90
class UVolumeTextureFactory : public UFactory {
    /* 0x0088 */ UTexture2D* InitialTexture;
};

// Size: 0x48
class UVolumeTextureThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
    /* 0x0040 */ UMaterialInstanceConstant* MaterialInstance;
};

// Size: 0xa0
class UVolumetricBuilder : public UEditorBrushBuilder {
    /* 0x0088 */ float Z;
    /* 0x008c */ float Radius;
    /* 0x0090 */ int32_t NumSheets;
    /* 0x0094 */ FName GroupName;
};

// Size: 0x90
class UWorldFactory : public UFactory {
};

// Size: 0x48
class UWorldThumbnailInfo : public USceneThumbnailInfo {
    /* 0x0040 */ uint8_t CameraMode;
    /* 0x0041 */ uint8_t OrthoDirection;
};

// Size: 0x48
class UWorldThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
    /* 0x0038 */ float GlobalOrbitPitchOffset;
    /* 0x003c */ float GlobalOrbitYawOffset;
    /* 0x0040 */ bool bUseUnlitScene;
    /* 0x0041 */ bool bAllowWorldThumbnails;
};

// Size: 0x88
class UWrangleContentCommandlet : public UCommandlet {
};

// Size: 0x10
struct FAssetEditorRequestOpenAsset {
    /* 0x0000 */ FString AssetName;
};

// Size: 0x20
struct FFileServerReady {
    /* 0x0000 */ TArray<FString> AddressList;
    /* 0x0010 */ FGuid InstanceId;
};

// Size: 0xc0
class UDockableWindowDragOperation : public UViewportDragOperation {
};

enum class EControllerType {
    Laser = 0,
    AssistingLaser = 1,
    UI = 2,
    Navigation = 3,
    Unknown = 4,
    EControllerType_MAX = 5,
};

enum class EInteractorHand {
    Right = 0,
    Left = 1,
    EInteractorHand_MAX = 2,
};

enum class ETouchSwipeDirection {
    None = 0,
    Left = 1,
    Right = 2,
    Up = 3,
    Down = 4,
    ETouchSwipeDirection_MAX = 5,
};

enum class EVREditorWidgetDrawingPolicy {
    Always = 0,
    Hovering = 1,
    EVREditorWidgetDrawingPolicy_MAX = 2,
};

// Size: 0x340
class AFloatingText : public AActor {
    /* 0x02f8 */ USceneComponent* SceneComponent;
    /* 0x0300 */ UStaticMeshComponent* FirstLineComponent;
    /* 0x0308 */ UStaticMeshComponent* JointSphereComponent;
    /* 0x0310 */ UStaticMeshComponent* SecondLineComponent;
    /* 0x0318 */ UTextRenderComponent* TextComponent;
    /* 0x0320 */ UMaterialInterface* MaskedTextMaterial;
    /* 0x0328 */ UMaterialInterface* TranslucentTextMaterial;
    /* 0x0330 */ UMaterialInterface* LineMaterial;
    /* 0x0338 */ UMaterialInstanceDynamic* LineMaterialMID;
};

// Size: 0x28
struct FVRButton {
    /* 0x0000 */ UVREditorWidgetComponent* ButtonWidget;
};

// Size: 0x190
class UVREditorAssetContainer : public UDataAsset {
    /* 0x0038 */ USoundBase* DockableWindowCloseSound;
    /* 0x0040 */ USoundBase* DockableWindowOpenSound;
    /* 0x0048 */ USoundBase* DockableWindowDropSound;
    /* 0x0050 */ USoundBase* DockableWindowDragSound;
    /* 0x0058 */ USoundBase* DropFromContentBrowserSound;
    /* 0x0060 */ USoundBase* RadialMenuOpenSound;
    /* 0x0068 */ USoundBase* RadialMenuCloseSound;
    /* 0x0070 */ USoundBase* TeleportSound;
    /* 0x0078 */ USoundCue* ButtonPressSound;
    /* 0x0080 */ USoundBase* AutoScaleSound;
    /* 0x0088 */ UStaticMesh* GenericHMDMesh;
    /* 0x0090 */ UStaticMesh* PlaneMesh;
    /* 0x0098 */ UStaticMesh* CylinderMesh;
    /* 0x00a0 */ UStaticMesh* LaserPointerStartMesh;
    /* 0x00a8 */ UStaticMesh* LaserPointerMesh;
    /* 0x00b0 */ UStaticMesh* LaserPointerEndMesh;
    /* 0x00b8 */ UStaticMesh* LaserPointerHoverMesh;
    /* 0x00c0 */ UStaticMesh* VivePreControllerMesh;
    /* 0x00c8 */ UStaticMesh* OculusControllerMesh;
    /* 0x00d0 */ UStaticMesh* GenericControllerMesh;
    /* 0x00d8 */ UStaticMesh* TeleportRootMesh;
    /* 0x00e0 */ UStaticMesh* WindowMesh;
    /* 0x00e8 */ UStaticMesh* WindowSelectionBarMesh;
    /* 0x00f0 */ UStaticMesh* WindowCloseButtonMesh;
    /* 0x00f8 */ UStaticMesh* RadialMenuMainMesh;
    /* 0x0100 */ UStaticMesh* RadialMenuPointerMesh;
    /* 0x0108 */ UStaticMesh* PointerCursorMesh;
    /* 0x0110 */ UStaticMesh* LineSegmentCylinderMesh;
    /* 0x0118 */ UStaticMesh* JointSphereMesh;
    /* 0x0120 */ UStaticMesh* DockingButtonMesh;
    /* 0x0128 */ UMaterialInterface* GridMaterial;
    /* 0x0130 */ UMaterialInterface* LaserPointerMaterial;
    /* 0x0138 */ UMaterialInterface* LaserPointerTranslucentMaterial;
    /* 0x0140 */ UMaterial* WorldMovementPostProcessMaterial;
    /* 0x0148 */ UMaterialInterface* TextMaterial;
    /* 0x0150 */ UMaterialInterface* VivePreControllerMaterial;
    /* 0x0158 */ UMaterialInterface* OculusControllerMaterial;
    /* 0x0160 */ UMaterialInterface* TeleportMaterial;
    /* 0x0168 */ UMaterialInterface* WindowMaterial;
    /* 0x0170 */ UMaterialInterface* WindowTranslucentMaterial;
    /* 0x0178 */ UMaterial* LineMaterial;
    /* 0x0180 */ UMaterialInterface* TranslucentTextMaterial;
    /* 0x0188 */ UFont* TextFont;
};

// Size: 0x38
class UVREditorAutoScaler : public UObject {
    /* 0x0030 */ UVREditorMode* VRMode;
};

// Size: 0x368
class AVREditorAvatarActor : public AActor {
    /* 0x02f8 */ UStaticMeshComponent* HeadMeshComponent;
    /* 0x0300 */ UStaticMeshComponent* WorldMovementGridMeshComponent;
    /* 0x0308 */ UMaterialInstanceDynamic* WorldMovementGridMID;
    /* 0x0310 */ float WorldMovementGridOpacity;
    /* 0x0314 */ bool bIsDrawingWorldMovementPostProcess;
    /* 0x0318 */ UMaterialInstanceDynamic* WorldMovementPostProcessMaterial;
    /* 0x0320 */ UStaticMeshComponent* ScaleProgressMeshComponent;
    /* 0x0328 */ UStaticMeshComponent* CurrentScaleProgressMeshComponent;
    /* 0x0330 */ UTextRenderComponent* UserScaleIndicatorText;
    /* 0x0338 */ UMaterialInstanceDynamic* FixedUserScaleMID;
    /* 0x0340 */ UMaterialInstanceDynamic* TranslucentFixedUserScaleMID;
    /* 0x0348 */ UMaterialInstanceDynamic* CurrentUserScaleMID;
    /* 0x0350 */ UMaterialInstanceDynamic* TranslucentCurrentUserScaleMID;
    /* 0x0358 */ UPostProcessComponent* PostProcessComponent;
    /* 0x0360 */ UVREditorMode* VRMode;
};

// Size: 0x3e0
class AVREditorBaseActor : public AActor {
    /* 0x0300 */ UVREditorMode* VRMode;
};

// Size: 0x400
class UVREditorBaseUserWidget : public UUserWidget {
    /* 0x03f8 */ TWeakObjectPtr<AVREditorFloatingUI> Owner;
};

// Size: 0x630
class UVREditorCameraWidgetComponent : public UVREditorWidgetComponent {
};

// Size: 0x530
class AVREditorDockableCameraWindow : public AVREditorDockableWindow {
};

// Size: 0x530
class AVREditorDockableWindow : public AVREditorFloatingUI {
    /* 0x04c0 */ UStaticMeshComponent* DockButtonMeshComponent;
    /* 0x04c8 */ UStaticMeshComponent* SelectionBarMeshComponent;
    /* 0x04d0 */ UStaticMeshComponent* CloseButtonMeshComponent;
    /* 0x04d8 */ UMaterialInstanceDynamic* DockButtonMID;
    /* 0x04e0 */ UMaterialInstanceDynamic* SelectionBarMID;
    /* 0x04e8 */ UMaterialInstanceDynamic* SelectionBarTranslucentMID;
    /* 0x04f0 */ UMaterialInstanceDynamic* CloseButtonMID;
    /* 0x04f8 */ UMaterialInstanceDynamic* CloseButtonTranslucentMID;
    /* 0x0500 */ UViewportDragOperationComponent* DragOperationComponent;
};

// Size: 0x4d0
class AVREditorFloatingCameraUI : public AVREditorFloatingUI {
    /* 0x04b8 */ FVector OffsetFromCamera;
    /* 0x04c4 */ TWeakObjectPtr<AActor> LinkedActor;
};

// Size: 0x4c0
class AVREditorFloatingUI : public AVREditorBaseActor {
    /* 0x03e0 */ FVREditorFloatingUICreationContext CreationContext;
    /* 0x0460 */ UUserWidget* UserWidget;
    /* 0x0468 */ UVREditorWidgetComponent* WidgetComponent;
    /* 0x0470 */ UStaticMeshComponent* WindowMeshComponent;
    /* 0x0490 */ UClass* UserWidgetClass;
};

// Size: 0x70
struct FVREditorFloatingUICreationContext {
    /* 0x0000 */ UClass* WidgetClass;
    /* 0x0008 */ FName PanelID;
    /* 0x0018 */ AActor* ParentActor;
    /* 0x0020 */ FTransform PanelSpawnOffset;
    /* 0x0050 */ FVector2D PanelSize;
    /* 0x0058 */ UStaticMesh* PanelMesh;
    /* 0x0060 */ float EditorUISize;
    /* 0x0064 */ bool bHideWindowHandles;
    /* 0x0065 */ bool bMaskOutWidgetBackground;
    /* 0x0066 */ bool bNoCloseButton;
};

// Size: 0x5d0
class UVREditorInteractor : public UViewportInteractor {
    /* 0x0468 */ bool bIsUndoRedoSwipeEnabled;
    /* 0x0470 */ UMotionControllerComponent* MotionControllerComponent;
    /* 0x0478 */ UStaticMeshComponent* HandMeshComponent;
    /* 0x0480 */ USplineComponent* LaserSplineComponent;
    /* 0x0488 */ TArray<USplineMeshComponent*> LaserSplineMeshComponents;
    /* 0x0498 */ UMaterialInstanceDynamic* LaserPointerMID;
    /* 0x04a0 */ UMaterialInstanceDynamic* TranslucentLaserPointerMID;
    /* 0x04a8 */ UStaticMeshComponent* HoverMeshComponent;
    /* 0x04b0 */ UPointLightComponent* HoverPointLightComponent;
    /* 0x04b8 */ UMaterialInstanceDynamic* HandMeshMID;
    /* 0x04c0 */ AActor* OwningAvatar;
    /* 0x04e8 */ EControllerType ControllerType;
    /* 0x04e9 */ EControllerType OverrideControllerType;
    /* 0x0544 */ FName ControllerMotionSource;
    /* 0x05c0 */ UVREditorMode* VRMode;

    FName GetControllerHandSide() const;
    EControllerHand GetControllerSide() const;
    EControllerType GetControllerType() const;
    FName GetHMDDeviceType() const;
    FVector GetLaserEnd() const;
    FVector GetLaserStart() const;
    FVector2D GetLastTrackpadPosition() const;
    UMotionControllerComponent* GetMotionControllerComponent() const;
    float GetSelectAndMoveTriggerValue() const;
    float GetSlideDelta() const;
    AVREditorTeleporter* GetTeleportActor();
    FVector2D GetTrackpadPosition() const;
    void Init(UVREditorMode* InVRMode);
    bool IsClickingOnUI() const;
    bool IsHoveringOverUI() const;
    bool IsTouchingTrackpad() const;
    void ReplaceHandMeshComponent(UStaticMesh* NewMesh);
    void SetControllerHandSide(const FName InControllerHandSide);
    void SetControllerType(const EControllerType InControllerType);
    void SetForceLaserColor(const FLinearColor& InColor);
    void SetForceShowLaser(const bool bInForceShow);
    void SetupComponent(AActor* OwningActor);
    bool TryOverrideControllerType(const EControllerType InControllerType);
};

// Size: 0x1f8
class UVREditorMode : public UEditorWorldExtension {
    /* 0x0110 */ AVREditorAvatarActor* AvatarActor;
    /* 0x0170 */ UVREditorUISystem* UISystem;
    /* 0x0178 */ AVREditorTeleporter* TeleportActor;
    /* 0x0180 */ UVREditorAutoScaler* AutoScalerSystem;
    /* 0x0188 */ UViewportWorldInteraction* WorldInteraction;
    /* 0x0198 */ UVREditorPlacement* PlacementSystem;
    /* 0x01a0 */ TArray<UVREditorInteractor*> Interactors;
    /* 0x01d8 */ UVREditorAssetContainer* AssetContainer;

    float GetWorldScaleFactor() const;
};

// Size: 0x50
class UVREditorPlacement : public UObject {
    /* 0x0030 */ UVREditorMode* VRMode;
    /* 0x0038 */ UViewportWorldInteraction* ViewportWorldInteraction;
    /* 0x0040 */ UWidgetComponent* FloatingUIAssetDraggedFrom;
    /* 0x0048 */ UObject* PlacingMaterialOrTextureAsset;
};

// Size: 0x490
class AVREditorRadialFloatingUI : public AVREditorBaseActor {
    /* 0x0400 */ TArray<UVREditorWidgetComponent*> WidgetComponents;
    /* 0x0410 */ UStaticMeshComponent* WindowMeshComponent;
    /* 0x0418 */ UStaticMeshComponent* ArrowMeshComponent;
    /* 0x0420 */ UVREditorWidgetComponent* CentralWidgetComponent;
};

// Size: 0x378
class AVREditorTeleporter : public AActor {
    /* 0x02f8 */ UVREditorMode* VRMode;
    /* 0x0320 */ UStaticMeshComponent* TeleportDirectionMeshComponent;
    /* 0x0328 */ UStaticMeshComponent* HMDMeshComponent;
    /* 0x0330 */ UStaticMeshComponent* LeftMotionControllerMeshComponent;
    /* 0x0338 */ UStaticMeshComponent* RightMotionControllerMeshComponent;
    /* 0x0340 */ UMaterialInstanceDynamic* TeleportMID;
    /* 0x0348 */ UViewportInteractor* InteractorTryingTeleport;

    void DoTeleport();
    UViewportInteractor* GetInteractorTryingTeleport() const;
    float GetSlideDelta(UVREditorInteractor* Interactor, const bool Axis);
    UVREditorMode* GetVRMode() const;
    void Init(UVREditorMode* InMode);
    bool IsAiming() const;
    bool IsTeleporting() const;
    void SetColor(const FLinearColor& Color);
    void SetVisibility(const bool bVisible);
    void Shutdown();
    void StartAiming(UViewportInteractor* Interactor);
    void StartTeleport();
    void StopAiming();
    void TeleportDone();
};

// Size: 0x1e0
class UVREditorUISystem : public UObject {
    /* 0x0030 */ UVREditorMode* VRMode;
    /* 0x0038 */ TMap<FName, AVREditorFloatingUI*> FloatingUIs;
    /* 0x0088 */ TMap<FName, AActor*> PreviewWindowInfo;
    /* 0x00d8 */ AVREditorFloatingUI* InfoDisplayPanel;
    /* 0x00f0 */ AVREditorRadialFloatingUI* QuickRadialMenu;
    /* 0x0140 */ AVREditorDockableWindow* DraggingUI;
    /* 0x0148 */ AVREditorDockableWindow* ColorPickerUI;
    /* 0x0150 */ UVREditorInteractor* LaserInteractor;
    /* 0x0158 */ UVREditorInteractor* UIInteractor;
    /* 0x0180 */ TArray<FVRButton> VRButtons;
    /* 0x0190 */ UVRRadialMenuHandler* RadialMenuHandler;
};

// Size: 0x630
class UVREditorWidgetComponent : public UWidgetComponent {
    /* 0x0628 */ EVREditorWidgetDrawingPolicy DrawingPolicy;
    /* 0x0629 */ bool bIsHovering;
    /* 0x062a */ bool bHasEverDrawn;
};

// Size: 0xb8
class UVRModeSettings : public UVISettings {
    /* 0x0038 */ bool bEnableAutoVREditMode;
    /* 0x0038 */ bool bAutokeySequences;
    /* 0x003c */ EInteractorHand InteractorHand;
    /* 0x0040 */ bool bShowWorldMovementGrid;
    /* 0x0040 */ bool bShowWorldMovementPostProcess;
    /* 0x0040 */ bool bShowWorldScaleProgressBar;
    /* 0x0044 */ float UIBrightness;
    /* 0x0048 */ float GizmoScale;
    /* 0x004c */ float DoubleClickTime;
    /* 0x0050 */ float TriggerPressedThreshold_Vive;
    /* 0x0054 */ float TriggerPressedThreshold_Rift;
    /* 0x0058 */ TSoftClassPtr<UVREditorInteractor> InteractorClass;
    /* 0x0088 */ TSoftClassPtr<AVREditorTeleporter> TeleporterClass;
};

// Size: 0xe8
class UVRRadialMenuHandler : public UObject {
};

// Size: 0x5d0
class UVRScoutingInteractor : public UVREditorInteractor {
    /* 0x05c8 */ UStaticMeshComponent* FlyingIndicatorComponent;

    EGizmoHandleTypes GetGizmoMode() const;
    static TArray<AActor*> GetSelectedActors();
    void SetGizmoMode(EGizmoHandleTypes InGizmoMode);
};

// Size: 0x28
struct FCapturedPropSegment {
    /* 0x0000 */ FString PropertyName;
    /* 0x0010 */ int32_t PropertyIndex;
    /* 0x0018 */ FString ComponentName;
};

enum class EPropertyValueCategory {
    Undefined = 0,
    Generic = 1,
    RelativeLocation = 2,
    RelativeRotation = 4,
    RelativeScale3D = 8,
    Visibility = 16,
    Material = 32,
    Color = 64,
    Option = 128,
    EPropertyValueCategory_MAX = 129,
};

// Size: 0x18
struct FFunctionCaller {
    /* 0x0000 */ FName FunctionName;
    /* 0x000c */ TWeakObjectPtr<UObject> FunctionEntry;
    /* 0x0014 */ uint32_t DisplayOrder;
};

// Size: 0xc0
class ULevelVariantSets : public UObject {
    /* 0x0040 */ UObject* DirectorBlueprint;
    /* 0x0058 */ UBlueprintGeneratedClass* DirectorClass;
    /* 0x0060 */ TArray<UVariantSet*> VariantSets;

    int32_t GetNumVariantSets();
    UVariantSet* GetVariantSet(int32_t VariantSetIndex);
    UVariantSet* GetVariantSetByName(FString VariantSetName);
};

// Size: 0x368
class ALevelVariantSetsActor : public AActor {
    /* 0x02f8 */ FSoftObjectPath LevelVariantSets;
    /* 0x0318 */ TMap<UBlueprintGeneratedClass*, ULevelVariantSetsFunctionDirector*> DirectorInstances;

    ULevelVariantSets* GetLevelVariantSets(bool bLoad);
    void SetLevelVariantSets(ULevelVariantSets* InVariantSets);
    bool SwitchOnVariantByIndex(int32_t VariantSetIndex, int32_t VariantIndex);
    bool SwitchOnVariantByName(FString VariantSetName, FString VariantName);
};

// Size: 0x48
class ULevelVariantSetsFunctionDirector : public UObject {
};

// Size: 0x1e0
class UPropertyValue : public UObject {
    /* 0x0090 */ TArray<FFieldPath> Properties;
    /* 0x00a0 */ TArray<int32_t> PropertyIndices;
    /* 0x00b0 */ TArray<FCapturedPropSegment> CapturedPropSegments;
    /* 0x00c0 */ FString FullDisplayString;
    /* 0x00d0 */ FName PropertySetterName;
    /* 0x00e0 */ TMap<FString, FString> PropertySetterParameterDefaults;
    /* 0x0130 */ bool bHasRecordedData;
    /* 0x0138 */ UClass* LeafPropertyClass;
    /* 0x0148 */ TArray<uint8_t> ValueBytes;
    /* 0x0158 */ EPropertyValueCategory PropCategory;
    /* 0x01d8 */ uint32_t DisplayOrder;

    FString GetFullDisplayString() const;
    FText GetPropertyTooltip() const;
    bool HasRecordedData() const;
};

// Size: 0x1e0
class UPropertyValueColor : public UPropertyValue {
};

// Size: 0x1e0
class UPropertyValueMaterial : public UPropertyValue {
};

// Size: 0x1e0
class UPropertyValueOption : public UPropertyValue {
};

// Size: 0x1e0
class UPropertyValueSoftObject : public UPropertyValue {
};

// Size: 0x1e0
class UPropertyValueTransform : public UPropertyValue {
};

// Size: 0x1e0
class UPropertyValueVisibility : public UPropertyValue {
};

// Size: 0x320
class ASwitchActor : public AActor {
    /* 0x0310 */ USceneComponent* SceneComponent;
    /* 0x0318 */ int32_t LastSelectedOption;

    TArray<AActor*> GetOptions() const;
    int32_t GetSelectedOption() const;
    void SelectOption(int32_t OptionIndex);
};

// Size: 0x90
class UVariant : public UObject {
    /* 0x0030 */ TArray<FVariantDependency> Dependencies;
    /* 0x0040 */ FText DisplayText;
    /* 0x0070 */ TArray<UVariantObjectBinding*> ObjectBindings;
    /* 0x0080 */ UTexture2D* Thumbnail;

    int32_t AddDependency(FVariantDependency& Dependency);
    void DeleteDependency(int32_t index);
    AActor* GetActor(int32_t ActorIndex);
    FVariantDependency GetDependency(int32_t index);
    TArray<UVariant*> GetDependents(ULevelVariantSets* LevelVariantSets, bool bOnlyEnabledDependencies);
    FText GetDisplayText() const;
    int32_t GetNumActors();
    int32_t GetNumDependencies();
    UVariantSet* GetParent();
    UTexture2D* GetThumbnail();
    bool IsActive();
    void SetDependency(int32_t index, FVariantDependency& Dependency);
    void SetDisplayText(const FText& NewDisplayText);
    void SetThumbnailFromCamera(UObject* WorldContextObject, const FTransform& CameraTransform, float FOVDegrees, float MinZ, float Gamma);
    void SetThumbnailFromEditorViewport();
    void SetThumbnailFromFile(FString FilePath);
    void SetThumbnailFromTexture(UTexture2D* NewThumbnail);
    void SwitchOn();
};

// Size: 0x68
struct FVariantDependency {
    /* 0x0000 */ TSoftObjectPtr<UVariantSet> VariantSet;
    /* 0x0030 */ TSoftObjectPtr<UVariant> Variant;
    /* 0x0060 */ bool bEnabled;
};

// Size: 0xa0
class UVariantObjectBinding : public UObject {
    /* 0x0030 */ FString CachedActorLabel;
    /* 0x0040 */ FSoftObjectPath ObjectPtr;
    /* 0x0060 */ TLazyObjectPtr<UObject> LazyObjectPtr;
    /* 0x0080 */ TArray<UPropertyValue*> CapturedProperties;
    /* 0x0090 */ TArray<FFunctionCaller> FunctionCallers;
};

// Size: 0x80
class UVariantSet : public UObject {
    /* 0x0030 */ FText DisplayText;
    /* 0x0060 */ bool bExpanded;
    /* 0x0068 */ TArray<UVariant*> Variants;
    /* 0x0078 */ UTexture2D* Thumbnail;

    FText GetDisplayText() const;
    int32_t GetNumVariants() const;
    ULevelVariantSets* GetParent();
    UTexture2D* GetThumbnail();
    UVariant* GetVariant(int32_t VariantIndex);
    UVariant* GetVariantByName(FString VariantName);
    void SetDisplayText(const FText& NewDisplayText);
    void SetThumbnailFromCamera(UObject* WorldContextObject, const FTransform& CameraTransform, float FOVDegrees, float MinZ, float Gamma);
    void SetThumbnailFromEditorViewport();
    void SetThumbnailFromFile(FString FilePath);
    void SetThumbnailFromTexture(UTexture2D* NewThumbnail);
};

enum class EVariantManagerTestEnum {
    None = 0,
    FirstOption = 1,
    SecondOption = 3,
    ThirdOption = 45,
    EVariantManagerTestEnum_MAX = 46,
};

// Size: 0x78
class ULevelVariantSetsActorFactory : public UActorFactory {
};

// Size: 0x78
class USwitchActorFactory : public UActorFactory {
};

// Size: 0x88
class UVariantManagerFactoryNew : public UFactory {
};

// Size: 0x3e0
class AVariantManagerTestActor : public AActor {
    /* 0x02f8 */ EVariantManagerTestEnum EnumWithNoDefault;
    /* 0x02f9 */ EVariantManagerTestEnum EnumWithSecondDefault;
    /* 0x02fa */ uint8_t CapturedByteProperty;
    /* 0x02fc */ int32_t CapturedIntProperty;
    /* 0x0300 */ float CapturedFloatProperty;
    /* 0x0304 */ bool bCapturedBoolProperty;
    /* 0x0308 */ UObject* CapturedObjectProperty;
    /* 0x0310 */ TScriptInterface<UInterface> CapturedInterfaceProperty;
    /* 0x0320 */ FName CapturedNameProperty;
    /* 0x0330 */ FString CapturedStrProperty;
    /* 0x0340 */ FText CapturedTextProperty;
    /* 0x0358 */ FRotator CapturedRotatorProperty;
    /* 0x0364 */ FColor CapturedColorProperty;
    /* 0x0368 */ FLinearColor CapturedLinearColorProperty;
    /* 0x0378 */ FVector CapturedVectorProperty;
    /* 0x0390 */ FQuat CapturedQuatProperty;
    /* 0x03a0 */ FVector4 CapturedVector4Property;
    /* 0x03b0 */ FVector2D CapturedVector2DProperty;
    /* 0x03b8 */ FIntPoint CapturedIntPointProperty;
    /* 0x03c0 */ TArray<UObject*> CapturedUObjectArrayProperty;
    /* 0x03d0 */ TArray<FVector> CapturedVectorArrayProperty;
};

enum class EVectorVMBaseTypes {
    Float = 0,
    Int = 1,
    Bool = 2,
    Num = 3,
    EVectorVMBaseTypes_MAX = 4,
};

enum class EVectorVMOp {
    done = 0,
    add = 1,
    sub = 2,
    mul = 3,
    div = 4,
    mad = 5,
    lerp = 6,
    rcp = 7,
    rsq = 8,
    sqrt = 9,
    neg = 10,
    abs = 11,
    exp = 12,
    exp2 = 13,
    log = 14,
    log2 = 15,
    sin = 16,
    cos = 17,
    tan = 18,
    asin = 19,
    acos = 20,
    atan = 21,
    atan2 = 22,
    ceil = 23,
    floor = 24,
    fmod = 25,
    frac = 26,
    trunc = 27,
    clamp = 28,
    min = 29,
    max = 30,
    pow = 31,
    round = 32,
    sign = 33,
    step = 34,
    random = 35,
    noise = 36,
    cmplt = 37,
    cmple = 38,
    cmpgt = 39,
    cmpge = 40,
    cmpeq = 41,
    cmpneq = 42,
    select = 43,
    addi = 44,
    subi = 45,
    muli = 46,
    divi = 47,
    clampi = 48,
    mini = 49,
    maxi = 50,
    absi = 51,
    negi = 52,
    signi = 53,
    randomi = 54,
    cmplti = 55,
    cmplei = 56,
    cmpgti = 57,
    cmpgei = 58,
    cmpeqi = 59,
    cmpneqi = 60,
    bit_and = 61,
    bit_or = 62,
    bit_xor = 63,
    bit_not = 64,
    bit_lshift = 65,
    bit_rshift = 66,
    logic_and = 67,
    logic_or = 68,
    logic_xor = 69,
    logic_not = 70,
    f2i = 71,
    i2f = 72,
    f2b = 73,
    b2f = 74,
    i2b = 75,
    b2i = 76,
    inputdata_float = 77,
    inputdata_int32 = 78,
    inputdata_half = 79,
    inputdata_noadvance_float = 80,
    inputdata_noadvance_int32 = 81,
    inputdata_noadvance_half = 82,
    outputdata_float = 83,
    outputdata_int32 = 84,
    outputdata_half = 85,
    acquireindex = 86,
    external_func_call = 87,
    exec_index = 88,
    noise2D = 89,
    noise3D = 90,
    enter_stat_scope = 91,
    exit_stat_scope = 92,
    update_id = 93,
    acquire_id = 94,
    NumOpcodes = 95,
    EVectorVMOp_MAX = 96,
};

enum class EVectorVMOperandLocation {
    Register = 0,
    Constant = 1,
    Num = 2,
    EVectorVMOperandLocation_MAX = 3,
};

// Size: 0x38
class UActorTransformer : public UViewportTransformer {
};

// Size: 0x260
class UAxisGizmoHandleGroup : public UGizmoHandleGroup {
};

// Size: 0x328
class ABaseTransformGizmo : public AActor {
    /* 0x0300 */ USceneComponent* SceneComponent;
    /* 0x0308 */ TArray<UGizmoHandleGroup*> AllHandleGroups;
    /* 0x0318 */ UViewportWorldInteraction* WorldInteraction;
};

// Size: 0x170
struct FDraggingTransformableData {
};

enum class EGizmoHandleTypes {
    All = 0,
    Translate = 1,
    Rotate = 2,
    Scale = 3,
    EGizmoHandleTypes_MAX = 4,
};

enum class EHitResultGizmoFilterMode {
    All = 0,
    NoGizmos = 1,
    GizmosOnly = 2,
    EHitResultGizmoFilterMode_MAX = 3,
};

enum class EViewportInteractionDraggingMode {
    Nothing = 0,
    TransformablesWithGizmo = 1,
    TransformablesAtLaserImpact = 2,
    AssistingDrag = 3,
    TransformablesFreely = 4,
    World = 5,
    Interactable = 6,
    Material = 7,
    EViewportInteractionDraggingMode_MAX = 8,
};

enum class EViewportWorldInteractionType {
    VR = 0,
    Legacy = 1,
    EViewportWorldInteractionType_MAX = 2,
};

// Size: 0x10
struct FGizmoHandle {
};

// Size: 0x260
class UGizmoHandleGroup : public USceneComponent {
    /* 0x0228 */ UMaterialInterface* GizmoMaterial;
    /* 0x0230 */ UMaterialInterface* TranslucentGizmoMaterial;
    /* 0x0238 */ TArray<FGizmoHandle> Handles;
    /* 0x0248 */ ABaseTransformGizmo* OwningTransformGizmoActor;
    /* 0x0250 */ UViewportDragOperationComponent* DragOperationComponent;
};

// Size: 0x5d0
class UGizmoHandleMeshComponent : public UStaticMeshComponent {
};

// Size: 0x470
class UMouseCursorInteractor : public UViewportInteractor {
};

// Size: 0x260
class UPivotPlaneTranslationGizmoHandleGroup : public UAxisGizmoHandleGroup {
};

// Size: 0x2b0
class UPivotRotationGizmoHandleGroup : public UAxisGizmoHandleGroup {
    /* 0x0260 */ USceneComponent* RootFullRotationHandleComponent;
    /* 0x0268 */ UGizmoHandleMeshComponent* FullRotationHandleMeshComponent;
    /* 0x0270 */ UGizmoHandleMeshComponent* StartRotationIndicatorMeshComponent;
    /* 0x0278 */ USceneComponent* RootStartRotationIdicatorComponent;
    /* 0x0280 */ UGizmoHandleMeshComponent* DeltaRotationIndicatorMeshComponent;
    /* 0x0288 */ USceneComponent* RootDeltaRotationIndicatorComponent;
};

// Size: 0x260
class UPivotScaleGizmoHandleGroup : public UAxisGizmoHandleGroup {
};

// Size: 0x368
class APivotTransformGizmo : public ABaseTransformGizmo {
    /* 0x0328 */ UUniformScaleGizmoHandleGroup* UniformScaleGizmoHandleGroup;
    /* 0x0330 */ UPivotTranslationGizmoHandleGroup* TranslationGizmoHandleGroup;
    /* 0x0338 */ UPivotScaleGizmoHandleGroup* ScaleGizmoHandleGroup;
    /* 0x0340 */ UPivotPlaneTranslationGizmoHandleGroup* PlaneTranslationGizmoHandleGroup;
    /* 0x0348 */ UPivotRotationGizmoHandleGroup* RotationGizmoHandleGroup;
    /* 0x0350 */ UStretchGizmoHandleGroup* StretchGizmoHandleGroup;
    /* 0x0360 */ UActorComponent* LastDraggingHandle;
};

// Size: 0x260
class UPivotTranslationGizmoHandleGroup : public UAxisGizmoHandleGroup {
};

// Size: 0x38
class UPlaneTranslationDragOperation : public UViewportDragOperation {
};

// Size: 0x60
class URotateOnAngleDragOperation : public UViewportDragOperation {
};

// Size: 0x38
class UScaleDragOperation : public UViewportDragOperation {
};

// Size: 0x38
class UStretchGizmoHandleDragOperation : public UViewportDragOperation {
};

// Size: 0x260
class UStretchGizmoHandleGroup : public UGizmoHandleGroup {
};

// Size: 0xc
struct FTransformGizmoHandlePlacement {
};

// Size: 0x8
struct FTransformGizmoMeasurement {
    /* 0x0000 */ UTextRenderComponent* MeasurementText;
};

// Size: 0x38
class UTranslationDragOperation : public UViewportDragOperation {
};

// Size: 0x38
class UUniformScaleDragOperation : public UViewportDragOperation {
};

// Size: 0x270
class UUniformScaleGizmoHandleGroup : public UGizmoHandleGroup {
};

// Size: 0x38
class UVISettings : public UObject {
    /* 0x0030 */ bool bScaleWorldFromFloor;
    /* 0x0030 */ bool bScaleWorldWithDynamicPivot;
    /* 0x0030 */ bool bAllowSimultaneousWorldScalingAndRotation;
};

// Size: 0x10
struct FViewportActionKeyInput {
    /* 0x0000 */ FName ActionType;
    /* 0x000c */ uint8_t Event;
    /* 0x000d */ bool bIsInputCaptured;
};

// Size: 0x38
class UViewportDragOperation : public UObject {
};

// Size: 0xd0
class UViewportDragOperationComponent : public UActorComponent {
    /* 0x00c0 */ UViewportDragOperation* DragOperation;
    /* 0x00c8 */ UClass* DragOperationSubclass;
};

// Size: 0x30
class IViewportInteractableInterface : public UInterface {
};

// Size: 0xe8
class UViewportInteractionAssetContainer : public UDataAsset {
    /* 0x0038 */ USoundBase* GizmoHandleSelectedSound;
    /* 0x0040 */ USoundBase* GizmoHandleDropSound;
    /* 0x0048 */ USoundBase* SelectionChangeSound;
    /* 0x0050 */ USoundBase* SelectionDropSound;
    /* 0x0058 */ USoundBase* SelectionStartDragSound;
    /* 0x0060 */ USoundBase* GridSnapSound;
    /* 0x0068 */ USoundBase* ActorSnapSound;
    /* 0x0070 */ USoundBase* UndoSound;
    /* 0x0078 */ USoundBase* RedoSound;
    /* 0x0080 */ UStaticMesh* GridMesh;
    /* 0x0088 */ UStaticMesh* TranslationHandleMesh;
    /* 0x0090 */ UStaticMesh* UniformScaleHandleMesh;
    /* 0x0098 */ UStaticMesh* ScaleHandleMesh;
    /* 0x00a0 */ UStaticMesh* PlaneTranslationHandleMesh;
    /* 0x00a8 */ UStaticMesh* RotationHandleMesh;
    /* 0x00b0 */ UStaticMesh* RotationHandleSelectedMesh;
    /* 0x00b8 */ UStaticMesh* StartRotationIndicatorMesh;
    /* 0x00c0 */ UStaticMesh* CurrentRotationIndicatorMesh;
    /* 0x00c8 */ UStaticMesh* FreeRotationHandleMesh;
    /* 0x00d0 */ UMaterialInterface* GridMaterial;
    /* 0x00d8 */ UMaterialInterface* TransformGizmoMaterial;
    /* 0x00e0 */ UMaterialInterface* TranslucentTransformGizmoMaterial;
};

// Size: 0x470
class UViewportInteractor : public UObject {
    /* 0x0320 */ TMap<FKey, FViewportActionKeyInput> KeyToActionMap;
    /* 0x0370 */ UViewportWorldInteraction* WorldInteraction;
    /* 0x0378 */ UViewportInteractor* OtherInteractor;

    bool CanCarry() const;
    EViewportInteractionDraggingMode GetDraggingMode() const;
    EHitResultGizmoFilterMode GetHitResultGizmoFilterMode() const;
    FVector GetHoverLocation();
    bool GetLaserPointer(FVector& LaserPointerStart, FVector& LaserPointerEnd, const bool bEvenIfBlocked, const float LaserLengthOverride);
    FTransform GetLastRoomSpaceTransform() const;
    FTransform GetLastTransform() const;
    UViewportInteractor* GetOtherInteractor() const;
    FTransform GetRoomSpaceTransform() const;
    FTransform GetTransform() const;
    bool GetTransformAndForwardVector(FTransform& OutHandTransform, FVector& OutForwardVector) const;
    UViewportWorldInteraction* GetWorldInteraction() const;
    void HandleInputAxis_BP(const FViewportActionKeyInput& Action, const FKey Key, const float Delta, const float DeltaTime, bool& bOutWasHandled);
    void HandleInputKey_BP(const FViewportActionKeyInput& Action, const FKey Key, const uint8_t Event, bool& bOutWasHandled);
    bool IsHoveringOverGizmo() const;
    void SetCanCarry(const bool bInCanCarry);
    void SetDraggingMode(const EViewportInteractionDraggingMode NewDraggingMode);
    void SetHitResultGizmoFilterMode(EHitResultGizmoFilterMode newFilter);
    void Shutdown();
    void Tick(const float DeltaTime);
};

// Size: 0x38
class UViewportTransformer : public UObject {
    /* 0x0030 */ UViewportWorldInteraction* ViewportWorldInteraction;

    bool CanAlignToActors() const;
    void Init(UViewportWorldInteraction* InitViewportWorldInteraction);
    void OnStartDragging(UViewportInteractor* Interactor);
    void OnStopDragging(UViewportInteractor* Interactor);
    bool ShouldCenterTransformGizmoPivot() const;
    void Shutdown();
};

// Size: 0x460
class UViewportWorldInteraction : public UEditorWorldExtension {
    /* 0x0138 */ TArray<UViewportInteractor*> Interactors;
    /* 0x0148 */ UViewportTransformer* ViewportTransformer;
    /* 0x0230 */ ABaseTransformGizmo* TransformGizmoActor;
    /* 0x02c0 */ AActor* SnapGridActor;
    /* 0x02c8 */ UStaticMeshComponent* SnapGridMeshComponent;
    /* 0x02d0 */ UMaterialInstanceDynamic* SnapGridMID;
    /* 0x03e8 */ UMouseCursorInteractor* DefaultMouseCursorInteractor;
    /* 0x03f8 */ TArray<TWeakObjectPtr<AActor>> ActorsToExcludeFromHitTest;
    /* 0x0438 */ UViewportInteractionAssetContainer* AssetContainer;

    void AddActorToExcludeFromHitTests(AActor* ActorToExcludeFromHitTests);
    void AddInteractor(UViewportInteractor* Interactor);
    FTransform GetHeadTransform() const;
    TArray<UViewportInteractor*> GetInteractors() const;
    FTransform GetRoomSpaceHeadTransform() const;
    FTransform GetRoomTransform() const;
    ABaseTransformGizmo* GetTransformGizmoActor();
    float GetWorldScaleFactor() const;
    void RemoveInteractor(UViewportInteractor* Interactor);
    void SetHeadTransform(const FTransform& NewHeadTransform);
    void SetRoomTransformForNextFrame(const FTransform& NewRoomTransform);
    void SetWorldToMetersScale(const float NewWorldToMetersScale, const bool bCompensateRoomWorldScale);
};

// Size: 0x88
class URuntimeVirtualTextureFactory : public UFactory {
};

// Size: 0x38
class URuntimeVirtualTextureThumbnailRenderer : public UDefaultSizedThumbnailRenderer {
};

// Size: 0x88
class UVirtualTextureBuilderFactory : public UFactory {
};

// Size: 0x30
class UVirtualTextureBuilderThumbnailRenderer : public UTextureThumbnailRenderer {
};

// Size: 0x88
class UWebMPlatFileMediaSourceFactory : public UFactory {
};

// Size: 0x9a8
struct FWidgetCarouselNavigationBarStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FSlateBrush HighlightBrush;
    /* 0x00a8 */ FButtonStyle LeftButtonStyle;
    /* 0x03a8 */ FButtonStyle CenterButtonStyle;
    /* 0x06a8 */ FButtonStyle RightButtonStyle;
};

// Size: 0x448
struct FWidgetCarouselNavigationButtonStyle : public FSlateWidgetStyle {
    /* 0x0008 */ FButtonStyle InnerButtonStyle;
    /* 0x0308 */ FSlateBrush NavigationButtonLeftImage;
    /* 0x03a8 */ FSlateBrush NavigationButtonRightImage;
};

enum class ECompilerVersion {
    Default = 0,
    VisualStudio2015 = 1,
    VisualStudio2017 = 2,
    VisualStudio2019 = 3,
    VisualStudio2022 = 4,
    ECompilerVersion_MAX = 5,
};

enum class EDefaultGraphicsRHI {
    DefaultGraphicsRHI_Default = 0,
    DefaultGraphicsRHI_DX11 = 1,
    DefaultGraphicsRHI_DX12 = 2,
    DefaultGraphicsRHI_Vulkan = 3,
    DefaultGraphicsRHI_MAX = 4,
};

enum class EMinimumSupportedOS {
    MSOS_Vista = 0,
    MSOS_MAX = 1,
};

// Size: 0xd0
class UWindowsTargetSettings : public UObject {
    /* 0x0030 */ ECompilerVersion Compiler;
    /* 0x0038 */ TArray<FString> TargetedRHIs;
    /* 0x0048 */ EDefaultGraphicsRHI DefaultGraphicsRHI;
    /* 0x0049 */ EMinimumSupportedOS MinimumOSVersion;
    /* 0x004c */ int32_t AudioSampleRate;
    /* 0x0050 */ int32_t AudioCallbackBufferFrameSize;
    /* 0x0054 */ int32_t AudioNumBuffersToEnqueue;
    /* 0x0058 */ int32_t AudioMaxChannels;
    /* 0x005c */ int32_t AudioNumSourceWorkers;
    /* 0x0060 */ FString SpatializationPlugin;
    /* 0x0070 */ FString ReverbPlugin;
    /* 0x0080 */ FString OcclusionPlugin;
    /* 0x0090 */ FPlatformRuntimeAudioCompressionOverrides CompressionOverrides;
    /* 0x00a0 */ bool bUseAudioStreamCaching;
    /* 0x00a4 */ int32_t CacheSizeKB;
    /* 0x00a8 */ int32_t MaxChunkSizeOverrideKB;
    /* 0x00ac */ bool bResampleForDevice;
    /* 0x00b0 */ float MaxSampleRate;
    /* 0x00b4 */ float HighSampleRate;
    /* 0x00b8 */ float MedSampleRate;
    /* 0x00bc */ float LowSampleRate;
    /* 0x00c0 */ float MinSampleRate;
    /* 0x00c4 */ float CompressionQualityModifier;
    /* 0x00c8 */ float AutoStreamingThreshold;
    /* 0x00cc */ int32_t SoundCueCookQualityIndex;
};

// Size: 0x88
class UWmfFileMediaSourceFactory : public UFactory {
};

// Size: 0x38
class UWmfMediaSettings : public UObject {
    /* 0x0030 */ bool AllowNonStandardCodecs;
    /* 0x0031 */ bool LowLatency;
    /* 0x0032 */ bool NativeAudioOut;
    /* 0x0033 */ bool HardwareAcceleratedVideoDecoding;
};

